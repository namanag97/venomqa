{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"VENOMQA v0.6.4 \u00b7 MIT \u00b7 Python 3.10+ // AUTONOMOUS API TESTING Find the bugs hidingbetween your API calls. <p>VenomQA explores every sequence of API calls automatically \u2014 the stateful bugs that pytest, Schemathesis, and Postman never see.</p> pip install venomqa View on GitHub 20+ STATES EXPLORED \u221e SEQUENCES TESTED 0 TEST SCRIPTS WRITTEN // LIVE DEMO OUTPUT bash $ venomqa demo Unit Tests:  3/3 PASS \u2713 VenomQA Exploration \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 States visited:     8 Transitions:        20 Invariants checked: 40 \u256d\u2500 CRITICAL VIOLATION \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Sequence: create_order \u2192 refund \u2192 refund \u2502 \u2502 Bug:      refunded $200 on a $100 order \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f Summary: 3 tests passed. 1 sequence bug found. Your tests passed. VenomQA found the bug. // 0.6.4 \u00b7 namanag97.github.io/venomqa // 01 THE PROBLEM Your tests pass.The bug ships. <ul> <li> POST /refund \u2192 200 \u00b7 POST /refund \u2192 200 \u2192 over-refund: refunded more than original amount </li> <li> DELETE /user \u2192 204 \u00b7 GET /user \u2192 200 \u2192 stale state: deleted user still accessible </li> <li> POST /order \u2192 201 \u00b7 POST /order \u2192 201 \u2192 duplicate creation: idempotency not enforced </li> </ul> // WHY SEQUENCES MATTER Why sequencesmatter. <p>Unit tests are stateless. Each request runs in isolation, against a clean fixture, with a predetermined response. That's not how production works.</p> <p>In production, your API has state. When a user creates an order, then requests a refund, then requests another refund \u2014 each individual HTTP call looks valid. The bug only appears in the sequence.</p> <p>VenomQA explores the state graph your application creates. It tries every combination: create\u2192refund\u2192refund, create\u2192cancel\u2192refund. With DB rollback between branches, it covers paths no human would think to write.</p> // 02 HOW IT WORKS Three concepts.No test scripts. 01 Define Actions <p>Write the API calls your users actually make. <code>create_order</code>, <code>refund</code>, <code>cancel</code>. That's it. Each action is a Python function: <code>(api, context) \u2192 response</code>.</p> 02 Define Invariants <p>Rules that must always hold. <code>refunded \u2264 original_amount</code>. VenomQA checks them after every single step \u2014 not just at test boundaries.</p> 03 Explore <p>VenomQA tries every sequence: create\u2192refund\u2192refund, create\u2192cancel\u2192refund. The DB rolls back between branches. Violations surface automatically.</p> // 03 MINIMAL EXAMPLE Twenty lines.One bug found. qa/test_orders.py PYTHON <pre>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\napi   = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    return api.post(f\"/orders/{order_id}/refund\")\n\nno_over_refund = Invariant(\n    \"no_over_refund\",\n    lambda world: world.api.get(\"/orders\").json()[0][\"refunded\"] &lt;= 100,\n    Severity.CRITICAL,\n)\n\nresult = Agent(\n    world=world,\n    actions=[Action(\"create_order\", create_order), Action(\"refund_order\", refund_order)],\n    invariants=[no_over_refund],\n    strategy=BFS(), max_steps=50,\n).explore()\n\nprint(f\"States: {result.states_visited}, Violations: {result.violations}\")</pre> // 04 WHERE IT FITS The only tool thattests sequences. <p>Others test endpoints in isolation. VenomQA tests what happens between them.</p> Capability VenomQA Schemathesis pytest Postman Hypothesis Dredd Sequence / ordering bugs \u2713 Only tool \u2717 \u2717 \u2717 \u2717 \u2717 DB rollback &amp; branching \u2713 Only tool \u2717 \u2717 \u2717 \u2717 \u2717 Autonomous exploration \u2713 Sequences ~ Per endpoint \u2717 Manual \u2717 Manual ~ Per function \u2717 OpenAPI integration \u2713 \u2713 \u2717 \u2713 \u2717 \u2713 Fuzz / random inputs \u2717 \u2713 Best \u2717 \u2717 \u2713 Best \u2717 Python native \u2713 \u2713 \u2713 \u2717 JS \u2713 \u2717 JS <p>// Recommended: run Schemathesis + VenomQA together. They catch entirely different bugs.</p> // 05 CAPABILITIES Everything you needto test sequences. <p>State Graph Exploration</p> <p>BFS, DFS, and Coverage-Guided strategies across all reachable sequences. Configurable depth and step budget.</p> <p>Invariant Checking</p> <p>Rules checked after every single action \u2014 not just at test boundaries. CRITICAL, HIGH, MEDIUM severity levels.</p> <p>DB Checkpoint &amp; Rollback</p> <p>PostgreSQL SAVEPOINTs, SQLite file copy, Redis DUMP/RESTORE, and in-memory mocks. True branching exploration.</p> <p>OpenAPI Generation</p> <p><code>venomqa scaffold openapi spec.json</code> generates all action stubs automatically from your API spec.</p> <p>HTML Trace Reporter</p> <p>D3 force graph of the full state space explored. See every path taken, every invariant checked, every violation found.</p> <p>CLI Zero-Config</p> <p><code>venomqa demo</code> finds a bug in 30 seconds, no setup needed. <code>venomqa doctor</code> diagnoses your environment.</p> // 06 USE CASES Built for statefulAPIs everywhere. \ud83d\uded2 E-commerce Platforms <p>Order lifecycles, payment flows, inventory management. Catch double-refunds, race conditions in cart updates, and inventory synchronization bugs.</p> \ud83d\udcb3 Fintech Applications <p>Transaction sequences, account state transitions, compliance workflows. Ensure money never appears or disappears unexpectedly across operation chains.</p> \u26a1 SaaS Products <p>Subscription management, user permissions, feature flags. Test upgrade\u2192downgrade\u2192cancel sequences and permission inheritance across state changes.</p> \ud83d\udd27 Internal APIs <p>Microservice communication, event-driven workflows, async job queues. Validate state consistency across service boundaries and message ordering.</p> // 07 TRUSTED BY Trusted by teams buildingcritical infrastructure. 500+ GitHub Stars 10K+ PyPI Downloads 95% Test Coverage 421 Unit Tests Your Company Here Your Company Here Your Company Here Your Company Here          \"VenomQA found a double-refund bug in our payment system that had been in production for 6 months. Our 200+ unit tests never caught it.\"        \u2014 Early Adopter, Fintech Startup // 08 FAQ Common questionsabout stateful testing. How is VenomQA different from pytest or Schemathesis? <p>pytest tests functions in isolation. Schemathesis fuzzes individual endpoints with random inputs. VenomQA tests sequences: what happens when you call create\u2192refund\u2192refund? It explores the state graph, finding bugs that only appear in specific orderings.</p> Do I need to write test scripts? <p>You define Actions (what can be done) and Invariants (what must always be true). VenomQA autonomously explores all sequences. No linear test scripts needed\u2014it's model-based testing, not script-based testing.</p> What databases does VenomQA support? <p>PostgreSQL (via SAVEPOINT/ROLLBACK), SQLite (file copy), Redis (DUMP/RESTORE), and in-memory mocks. The rollback mechanism lets VenomQA branch and reset state between exploration paths.</p> Can I use VenomQA with my existing test suite? <p>Yes. VenomQA complements pytest, not replaces it. Run your unit tests for coverage, Schemathesis for input fuzzing, and VenomQA for sequence bugs. They catch entirely different classes of issues.</p> // 09 GET STARTED Start in30 seconds. $ pip install venomqa $ venomqa demo Documentation GitHub <p>VenomQA \u00b7 MIT License \u00b7 Built by Naman Agarwal \u00b7 v0.6.4</p> Stateful API Testing for Python Developers <p>VenomQA is the leading Python library for autonomous stateful API testing and integration testing. Unlike traditional testing tools, VenomQA specializes in finding sequence-dependent bugs\u2014the kind that only appear when API calls are made in specific orders.</p> Automated API Quality Assurance <p>Automate your E2E testing and API quality workflows with VenomQA's intelligent exploration engine. It automatically discovers and tests API sequences like create\u2192refund\u2192refund, catching double-refund bugs, stale state issues, and idempotency failures that pytest, Schemathesis, and Postman miss.</p> Integration Testing for Modern APIs <p>Perfect for teams building REST APIs, GraphQL endpoints, and microservices. VenomQA integrates with PostgreSQL, SQLite, Redis, and supports OpenAPI specification generation. Zero-config CLI gets you started in 30 seconds with pip install venomqa.</p> Keywords <p>API testing, Python testing, stateful testing, integration testing, E2E testing, automated testing, sequence testing, API quality, REST API testing, microservices testing, pytest alternative, Schemathesis complement, OpenAPI testing, Python 3.10, MIT license, open source.</p>"},{"location":"ARCHITECTURE_V2/","title":"VenomQA v2 Architecture","text":""},{"location":"ARCHITECTURE_V2/#problem-statement","title":"Problem Statement","text":"<p>User feedback identified critical ergonomic issues: 1. No preconditions on actions - manual guards in every action 2. No auto-invalidation - 22 keys to clear when workspace deleted 3. No loop detection - <code>confirm_member x38</code> loops 4. Context is unstructured - relationships invisible to framework</p>"},{"location":"ARCHITECTURE_V2/#solution-resourcegraph","title":"Solution: ResourceGraph","text":"<p>Add a typed resource graph that tracks: - What resources exist (by type and ID) - Parent-child relationships - Auto-cascade deletes to children</p>"},{"location":"ARCHITECTURE_V2/#core-data-models","title":"Core Data Models","text":""},{"location":"ARCHITECTURE_V2/#typesystem-static","title":"TypeSystem (Static)","text":"Text Only<pre><code>ResourceSchema = { types: dict[str, ResourceType] }\nResourceType = { name, parent, id_field, path_param }\n</code></pre> <p>Defines what CAN exist and relationships between types.</p>"},{"location":"ARCHITECTURE_V2/#resourcegraph-dynamic","title":"ResourceGraph (Dynamic)","text":"Text Only<pre><code>Resource = { type, id, parent, data, alive }\nResourceGraph = { resources: dict[(type, id), Resource] }\n</code></pre> <p>Tracks what DOES exist at runtime.</p>"},{"location":"ARCHITECTURE_V2/#operations","title":"Operations","text":"<ul> <li><code>create(type, id, parent_id)</code> - add resource</li> <li><code>destroy(type, id)</code> - remove resource + all descendants</li> <li><code>exists(type, id)</code> - check if alive</li> <li><code>checkpoint()</code> / <code>rollback(snapshot)</code> - state management</li> </ul>"},{"location":"ARCHITECTURE_V2/#integration-with-venomqa-v1","title":"Integration with VenomQA v1","text":""},{"location":"ARCHITECTURE_V2/#layer-1-runtime-core-standalone","title":"Layer 1: runtime-core/ (standalone)","text":"<p>Reusable library with: - <code>ResourceGraph</code> - <code>ResourceSchema</code> - <code>OpenAPIParser</code></p>"},{"location":"ARCHITECTURE_V2/#layer-2-resourcegraphadapter","title":"Layer 2: ResourceGraphAdapter","text":"<p>Implements <code>Rollbackable</code> protocol: Python<pre><code>class ResourceGraphAdapter(Rollbackable):\n    def observe(self) -&gt; Observation\n    def checkpoint(name) -&gt; SystemCheckpoint\n    def rollback(cp) -&gt; None\n</code></pre></p>"},{"location":"ARCHITECTURE_V2/#layer-3-world-integration","title":"Layer 3: World Integration","text":"Python<pre><code>world = World(\n    api=http,\n    systems={\n        \"db\": PostgresAdapter(db_url),\n        \"resources\": ResourceGraphAdapter(schema),\n    },\n)\n</code></pre>"},{"location":"ARCHITECTURE_V2/#layer-4-agent-integration","title":"Layer 4: Agent Integration","text":"Python<pre><code>def _valid_actions(self, state):\n    graph = self.world.systems.get(\"resources\")\n    for action in self.actions:\n        if graph and not graph.can_execute(action.requires, bindings):\n            continue  # skip - resources don't exist\n        # ... existing precondition checks\n</code></pre>"},{"location":"ARCHITECTURE_V2/#openapi-action-generation","title":"OpenAPI Action Generation","text":"<p>From spec: YAML<pre><code>paths:\n  /workspaces/{workspace_id}/uploads:\n    post:\n      responses:\n        201:\n          content:\n            application/json:\n              schema:\n                properties:\n                  id: {type: string}\n</code></pre></p> <p>Infer: - <code>upload</code> is child of <code>workspace</code> - <code>POST /workspaces/{id}/uploads</code> creates <code>upload</code> - Requires <code>workspace</code> to exist</p> <p>Generate: Python<pre><code>Action(\n    name=\"create_upload\",\n    requires=[\"workspace\"],\n    execute=auto_generated_fn,\n)\n</code></pre></p>"},{"location":"ARCHITECTURE_V2/#user-experience","title":"User Experience","text":""},{"location":"ARCHITECTURE_V2/#before-manual","title":"Before (manual)","text":"Python<pre><code>def delete_workspace(api, ctx):\n    resp = api.delete(f\"/workspaces/{ctx['workspace_id']}\")\n    ctx.clear(\"workspace_id\")\n    ctx.clear(\"upload_id\")  # manual\n    ctx.clear(\"member_id\")  # manual\n    # ... 19 more keys\n    return resp\n</code></pre>"},{"location":"ARCHITECTURE_V2/#after-resourcegraph","title":"After (ResourceGraph)","text":"Python<pre><code>def delete_workspace(api, ctx, resources):\n    resp = api.delete(f\"/workspaces/{ctx['workspace_id']}\")\n    resources.destroy(\"workspace\", ctx[\"workspace_id\"])  # auto-cascades\n    return resp\n</code></pre>"},{"location":"ARCHITECTURE_V2/#task-dependencies","title":"Task Dependencies","text":"Text Only<pre><code>Task 1: runtime-core/ template\n    \u2193\nTask 2: ResourceGraphAdapter \u2500\u2500\u2192 Task 3: Wire into World\n    \u2193                                    \u2193\nTask 5: OpenAPI generator         Task 4: Agent preconditions\n    \u2193                                    \u2193\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Task 6: Integration tests \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"ARCHITECTURE_V2/#research-sources","title":"Research Sources","text":"<ul> <li>QuickCheck State Machine - symbolic references</li> <li>Hypothesis Stateful Testing - bundles, consumes()</li> <li>RESTler - producer-consumer inference</li> <li>Schemathesis - OpenAPI-driven testing</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances   of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at conduct@venomqa.dev or via GitHub's private reporting feature.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"INVARIANTS_GUIDE/","title":"Understanding Violations in VenomQA","text":""},{"location":"INVARIANTS_GUIDE/#what-is-a-violation","title":"What is a Violation?","text":"<p>A violation occurs when an invariant returns <code>False</code>.</p> <ul> <li>Invariant = A rule that must ALWAYS be true, no matter what sequence of actions was executed</li> <li>Violation = The invariant returned <code>False</code> \u2014 something is broken</li> </ul>"},{"location":"INVARIANTS_GUIDE/#how-developers-define-whats-a-violation","title":"How Developers Define What's a Violation","text":""},{"location":"INVARIANTS_GUIDE/#step-1-identify-business-rules","title":"Step 1: Identify Business Rules","text":"<p>Before writing code, list your business rules:</p> Text Only<pre><code>1. A user can't have negative balance\n2. Refunds can't exceed the original payment\n3. Deleted resources must return 404\n4. Open issues list must not contain closed issues\n5. Order total must equal sum of line items\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#step-2-write-the-invariant-function","title":"Step 2: Write the Invariant Function","text":"<p>Each invariant is a function that returns <code>True</code> (pass) or <code>False</code> (violation):</p> Python<pre><code>def refund_cannot_exceed_payment(world):\n    \"\"\"VIOLATION if refunded_amount &gt; payment_amount.\"\"\"\n    refund = world.context.get(\"refund_amount\") or 0\n    payment = world.context.get(\"payment_amount\") or 0\n\n    # Return True = OK, False = VIOLATION\n    return refund &lt;= payment\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#step-3-register-with-severity","title":"Step 3: Register with Severity","text":"Python<pre><code>from venomqa import Invariant, Severity\n\nInvariant(\n    name=\"refund_cannot_exceed_payment\",\n    check=refund_cannot_exceed_payment,\n    message=\"Refunded amount exceeds original payment. Billing integrity bug!\",\n    severity=Severity.CRITICAL,  # CRITICAL, HIGH, MEDIUM, LOW\n)\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#severity-guidelines","title":"Severity Guidelines","text":"Severity When to Use Examples <code>CRITICAL</code> Data corruption, security breach, money issues Over-refund, data leak, auth bypass <code>HIGH</code> Major feature broken Can't checkout, can't login <code>MEDIUM</code> Partial functionality loss Wrong count displayed, slow response <code>LOW</code> Minor issues Typo in response, extra whitespace"},{"location":"INVARIANTS_GUIDE/#common-invariant-patterns","title":"Common Invariant Patterns","text":""},{"location":"INVARIANTS_GUIDE/#pattern-1-check-context-state","title":"Pattern 1: Check Context State","text":"Python<pre><code>def user_must_exist_after_login(world):\n    \"\"\"After login action runs, user_id must be set.\"\"\"\n    if not world.context.has(\"logged_in\"):\n        return True  # Login hasn't run yet, skip\n    return world.context.get(\"user_id\") is not None\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#pattern-2-make-live-api-call","title":"Pattern 2: Make Live API Call","text":"Python<pre><code>def deleted_resource_returns_404(world):\n    \"\"\"After delete, GET must return 404.\"\"\"\n    deleted_id = world.context.get(\"deleted_resource_id\")\n    if not deleted_id:\n        return True  # Nothing deleted yet\n\n    resp = world.api.get(f\"/resources/{deleted_id}\")\n    return resp.status_code == 404\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#pattern-3-cross-reference-data","title":"Pattern 3: Cross-Reference Data","text":"Python<pre><code>def order_total_matches_items(world):\n    \"\"\"Order total must equal sum of line items.\"\"\"\n    order = world.context.get(\"order\")\n    if not order:\n        return True\n\n    expected_total = sum(item[\"price\"] * item[\"qty\"] for item in order[\"items\"])\n    return order[\"total\"] == expected_total\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#pattern-4-compare-api-vs-database","title":"Pattern 4: Compare API vs Database","text":"Python<pre><code>def api_count_matches_db(world):\n    \"\"\"API response count must match database count.\"\"\"\n    api_count = world.context.get(\"api_item_count\")\n\n    # Query database directly (if db adapter registered)\n    db = world.systems.get(\"db\")\n    if not db or api_count is None:\n        return True\n\n    db_count = db.query_one(\"SELECT COUNT(*) FROM items\")\n    return api_count == db_count\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#understanding-violation-output","title":"Understanding Violation Output","text":"<p>When a violation is detected:</p> Text Only<pre><code>[CRITICAL] refund_cannot_exceed_payment\n  Message: Refunded amount exceeds original payment. Billing integrity bug!\n\n  Reproduction Path:\n    -&gt; create_customer\n    -&gt; create_payment_intent\n    -&gt; confirm_payment\n    -&gt; create_refund           \u2190 This action triggered the violation\n\n  Request: POST http://localhost:8102/refunds\n  Response: 200\n  Body: {\"id\": \"re_123\", \"amount\": 2000, ...}\n</code></pre> <p>Key information: - Invariant name: Which rule was broken - Message: Human explanation of the issue - Reproduction path: Exact sequence of actions to reproduce - Request/Response: The HTTP call that led to the violation</p>"},{"location":"INVARIANTS_GUIDE/#good-defaults-for-complex-projects","title":"Good Defaults for Complex Projects","text":""},{"location":"INVARIANTS_GUIDE/#recommended-config-venomqayaml","title":"Recommended Config (<code>venomqa.yaml</code>)","text":"YAML<pre><code># Target API\nbase_url: \"http://localhost:8000\"\ntimeout: 30\n\n# Retry configuration\nretry:\n  max_attempts: 3\n  delay: 1\n  backoff_multiplier: 2\n  max_delay: 30\n  retry_on_status: [429, 500, 502, 503, 504]\n\n# Exploration settings\nexploration:\n  strategy: \"bfs\"           # bfs, dfs, random, coverage_guided\n  max_steps: 500            # Increase for more coverage\n  stop_on_first_violation: false  # Set true for fast feedback\n\n# Reporting\nreport:\n  formats: [html, json, junit]\n  output_dir: \"./reports\"\n  include_request_response: true  # Show full HTTP payloads\n\n# For CI/CD\nfail_on_severity: \"high\"    # Fail pipeline if HIGH or CRITICAL found\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#recommended-project-structure","title":"Recommended Project Structure","text":"Text Only<pre><code>qa/\n\u251c\u2500\u2500 venomqa.yaml           # Config\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth.py            # Login, logout, register\n\u2502   \u251c\u2500\u2500 users.py           # CRUD for users\n\u2502   \u2514\u2500\u2500 orders.py          # Order operations\n\u251c\u2500\u2500 invariants/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth.py            # Auth invariants\n\u2502   \u251c\u2500\u2500 data_integrity.py  # Cross-reference checks\n\u2502   \u2514\u2500\u2500 security.py        # Security invariants\n\u251c\u2500\u2500 journeys/\n\u2502   \u251c\u2500\u2500 auth_flow.py       # Focused: auth actions only\n\u2502   \u251c\u2500\u2500 order_flow.py      # Focused: order actions only\n\u2502   \u2514\u2500\u2500 full_exploration.py # All actions (needs more steps)\n\u2514\u2500\u2500 reports/\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#recommended-invariants-by-domain","title":"Recommended Invariants by Domain","text":"<p>Authentication: Python<pre><code>INVARIANTS = [\n    Invariant(name=\"logged_out_cant_access_protected\", check=..., severity=Severity.CRITICAL),\n    Invariant(name=\"session_expires_correctly\", check=..., severity=Severity.HIGH),\n    Invariant(name=\"password_not_in_response\", check=..., severity=Severity.CRITICAL),\n]\n</code></pre></p> <p>E-commerce: Python<pre><code>INVARIANTS = [\n    Invariant(name=\"cart_total_matches_items\", check=..., severity=Severity.CRITICAL),\n    Invariant(name=\"inventory_not_negative\", check=..., severity=Severity.CRITICAL),\n    Invariant(name=\"order_total_correct\", check=..., severity=Severity.CRITICAL),\n    Invariant(name=\"refund_within_bounds\", check=..., severity=Severity.CRITICAL),\n]\n</code></pre></p> <p>Data Integrity: Python<pre><code>INVARIANTS = [\n    Invariant(name=\"deleted_returns_404\", check=..., severity=Severity.HIGH),\n    Invariant(name=\"created_is_retrievable\", check=..., severity=Severity.CRITICAL),\n    Invariant(name=\"list_count_matches_db\", check=..., severity=Severity.MEDIUM),\n]\n</code></pre></p>"},{"location":"INVARIANTS_GUIDE/#testing-your-invariants","title":"Testing Your Invariants","text":""},{"location":"INVARIANTS_GUIDE/#1-plant-known-bugs","title":"1. Plant Known Bugs","text":"<p>Create a mock server with deliberate bugs to verify detection:</p> Python<pre><code># mock_server.py\n@app.post(\"/refunds\")\ndef create_refund(amount: int):\n    # BUG: No validation - allows over-refund\n    return {\"refund_id\": \"123\", \"amount\": amount}\n</code></pre> <p>Then run exploration: Bash<pre><code>python3 qa/journeys/payment_flow.py\n</code></pre></p> <p>Expected: VenomQA should find the <code>refund_cannot_exceed_payment</code> violation.</p>"},{"location":"INVARIANTS_GUIDE/#2-run-focused-explorations","title":"2. Run Focused Explorations","text":"<p>Don't start with 50 actions. Start focused:</p> Python<pre><code># Test just auth (5 actions, finds bugs in ~30 steps)\nagent = Agent(\n    actions=[login, logout, register, change_password, delete_account],\n    invariants=AUTH_INVARIANTS,\n    max_steps=100,\n)\n\n# Test just payments (5 actions, finds bugs in ~30 steps)\nagent = Agent(\n    actions=[create_customer, create_payment, confirm, refund, get_status],\n    invariants=PAYMENT_INVARIANTS,\n    max_steps=100,\n)\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#3-verify-reproduction-paths","title":"3. Verify Reproduction Paths","text":"<p>When a violation is found, manually replay the path:</p> Bash<pre><code># Violation says: create_user -&gt; create_order -&gt; apply_discount -&gt; checkout\ncurl -X POST localhost:8000/users -d '{\"name\": \"test\"}'\ncurl -X POST localhost:8000/orders -d '{\"user_id\": 1}'\ncurl -X POST localhost:8000/orders/1/discount -d '{\"code\": \"50OFF\"}'\ncurl -X POST localhost:8000/orders/1/checkout\n# Verify the bug exists\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#performance-avoid-slow-invariants","title":"Performance: Avoid Slow Invariants","text":"<p>Invariants are checked after every action. If an invariant makes HTTP calls, it can slow exploration significantly.</p> <p>Slow (HTTP call per check): Python<pre><code>def list_shows_only_open(world):\n    resp = world.api.get(\"/issues?state=open\")  # HTTP call every check!\n    issues = resp.json()\n    return all(i[\"state\"] == \"open\" for i in issues)\n</code></pre></p> <p>Fast (use context instead): Python<pre><code># Action stores data in context\ndef list_open_issues(api, context):\n    resp = api.get(\"/issues?state=open\")\n    context.set(\"open_issues\", resp.json())\n    return resp\n\n# Invariant reads from context (no HTTP call)\ndef list_shows_only_open(world):\n    issues = world.context.get(\"open_issues\")\n    if not issues:\n        return True  # Not fetched yet\n    return all(i[\"state\"] == \"open\" for i in issues)\n</code></pre></p> <p>Rule of thumb: - Store API responses in context via actions - Invariants should read from context, not call APIs - Exception: Cross-reference checks that MUST call the API</p>"},{"location":"INVARIANTS_GUIDE/#quick-reference","title":"Quick Reference","text":"Question Answer What's a violation? Invariant returned <code>False</code> What severity to use? CRITICAL for money/security, HIGH for broken features How many actions? Start with 5-10 per exploration How many steps? 100-500 depending on action count BFS vs DFS? BFS finds shallow bugs faster When to check invariants? After every action (default)"},{"location":"advanced/","title":"Advanced Usage","text":"<p>This guide covers advanced features and patterns in VenomQA.</p> <p>Prerequisites: Familiarity with Journeys and Configuration.</p>"},{"location":"advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Caching</li> <li>Parallel Execution</li> <li>Custom Reporters</li> <li>Custom State Backends</li> <li>Hooks and Extensions</li> <li>Performance Optimization</li> <li>Error Handling Strategies</li> <li>Testing Patterns</li> </ul>"},{"location":"advanced/#related-documentation","title":"Related Documentation","text":"Topic Document API Reference api.md Adapters adapters.md Examples examples.md FAQ FAQ.md"},{"location":"advanced/#caching","title":"Caching","text":""},{"location":"advanced/#response-caching","title":"Response Caching","text":"<p>Cache responses to speed up repeated requests:</p> Python<pre><code>from functools import lru_cache\nfrom venomqa import Client\n\nclass CachedClient(Client):\n    \"\"\"HTTP client with response caching for GET requests.\"\"\"\n\n    def __init__(self, *args, cache_size: int = 100, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._cache_size = cache_size\n        self._get_cached = lru_cache(maxsize=cache_size)(self._get_uncached)\n\n    def _get_uncached(self, path: str, cache_key: str) -&gt; dict:\n        \"\"\"Uncached GET implementation.\"\"\"\n        return super().get(path)\n\n    def get(self, path: str, **kwargs) -&gt; dict:\n        # Create cache key from path and params\n        import json\n        cache_key = json.dumps({\"path\": path, \"kwargs\": kwargs}, sort_keys=True)\n        return self._get_cached(path, cache_key)\n\n    def clear_cache(self):\n        \"\"\"Clear the response cache.\"\"\"\n        self._get_cached.cache_clear()\n</code></pre>"},{"location":"advanced/#authentication-token-caching","title":"Authentication Token Caching","text":"<p>Cache auth tokens across steps:</p> Python<pre><code>from venomqa.core.context import ExecutionContext\n\ndef login_with_cache(client, context: ExecutionContext):\n    \"\"\"Login with token caching to avoid repeated auth.\"\"\"\n    cached_token = context.get(\"_cached_auth_token\")\n\n    if cached_token:\n        client.set_auth_token(cached_token)\n        # Verify token still works\n        response = client.get(\"/api/auth/verify\")\n        if response.status_code == 200:\n            return response\n\n    # Perform fresh login\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n\n    if response.status_code == 200:\n        token = response.json()[\"token\"]\n        context[\"_cached_auth_token\"] = token\n        client.set_auth_token(token)\n\n    return response\n</code></pre>"},{"location":"advanced/#fixture-data-caching","title":"Fixture Data Caching","text":"<p>Cache expensive setup operations:</p> Python<pre><code>import hashlib\nimport pickle\nfrom pathlib import Path\n\nclass FixtureCache:\n    \"\"\"Cache fixture data to disk.\"\"\"\n\n    def __init__(self, cache_dir: str = \".venomqa_cache\"):\n        self.cache_dir = Path(cache_dir)\n        self.cache_dir.mkdir(exist_ok=True)\n\n    def _cache_key(self, data: dict) -&gt; str:\n        return hashlib.md5(pickle.dumps(data)).hexdigest()\n\n    def get(self, key: str) -&gt; dict | None:\n        cache_file = self.cache_dir / f\"{key}.pkl\"\n        if cache_file.exists():\n            return pickle.loads(cache_file.read_bytes())\n        return None\n\n    def set(self, key: str, data: dict) -&gt; None:\n        cache_file = self.cache_dir / f\"{key}.pkl\"\n        cache_file.write_bytes(pickle.dumps(data))\n\n    def cached_setup(self, setup_func, *args, **kwargs):\n        \"\"\"Run setup function with caching.\"\"\"\n        cache_key = self._cache_key({\"func\": setup_func.__name__, \"args\": args, \"kwargs\": kwargs})\n\n        cached = self.get(cache_key)\n        if cached is not None:\n            return cached\n\n        result = setup_func(*args, **kwargs)\n        self.set(cache_key, result)\n        return result\n</code></pre>"},{"location":"advanced/#parallel-execution","title":"Parallel Execution","text":""},{"location":"advanced/#enabling-parallel-paths","title":"Enabling Parallel Paths","text":"<p>Run branch paths in parallel:</p> Python<pre><code>from venomqa import JourneyRunner\n\nrunner = JourneyRunner(\n    client=client,\n    state_manager=state_manager,\n    parallel_paths=4,  # Run up to 4 paths concurrently\n)\n\nresult = runner.run(journey)\n</code></pre>"},{"location":"advanced/#configuration","title":"Configuration","text":"YAML<pre><code># venomqa.yaml\nparallel_paths: 4\n</code></pre>"},{"location":"advanced/#considerations-for-parallel-execution","title":"Considerations for Parallel Execution","text":"<ol> <li>State Isolation: Each parallel path needs isolated state</li> <li>Resource Limits: Don't exceed database connection limits</li> <li>Rate Limiting: APIs may have rate limits</li> </ol>"},{"location":"advanced/#isolating-state-for-parallel-paths","title":"Isolating State for Parallel Paths","text":"<p>When running in parallel, each path needs its own context:</p> Python<pre><code># The runner automatically handles this by:\n# 1. Creating a context snapshot before the branch\n# 2. Restoring the snapshot for each path\n# 3. Each path gets its own isolated context\n\n# For database state, ensure:\n# 1. Each path uses different record IDs\n# 2. Or use database-level transactions with SAVEPOINT\n</code></pre>"},{"location":"advanced/#parallel-journey-execution","title":"Parallel Journey Execution","text":"<p>Run multiple journeys in parallel:</p> Python<pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed\nfrom venomqa import JourneyRunner, Client\n\ndef run_journey(journey, config):\n    client = Client(base_url=config.base_url)\n    runner = JourneyRunner(client=client)\n    return runner.run(journey)\n\ndef run_all_parallel(journeys, config, max_workers=4):\n    results = []\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(run_journey, j, config): j\n            for j in journeys\n        }\n\n        for future in as_completed(futures):\n            journey = futures[future]\n            try:\n                result = future.result()\n                results.append(result)\n            except Exception as e:\n                print(f\"Journey {journey.name} failed: {e}\")\n\n    return results\n</code></pre>"},{"location":"advanced/#custom-reporters","title":"Custom Reporters","text":""},{"location":"advanced/#creating-a-custom-reporter","title":"Creating a Custom Reporter","text":"Python<pre><code>from pathlib import Path\nfrom typing import Any\nfrom venomqa.reporters.base import BaseReporter\nfrom venomqa.core.models import JourneyResult\n\nclass CSVReporter(BaseReporter):\n    \"\"\"Generate CSV reports for spreadsheet analysis.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".csv\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        lines = [\n            \"journey_name,success,duration_ms,total_steps,passed_steps,issue_count\"\n        ]\n\n        for result in results:\n            lines.append(\n                f\"{result.journey_name},\"\n                f\"{result.success},\"\n                f\"{result.duration_ms:.0f},\"\n                f\"{result.total_steps},\"\n                f\"{result.passed_steps},\"\n                f\"{len(result.issues)}\"\n            )\n\n        return \"\\n\".join(lines)\n\n\nclass SlackReporter(BaseReporter):\n    \"\"\"Send test results to Slack.\"\"\"\n\n    def __init__(self, webhook_url: str, output_path: str | Path | None = None):\n        super().__init__(output_path)\n        self.webhook_url = webhook_url\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".json\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; dict[str, Any]:\n        passed = sum(1 for r in results if r.success)\n        failed = len(results) - passed\n\n        color = \"good\" if failed == 0 else \"danger\"\n        status = \"All tests passed!\" if failed == 0 else f\"{failed} test(s) failed\"\n\n        return {\n            \"attachments\": [{\n                \"color\": color,\n                \"title\": \"VenomQA Test Results\",\n                \"text\": status,\n                \"fields\": [\n                    {\"title\": \"Passed\", \"value\": str(passed), \"short\": True},\n                    {\"title\": \"Failed\", \"value\": str(failed), \"short\": True},\n                ],\n            }]\n        }\n\n    def send_to_slack(self, results: list[JourneyResult]) -&gt; None:\n        import httpx\n\n        payload = self.generate(results)\n        httpx.post(self.webhook_url, json=payload)\n\n\nclass HTMLDashboardReporter(BaseReporter):\n    \"\"\"Generate interactive HTML dashboard.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".html\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        return f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;VenomQA Dashboard&lt;/title&gt;\n    &lt;style&gt;\n        body {{ font-family: system-ui, sans-serif; margin: 40px; }}\n        .card {{ border: 1px solid #e5e5e5; border-radius: 8px; padding: 16px; margin: 16px 0; }}\n        .passed {{ border-left: 4px solid #22c55e; }}\n        .failed {{ border-left: 4px solid #ef4444; }}\n        .metrics {{ display: flex; gap: 24px; }}\n        .metric {{ text-align: center; }}\n        .metric-value {{ font-size: 2em; font-weight: bold; }}\n        .metric-label {{ color: #666; }}\n        table {{ width: 100%; border-collapse: collapse; }}\n        th, td {{ padding: 8px; text-align: left; border-bottom: 1px solid #e5e5e5; }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;VenomQA Dashboard&lt;/h1&gt;\n\n    &lt;div class=\"card\"&gt;\n        &lt;div class=\"metrics\"&gt;\n            {self._generate_metrics(results)}\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"card\"&gt;\n        &lt;h2&gt;Journey Results&lt;/h2&gt;\n        &lt;table&gt;\n            &lt;tr&gt;\n                &lt;th&gt;Journey&lt;/th&gt;\n                &lt;th&gt;Status&lt;/th&gt;\n                &lt;th&gt;Duration&lt;/th&gt;\n                &lt;th&gt;Steps&lt;/th&gt;\n                &lt;th&gt;Issues&lt;/th&gt;\n            &lt;/tr&gt;\n            {self._generate_rows(results)}\n        &lt;/table&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n\n    def _generate_metrics(self, results: list[JourneyResult]) -&gt; str:\n        passed = sum(1 for r in results if r.success)\n        failed = len(results) - passed\n        total_duration = sum(r.duration_ms for r in results)\n\n        return f\"\"\"\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\" style=\"color: #22c55e;\"&gt;{passed}&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Passed&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\" style=\"color: #ef4444;\"&gt;{failed}&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Failed&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\"&gt;{total_duration/1000:.1f}s&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Duration&lt;/div&gt;\n            &lt;/div&gt;\n        \"\"\"\n\n    def _generate_rows(self, results: list[JourneyResult]) -&gt; str:\n        rows = []\n        for r in results:\n            status_class = \"passed\" if r.success else \"failed\"\n            status_icon = \"\u2713\" if r.success else \"\u2717\"\n            rows.append(f\"\"\"\n                &lt;tr class=\"{status_class}\"&gt;\n                    &lt;td&gt;{r.journey_name}&lt;/td&gt;\n                    &lt;td&gt;{status_icon}&lt;/td&gt;\n                    &lt;td&gt;{r.duration_ms:.0f}ms&lt;/td&gt;\n                    &lt;td&gt;{r.passed_steps}/{r.total_steps}&lt;/td&gt;\n                    &lt;td&gt;{len(r.issues)}&lt;/td&gt;\n                &lt;/tr&gt;\n            \"\"\")\n        return \"\\n\".join(rows)\n</code></pre>"},{"location":"advanced/#using-custom-reporters","title":"Using Custom Reporters","text":"Python<pre><code>from venomqa.reporters import MarkdownReporter\n\n# Use built-in reporter\nreporter = MarkdownReporter(output_path=\"reports/test.md\")\nreporter.save([result1, result2])\n\n# Use custom reporter\ncsv_reporter = CSVReporter(output_path=\"reports/results.csv\")\ncsv_reporter.save([result1, result2])\n\nslack_reporter = SlackReporter(webhook_url=\"https://hooks.slack.com/...\")\nslack_reporter.send_to_slack([result1, result2])\n</code></pre>"},{"location":"advanced/#custom-state-backends","title":"Custom State Backends","text":"<p>See Database Backends for implementing custom state backends.</p>"},{"location":"advanced/#hooks-and-extensions","title":"Hooks and Extensions","text":""},{"location":"advanced/#prepost-step-hooks","title":"Pre/Post Step Hooks","text":"Python<pre><code>from venomqa import JourneyRunner, Step\nfrom venomqa.core.models import StepResult\nfrom typing import Callable\n\nclass HookedJourneyRunner(JourneyRunner):\n    \"\"\"Runner with pre/post step hooks.\"\"\"\n\n    def __init__(self, *args, \n                 pre_step_hook: Callable | None = None,\n                 post_step_hook: Callable | None = None,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        self.pre_step_hook = pre_step_hook\n        self.post_step_hook = post_step_hook\n\n    def _run_step(self, step: Step, journey_name: str, path_name: str, context) -&gt; StepResult:\n        # Pre-step hook\n        if self.pre_step_hook:\n            self.pre_step_hook(step=step, journey=journey_name, path=path_name, context=context)\n\n        # Run the step\n        result = super()._run_step(step, journey_name, path_name, context)\n\n        # Post-step hook\n        if self.post_step_hook:\n            self.post_step_hook(step=step, result=result, context=context)\n\n        return result\n\n\n# Usage\ndef log_step(step, journey, path, context):\n    print(f\"Running: {journey}/{path}/{step.name}\")\n\ndef capture_screenshot_on_failure(step, result, context):\n    if not result.success:\n        # Take screenshot, save logs, etc.\n        print(f\"Step {step.name} failed, capturing diagnostics...\")\n\nrunner = HookedJourneyRunner(\n    client=client,\n    pre_step_hook=log_step,\n    post_step_hook=capture_screenshot_on_failure,\n)\n</code></pre>"},{"location":"advanced/#journey-lifecycle-hooks","title":"Journey Lifecycle Hooks","text":"Python<pre><code>class LifecycleRunner(JourneyRunner):\n    \"\"\"Runner with full lifecycle hooks.\"\"\"\n\n    def __init__(self, *args,\n                 on_journey_start: Callable | None = None,\n                 on_journey_end: Callable | None = None,\n                 on_branch_start: Callable | None = None,\n                 on_branch_end: Callable | None = None,\n                 on_path_start: Callable | None = None,\n                 on_path_end: Callable | None = None,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        self.on_journey_start = on_journey_start\n        self.on_journey_end = on_journey_end\n        self.on_branch_start = on_branch_start\n        self.on_branch_end = on_branch_end\n        self.on_path_start = on_path_start\n        self.on_path_end = on_path_end\n\n    def run(self, journey):\n        if self.on_journey_start:\n            self.on_journey_start(journey=journey)\n\n        result = super().run(journey)\n\n        if self.on_journey_end:\n            self.on_journey_end(journey=journey, result=result)\n\n        return result\n</code></pre>"},{"location":"advanced/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/#reduce-request-overhead","title":"Reduce Request Overhead","text":"Python<pre><code># Reuse client across journeys\nclient = Client(base_url=\"http://localhost:8000\")\nclient.connect()  # Keep connection open\n\nfor journey in journeys:\n    runner = JourneyRunner(client=client)\n    result = runner.run(journey)\n\nclient.disconnect()\n</code></pre>"},{"location":"advanced/#batch-operations","title":"Batch Operations","text":"Python<pre><code>def create_items_batch(client, context):\n    \"\"\"Create multiple items in one request.\"\"\"\n    items = [{\"name\": f\"Item {i}\"} for i in range(10)]\n    return client.post(\"/api/items/batch\", json={\"items\": items})\n</code></pre>"},{"location":"advanced/#skip-unnecessary-steps","title":"Skip Unnecessary Steps","text":"Python<pre><code>def conditional_step(client, context):\n    # Skip if already done\n    if context.get(\"setup_complete\"):\n        return {\"status\": \"skipped\"}\n\n    # Do expensive setup\n    result = client.post(\"/api/setup\", json={...})\n    context[\"setup_complete\"] = True\n    return result\n</code></pre>"},{"location":"advanced/#parallel-data-setup","title":"Parallel Data Setup","text":"Python<pre><code>from concurrent.futures import ThreadPoolExecutor\n\ndef setup_test_data_parallel(client, context):\n    \"\"\"Setup test data in parallel.\"\"\"\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        futures = [\n            executor.submit(client.post, \"/api/users\", json={\"name\": f\"User {i}\"})\n            for i in range(10)\n        ]\n        results = [f.result() for f in futures]\n\n    context[\"user_ids\"] = [r.json()[\"id\"] for r in results]\n    return results\n</code></pre>"},{"location":"advanced/#error-handling-strategies","title":"Error Handling Strategies","text":""},{"location":"advanced/#graceful-degradation","title":"Graceful Degradation","text":"Python<pre><code>def resilient_step(client, context):\n    \"\"\"Step that degrades gracefully on failure.\"\"\"\n    try:\n        response = client.get(\"/api/features\")\n        context[\"features\"] = response.json()\n    except Exception:\n        # Use defaults if features API is down\n        context[\"features\"] = {\"default_feature\": True}\n\n    return response\n</code></pre>"},{"location":"advanced/#retry-with-exponential-backoff","title":"Retry with Exponential Backoff","text":"Python<pre><code>import time\nimport random\n\ndef retry_with_backoff(func, max_retries=3, base_delay=1.0):\n    \"\"\"Execute function with exponential backoff retry.\"\"\"\n    for attempt in range(max_retries):\n        try:\n            return func()\n        except Exception as e:\n            if attempt == max_retries - 1:\n                raise\n\n            delay = base_delay * (2 ** attempt) + random.uniform(0, 1)\n            time.sleep(delay)\n\ndef flaky_api_call(client, context):\n    return retry_with_backoff(\n        lambda: client.get(\"/api/flaky-endpoint\"),\n        max_retries=5,\n        base_delay=0.5,\n    )\n</code></pre>"},{"location":"advanced/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"Python<pre><code>from datetime import datetime, timedelta\nfrom enum import Enum\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"\n    OPEN = \"open\"\n    HALF_OPEN = \"half_open\"\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker for unreliable services.\"\"\"\n\n    def __init__(self, failure_threshold: int = 3, recovery_timeout: float = 30.0):\n        self.failure_threshold = failure_threshold\n        self.recovery_timeout = recovery_timeout\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n        self.last_failure_time: datetime | None = None\n\n    def execute(self, func):\n        if self.state == CircuitState.OPEN:\n            if self._should_try_recovery():\n                self.state = CircuitState.HALF_OPEN\n            else:\n                raise Exception(\"Circuit breaker is open\")\n\n        try:\n            result = func()\n            self._on_success()\n            return result\n        except Exception as e:\n            self._on_failure()\n            raise e\n\n    def _should_try_recovery(self) -&gt; bool:\n        if self.last_failure_time is None:\n            return True\n        return datetime.now() - self.last_failure_time &gt; timedelta(seconds=self.recovery_timeout)\n\n    def _on_success(self):\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n\n    def _on_failure(self):\n        self.failures += 1\n        self.last_failure_time = datetime.now()\n        if self.failures &gt;= self.failure_threshold:\n            self.state = CircuitState.OPEN\n\n# Usage\ncircuit = CircuitBreaker(failure_threshold=3, recovery_timeout=30)\n\ndef protected_api_call(client, context):\n    return circuit.execute(lambda: client.get(\"/api/unreliable\"))\n</code></pre>"},{"location":"advanced/#known-limitations","title":"Known Limitations","text":""},{"location":"advanced/#parallel-path-execution-with-state-management","title":"Parallel Path Execution with State Management","text":"<p>When using <code>parallel_paths &gt; 1</code> (parallel branch execution), database state isolation is not guaranteed. Each path should start from the checkpoint state, but with parallel execution:</p> <ul> <li>All threads share the same database connection</li> <li>Rollback doesn't happen between parallel paths</li> <li>Paths may interfere with each other's database state</li> </ul> <p>Recommendation: Use <code>parallel_paths=1</code> (sequential execution) when: - Your journeys use database checkpoints and rollback - Your paths modify database state - State isolation between paths is important</p> <p>Parallel execution is safe when: - You're only testing read operations - Paths are independent and don't rely on specific database state - You're using the MockStateManager (in-memory)</p>"},{"location":"advanced/#testing-patterns","title":"Testing Patterns","text":""},{"location":"advanced/#data-driven-testing","title":"Data-Driven Testing","text":"Python<pre><code>from venomqa import Journey, Step\n\n# Test with multiple data sets\ntest_cases = [\n    {\"name\": \"valid_user\", \"email\": \"test@example.com\", \"expect_success\": True},\n    {\"name\": \"invalid_email\", \"email\": \"invalid\", \"expect_success\": False},\n    {\"name\": \"missing_email\", \"email\": None, \"expect_success\": False},\n]\n\njourneys = []\nfor case in test_cases:\n    def register_test(client, context, case=case):\n        return client.post(\"/api/register\", json={\"email\": case[\"email\"]})\n\n    journey = Journey(\n        name=f\"register_{case['name']}\",\n        steps=[\n            Step(\n                name=\"register\",\n                action=register_test,\n                expect_failure=not case[\"expect_success\"],\n            ),\n        ],\n    )\n    journeys.append(journey)\n</code></pre>"},{"location":"advanced/#smoke-tests","title":"Smoke Tests","text":"Python<pre><code>smoke_journey = Journey(\n    name=\"smoke_test\",\n    description=\"Quick health check of critical endpoints\",\n    timeout=30.0,\n    steps=[\n        Step(name=\"health\", action=lambda c, ctx: c.get(\"/health\")),\n        Step(name=\"api_status\", action=lambda c, ctx: c.get(\"/api/status\")),\n        Step(name=\"db_ping\", action=lambda c, ctx: c.get(\"/api/ping/db\")),\n    ],\n)\n</code></pre>"},{"location":"advanced/#regression-tests","title":"Regression Tests","text":"Python<pre><code># Capture expected responses for regression testing\nexpected_responses = {\n    \"get_user\": {\"id\": 1, \"name\": \"Test User\"},\n}\n\ndef regression_test_step(client, context):\n    response = client.get(\"/api/users/1\")\n    actual = response.json()\n    expected = expected_responses[\"get_user\"]\n\n    if actual != expected:\n        context[\"regression_diff\"] = {\n            \"expected\": expected,\n            \"actual\": actual,\n        }\n        raise AssertionError(\"Response differs from expected\")\n\n    return response\n</code></pre>"},{"location":"advanced/#chaos-testing","title":"Chaos Testing","text":"Python<pre><code>import random\n\ndef chaos_step(client, context):\n    \"\"\"Introduce random failures for resilience testing.\"\"\"\n    # Randomly fail 10% of the time\n    if random.random() &lt; 0.1:\n        raise Exception(\"Chaos monkey strike!\")\n\n    return client.get(\"/api/data\")\n\ndef slow_network_step(client, context):\n    \"\"\"Simulate slow network conditions.\"\"\"\n    import time\n    time.sleep(random.uniform(0.5, 2.0))  # Random delay\n    return client.get(\"/api/data\")\n</code></pre>"},{"location":"advanced/#ports-adapters","title":"Ports &amp; Adapters","text":"<p>The Ports and Adapters architecture enables clean separation between test logic and external dependencies.</p>"},{"location":"advanced/#dependency-injection-pattern","title":"Dependency Injection Pattern","text":"<p>Inject adapters through constructor or fixtures:</p> Python<pre><code>import pytest\nfrom venomqa.ports import CachePort, MailPort\nfrom venomqa.adapters import RedisCacheAdapter, MailhogAdapter\n\nclass TestUserRegistration:\n    def __init__(self, cache: CachePort, mail: MailPort):\n        self.cache = cache\n        self.mail = mail\n\n    def test_registration_sends_email(self):\n        # Register user\n        self.register_user(\"test@example.com\")\n\n        # Verify email was sent\n        email = self.mail.wait_for_email(\n            to=\"test@example.com\",\n            subject=\"Welcome\",\n            timeout=30.0,\n        )\n        assert email is not None\n\n        # Verify cache was updated\n        assert self.cache.exists(\"user:test@example.com\")\n\n# Using with pytest fixtures\n@pytest.fixture\ndef cache():\n    return RedisCacheAdapter(host=\"localhost\")\n\n@pytest.fixture\ndef mail():\n    return MailhogAdapter(host=\"localhost\")\n\ndef test_with_adapters(cache, mail):\n    tester = TestUserRegistration(cache, mail)\n    tester.test_registration_sends_email()\n</code></pre>"},{"location":"advanced/#swapping-adapters-for-testing","title":"Swapping Adapters for Testing","text":"<p>Use different adapters for different test environments:</p> Python<pre><code>from venomqa.ports import CachePort\nfrom venomqa.adapters import RedisCacheAdapter, LocalStorageAdapter\n\ndef get_cache_adapter(env: str) -&gt; CachePort:\n    if env == \"production\":\n        return RedisCacheAdapter(\n            host=\"redis.production.internal\",\n            password=os.environ[\"REDIS_PASSWORD\"],\n        )\n    elif env == \"staging\":\n        return RedisCacheAdapter(host=\"localhost\")\n    else:\n        # In-memory adapter for unit tests\n        return LocalStorageAdapter(base_path=\"/tmp/test-cache\")\n</code></pre>"},{"location":"advanced/#time-travel-testing","title":"Time Travel Testing","text":"<p>Test time-dependent logic without waiting:</p> Python<pre><code>from datetime import timedelta\nfrom venomqa.adapters import ControllableTimeAdapter\n\ndef test_token_expiration():\n    time = ControllableTimeAdapter()\n    time.freeze()\n\n    # Create token that expires in 1 hour\n    token = create_token(expires_in=3600)\n    assert token.is_valid()\n\n    # Fast forward 59 minutes\n    time.advance(timedelta(minutes=59))\n    assert token.is_valid()\n\n    # Fast forward 1 more minute - token should expire\n    time.advance(timedelta(minutes=1))\n    assert not token.is_valid()\n\ndef test_scheduled_task():\n    time = ControllableTimeAdapter()\n    results = []\n\n    def callback():\n        results.append(\"executed\")\n\n    # Schedule task for 5 seconds\n    time.schedule_after(5.0, callback)\n\n    # Time hasn't advanced yet\n    assert len(results) == 0\n\n    # Advance past scheduled time\n    time.advance(timedelta(seconds=5))\n    assert len(results) == 1\n</code></pre>"},{"location":"advanced/#mock-server-integration","title":"Mock Server Integration","text":"<p>Use WireMock for API stubbing in tests:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import WireMockAdapter\nfrom venomqa import Client\n\n@pytest.fixture\ndef mock_server():\n    mock = WireMockAdapter(port=8080)\n    yield mock\n    mock.reset()\n\ndef test_api_with_mock(mock_server):\n    # Stub API response\n    mock_server.stub(\n        \"GET\",\n        \"/api/users/1\",\n        body={\"id\": 1, \"name\": \"John Doe\"},\n        status_code=200,\n    )\n\n    # Stub error response\n    mock_server.stub(\n        \"GET\",\n        \"/api/users/999\",\n        body={\"error\": \"Not found\"},\n        status_code=404,\n    )\n\n    # Use mocked API\n    client = Client(base_url=mock_server.get_base_url())\n\n    response = client.get(\"/api/users/1\")\n    assert response.status_code == 200\n    assert response.json()[\"name\"] == \"John Doe\"\n\n    # Verify request was made\n    assert mock_server.verify(\"GET\", \"/api/users/1\", count=1)\n\ndef test_sequential_responses(mock_server):\n    # Return different responses on each call\n    mock_server.stub_sequence(\"POST\", \"/api/orders\", responses=[\n        MockResponse(status_code=201, body={\"id\": 1}),\n        MockResponse(status_code=201, body={\"id\": 2}),\n        MockResponse(status_code=429, body={\"error\": \"Rate limited\"}),\n    ])\n\n    client = Client(base_url=mock_server.get_base_url())\n\n    # First call\n    r1 = client.post(\"/api/orders\")\n    assert r1.status_code == 201\n\n    # Second call\n    r2 = client.post(\"/api/orders\")\n    assert r2.status_code == 201\n\n    # Third call - rate limited\n    r3 = client.post(\"/api/orders\")\n    assert r3.status_code == 429\n</code></pre>"},{"location":"advanced/#parallel-task-execution","title":"Parallel Task Execution","text":"<p>Test concurrent operations:</p> Python<pre><code>from venomqa.adapters import ThreadingConcurrencyAdapter\n\ndef test_concurrent_requests():\n    concurrency = ThreadingConcurrencyAdapter(max_workers=10)\n\n    def make_request(user_id):\n        # Simulate API call\n        return client.get(f\"/api/users/{user_id}\")\n\n    # Spawn 100 concurrent tasks\n    task_ids = concurrency.map_async(make_request, range(100))\n\n    # Wait for all to complete\n    results = concurrency.join_all(task_ids, timeout=30.0)\n\n    # Verify all succeeded\n    successful = [r for r in results if r.success]\n    assert len(successful) == 100\n</code></pre>"},{"location":"advanced/#email-testing-workflow","title":"Email Testing Workflow","text":"<p>Complete email testing with cleanup:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import MailhogAdapter\n\n@pytest.fixture\ndef mail():\n    adapter = MailhogAdapter(host=\"localhost\")\n    adapter.delete_all_emails()  # Clean slate\n    yield adapter\n    adapter.delete_all_emails()  # Cleanup\n\ndef test_password_reset_email(mail):\n    # Request password reset\n    response = client.post(\"/api/auth/forgot-password\", json={\n        \"email\": \"user@example.com\",\n    })\n    assert response.status_code == 200\n\n    # Wait for and verify email\n    email = mail.wait_for_email(\n        to=\"user@example.com\",\n        subject=\"Password Reset\",\n        timeout=30.0,\n    )\n\n    assert email is not None\n    assert \"reset\" in email.body.lower()\n\n    # Extract reset link from email\n    import re\n    match = re.search(r'https://\\S+/reset/\\S+', email.body)\n    assert match\n    reset_link = match.group(0)\n\n    # Use reset link\n    response = client.post(reset_link, json={\"password\": \"newpass123\"})\n    assert response.status_code == 200\n</code></pre>"},{"location":"advanced/#cache-testing-patterns","title":"Cache Testing Patterns","text":"<p>Test cache behavior:</p> Python<pre><code>from venomqa.adapters import RedisCacheAdapter\n\ndef test_cache_expiration():\n    cache = RedisCacheAdapter()\n\n    # Set with TTL\n    cache.set(\"session:abc123\", {\"user_id\": 1}, ttl=60)\n\n    # Verify exists\n    assert cache.exists(\"session:abc123\")\n\n    # Check TTL\n    ttl = cache.get_ttl(\"session:abc123\")\n    assert 0 &lt; ttl &lt;= 60\n\n    # Get stats\n    stats = cache.get_stats()\n    print(f\"Hit rate: {stats.hit_rate}%\")\n\ndef test_cache_invalidation():\n    cache = RedisCacheAdapter()\n\n    # Cache user data\n    cache.set(\"user:1\", {\"name\": \"John\", \"role\": \"user\"})\n\n    # Update user\n    update_user(1, role=\"admin\")\n\n    # Invalidate cache\n    cache.delete(\"user:1\")\n\n    # Next read will fetch fresh data\n    user = cache.get(\"user:1\")\n    assert user is None\n</code></pre>"},{"location":"advanced/#queue-testing-patterns","title":"Queue Testing Patterns","text":"<p>Test async job processing:</p> Python<pre><code>from venomqa.adapters import RedisQueueAdapter\n\ndef test_job_queue():\n    queue = RedisQueueAdapter(host=\"localhost\")\n\n    # Clear queue\n    queue.clear_queue(\"test\")\n\n    # Enqueue job\n    job_id = queue.enqueue(\n        \"myapp.tasks.send_notification\",\n        user_id=123,\n        message=\"Hello!\",\n        queue=\"test\",\n    )\n\n    # Check job status\n    job = queue.get_job(job_id)\n    assert job.status == \"pending\"\n\n    # Wait for completion (requires worker running)\n    result = queue.get_job_result(job_id, timeout=60.0)\n\n    if result:\n        assert result.success\n        print(f\"Job result: {result.result}\")\n\n    # Check for failed jobs\n    failed = queue.get_failed_jobs(queue=\"test\")\n    assert len(failed) == 0\n</code></pre>"},{"location":"advanced/#creating-test-fixtures-with-ports","title":"Creating Test Fixtures with Ports","text":"<p>Create reusable test fixtures:</p> Python<pre><code>import pytest\nfrom typing import TypeVar, Protocol\nfrom venomqa.ports import CachePort, MailPort, QueuePort\n\nT = TypeVar('T')\n\nclass TestFixtures:\n    \"\"\"Collection of test fixtures using ports.\"\"\"\n\n    def __init__(\n        self,\n        cache: CachePort,\n        mail: MailPort,\n        queue: QueuePort,\n    ):\n        self.cache = cache\n        self.mail = mail\n        self.queue = queue\n\n    def reset(self):\n        \"\"\"Reset all fixtures to clean state.\"\"\"\n        self.cache.clear()\n        self.mail.delete_all_emails()\n        self.queue.clear_queue()\n\n    def cached_user(self, user_id: int) -&gt; dict:\n        \"\"\"Get or create cached user.\"\"\"\n        key = f\"test:user:{user_id}\"\n        user = self.cache.get(key)\n        if user is None:\n            user = {\"id\": user_id, \"name\": f\"User {user_id}\"}\n            self.cache.set(key, user, ttl=300)\n        return user\n\n@pytest.fixture\ndef fixtures():\n    from venomqa.adapters import (\n        RedisCacheAdapter,\n        MailhogAdapter,\n        RedisQueueAdapter,\n    )\n\n    fx = TestFixtures(\n        cache=RedisCacheAdapter(),\n        mail=MailhogAdapter(),\n        queue=RedisQueueAdapter(),\n    )\n    fx.reset()\n    yield fx\n    fx.reset()\n</code></pre>"},{"location":"advanced/#health-check-pattern","title":"Health Check Pattern","text":"<p>Verify external services before tests:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import (\n    RedisCacheAdapter,\n    MailhogAdapter,\n    ElasticsearchAdapter,\n)\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef verify_services():\n    \"\"\"Verify all required services are healthy.\"\"\"\n    services = [\n        (\"Redis\", RedisCacheAdapter()),\n        (\"MailHog\", MailhogAdapter()),\n        (\"Elasticsearch\", ElasticsearchAdapter()),\n    ]\n\n    unhealthy = []\n    for name, adapter in services:\n        if not adapter.health_check():\n            unhealthy.append(name)\n\n    if unhealthy:\n        pytest.skip(f\"Services not available: {', '.join(unhealthy)}\")\n</code></pre>"},{"location":"advanced/#multi-environment-configuration","title":"Multi-Environment Configuration","text":"<p>Configure adapters for different environments:</p> Python<pre><code>from dataclasses import dataclass\nfrom venomqa.ports import CachePort, MailPort\nfrom venomqa.adapters import RedisCacheAdapter, MailhogAdapter, MailpitAdapter\n\n@dataclass\nclass Environment:\n    name: str\n    cache: CachePort\n    mail: MailPort\n\ndef get_environment() -&gt; Environment:\n    env_name = os.environ.get(\"ENV\", \"local\")\n\n    if env_name == \"production\":\n        return Environment(\n            name=\"production\",\n            cache=RedisCacheAdapter(\n                host=\"redis.prod.internal\",\n                password=os.environ[\"REDIS_PASSWORD\"],\n            ),\n            mail=MailpitAdapter(\n                host=\"mail.prod.internal\",\n                use_tls=True,\n            ),\n        )\n    elif env_name == \"staging\":\n        return Environment(\n            name=\"staging\",\n            cache=RedisCacheAdapter(host=\"localhost\"),\n            mail=MailhogAdapter(host=\"localhost\"),\n        )\n    else:\n        return Environment(\n            name=\"local\",\n            cache=RedisCacheAdapter(host=\"localhost\"),\n            mail=MailhogAdapter(host=\"localhost\"),\n        )\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to VenomQA will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>MkDocs documentation site with Material theme</li> <li>Comprehensive API documentation</li> <li>Tutorial guides for common scenarios</li> <li>Advanced usage documentation</li> </ul>"},{"location":"changelog/#020-2024-01-15","title":"[0.2.0] - 2024-01-15","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Ports and Adapters architecture</li> <li>Multiple cache adapters (Redis, Memory)</li> <li>Email testing adapters (Mailhog, Mailpit)</li> <li>Queue adapters (Redis Queue, Celery)</li> <li>Time control adapter for testing</li> <li>Mock server adapter (WireMock)</li> <li>SARIF report format</li> <li>Slack and Discord reporters</li> <li>Performance optimizations (connection pooling, caching)</li> <li>Security features (input validation, secrets management)</li> <li>File handling utilities</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improved error messages with fix suggestions</li> <li>Enhanced CLI output formatting</li> <li>Better parallel execution support</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Checkpoint rollback in nested branches</li> <li>Context restoration edge cases</li> <li>Connection handling in long-running journeys</li> </ul>"},{"location":"changelog/#010-2024-01-01","title":"[0.1.0] - 2024-01-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Initial release</li> <li>Core journey DSL (Journey, Step, Checkpoint, Branch, Path)</li> <li>PostgreSQL state management</li> <li>HTTP client with retry logic</li> <li>Basic reporters (Markdown, JSON, JUnit)</li> <li>Docker Compose integration</li> <li>CLI tool (venomqa run, venomqa list, venomqa report)</li> </ul>"},{"location":"changelog/#version-history","title":"Version History","text":"Version Date Highlights 0.2.0 2024-01-15 Ports &amp; Adapters, Performance 0.1.0 2024-01-01 Initial release"},{"location":"changelog/#upgrade-guide","title":"Upgrade Guide","text":""},{"location":"changelog/#01x-to-02x","title":"0.1.x to 0.2.x","text":"<p>No breaking changes. New features are additive.</p> <p>To use new adapters:</p> Bash<pre><code>pip install \"venomqa[redis,s3]\"  # Install adapter dependencies\n</code></pre>"},{"location":"changelog/#roadmap","title":"Roadmap","text":""},{"location":"changelog/#v030-enhanced-reporting","title":"v0.3.0 - Enhanced Reporting","text":"<ul> <li>Interactive HTML reports with charts</li> <li>Slack/Teams webhook notifications</li> <li>Test trend analysis</li> <li>Flaky test detection</li> </ul>"},{"location":"changelog/#v040-parallel-execution","title":"v0.4.0 - Parallel Execution","text":"<ul> <li>Distributed journey execution</li> <li>Shared state cache for checkpoints</li> <li>Resource-aware scheduling</li> </ul>"},{"location":"changelog/#v050-ai-powered-features","title":"v0.5.0 - AI-Powered Features","text":"<ul> <li>Journey generation from OpenAPI specs</li> <li>Intelligent failure analysis</li> <li>Anomaly detection</li> </ul> <p>See GitHub Projects for detailed tracking.</p>"},{"location":"ci-cd/","title":"VenomQA CI/CD Integration Guide","text":"<p>This guide covers how to integrate VenomQA into your CI/CD pipelines for automated journey testing.</p>"},{"location":"ci-cd/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Exit Codes</li> <li>GitHub Actions</li> <li>GitLab CI</li> <li>Docker-based Runner</li> <li>Other CI Systems</li> <li>Best Practices</li> <li>Handling Secrets</li> <li>Parallelization Strategies</li> <li>Troubleshooting</li> </ul>"},{"location":"ci-cd/#overview","title":"Overview","text":"<p>VenomQA is designed for CI/CD environments with proper exit codes, report generation, and configurable timeouts. The CLI returns meaningful exit codes that CI systems can use to determine build success or failure.</p>"},{"location":"ci-cd/#key-features-for-cicd","title":"Key Features for CI/CD","text":"<ul> <li>Proper Exit Codes: Clear indication of success, failure, or configuration errors</li> <li>Multiple Report Formats: JUnit XML, HTML, JSON, and Markdown</li> <li>Docker Support: Pre-built runner image for consistent environments</li> <li>Parallel Execution: Run journey groups in parallel for faster feedback</li> <li>Service Orchestration: Integration with Docker Compose for test dependencies</li> </ul>"},{"location":"ci-cd/#exit-codes","title":"Exit Codes","text":"<p>VenomQA uses standard exit codes for CI/CD integration:</p> Exit Code Meaning CI Action <code>0</code> All journeys passed Build succeeds <code>1</code> Some journeys failed Build fails <code>2</code> Configuration error Build fails (setup issue) <p>Example usage in shell scripts:</p> Bash<pre><code>venomqa run --config qa/venomqa.yaml\nEXIT_CODE=$?\n\ncase $EXIT_CODE in\n    0)\n        echo \"All journeys passed!\"\n        ;;\n    1)\n        echo \"Some journeys failed - check reports\"\n        exit 1\n        ;;\n    2)\n        echo \"Configuration error - check venomqa.yaml\"\n        exit 2\n        ;;\nesac\n</code></pre>"},{"location":"ci-cd/#github-actions","title":"GitHub Actions","text":""},{"location":"ci-cd/#basic-setup","title":"Basic Setup","text":"<p>Create <code>.github/workflows/venomqa.yml</code>:</p> YAML<pre><code>name: VenomQA Tests\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:15-alpine\n        env:\n          POSTGRES_USER: qa\n          POSTGRES_PASSWORD: ${{ secrets.QA_DB_PASSWORD }}\n          POSTGRES_DB: venomqa_qa\n        ports:\n          - 5432:5432\n        options: &gt;-\n          --health-cmd \"pg_isready -U qa\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.12'\n          cache: 'pip'\n\n      - name: Install VenomQA\n        run: pip install venomqa[all]\n\n      - name: Start application\n        run: docker compose up -d --wait\n\n      - name: Run journeys\n        run: |\n          venomqa run --config qa/venomqa.yaml\n\n      - name: Generate reports\n        if: always()\n        run: |\n          mkdir -p reports\n          venomqa report --format junit --output reports/junit.xml\n          venomqa report --format html --output reports/report.html\n\n      - name: Upload reports\n        uses: actions/upload-artifact@v4\n        if: always()\n        with:\n          name: venomqa-reports\n          path: reports/\n</code></pre>"},{"location":"ci-cd/#parallel-journey-groups","title":"Parallel Journey Groups","text":"<p>For larger test suites, run journey groups in parallel:</p> YAML<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        group: [auth, checkout, api, content]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Run ${{ matrix.group }} journeys\n        run: |\n          venomqa run ${{ matrix.group }}_* --config qa/venomqa.yaml\n</code></pre>"},{"location":"ci-cd/#full-example","title":"Full Example","text":"<p>See <code>.github/workflows/venomqa.yml.example</code> for a complete workflow with: - Configuration validation - Parallel test execution - Artifact collection - JUnit report publishing - Conditional deployment</p>"},{"location":"ci-cd/#gitlab-ci","title":"GitLab CI","text":""},{"location":"ci-cd/#basic-setup_1","title":"Basic Setup","text":"<p>Create <code>.gitlab-ci.yml</code>:</p> YAML<pre><code>stages:\n  - test\n  - deploy\n\nvariables:\n  POSTGRES_USER: qa\n  POSTGRES_PASSWORD: $QA_DB_PASSWORD\n  POSTGRES_DB: venomqa_qa\n\ntest:\n  stage: test\n  image: python:3.12\n  services:\n    - postgres:15-alpine\n    - redis:7-alpine\n  script:\n    - pip install venomqa[all]\n    - venomqa run --config qa/venomqa.yaml\n    - venomqa report --format junit --output reports/junit.xml\n  artifacts:\n    when: always\n    paths:\n      - reports/\n    reports:\n      junit: reports/junit.xml\n</code></pre>"},{"location":"ci-cd/#parallel-groups-with-gitlab","title":"Parallel Groups with GitLab","text":"YAML<pre><code>.test-template:\n  stage: test\n  image: python:3.12\n  services:\n    - postgres:15-alpine\n  before_script:\n    - pip install venomqa[all]\n  artifacts:\n    when: always\n    reports:\n      junit: reports/junit-*.xml\n\ntest-auth:\n  extends: .test-template\n  script:\n    - venomqa run auth_* --config qa/venomqa.yaml\n    - venomqa report --format junit --output reports/junit-auth.xml\n\ntest-checkout:\n  extends: .test-template\n  script:\n    - venomqa run checkout_* --config qa/venomqa.yaml\n    - venomqa report --format junit --output reports/junit-checkout.xml\n</code></pre>"},{"location":"ci-cd/#full-example_1","title":"Full Example","text":"<p>See <code>.gitlab-ci.yml.example</code> for a complete pipeline with: - Multi-stage workflow - Parallel job execution - GitLab Pages for reports - Environment-based deployment</p>"},{"location":"ci-cd/#docker-based-runner","title":"Docker-based Runner","text":"<p>VenomQA provides a Docker image that can run in any CI system.</p>"},{"location":"ci-cd/#building-the-runner-image","title":"Building the Runner Image","text":"Bash<pre><code># Build the runner image\ndocker build -f docker/Dockerfile.runner -t venomqa-runner:latest .\n\n# Or use multi-stage for smaller image\ndocker build -f docker/Dockerfile.runner --target production -t venomqa-runner:prod .\n</code></pre>"},{"location":"ci-cd/#using-the-runner","title":"Using the Runner","text":"Bash<pre><code># Run journeys with mounted volumes\ndocker run --rm \\\n  -e API_BASE_URL=http://host.docker.internal:8000 \\\n  -v $(pwd)/qa:/app/qa:ro \\\n  -v $(pwd)/reports:/app/reports \\\n  venomqa-runner:latest \\\n  run --config qa/venomqa.yaml\n</code></pre>"},{"location":"ci-cd/#docker-compose-integration","title":"Docker Compose Integration","text":"YAML<pre><code>version: \"3.8\"\n\nservices:\n  api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      - postgres\n\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_USER: qa\n      POSTGRES_PASSWORD: qapass\n      POSTGRES_DB: qa\n\n  venomqa:\n    image: venomqa-runner:latest\n    environment:\n      - API_BASE_URL=http://api:8000\n      - WAIT_FOR_POSTGRES=postgres:5432\n      - WAIT_FOR_HTTP=http://api:8000/health\n    volumes:\n      - ./qa:/app/qa:ro\n      - ./reports:/app/reports\n    depends_on:\n      - api\n    command: [\"run\", \"--config\", \"qa/venomqa.yaml\"]\n</code></pre>"},{"location":"ci-cd/#helper-scripts","title":"Helper Scripts","text":"<p>The runner image includes helper scripts:</p> <p>wait-for-services.sh: Wait for dependencies before running tests</p> Bash<pre><code>docker run --rm venomqa-runner:latest \\\n  /usr/local/bin/wait-for-services.sh \\\n    --postgres db:5432 \\\n    --redis cache:6379 \\\n    --http http://api:8000/health \\\n    -- venomqa run\n</code></pre> <p>run-journeys.sh: Comprehensive test runner with reports</p> Bash<pre><code>docker run --rm \\\n  -e WAIT_FOR_POSTGRES=db:5432 \\\n  -e VENOMQA_CONFIG=qa/venomqa.yaml \\\n  -v ./qa:/app/qa:ro \\\n  -v ./reports:/app/reports \\\n  venomqa-runner:latest \\\n  /usr/local/bin/run-journeys.sh\n</code></pre>"},{"location":"ci-cd/#other-ci-systems","title":"Other CI Systems","text":""},{"location":"ci-cd/#jenkins","title":"Jenkins","text":"Groovy<pre><code>pipeline {\n    agent {\n        docker {\n            image 'venomqa-runner:latest'\n        }\n    }\n\n    environment {\n        API_BASE_URL = 'http://localhost:8000'\n    }\n\n    stages {\n        stage('Test') {\n            steps {\n                sh 'venomqa run --config qa/venomqa.yaml'\n            }\n            post {\n                always {\n                    sh 'venomqa report --format junit --output reports/junit.xml'\n                    junit 'reports/junit.xml'\n                    archiveArtifacts artifacts: 'reports/**'\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"ci-cd/#circleci","title":"CircleCI","text":"YAML<pre><code>version: 2.1\n\njobs:\n  test:\n    docker:\n      - image: python:3.12\n      - image: postgres:15-alpine\n        environment:\n          POSTGRES_USER: qa\n          POSTGRES_PASSWORD: qapass\n          POSTGRES_DB: qa\n    steps:\n      - checkout\n      - run:\n          name: Install VenomQA\n          command: pip install venomqa[all]\n      - run:\n          name: Run journeys\n          command: venomqa run --config qa/venomqa.yaml\n      - run:\n          name: Generate reports\n          command: venomqa report --format junit --output reports/junit.xml\n          when: always\n      - store_test_results:\n          path: reports\n      - store_artifacts:\n          path: reports\n\nworkflows:\n  test:\n    jobs:\n      - test\n</code></pre>"},{"location":"ci-cd/#azure-devops","title":"Azure DevOps","text":"YAML<pre><code>trigger:\n  - main\n\npool:\n  vmImage: 'ubuntu-latest'\n\nservices:\n  postgres:\n    image: postgres:15-alpine\n    ports:\n      - 5432:5432\n\nsteps:\n  - task: UsePythonVersion@0\n    inputs:\n      versionSpec: '3.12'\n\n  - script: pip install venomqa[all]\n    displayName: Install VenomQA\n\n  - script: venomqa run --config qa/venomqa.yaml\n    displayName: Run Journeys\n\n  - script: |\n      venomqa report --format junit --output $(Build.ArtifactStagingDirectory)/junit.xml\n    displayName: Generate Reports\n    condition: always()\n\n  - task: PublishTestResults@2\n    inputs:\n      testResultsFormat: 'JUnit'\n      testResultsFiles: '$(Build.ArtifactStagingDirectory)/junit.xml'\n    condition: always()\n</code></pre>"},{"location":"ci-cd/#buildkite","title":"Buildkite","text":"YAML<pre><code>steps:\n  - label: \":snake: VenomQA Tests\"\n    command:\n      - pip install venomqa[all]\n      - venomqa run --config qa/venomqa.yaml\n      - venomqa report --format junit --output reports/junit.xml\n    plugins:\n      - docker-compose#v4.0.0:\n          services:\n            - postgres\n            - redis\n    artifact_paths:\n      - \"reports/**\"\n</code></pre>"},{"location":"ci-cd/#best-practices","title":"Best Practices","text":""},{"location":"ci-cd/#1-fail-fast-in-development-full-run-in-ci","title":"1. Fail Fast in Development, Full Run in CI","text":"YAML<pre><code># Development - stop on first failure for quick feedback\nvenomqa run --fail-fast --config qa/venomqa.yaml\n\n# CI - run all tests for complete picture\nvenomqa run --config qa/venomqa.yaml\n</code></pre>"},{"location":"ci-cd/#2-use-journey-groups-for-parallelization","title":"2. Use Journey Groups for Parallelization","text":"<p>Organize journeys by domain: Text Only<pre><code>qa/journeys/\n  auth_login.py\n  auth_registration.py\n  checkout_basic.py\n  checkout_with_coupon.py\n  api_crud.py\n  api_versioning.py\n</code></pre></p> <p>Then run groups in parallel: YAML<pre><code>matrix:\n  group: [auth, checkout, api]\n</code></pre></p>"},{"location":"ci-cd/#3-generate-multiple-report-formats","title":"3. Generate Multiple Report Formats","text":"Bash<pre><code># JUnit for CI integration\nvenomqa report --format junit --output reports/junit.xml\n\n# HTML for human review\nvenomqa report --format html --output reports/report.html\n\n# JSON for custom processing\nvenomqa report --format json --output reports/results.json\n</code></pre>"},{"location":"ci-cd/#4-set-appropriate-timeouts","title":"4. Set Appropriate Timeouts","text":"YAML<pre><code># venomqa.yaml\ntimeout: 30  # Default request timeout\n\n# For specific slow operations, override in journey\nsteps:\n  - name: process_large_file\n    action: upload.process\n    timeout: 120  # 2 minutes for this step\n</code></pre>"},{"location":"ci-cd/#5-use-health-checks","title":"5. Use Health Checks","text":"<p>Always wait for services before running tests:</p> YAML<pre><code>services:\n  api:\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n</code></pre>"},{"location":"ci-cd/#6-capture-logs-on-failure","title":"6. Capture Logs on Failure","text":"YAML<pre><code>- name: Collect logs on failure\n  if: failure()\n  run: |\n    docker compose logs &gt; reports/docker.log\n    docker ps -a &gt; reports/containers.txt\n</code></pre>"},{"location":"ci-cd/#handling-secrets","title":"Handling Secrets","text":""},{"location":"ci-cd/#environment-variables","title":"Environment Variables","text":"<p>Never commit secrets to code. Use CI/CD secret management:</p> <p>GitHub Actions: YAML<pre><code>env:\n  DATABASE_URL: ${{ secrets.DATABASE_URL }}\n  API_KEY: ${{ secrets.API_KEY }}\n</code></pre></p> <p>GitLab CI: YAML<pre><code>variables:\n  DATABASE_URL: $DB_URL  # CI/CD variable\n</code></pre></p>"},{"location":"ci-cd/#secret-files","title":"Secret Files","text":"<p>For complex secrets (certificates, key files):</p> YAML<pre><code># GitHub Actions\n- name: Setup credentials\n  run: |\n    echo \"${{ secrets.SERVICE_ACCOUNT_KEY }}\" &gt; /tmp/sa-key.json\n    export GOOGLE_APPLICATION_CREDENTIALS=/tmp/sa-key.json\n</code></pre>"},{"location":"ci-cd/#venomqa-configuration","title":"VenomQA Configuration","text":"<p>Reference secrets via environment variables in <code>venomqa.yaml</code>:</p> YAML<pre><code># venomqa.yaml\nbase_url: ${API_BASE_URL:-http://localhost:8000}\n\nports:\n  - name: database\n    adapter_type: postgres\n    config:\n      host: ${POSTGRES_HOST:-localhost}\n      port: ${POSTGRES_PORT:-5432}\n      user: ${POSTGRES_USER}\n      password: ${POSTGRES_PASSWORD}  # From environment\n      database: ${POSTGRES_DB}\n</code></pre>"},{"location":"ci-cd/#secret-masking","title":"Secret Masking","text":"<p>VenomQA automatically masks common secret patterns in logs: - API keys - Passwords - Tokens - Authorization headers</p>"},{"location":"ci-cd/#parallelization-strategies","title":"Parallelization Strategies","text":""},{"location":"ci-cd/#1-journey-group-parallelization","title":"1. Journey Group Parallelization","text":"<p>Split journeys by domain/feature:</p> YAML<pre><code># GitHub Actions\nstrategy:\n  matrix:\n    group: [auth, checkout, api, content, realtime]\n</code></pre>"},{"location":"ci-cd/#2-test-environment-parallelization","title":"2. Test Environment Parallelization","text":"<p>Run against multiple environments:</p> YAML<pre><code>strategy:\n  matrix:\n    environment: [staging, qa, preview]\n    include:\n      - environment: staging\n        base_url: https://staging.example.com\n      - environment: qa\n        base_url: https://qa.example.com\n</code></pre>"},{"location":"ci-cd/#3-database-sharding","title":"3. Database Sharding","text":"<p>For database-heavy tests, use separate databases:</p> YAML<pre><code>strategy:\n  matrix:\n    shard: [1, 2, 3, 4]\n\nservices:\n  postgres:\n    image: postgres:15-alpine\n    env:\n      POSTGRES_DB: qa_shard_${{ matrix.shard }}\n</code></pre>"},{"location":"ci-cd/#4-time-based-parallelization","title":"4. Time-based Parallelization","text":"<p>Run different test suites at different times:</p> YAML<pre><code># Fast tests on every push\non:\n  push:\n    branches: [main, develop]\n\n# Full test suite nightly\non:\n  schedule:\n    - cron: '0 2 * * *'  # 2 AM daily\n</code></pre>"},{"location":"ci-cd/#troubleshooting","title":"Troubleshooting","text":""},{"location":"ci-cd/#common-issues","title":"Common Issues","text":"<p>1. Services not ready</p> Text Only<pre><code>Error: Connection refused to localhost:5432\n</code></pre> <p>Solution: Use health checks and wait scripts: Bash<pre><code>wait-for-services.sh --postgres localhost:5432 -- venomqa run\n</code></pre></p> <p>2. Timeout errors</p> Text Only<pre><code>Error: Request timeout after 30s\n</code></pre> <p>Solution: Increase timeout in config: YAML<pre><code>timeout: 60  # Increase default timeout\n</code></pre></p> <p>3. Permission errors in Docker</p> Text Only<pre><code>Error: Permission denied: /app/reports\n</code></pre> <p>Solution: Match user IDs: Bash<pre><code>docker run --user $(id -u):$(id -g) ...\n</code></pre></p> <p>4. Exit code not propagated</p> <p>Ensure your shell script properly captures exit codes: Bash<pre><code>set +e  # Don't exit on error\nvenomqa run\nEXIT_CODE=$?\nset -e  # Re-enable exit on error\n# ... generate reports ...\nexit $EXIT_CODE  # Propagate original exit code\n</code></pre></p>"},{"location":"ci-cd/#debugging-ci-failures","title":"Debugging CI Failures","text":"<p>1. Enable verbose output: Bash<pre><code>venomqa run --verbose --config qa/venomqa.yaml\n</code></pre></p> <p>2. Add debugging steps: YAML<pre><code>- name: Debug environment\n  if: failure()\n  run: |\n    env | sort\n    docker ps -a\n    docker compose logs\n    cat qa/venomqa.yaml\n</code></pre></p> <p>3. SSH into failed runner (GitHub Actions): YAML<pre><code>- name: Debug with tmate\n  if: failure()\n  uses: mxschmitt/action-tmate@v3\n  with:\n    limit-access-to-actor: true\n</code></pre></p>"},{"location":"ci-cd/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: https://venomqa.dev/docs</li> <li>Issues: https://github.com/namanag97/venomqa/issues</li> <li>Discussions: https://github.com/namanag97/venomqa/discussions</li> </ul> <p>For complete working examples, see: - <code>.github/workflows/venomqa.yml.example</code> - GitHub Actions - <code>.gitlab-ci.yml.example</code> - GitLab CI - <code>docker/Dockerfile.runner</code> - Docker runner image</p>"},{"location":"cli-output/","title":"VenomQA CLI Output Features","text":"<p>VenomQA includes professional, live progress indicators and beautiful visualizations for your test journeys using the Rich library.</p>"},{"location":"cli-output/#features","title":"Features","text":""},{"location":"cli-output/#1-live-progress-bar","title":"1. Live Progress Bar","text":"<p>Real-time progress tracking with: - Spinner animation - Shows activity while tests are running - Progress bar - Visual representation: <code>[=====&gt;    ] 50%</code> - Step counter - Current and total steps: <code>5/10</code> - Elapsed time - How long the journey has been running - Estimated time remaining (ETA) - Predicted completion time</p> <p>Example output: Text Only<pre><code>\u280b \u2192 Step 5/10: process_payment \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 5/10 \u2022 0:00:02 \u2022 0:00:02\n</code></pre></p>"},{"location":"cli-output/#2-current-step-indicator","title":"2. Current Step Indicator","text":"<p>Each step is displayed with: - Spinner - Animated spinner (\u280b \u2819 \u2839 \u2838 \u283c \u2834 \u2826 \u2827 \u2807 \u280f) - Step number - Current position in journey - Step name - Descriptive name of the action - Status updates - Updates in real-time without spamming the terminal</p>"},{"location":"cli-output/#3-timing-information","title":"3. Timing Information","text":"<p>Comprehensive timing data: - Per-step duration - Time taken for each step (shown after completion) - Elapsed time - Total time since journey started - ETA calculation - Smart prediction based on average step time - Summary timing - Complete breakdown in the final summary</p> <p>Example: Text Only<pre><code>Step Timings:\n  login            270ms\n  browse_products  290ms\n  add_to_cart      310ms\n  ...\n</code></pre></p>"},{"location":"cli-output/#4-branch-visualization","title":"4. Branch Visualization","text":"<p>Tree-like visualization for branches and paths:</p> Text Only<pre><code>\u251c\u2500 Branch: before_payment (3 paths)\n  \u2502 \u251c\u2500 Path: credit_card_payment\n  \u2502 \u2514\u2500 \u2713 credit_card_payment (3 steps)\n  \u2502 \u251c\u2500 Path: paypal_payment\n  \u2502 \u2514\u2500 \u2713 paypal_payment (2 steps)\n  \u2502 \u251c\u2500 Path: crypto_payment\n  \u2502 \u2514\u2500 \u2717 crypto_payment (2 steps)\n</code></pre> <p>Features: - Tree characters - Visual hierarchy (\u251c\u2500, \u2514\u2500, \u2502) - Branch indicators - Shows checkpoint name and path count - Path status - Success (\u2713) or failure (\u2717) with step counts - Color coding - Green for success, red for failure</p>"},{"location":"cli-output/#5-checkpoint-rollback-indicators","title":"5. Checkpoint &amp; Rollback Indicators","text":"<p>Visual markers for state management:</p> Text Only<pre><code>\u25c9 Checkpoint: before_payment\n\u21a9 Rollback to: before_payment\n</code></pre> <ul> <li>Checkpoints - Shown in yellow with \u25c9 symbol</li> <li>Rollbacks - Shown in cyan with \u21a9 symbol</li> <li>Integration - Seamlessly displayed during live progress</li> </ul>"},{"location":"cli-output/#6-summary-panel","title":"6. Summary Panel","text":"<p>Beautiful summary boxes at journey completion:</p> Text Only<pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 JOURNEY COMPLETE: checkout_flow \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                \u2502\n\u2502  Status:            \u2713 PASSED                                                   \u2502\n\u2502  Duration:          3.50s                                                      \u2502\n\u2502  Steps:             10/10 passed                                               \u2502\n\u2502  Paths:             3/3 passed                                                 \u2502\n\u2502                                                                                \u2502\n\u2502  Step Timings:                                                                 \u2502\n\u2502    login            270ms                                                      \u2502\n\u2502    browse_products  290ms                                                      \u2502\n\u2502    add_to_cart      310ms                                                      \u2502\n\u2502    ...                                                                         \u2502\n\u2502                                                                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Includes: - Status indicator - Pass/fail with colored symbols - Duration - Total execution time - Step statistics - Passed vs total steps - Path statistics - Passed vs total paths (if applicable) - Timing breakdown - Top 10 slowest steps - Border styling - Green for success, red for failure</p>"},{"location":"cli-output/#7-overall-summary","title":"7. Overall Summary","text":"<p>Multi-journey summary with aggregate statistics:</p> Text Only<pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2713 SUMMARY: ALL JOURNEYS PASSED \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                \u2502\n\u2502  Total:     5                                                                  \u2502\n\u2502  Passed:    5                                                                  \u2502\n\u2502  Failed:    0                                                                  \u2502\n\u2502  Duration:  15.00s                                                             \u2502\n\u2502                                                                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli-output/#8-issue-reporting","title":"8. Issue Reporting","text":"<p>Failed steps are clearly highlighted:</p> Text Only<pre><code>\u2717 Issues:\n  \u2717 apply_discount: Discount code expired\n  \u2717 payment_gateway: Connection timeout\n</code></pre>"},{"location":"cli-output/#configuration","title":"Configuration","text":"<p>Control output features via <code>ProgressConfig</code>:</p> Python<pre><code>from venomqa.cli.output import CLIOutput, ProgressConfig\n\nconfig = ProgressConfig(\n    show_progress=True,      # Enable progress bars\n    show_checkpoints=True,   # Show checkpoint markers\n    show_paths=True,         # Show branch paths\n    show_timing=True,        # Show timing information\n    use_colors=True,         # Enable colored output\n    use_unicode=True,        # Use Unicode symbols (vs ASCII)\n)\n\noutput = CLIOutput(config)\n</code></pre>"},{"location":"cli-output/#terminal-compatibility","title":"Terminal Compatibility","text":""},{"location":"cli-output/#unicode-support","title":"Unicode Support","text":"<p>The CLI automatically detects terminal capabilities:</p> <p>Unicode terminals (default): - Beautiful symbols: \u2713 \u2717 \u2699 \u25c9 \u21a9 \u2192 \u251c\u2500 \u2514\u2500 \u2502 - Smooth spinners: \u280b \u2819 \u2839 \u2838 \u283c \u2834 \u2826 \u2827</p> <p>ASCII-only terminals: - ASCII fallbacks: [OK][FAIL] [*] &lt;- -&gt; |-- `-- | - Text-based indicators</p>"},{"location":"cli-output/#color-support","title":"Color Support","text":"<ul> <li>Color terminals: Rich colors with ANSI codes</li> <li>No-color terminals: Plain text output</li> <li>Auto-detection: Automatically detects TTY capabilities</li> </ul>"},{"location":"cli-output/#usage-examples","title":"Usage Examples","text":""},{"location":"cli-output/#basic-journey","title":"Basic Journey","text":"Python<pre><code>from venomqa import Journey, Step\nfrom venomqa.cli.output import CLIOutput, ProgressConfig\n\noutput = CLIOutput()\n\n# Start journey\noutput.journey_start(\n    name=\"user_registration\",\n    description=\"Complete user registration flow\",\n    total_steps=5\n)\n\n# Run steps (integrated with runner)\n# Output automatically updates during execution\n\n# Show summary\noutput.journey_summary(\n    name=\"user_registration\",\n    success=True,\n    step_count=5,\n    passed_steps=5,\n    duration_ms=1200\n)\n</code></pre>"},{"location":"cli-output/#with-branches","title":"With Branches","text":"Python<pre><code># Branch starts automatically\noutput.branch_start(\"after_signup\", 3)\n\n# Paths run automatically\noutput.path_start(\"email_verification\")\noutput.path_result(\"email_verification\", True, 3)\n\noutput.path_start(\"phone_verification\")\noutput.path_result(\"phone_verification\", True, 2)\n</code></pre>"},{"location":"cli-output/#integration","title":"Integration","text":"<p>The CLI output is automatically integrated with: - JourneyRunner - Automatic progress updates during execution - Commands - Built into <code>venomqa run</code> command - Reporters - Works alongside all reporter formats</p>"},{"location":"cli-output/#performance","title":"Performance","text":"<ul> <li>Non-blocking - Progress updates don't slow down tests</li> <li>Efficient rendering - Updates at 10 FPS (configurable)</li> <li>Memory conscious - Minimal overhead</li> <li>Live updates - In-place rendering without terminal spam</li> </ul>"},{"location":"cli-output/#best-practices","title":"Best Practices","text":"<ol> <li>Always provide total_steps for accurate progress bars</li> <li>Use descriptive step names for clarity</li> <li>Enable timing to identify slow steps</li> <li>Color support improves readability in CI logs</li> <li>Unicode symbols provide better visual hierarchy</li> </ol>"},{"location":"cli-output/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli-output/#progress-bar-not-showing","title":"Progress bar not showing","text":"<ul> <li>Ensure <code>total_steps &gt; 0</code> in <code>journey_start()</code></li> <li>Check <code>show_progress=True</code> in config</li> </ul>"},{"location":"cli-output/#symbols-displaying-incorrectly","title":"Symbols displaying incorrectly","text":"<ul> <li>Terminal may not support Unicode</li> <li>Set <code>use_unicode=False</code> for ASCII fallback</li> </ul>"},{"location":"cli-output/#colors-not-working","title":"Colors not working","text":"<ul> <li>Verify terminal supports ANSI colors</li> <li>Check TTY detection with <code>output._supports_color()</code></li> </ul>"},{"location":"cli-output/#future-enhancements","title":"Future Enhancements","text":"<p>Planned features: - Real-time request/response preview - Interactive mode for step debugging - Performance graphs and charts - Export progress to file/stream - WebSocket streaming for remote monitoring</p>"},{"location":"cli-output/#see-also","title":"See Also","text":"<ul> <li>CLI Commands - Command-line interface</li> <li>Journeys - Journey structure</li> <li>Reporters - Report formats</li> </ul>"},{"location":"comparison/","title":"VenomQA vs Other API Testing Tools","text":"<p>Most API testing tools check one endpoint at a time. VenomQA does something fundamentally different: it explores sequences of API calls \u2014 <code>create \u2192 refund \u2192 refund</code>, <code>login \u2192 delete \u2192 login</code> \u2014 and checks that your invariants hold across every reachable state.</p> <p>This page compares VenomQA to the tools developers search for most: Schemathesis, pytest, Postman/Newman, Dredd, Hypothesis, and Playwright.</p>"},{"location":"comparison/#decision-tree-which-tool-do-you-need","title":"Decision Tree: Which Tool Do You Need?","text":"Text Only<pre><code>Do you need to test sequences of API calls?\n  \u2514\u2500 YES \u2192 VenomQA\n\nDo you need to fuzz individual endpoint inputs from an OpenAPI spec?\n  \u2514\u2500 YES \u2192 Schemathesis  (use alongside VenomQA \u2014 they're complementary)\n\nDo you need browser / UI testing?\n  \u2514\u2500 YES \u2192 Playwright\n\nDo you need a visual GUI for ad-hoc exploration?\n  \u2514\u2500 YES \u2192 Postman\n\nDo you need property-based unit testing?\n  \u2514\u2500 YES \u2192 Hypothesis\n\nDo you need unit or integration tests with maximum flexibility?\n  \u2514\u2500 YES \u2192 pytest\n\nDo you need contract validation from an OpenAPI/Swagger spec?\n  \u2514\u2500 YES \u2192 Dredd\n</code></pre>"},{"location":"comparison/#quick-comparison-table","title":"Quick Comparison Table","text":"Tool What it tests Sequence testing Real DB state Auto-exploration Language VenomQA API state sequences Yes \u2014 exhaustive Yes (savepoints) Yes \u2014 BFS/DFS over state graph Python Schemathesis Individual endpoint inputs No No Yes \u2014 fuzz per endpoint Python / CLI pytest Anything you write Manual Manual (fixtures) No Python Postman/Newman Request-response flows Manual collections No No JS / GUI Dredd OpenAPI contract compliance No No No CLI / any Hypothesis Property-based unit tests No No Yes \u2014 per function Python Playwright Browser + UI flows Via scripts No No JS / Python / Java"},{"location":"comparison/#schemathesis-vs-venomqa-most-important-comparison","title":"Schemathesis vs VenomQA (Most Important Comparison)","text":"<p>Schemathesis is the closest tool to VenomQA in the Python ecosystem, and the most common comparison search. Understanding the difference is critical before choosing.</p>"},{"location":"comparison/#what-schemathesis-does","title":"What Schemathesis does","text":"<p>Schemathesis reads your OpenAPI spec and fuzzes every endpoint in isolation with generated inputs. It is excellent at finding:</p> <ul> <li>Missing input validation (null values, unexpected types)</li> <li>500 errors on malformed requests</li> <li>Schema mismatches between spec and implementation</li> <li>Edge-case inputs that crash a single handler</li> </ul> Bash<pre><code># Schemathesis: fuzz every endpoint independently\nschemathesis run openapi.json --checks all --base-url http://localhost:8000\n</code></pre>"},{"location":"comparison/#what-venomqa-does","title":"What VenomQA does","text":"<p>VenomQA treats your API as a state machine and explores every reachable sequence of calls. It finds bugs that only appear in a specific order:</p> Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    resp = api.post(f\"/orders/{order_id}/refund\")\n    return resp\n\nno_double_refund = Invariant(\n    name=\"no_double_refund\",\n    check=lambda world: world.context.get(\"last_status\", 200) != 200\n                        or world.context.get(\"refund_count\", 0) &lt;= 1,\n    severity=Severity.CRITICAL,\n)\n\nagent = Agent(\n    world=world,\n    actions=[\n        Action(\"create_order\", create_order),\n        Action(\"refund_order\", refund_order),\n    ],\n    invariants=[no_double_refund],\n    strategy=BFS(),\n    max_steps=50,\n)\n\nresult = agent.explore()\n# VenomQA automatically tries: create, refund, refund \u2014 and catches the double-refund bug\n</code></pre> <p>Schemathesis would never try <code>refund \u2192 refund</code> because it fuzzes endpoints independently. VenomQA finds exactly these sequence-dependent bugs.</p>"},{"location":"comparison/#head-to-head","title":"Head-to-head","text":"Schemathesis VenomQA Finds single-endpoint validation bugs Yes Limited Finds sequence-dependent bugs No Yes Requires OpenAPI spec Yes No Tests real DB state No Yes (savepoints) Exploration strategy Fuzz per endpoint BFS/DFS over state graph Best for Input validation, contract testing Business logic, state machine bugs"},{"location":"comparison/#when-to-use-schemathesis","title":"When to use Schemathesis","text":"<ul> <li>You want to fuzz every endpoint with random valid/invalid inputs</li> <li>You have an OpenAPI spec and want instant coverage without writing test code</li> <li>You are looking for crashes on malformed inputs</li> </ul>"},{"location":"comparison/#when-to-use-venomqa","title":"When to use VenomQA","text":"<ul> <li>You want to test sequences like <code>create \u2192 update \u2192 delete \u2192 create</code></li> <li>You have business rules (invariants) that must hold across all orderings</li> <li>You need real database rollback between explored paths</li> </ul>"},{"location":"comparison/#use-them-together","title":"Use them together","text":"<p>They test completely different things and compose well:</p> YAML<pre><code># CI: run both in parallel\njobs:\n  fuzz-endpoints:\n    run: schemathesis run openapi.json --checks all\n\n  sequence-test:\n    run: python qa/run_agent.py  # VenomQA explores state sequences\n</code></pre> <p>Schemathesis catches bad inputs. VenomQA catches bad sequences.</p>"},{"location":"comparison/#pytest-vs-venomqa","title":"pytest vs VenomQA","text":"<p>pytest is the standard Python testing framework. It is excellent for unit tests and integration tests where you write the exact sequence to execute.</p>"},{"location":"comparison/#the-core-difference","title":"The core difference","text":"<p>With pytest, you write the path:</p> Python<pre><code>import httpx\n\ndef test_double_refund():\n    client = httpx.Client(base_url=\"http://localhost:8000\")\n\n    # You must manually think of this sequence\n    resp = client.post(\"/orders\", json={\"amount\": 100})\n    order_id = resp.json()[\"id\"]\n\n    client.post(f\"/orders/{order_id}/refund\")\n    resp2 = client.post(f\"/orders/{order_id}/refund\")  # Should this 200 or 400?\n    assert resp2.status_code == 400  # You have to know to test this\n</code></pre> <p>With VenomQA, you define what is possible and what must be true, and the agent explores all paths automatically:</p> Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    return api.post(f\"/orders/{order_id}/refund\")\n\nno_500s = Invariant(\n    name=\"no_server_errors\",\n    check=lambda world: world.context.get(\"last_status\", 200) &lt; 500,\n    severity=Severity.CRITICAL,\n)\n\nagent = Agent(\n    world=world,\n    actions=[Action(\"create_order\", create_order), Action(\"refund_order\", refund_order)],\n    invariants=[no_500s],\n    strategy=BFS(),\n    max_steps=100,\n)\n\nresult = agent.explore()\n# Agent automatically discovers: create, refund, refund, refund...\n# You did not have to think of this path\nprint(f\"Paths explored: {result.states_visited}, Violations: {result.violations}\")\n</code></pre>"},{"location":"comparison/#feature-comparison","title":"Feature comparison","text":"pytest VenomQA Unit testing Excellent Not the purpose Integration testing Yes (manual paths) Yes (auto-explored paths) Auto-exploration of sequences No Yes DB rollback between paths Manual (fixtures) Built-in (savepoints) Invariant checking across all paths No Yes Plugin ecosystem Extensive Focused on API testing Flexibility Maximum Focused"},{"location":"comparison/#use-them-together_1","title":"Use them together","text":"<p>VenomQA works inside a pytest project. Run your unit tests with pytest, your sequence tests with VenomQA's agent:</p> Python<pre><code># tests/test_agent.py \u2014 run with pytest\nfrom venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\ndef test_no_violations_in_order_flow():\n    api = HttpClient(\"http://localhost:8000\")\n    world = World(api=api, state_from_context=[\"order_id\"])\n\n    agent = Agent(\n        world=world,\n        actions=[Action(\"create_order\", create_order)],\n        invariants=[no_500s],\n        strategy=BFS(),\n        max_steps=50,\n    )\n\n    result = agent.explore()\n    assert len(result.violations) == 0, f\"Violations found: {result.violations}\"\n</code></pre>"},{"location":"comparison/#postmannewman-vs-venomqa","title":"Postman/Newman vs VenomQA","text":"<p>Postman is the industry-standard GUI tool for API exploration and manual testing. Newman is its CLI runner for CI/CD.</p>"},{"location":"comparison/#what-postman-does-well","title":"What Postman does well","text":"<ul> <li>Visual exploration of an API during development</li> <li>Sharing collections with non-technical stakeholders</li> <li>Generating API documentation from collections</li> <li>Quick smoke tests on a new environment</li> </ul>"},{"location":"comparison/#what-venomqa-does-instead","title":"What VenomQA does instead","text":"<p>VenomQA is code-first and designed for automated, exhaustive state-space exploration \u2014 not manual scripting of known-good flows.</p> <p>Postman collection (JavaScript): JavaScript<pre><code>// You manually define every step in order\npm.test(\"Create order\", function() {\n    pm.sendRequest({\n        url: pm.environment.get(\"base_url\") + \"/orders\",\n        method: \"POST\",\n        body: { mode: \"raw\", raw: JSON.stringify({ amount: 100 }) }\n    }, function(err, res) {\n        pm.environment.set(\"order_id\", res.json().id);\n    });\n});\n</code></pre></p> <p>VenomQA: Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\nagent = Agent(\n    world=world,\n    actions=[Action(\"create_order\", create_order)],\n    invariants=[Invariant(\"no_500s\", lambda w: w.context.get(\"last_status\", 200) &lt; 500, Severity.CRITICAL)],\n    strategy=BFS(),\n    max_steps=50,\n)\nresult = agent.explore()\n</code></pre></p>"},{"location":"comparison/#when-to-use-postman","title":"When to use Postman","text":"<ul> <li>Your team needs a GUI to explore or demo an API</li> <li>You want to generate API documentation alongside tests</li> <li>You are running simple smoke checks on a deployed environment</li> </ul>"},{"location":"comparison/#when-to-use-venomqa_1","title":"When to use VenomQA","text":"<ul> <li>You want to find bugs in sequences your team has not thought of yet</li> <li>You need tests in version control, reviewed in pull requests</li> <li>You need database state control and rollback between paths</li> </ul>"},{"location":"comparison/#dredd-vs-venomqa","title":"Dredd vs VenomQA","text":"<p>Dredd validates that your API implementation matches an OpenAPI or API Blueprint contract. It sends example requests from the spec and checks that responses match the defined schema.</p> <p>Dredd answers: \"Does my implementation conform to its spec?\"</p> <p>VenomQA answers: \"Does my implementation behave correctly across all sequences of operations?\"</p> <p>These are orthogonal questions. Use Dredd to catch spec drift, use VenomQA to catch logic bugs in sequences.</p>"},{"location":"comparison/#hypothesis-vs-venomqa","title":"Hypothesis vs VenomQA","text":"<p>Hypothesis is a property-based testing library for Python. You define properties that should hold for any input, and Hypothesis generates inputs that try to falsify them.</p> <p>Hypothesis operates at the function level \u2014 it generates inputs to a Python function and checks that it behaves correctly for all of them.</p> <p>VenomQA operates at the API sequence level \u2014 it generates sequences of HTTP calls and checks that business invariants hold across all reachable states.</p> <p>They are both \"property-based\" in spirit but at completely different layers:</p> Python<pre><code># Hypothesis: test a Python function with generated inputs\nfrom hypothesis import given, strategies as st\n\n@given(st.integers(min_value=1))\ndef test_refund_never_exceeds_payment(amount):\n    order = Order(amount=amount)\n    refund = Refund(order, amount=amount)\n    assert refund.total &lt;= order.amount  # tests the Python object, not the HTTP API\n</code></pre> Python<pre><code># VenomQA: test the HTTP API with generated sequences\nno_over_refund = Invariant(\n    name=\"no_over_refund\",\n    check=lambda world: world.context.get(\"refunded\", 0) &lt;= world.context.get(\"amount\", 0),\n    severity=Severity.CRITICAL,\n)\n# Agent explores create \u2192 refund \u2192 refund \u2192 refund against a real (or test) server\n</code></pre>"},{"location":"comparison/#playwright-vs-venomqa","title":"Playwright vs VenomQA","text":"<p>Playwright automates a real browser. It is the right tool when you need to test JavaScript rendering, CSS interactions, accessibility, or any behavior that only manifests in a browser.</p> <p>VenomQA makes direct HTTP calls. There is no browser involved.</p> <p>Use Playwright for end-to-end tests that include the UI. Use VenomQA to cover the API layer exhaustively before those E2E tests run.</p> YAML<pre><code># Recommended CI pipeline\njobs:\n  unit:\n    run: pytest tests/unit/\n\n  stateful-api:\n    run: python qa/run_agent.py  # VenomQA\n\n  fuzz:\n    run: schemathesis run openapi.json --checks all  # Schemathesis\n\n  e2e:\n    needs: [unit, stateful-api, fuzz]\n    run: npx playwright test\n</code></pre>"},{"location":"comparison/#full-feature-matrix","title":"Full Feature Matrix","text":"Feature VenomQA Schemathesis pytest Postman Dredd Hypothesis Playwright Sequence / stateful testing Yes No Manual Manual No No Manual Auto-exploration Yes (BFS/DFS) Yes (fuzz) No No No Yes (unit) No Real DB state + rollback Yes No No No No No No Invariant checking Yes Partial Manual Manual Schema only Yes No OpenAPI spec required No Yes No Optional Yes No No Browser support No No No No No No Yes GUI No No No Yes No No No Language Python Python / CLI Python JS CLI Python JS / Python / Java CI/CD ready Yes Yes Yes Yes (Newman) Yes Yes Yes"},{"location":"comparison/#venomqa-schemathesis-the-recommended-stack","title":"VenomQA + Schemathesis: The Recommended Stack","text":"<p>For Python teams building REST APIs, running both tools gives you two complementary layers of coverage:</p> <ol> <li>Schemathesis \u2014 fuzzes every endpoint with random valid and invalid inputs, catches crashes and schema violations fast</li> <li>VenomQA \u2014 explores state sequences and checks business invariants across all reachable paths</li> </ol> <p>Neither tool replaces the other. A bug that requires <code>create \u2192 refund \u2192 refund</code> will never be found by fuzzing <code>POST /refund</code> in isolation. A null-pointer crash on a malformed <code>amount</code> field will never be found by exploring pre-seeded state sequences.</p> Bash<pre><code># Install both\npip install venomqa schemathesis\n\n# Fuzz endpoints\nschemathesis run openapi.json --checks all --base-url http://localhost:8000\n\n# Explore state sequences\npython qa/run_agent.py\n</code></pre>"},{"location":"comparison/#summary","title":"Summary","text":"Tool Use it when... VenomQA You need to find bugs in sequences of API calls, and maintain real DB state between paths Schemathesis You need to fuzz individual endpoints with generated inputs from an OpenAPI spec pytest You need unit tests or integration tests where you write the exact sequence Postman You need a GUI to explore an API or share collections with non-technical teammates Dredd You need to verify your implementation matches its OpenAPI contract Hypothesis You need property-based tests at the Python function level Playwright You need browser automation and end-to-end UI testing <p>The tools are not mutually exclusive. A mature backend project typically uses pytest for unit tests, Schemathesis for endpoint fuzzing, VenomQA for stateful sequence testing, and Playwright for end-to-end tests. Each covers a distinct layer.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We love contributions! Here's how to get started with VenomQA development.</p>"},{"location":"contributing/#quick-start","title":"Quick Start","text":"Bash<pre><code># Clone the repository\ngit clone https://github.com/venomqa/venomqa.git\ncd venomqa\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install with development dependencies\npip install -e \".[dev,docs]\"\n\n# Install pre-commit hooks\npre-commit install\n\n# Run tests\npytest\n\n# Run linting\nruff check .\nmypy venomqa\n</code></pre>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Found a bug? Open an issue with:</p> <ul> <li>VenomQA version</li> <li>Python version</li> <li>Minimal reproduction steps</li> <li>Expected vs actual behavior</li> </ul>"},{"location":"contributing/#suggest-features","title":"Suggest Features","text":"<p>Have an idea? Start a discussion to:</p> <ul> <li>Describe the use case</li> <li>Explain the proposed solution</li> <li>Discuss alternatives</li> </ul>"},{"location":"contributing/#improve-documentation","title":"Improve Documentation","text":"<p>Documentation improvements are always welcome:</p> <ul> <li>Fix typos</li> <li>Add examples</li> <li>Clarify explanations</li> <li>Translate documentation</li> </ul>"},{"location":"contributing/#submit-code","title":"Submit Code","text":"<p>Ready to code? Look for issues labeled <code>good first issue</code>.</p>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"Bash<pre><code># Fork on GitHub, then clone\ngit clone https://github.com/YOUR_USERNAME/venomqa.git\ncd venomqa\ngit remote add upstream https://github.com/venomqa/venomqa.git\n</code></pre>"},{"location":"contributing/#2-create-branch","title":"2. Create Branch","text":"Bash<pre><code>git checkout -b feature/my-feature\n# or\ngit checkout -b fix/my-fix\n</code></pre>"},{"location":"contributing/#3-make-changes","title":"3. Make Changes","text":"<ul> <li>Write code</li> <li>Add tests</li> <li>Update documentation</li> </ul>"},{"location":"contributing/#4-test-changes","title":"4. Test Changes","text":"Bash<pre><code># Run all tests\npytest\n\n# Run specific tests\npytest tests/test_models.py\n\n# Run with coverage\npytest --cov=venomqa\n\n# Run linting\nruff check .\nruff format --check .\n\n# Run type checking\nmypy venomqa\n</code></pre>"},{"location":"contributing/#5-commit-changes","title":"5. Commit Changes","text":"<p>Follow Conventional Commits:</p> Bash<pre><code>git commit -m \"feat: add support for MySQL backend\"\ngit commit -m \"fix: resolve checkpoint naming conflict\"\ngit commit -m \"docs: add MySQL configuration example\"\ngit commit -m \"test: add tests for branch rollback\"\n</code></pre>"},{"location":"contributing/#6-push-and-create-pr","title":"6. Push and Create PR","text":"Bash<pre><code>git push origin feature/my-feature\n</code></pre> <p>Then create a Pull Request on GitHub.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":""},{"location":"contributing/#python-style","title":"Python Style","text":"<p>We use:</p> <ul> <li>Ruff for linting and formatting</li> <li>mypy for type checking</li> <li>Line length: 100 characters</li> </ul> Bash<pre><code># Format code\nruff format .\n\n# Check linting\nruff check .\n\n# Fix linting issues\nruff check --fix .\n</code></pre>"},{"location":"contributing/#type-hints","title":"Type Hints","text":"<p>Use type hints for all public APIs:</p> Python<pre><code>def create_journey(\n    name: str,\n    steps: list[Step],\n    description: str = \"\",\n    tags: list[str] | None = None,\n) -&gt; Journey:\n    \"\"\"Create a new journey.\n\n    Args:\n        name: Unique journey identifier\n        steps: List of steps to execute\n        description: Human-readable description\n        tags: Optional tags for filtering\n\n    Returns:\n        A new Journey instance\n    \"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings:</p> Python<pre><code>def process_result(\n    result: StepResult,\n    context: ExecutionContext,\n) -&gt; dict[str, Any]:\n    \"\"\"Process a step result and update context.\n\n    Args:\n        result: The step execution result\n        context: The execution context to update\n\n    Returns:\n        A dictionary containing processed result data\n\n    Raises:\n        ValueError: If result is invalid\n        StateError: If context cannot be updated\n    \"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#test-structure","title":"Test Structure","text":"Text Only<pre><code>tests/\n\u251c\u2500\u2500 test_models.py          # Core model tests\n\u251c\u2500\u2500 test_runner.py          # Runner tests\n\u251c\u2500\u2500 test_client.py          # HTTP client tests\n\u251c\u2500\u2500 test_state.py           # State manager tests\n\u251c\u2500\u2500 test_reporters.py       # Reporter tests\n\u2514\u2500\u2500 conftest.py             # Shared fixtures\n</code></pre>"},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"Python<pre><code>import pytest\nfrom venomqa import Journey, Step, Client\n\n\nclass TestJourney:\n    def test_journey_creation(self):\n        \"\"\"Test basic journey creation.\"\"\"\n        journey = Journey(\n            name=\"test\",\n            steps=[\n                Step(name=\"step1\", action=lambda c, ctx: c.get(\"/\"))\n            ],\n        )\n        assert journey.name == \"test\"\n        assert len(journey.steps) == 1\n\n    def test_journey_validation(self):\n        \"\"\"Test journey validates checkpoint references.\"\"\"\n        with pytest.raises(ValueError):\n            Journey(\n                name=\"test\",\n                steps=[\n                    Branch(checkpoint_name=\"nonexistent\", paths=[])\n                ],\n            )\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client.\"\"\"\n    return Client(base_url=\"http://localhost:8000\")\n\n\n@pytest.fixture\ndef mock_response(respx_mock):\n    \"\"\"Mock HTTP responses.\"\"\"\n    respx_mock.get(\"/health\").respond(200, json={\"status\": \"ok\"})\n    return respx_mock\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"Bash<pre><code># All tests\npytest\n\n# With coverage\npytest --cov=venomqa --cov-report=html\n\n# Specific file\npytest tests/test_models.py\n\n# Specific test\npytest tests/test_models.py::TestJourney::test_journey_creation\n\n# Verbose output\npytest -v\n\n# Stop on first failure\npytest -x\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#building-docs","title":"Building Docs","text":"Bash<pre><code># Install docs dependencies\npip install -e \".[docs]\"\n\n# Serve locally\nmkdocs serve\n\n# Build\nmkdocs build\n</code></pre>"},{"location":"contributing/#documentation-structure","title":"Documentation Structure","text":"Text Only<pre><code>docs/\n\u251c\u2500\u2500 index.md                  # Home page\n\u251c\u2500\u2500 getting-started/          # Getting started guides\n\u251c\u2500\u2500 concepts/                 # Core concepts\n\u251c\u2500\u2500 tutorials/                # Step-by-step tutorials\n\u251c\u2500\u2500 reference/                # API reference\n\u251c\u2500\u2500 examples/                 # Code examples\n\u2514\u2500\u2500 advanced/                 # Advanced topics\n</code></pre>"},{"location":"contributing/#release-process","title":"Release Process","text":"<ol> <li>Update version in <code>venomqa/__init__.py</code> and <code>pyproject.toml</code></li> <li>Update CHANGELOG.md</li> <li>Create release PR</li> <li>After merge, tag release: <code>git tag v0.x.0</code></li> <li>Push tag: <code>git push --tags</code></li> <li>GitHub Actions builds and publishes to PyPI</li> </ol>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please read our Code of Conduct before contributing.</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>GitHub Discussions</li> <li>Discord</li> </ul>"},{"location":"examples/","title":"Real-World Examples","text":"<p>This page provides practical, real-world examples of using VenomQA.</p> <p>Looking for basics? See the Getting Started Guide for introductory examples.</p>"},{"location":"examples/#table-of-contents","title":"Table of Contents","text":"<ul> <li>E-Commerce Checkout Flow</li> <li>User Registration with Email Verification</li> <li>API Rate Limiting Tests</li> <li>Multi-Tenant Application Testing</li> <li>Payment Gateway Integration</li> <li>File Upload and Processing</li> <li>WebSocket and Real-Time Features</li> <li>Third-Party API Mocking</li> </ul>"},{"location":"examples/#related-documentation","title":"Related Documentation","text":"Topic Document Journey DSL journeys.md Adapters adapters.md Ports ports.md Advanced Patterns advanced.md"},{"location":"examples/#e-commerce-checkout-flow","title":"E-Commerce Checkout Flow","text":"<p>Complete checkout journey testing multiple payment methods.</p>"},{"location":"examples/#actions-file","title":"Actions File","text":"Python<pre><code># actions/shop.py\n\ndef add_to_cart(client, context, product_id=None, quantity=1):\n    \"\"\"Add product to shopping cart.\"\"\"\n    product_id = product_id or context.get(\"product_id\")\n    response = client.post(\"/api/cart/items\", json={\n        \"product_id\": product_id,\n        \"quantity\": quantity,\n    })\n    if response.status_code == 200:\n        context[\"cart_id\"] = response.json()[\"cart_id\"]\n    return response\n\ndef get_cart(client, context):\n    \"\"\"Get current cart contents.\"\"\"\n    cart_id = context.get(\"cart_id\")\n    if cart_id:\n        return client.get(f\"/api/cart/{cart_id}\")\n    return client.get(\"/api/cart\")\n\ndef apply_coupon(client, context, code=\"DISCOUNT10\"):\n    \"\"\"Apply discount coupon to cart.\"\"\"\n    cart_id = context.get_required(\"cart_id\")\n    return client.post(f\"/api/cart/{cart_id}/coupon\", json={\"code\": code})\n\ndef start_checkout(client, context):\n    \"\"\"Begin checkout process.\"\"\"\n    cart_id = context.get_required(\"cart_id\")\n    response = client.post(f\"/api/cart/{cart_id}/checkout\")\n    if response.status_code == 200:\n        context[\"order_id\"] = response.json()[\"order_id\"]\n    return response\n\ndef add_shipping_address(client, context):\n    \"\"\"Add shipping address to order.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/shipping\", json={\n        \"name\": \"John Doe\",\n        \"address\": \"123 Main St\",\n        \"city\": \"New York\",\n        \"state\": \"NY\",\n        \"zip\": \"10001\",\n        \"country\": \"USA\",\n    })\n\ndef pay_with_credit_card(client, context):\n    \"\"\"Process credit card payment.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/payment\", json={\n        \"method\": \"credit_card\",\n        \"card_number\": \"4242424242424242\",\n        \"exp_month\": 12,\n        \"exp_year\": 2025,\n        \"cvv\": \"123\",\n    })\n\ndef pay_with_paypal(client, context):\n    \"\"\"Process PayPal payment.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/payment\", json={\n        \"method\": \"paypal\",\n        \"return_url\": \"https://example.com/return\",\n    })\n\ndef pay_with_crypto(client, context):\n    \"\"\"Process cryptocurrency payment.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/payment\", json={\n        \"method\": \"crypto\",\n        \"currency\": \"BTC\",\n    })\n\ndef confirm_order(client, context):\n    \"\"\"Confirm and finalize order.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    response = client.post(f\"/api/orders/{order_id}/confirm\")\n    if response.status_code == 200:\n        context[\"confirmation_number\"] = response.json()[\"confirmation_number\"]\n    return response\n</code></pre>"},{"location":"examples/#journey-definition","title":"Journey Definition","text":"Python<pre><code># journeys/ecommerce_checkout.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.shop import (\n    add_to_cart, get_cart, apply_coupon, start_checkout,\n    add_shipping_address, pay_with_credit_card, pay_with_paypal,\n    pay_with_crypto, confirm_order,\n)\n\ncheckout_journey = Journey(\n    name=\"ecommerce_checkout\",\n    description=\"Complete e-commerce checkout flow with multiple payment methods\",\n    tags=[\"e-commerce\", \"checkout\", \"payment\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"add_item\", action=lambda c, ctx: add_to_cart(c, ctx, product_id=123)),\n        Step(name=\"verify_cart\", action=get_cart),\n        Step(name=\"apply_discount\", action=apply_coupon),\n        Checkpoint(name=\"cart_ready\"),\n        Step(name=\"start_checkout\", action=start_checkout),\n        Step(name=\"add_shipping\", action=add_shipping_address),\n        Checkpoint(name=\"ready_for_payment\"),\n        Branch(\n            checkpoint_name=\"ready_for_payment\",\n            paths=[\n                Path(name=\"credit_card\", steps=[\n                    Step(name=\"pay_card\", action=pay_with_credit_card),\n                    Step(name=\"confirm_card\", action=confirm_order),\n                ]),\n                Path(name=\"paypal\", steps=[\n                    Step(name=\"pay_paypal\", action=pay_with_paypal),\n                    Step(name=\"confirm_paypal\", action=confirm_order),\n                ]),\n                Path(name=\"crypto\", steps=[\n                    Step(name=\"pay_crypto\", action=pay_with_crypto),\n                    Step(name=\"confirm_crypto\", action=confirm_order),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#user-registration-with-email-verification","title":"User Registration with Email Verification","text":"<p>Test complete registration flow including email verification.</p>"},{"location":"examples/#actions","title":"Actions","text":"Python<pre><code># actions/user_registration.py\nimport time\n\ndef register_user(client, context, email=None, password=None):\n    \"\"\"Register a new user account.\"\"\"\n    email = email or context.get(\"email\", f\"test_{int(time.time())}@example.com\")\n    password = password or context.get(\"password\", \"SecurePass123!\")\n\n    response = client.post(\"/api/auth/register\", json={\n        \"email\": email,\n        \"password\": password,\n        \"name\": \"Test User\",\n    })\n\n    if response.status_code == 201:\n        context[\"user_email\"] = email\n        context[\"user_password\"] = password\n        context[\"user_id\"] = response.json()[\"user\"][\"id\"]\n\n    return response\n\ndef get_verification_token(client, context):\n    \"\"\"Get email verification token (simulating email retrieval).\"\"\"\n    # In real tests, this might query a test email service\n    user_id = context.get_required(\"user_id\")\n    response = client.get(f\"/api/test/verification-token/{user_id}\")\n\n    if response.status_code == 200:\n        context[\"verification_token\"] = response.json()[\"token\"]\n\n    return response\n\ndef verify_email(client, context):\n    \"\"\"Verify email with token.\"\"\"\n    token = context.get_required(\"verification_token\")\n    return client.post(\"/api/auth/verify-email\", json={\"token\": token})\n\ndef login_and_verify(client, context):\n    \"\"\"Login and verify account is active.\"\"\"\n    email = context.get_required(\"user_email\")\n    password = context.get_required(\"user_password\")\n\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": email,\n        \"password\": password,\n    })\n\n    if response.status_code == 200:\n        context[\"auth_token\"] = response.json()[\"token\"]\n        client.set_auth_token(context[\"auth_token\"])\n\n    return response\n\ndef check_account_status(client, context):\n    \"\"\"Verify account is verified and active.\"\"\"\n    return client.get(\"/api/auth/me\")\n</code></pre>"},{"location":"examples/#journey","title":"Journey","text":"Python<pre><code># journeys/user_registration.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.user_registration import (\n    register_user, get_verification_token, verify_email,\n    login_and_verify, check_account_status,\n)\n\nregistration_journey = Journey(\n    name=\"user_registration\",\n    description=\"Complete user registration with email verification\",\n    tags=[\"auth\", \"registration\", \"email\"],\n    steps=[\n        Step(name=\"register\", action=register_user),\n        Checkpoint(name=\"user_created\"),\n        Step(name=\"get_token\", action=get_verification_token),\n        Checkpoint(name=\"token_retrieved\"),\n        Branch(\n            checkpoint_name=\"token_retrieved\",\n            paths=[\n                Path(name=\"valid_verification\", steps=[\n                    Step(name=\"verify_email\", action=verify_email),\n                    Step(name=\"login\", action=login_and_verify),\n                    Step(name=\"check_status\", action=check_account_status),\n                ]),\n                Path(name=\"invalid_token\", steps=[\n                    Step(\n                        name=\"verify_with_invalid\",\n                        action=lambda c, ctx: c.post(\"/api/auth/verify-email\", json={\"token\": \"invalid\"}),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"expired_token\", steps=[\n                    Step(\n                        name=\"verify_with_expired\",\n                        action=lambda c, ctx: c.post(\"/api/auth/verify-email\", json={\"token\": \"expired_token_123\"}),\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#api-rate-limiting-tests","title":"API Rate Limiting Tests","text":"<p>Test rate limiting behavior and error handling.</p>"},{"location":"examples/#actions_1","title":"Actions","text":"Python<pre><code># actions/rate_limit.py\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef make_request(client, context, endpoint=\"/api/data\"):\n    \"\"\"Make a single API request.\"\"\"\n    return client.get(endpoint)\n\ndef burst_requests(client, context, count=10, endpoint=\"/api/data\"):\n    \"\"\"Make multiple rapid requests.\"\"\"\n    results = []\n    for _ in range(count):\n        results.append(client.get(endpoint))\n    context[\"burst_results\"] = results\n    return results[-1]\n\ndef parallel_requests(client, context, count=10, endpoint=\"/api/data\"):\n    \"\"\"Make parallel requests to trigger rate limiting.\"\"\"\n    def make_request():\n        return client.get(endpoint)\n\n    with ThreadPoolExecutor(max_workers=count) as executor:\n        futures = [executor.submit(make_request) for _ in range(count)]\n        results = [f.result() for f in futures]\n\n    context[\"parallel_results\"] = results\n    return results[-1]\n\ndef wait_and_retry(client, context):\n    \"\"\"Wait for rate limit to reset and retry.\"\"\"\n    time.sleep(60)  # Wait for rate limit window\n    return client.get(\"/api/data\")\n\ndef check_rate_limit_headers(client, context):\n    \"\"\"Check rate limit headers in response.\"\"\"\n    response = client.get(\"/api/data\")\n\n    headers = response.headers\n    context[\"rate_limit\"] = {\n        \"limit\": headers.get(\"X-RateLimit-Limit\"),\n        \"remaining\": headers.get(\"X-RateLimit-Remaining\"),\n        \"reset\": headers.get(\"X-RateLimit-Reset\"),\n    }\n\n    return response\n</code></pre>"},{"location":"examples/#journey_1","title":"Journey","text":"Python<pre><code># journeys/rate_limiting.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.rate_limit import (\n    make_request, burst_requests, parallel_requests,\n    wait_and_retry, check_rate_limit_headers,\n)\n\nrate_limit_journey = Journey(\n    name=\"rate_limiting\",\n    description=\"Test API rate limiting behavior\",\n    tags=[\"rate-limit\", \"api\", \"reliability\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"check_headers\", action=check_rate_limit_headers),\n        Checkpoint(name=\"initial_state\"),\n        Branch(\n            checkpoint_name=\"initial_state\",\n            paths=[\n                Path(name=\"sequential_burst\", steps=[\n                    Step(name=\"burst_10\", action=lambda c, ctx: burst_requests(c, ctx, count=10)),\n                    Step(\n                        name=\"expect_rate_limited\",\n                        action=lambda c, ctx: make_request(c, ctx),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"parallel_burst\", steps=[\n                    Step(name=\"parallel_20\", action=lambda c, ctx: parallel_requests(c, ctx, count=20)),\n                    Step(\n                        name=\"expect_blocked\",\n                        action=lambda c, ctx: make_request(c, ctx),\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#multi-tenant-application-testing","title":"Multi-Tenant Application Testing","text":"<p>Test behavior across different tenants with data isolation.</p>"},{"location":"examples/#actions_2","title":"Actions","text":"Python<pre><code># actions/multi_tenant.py\n\ndef switch_tenant(client, context, tenant_id=None):\n    \"\"\"Switch to a specific tenant context.\"\"\"\n    tenant_id = tenant_id or context.get(\"tenant_id\")\n    client.clear_auth()\n\n    # Get tenant-specific auth\n    response = client.post(\"/api/auth/tenant-login\", json={\n        \"tenant_id\": tenant_id,\n        \"api_key\": f\"key_{tenant_id}\",\n    })\n\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n        context[\"current_tenant\"] = tenant_id\n\n    return response\n\ndef create_tenant_resource(client, context, name=None):\n    \"\"\"Create a resource in current tenant.\"\"\"\n    tenant = context.get(\"current_tenant\")\n    name = name or f\"Resource for {tenant}\"\n\n    response = client.post(\"/api/resources\", json={\n        \"name\": name,\n        \"tenant_id\": tenant,\n    })\n\n    if response.status_code == 201:\n        context[f\"resource_{tenant}\"] = response.json()[\"id\"]\n\n    return response\n\ndef list_tenant_resources(client, context):\n    \"\"\"List resources for current tenant.\"\"\"\n    return client.get(\"/api/resources\")\n\ndef try_cross_tenant_access(client, context, target_tenant=None, resource_id=None):\n    \"\"\"Attempt to access another tenant's resource.\"\"\"\n    target = target_tenant or context.get(\"other_tenant\")\n    resource = resource_id or context.get(f\"resource_{target}\")\n\n    return client.get(f\"/api/resources/{resource}\")\n</code></pre>"},{"location":"examples/#journey_2","title":"Journey","text":"Python<pre><code># journeys/multi_tenant.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.multi_tenant import (\n    switch_tenant, create_tenant_resource, list_tenant_resources,\n    try_cross_tenant_access,\n)\n\nmulti_tenant_journey = Journey(\n    name=\"multi_tenant_isolation\",\n    description=\"Test multi-tenant data isolation\",\n    tags=[\"multi-tenant\", \"security\", \"isolation\"],\n    steps=[\n        # Setup tenant A\n        Step(name=\"switch_tenant_a\", action=lambda c, ctx: switch_tenant(c, ctx, tenant_id=\"tenant_a\")),\n        Step(name=\"create_resource_a\", action=create_tenant_resource),\n        Checkpoint(name=\"tenant_a_setup\"),\n\n        # Setup tenant B\n        Step(name=\"switch_tenant_b\", action=lambda c, ctx: switch_tenant(c, ctx, tenant_id=\"tenant_b\")),\n        Step(name=\"create_resource_b\", action=create_tenant_resource),\n        context[\"other_tenant\"] = \"tenant_a\",\n        Checkpoint(name=\"tenant_b_setup\"),\n\n        # Test isolation\n        Branch(\n            checkpoint_name=\"tenant_b_setup\",\n            paths=[\n                Path(name=\"isolation_test\", steps=[\n                    # Tenant B tries to access Tenant A's resource\n                    Step(\n                        name=\"cross_tenant_access\",\n                        action=try_cross_tenant_access,\n                        expect_failure=True,  # Should fail\n                    ),\n                ]),\n                Path(name=\"list_own_resources\", steps=[\n                    Step(name=\"list_b_resources\", action=list_tenant_resources),\n                ]),\n            ],\n        ),\n\n        # Switch back to A and verify\n        Step(name=\"back_to_tenant_a\", action=lambda c, ctx: switch_tenant(c, ctx, tenant_id=\"tenant_a\")),\n        Step(name=\"verify_a_resources\", action=list_tenant_resources),\n    ],\n)\n</code></pre>"},{"location":"examples/#payment-gateway-integration","title":"Payment Gateway Integration","text":"<p>Test payment processing with various scenarios.</p>"},{"location":"examples/#actions_3","title":"Actions","text":"Python<pre><code># actions/payment.py\n\ndef create_payment_intent(client, context, amount=1000, currency=\"usd\"):\n    \"\"\"Create a payment intent.\"\"\"\n    response = client.post(\"/api/payments/intents\", json={\n        \"amount\": amount,\n        \"currency\": currency,\n    })\n\n    if response.status_code == 201:\n        context[\"payment_intent_id\"] = response.json()[\"id\"]\n        context[\"payment_amount\"] = amount\n\n    return response\n\ndef confirm_payment(client, context, payment_method=\"card_success\"):\n    \"\"\"Confirm a payment with specified method.\"\"\"\n    intent_id = context.get_required(\"payment_intent_id\")\n\n    response = client.post(f\"/api/payments/intents/{intent_id}/confirm\", json={\n        \"payment_method\": payment_method,\n    })\n\n    if response.status_code == 200:\n        context[\"payment_status\"] = response.json()[\"status\"]\n\n    return response\n\ndef refund_payment(client, context, amount=None):\n    \"\"\"Refund a payment.\"\"\"\n    intent_id = context.get_required(\"payment_intent_id\")\n    amount = amount or context.get(\"payment_amount\")\n\n    return client.post(f\"/api/payments/intents/{intent_id}/refund\", json={\n        \"amount\": amount,\n    })\n\ndef get_payment_status(client, context):\n    \"\"\"Get current payment status.\"\"\"\n    intent_id = context.get_required(\"payment_intent_id\")\n    return client.get(f\"/api/payments/intents/{intent_id}\")\n</code></pre>"},{"location":"examples/#journey_3","title":"Journey","text":"Python<pre><code># journeys/payment_gateway.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.payment import (\n    create_payment_intent, confirm_payment, refund_payment, get_payment_status,\n)\n\npayment_journey = Journey(\n    name=\"payment_gateway\",\n    description=\"Test payment gateway integration\",\n    tags=[\"payment\", \"integration\", \"critical\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"create_intent\", action=create_payment_intent),\n        Checkpoint(name=\"intent_created\"),\n        Branch(\n            checkpoint_name=\"intent_created\",\n            paths=[\n                Path(name=\"successful_payment\", steps=[\n                    Step(name=\"confirm_success\", action=lambda c, ctx: confirm_payment(c, ctx, \"card_success\")),\n                    Step(name=\"verify_success\", action=get_payment_status),\n                ]),\n                Path(name=\"declined_payment\", steps=[\n                    Step(\n                        name=\"confirm_declined\",\n                        action=lambda c, ctx: confirm_payment(c, ctx, \"card_declined\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"insufficient_funds\", steps=[\n                    Step(\n                        name=\"confirm_insufficient\",\n                        action=lambda c, ctx: confirm_payment(c, ctx, \"card_insufficient\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"payment_then_refund\", steps=[\n                    Step(name=\"confirm_for_refund\", action=lambda c, ctx: confirm_payment(c, ctx, \"card_success\")),\n                    Step(name=\"refund_full\", action=refund_payment),\n                    Step(name=\"verify_refunded\", action=get_payment_status),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#file-upload-and-processing","title":"File Upload and Processing","text":"<p>Test file upload and async processing.</p>"},{"location":"examples/#actions_4","title":"Actions","text":"Python<pre><code># actions/file_upload.py\nimport io\nimport time\n\ndef upload_file(client, context, filename=\"test.csv\", content=None):\n    \"\"\"Upload a file for processing.\"\"\"\n    content = content or b\"id,name\\n1,Test\\n2,Example\"\n\n    files = {\n        \"file\": (filename, io.BytesIO(content), \"text/csv\"),\n    }\n\n    response = client.post(\"/api/uploads\", files=files)\n\n    if response.status_code == 201:\n        context[\"upload_id\"] = response.json()[\"upload_id\"]\n\n    return response\n\ndef get_upload_status(client, context):\n    \"\"\"Get upload processing status.\"\"\"\n    upload_id = context.get_required(\"upload_id\")\n    return client.get(f\"/api/uploads/{upload_id}\")\n\ndef wait_for_processing(client, context, timeout=60):\n    \"\"\"Wait for upload to finish processing.\"\"\"\n    upload_id = context.get_required(\"upload_id\")\n    start = time.time()\n\n    while time.time() - start &lt; timeout:\n        response = client.get(f\"/api/uploads/{upload_id}\")\n        status = response.json()[\"status\"]\n\n        if status in [\"completed\", \"failed\"]:\n            context[\"processing_status\"] = status\n            return response\n\n        time.sleep(1)\n\n    raise TimeoutError(\"Processing timed out\")\n\ndef get_upload_results(client, context):\n    \"\"\"Get results of processed upload.\"\"\"\n    upload_id = context.get_required(\"upload_id\")\n    return client.get(f\"/api/uploads/{upload_id}/results\")\n\ndef upload_large_file(client, context, size_mb=10):\n    \"\"\"Upload a large file.\"\"\"\n    content = b\"x\" * (size_mb * 1024 * 1024)\n    return upload_file(client, context, filename=\"large.bin\", content=content)\n</code></pre>"},{"location":"examples/#journey_4","title":"Journey","text":"Python<pre><code># journeys/file_upload.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.file_upload import (\n    upload_file, get_upload_status, wait_for_processing,\n    get_upload_results, upload_large_file,\n)\n\nfile_upload_journey = Journey(\n    name=\"file_upload\",\n    description=\"Test file upload and processing\",\n    tags=[\"upload\", \"async\", \"processing\"],\n    timeout=120.0,\n    steps=[\n        Step(name=\"login\", action=login),\n        Checkpoint(name=\"authenticated\"),\n        Branch(\n            checkpoint_name=\"authenticated\",\n            paths=[\n                Path(name=\"small_csv\", steps=[\n                    Step(name=\"upload_csv\", action=upload_file),\n                    Step(name=\"wait_process\", action=wait_for_processing),\n                    Step(name=\"get_results\", action=get_upload_results),\n                ]),\n                Path(name=\"invalid_format\", steps=[\n                    Step(\n                        name=\"upload_invalid\",\n                        action=lambda c, ctx: upload_file(c, ctx, filename=\"test.exe\", content=b\"invalid\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"large_file\", steps=[\n                    Step(name=\"upload_large\", action=lambda c, ctx: upload_large_file(c, ctx, size_mb=50)),\n                    Step(name=\"wait_large\", action=wait_for_processing),\n                ], description=\"Test large file handling\"),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#websocket-and-real-time-features","title":"WebSocket and Real-Time Features","text":"<p>Test WebSocket connections and real-time updates.</p>"},{"location":"examples/#actions_5","title":"Actions","text":"Python<pre><code># actions/websocket.py\nimport json\nimport time\n\ndef subscribe_to_channel(client, context, channel=\"updates\"):\n    \"\"\"Subscribe to a real-time channel via REST.\"\"\"\n    response = client.post(\"/api/realtime/subscribe\", json={\n        \"channel\": channel,\n    })\n\n    if response.status_code == 200:\n        context[\"channel\"] = channel\n        context[\"subscription_id\"] = response.json()[\"subscription_id\"]\n\n    return response\n\ndef trigger_event(client, context, event_type=\"test_event\", data=None):\n    \"\"\"Trigger a real-time event.\"\"\"\n    channel = context.get(\"channel\", \"updates\")\n\n    return client.post(\"/api/realtime/events\", json={\n        \"channel\": channel,\n        \"event\": event_type,\n        \"data\": data or {\"message\": \"test\"},\n    })\n\ndef poll_for_events(client, context, timeout=10):\n    \"\"\"Poll for events (simulating WebSocket).\"\"\"\n    subscription_id = context.get_required(\"subscription_id\")\n    events = []\n    start = time.time()\n\n    while time.time() - start &lt; timeout:\n        response = client.get(f\"/api/realtime/events/{subscription_id}\")\n        if response.status_code == 200:\n            new_events = response.json().get(\"events\", [])\n            events.extend(new_events)\n\n            if events:\n                context[\"received_events\"] = events\n                return response\n\n        time.sleep(0.5)\n\n    context[\"received_events\"] = events\n    return response\n\ndef unsubscribe(client, context):\n    \"\"\"Unsubscribe from channel.\"\"\"\n    subscription_id = context.get_required(\"subscription_id\")\n    return client.delete(f\"/api/realtime/subscriptions/{subscription_id}\")\n</code></pre>"},{"location":"examples/#journey_5","title":"Journey","text":"Python<pre><code># journeys/realtime.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.websocket import (\n    subscribe_to_channel, trigger_event, poll_for_events, unsubscribe,\n)\n\nrealtime_journey = Journey(\n    name=\"realtime_features\",\n    description=\"Test real-time WebSocket features\",\n    tags=[\"websocket\", \"realtime\", \"events\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"subscribe\", action=subscribe_to_channel),\n        Checkpoint(name=\"subscribed\"),\n        Branch(\n            checkpoint_name=\"subscribed\",\n            paths=[\n                Path(name=\"single_event\", steps=[\n                    Step(name=\"trigger\", action=trigger_event),\n                    Step(name=\"poll\", action=poll_for_events),\n                ]),\n                Path(name=\"multiple_events\", steps=[\n                    Step(name=\"trigger_1\", action=lambda c, ctx: trigger_event(c, ctx, \"event_1\")),\n                    Step(name=\"trigger_2\", action=lambda c, ctx: trigger_event(c, ctx, \"event_2\")),\n                    Step(name=\"trigger_3\", action=lambda c, ctx: trigger_event(c, ctx, \"event_3\")),\n                    Step(name=\"poll_multiple\", action=lambda c, ctx: poll_for_events(c, ctx, timeout=15)),\n                ]),\n            ],\n        ),\n        Step(name=\"unsubscribe\", action=unsubscribe),\n    ],\n)\n</code></pre>"},{"location":"examples/#third-party-api-mocking","title":"Third-Party API Mocking","text":"<p>Test with mocked third-party services.</p>"},{"location":"examples/#actions_6","title":"Actions","text":"Python<pre><code># actions/integrations.py\n\ndef configure_stripe_mock(client, context, scenario=\"success\"):\n    \"\"\"Configure Stripe mock for testing.\"\"\"\n    return client.post(\"/api/test/mock/stripe\", json={\n        \"scenario\": scenario,\n    })\n\ndef configure_sendgrid_mock(client, context, scenario=\"success\"):\n    \"\"\"Configure SendGrid mock for testing.\"\"\"\n    return client.post(\"/api/test/mock/sendgrid\", json={\n        \"scenario\": scenario,\n    })\n\ndef verify_email_sent(client, context):\n    \"\"\"Verify email was sent via mock.\"\"\"\n    response = client.get(\"/api/test/mock/sendgrid/emails\")\n\n    if response.status_code == 200:\n        emails = response.json().get(\"emails\", [])\n        if emails:\n            context[\"last_email\"] = emails[-1]\n\n    return response\n\ndef verify_stripe_charge(client, context):\n    \"\"\"Verify Stripe charge was created.\"\"\"\n    response = client.get(\"/api/test/mock/stripe/charges\")\n\n    if response.status_code == 200:\n        charges = response.json().get(\"charges\", [])\n        if charges:\n            context[\"last_charge\"] = charges[-1]\n\n    return response\n</code></pre>"},{"location":"examples/#journey_6","title":"Journey","text":"Python<pre><code># journeys/third_party_mocks.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.integrations import (\n    configure_stripe_mock, configure_sendgrid_mock,\n    verify_email_sent, verify_stripe_charge,\n)\nfrom actions.payment import create_payment_intent, confirm_payment\nfrom actions.user_registration import register_user\n\nmocked_integration_journey = Journey(\n    name=\"third_party_mocks\",\n    description=\"Test with mocked third-party services\",\n    tags=[\"mocking\", \"integration\", \"testing\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Checkpoint(name=\"authenticated\"),\n\n        Branch(\n            checkpoint_name=\"authenticated\",\n            paths=[\n                Path(name=\"stripe_success\", steps=[\n                    Step(name=\"mock_stripe_ok\", action=lambda c, ctx: configure_stripe_mock(c, ctx, \"success\")),\n                    Step(name=\"create_payment\", action=create_payment_intent),\n                    Step(name=\"confirm_payment\", action=lambda c, ctx: confirm_payment(c, ctx, \"card_success\")),\n                    Step(name=\"verify_charge\", action=verify_stripe_charge),\n                ]),\n                Path(name=\"stripe_failure\", steps=[\n                    Step(name=\"mock_stripe_fail\", action=lambda c, ctx: configure_stripe_mock(c, ctx, \"card_declined\")),\n                    Step(name=\"create_payment_fail\", action=create_payment_intent),\n                    Step(\n                        name=\"confirm_fail\",\n                        action=lambda c, ctx: confirm_payment(c, ctx, \"card_declined\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"email_success\", steps=[\n                    Step(name=\"mock_sendgrid_ok\", action=lambda c, ctx: configure_sendgrid_mock(c, ctx, \"success\")),\n                    Step(name=\"register_user\", action=register_user),\n                    Step(name=\"verify_email\", action=verify_email_sent),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"faq/","title":"FAQ","text":"<p>Common questions about VenomQA.</p>"},{"location":"faq/#general","title":"General","text":"<p>Q: What is VenomQA?</p> <p>A: VenomQA is a state-based API testing framework that helps you test your entire application through state exploration. Unlike traditional API testing tools that test endpoints in isolation, VenomQA tests complete user workflows and verifies that your system remains consistent after every action.</p>"},{"location":"faq/#getting-started","title":"Getting Started","text":"<p>Q: When should I use StateGraph vs Journey?</p> <p>A: Use each approach for different scenarios:</p> Scenario Recommended Approach Testing a specific user flow (login, checkout, etc.) Journey Exploring all possible state transitions StateGraph Smoke tests and quick sanity checks Journey Finding edge cases and unexpected paths StateGraph CI/CD integration Both work well <p>Journey is simpler and more intuitive - start here if you're new. It's like writing a script that a user would follow.</p> <p>StateGraph is more powerful - it automatically explores all paths through your system and finds bugs that linear tests miss.</p> Python<pre><code># Journey: Test one specific flow\njourney = Journey(\n    name=\"checkout\",\n    steps=[Step(name=\"login\", action=login), Step(name=\"checkout\", action=checkout)]\n)\n\n# StateGraph: Explore ALL state transitions\ngraph = StateGraph(name=\"shopping\")\ngraph.add_node(\"empty\", initial=True)\ngraph.add_node(\"has_items\")\ngraph.add_edge(\"empty\", \"has_items\", action=add_item)\ngraph.add_edge(\"has_items\", \"empty\", action=remove_item)\nresult = graph.explore(client)  # Tests all paths automatically\n</code></pre> <p>Q: Do I need PostgreSQL to use VenomQA?</p> <p>A: No! PostgreSQL is optional and only needed for advanced features:</p> Feature Requires Database? Basic Journey testing No HTTP assertions No Checkpoint/Branch (context only) No Checkpoint/Branch (database rollback) Yes (PostgreSQL, MySQL, or SQLite) StateGraph exploration No (but recommended for full rollback) <p>For most use cases, you can start without any database:</p> YAML<pre><code># venomqa.yaml - minimal config (no database)\nbase_url: \"http://localhost:8000\"\ntimeout: 30\n</code></pre> <p>If you need database state rollback, add:</p> YAML<pre><code># venomqa.yaml - with PostgreSQL\nbase_url: \"http://localhost:8000\"\ndb_url: \"postgresql://user:pass@localhost:5432/testdb\"\ndb_backend: \"postgresql\"\n</code></pre> <p>Q: How do I test without a real API?</p> <p>A: You have several options:</p> <ol> <li> <p>Use the test server we provide: Bash<pre><code>cd examples/quickstart\npip install fastapi uvicorn\npython test_server.py\n</code></pre></p> </li> <li> <p>Use mocking (for unit testing the framework itself): Python<pre><code>from venomqa.mocking import MockClient\n\nmock = MockClient()\nmock.when_get(\"/health\").respond({\"status\": \"ok\"})\n\njourney(mock)  # Uses mock responses\n</code></pre></p> </li> <li> <p>Use fixtures for predictable test data: Python<pre><code>from venomqa.data import DataFactory\n\nfactory = DataFactory()\nuser = factory.user(email=\"test@example.com\")\n</code></pre></p> </li> </ol> <p>Q: What's the difference between <code>context[\"key\"]</code> and <code>context.get(\"key\")</code>?</p> <p>A: They behave differently when the key doesn't exist:</p> Python<pre><code># context[\"key\"] - Raises KeyError if key doesn't exist\nitem_id = context[\"item_id\"]  # Crashes if item_id not set!\n\n# context.get(\"key\") - Returns None (or default) if key doesn't exist\nitem_id = context.get(\"item_id\")  # Returns None if not set\nitem_id = context.get(\"item_id\", default=1)  # Returns 1 if not set\n\n# context.get_required(\"key\") - Raises KeyError with a better error message\nitem_id = context.get_required(\"item_id\")  # KeyError: \"Required context key not found: item_id\"\n</code></pre> <p>Best practice: Use <code>context.get()</code> in most cases, and <code>context.get_required()</code> when the value MUST exist.</p>"},{"location":"faq/#common-errors","title":"Common Errors","text":"<p>Q: I get \"Connection refused\" error. What's wrong?</p> <p>A: Your API server isn't running or isn't accessible. Check:</p> <ol> <li> <p>Is the server running? Bash<pre><code># Check if anything is listening on the port\nlsof -i :8000\ncurl http://localhost:8000/health\n</code></pre></p> </li> <li> <p>Is <code>base_url</code> correct in <code>venomqa.yaml</code>? YAML<pre><code># Make sure this matches your actual server\nbase_url: \"http://localhost:8000\"  # Not https, correct port\n</code></pre></p> </li> <li> <p>If using Docker, is the network configured? YAML<pre><code># docker-compose.yml\nservices:\n  api:\n    ports:\n      - \"8000:8000\"  # Make sure port is exposed\n</code></pre></p> </li> </ol> <p>Q: I get \"Journey not found\" error. How do I fix it?</p> <p>A: VenomQA can't find your journey file. Check:</p> <ol> <li> <p>Is the file in the right directory? Text Only<pre><code>my-project/\n\u251c\u2500\u2500 journeys/           # Journeys go here\n\u2502   \u2514\u2500\u2500 my_journey.py\n\u2514\u2500\u2500 venomqa.yaml\n</code></pre></p> </li> <li> <p>Does the file have a <code>journey</code> variable? Python<pre><code># journeys/my_journey.py\nfrom venomqa import Journey, Step\n\njourney = Journey(  # Must be named 'journey' at module level\n    name=\"my_journey\",\n    steps=[...]\n)\n</code></pre></p> </li> <li> <p>Are you using the correct name? Bash<pre><code># Run with the journey 'name', not the filename\nvenomqa run my_journey      # Correct (uses name=\"my_journey\")\nvenomqa run my_journey.py   # Wrong (filename)\n</code></pre></p> </li> </ol> <p>List available journeys: Bash<pre><code>venomqa list\n</code></pre></p> <p>Q: I get \"KeyError: 'item_id'\" in my action. What happened?</p> <p>A: A previous step didn't set the value you're expecting. Common causes:</p> <ol> <li> <p>Previous step failed silently: Python<pre><code>def create_item(client, context):\n    response = client.post(\"/items\", json={...})\n    # This only sets item_id if successful!\n    if response.status_code == 201:\n        context[\"item_id\"] = response.json()[\"id\"]\n    return response\n</code></pre></p> </li> <li> <p>You're in a branch and context was reset:    Branches restore context to the checkpoint state. Make sure the value was set BEFORE the checkpoint.</p> </li> <li> <p>Typo in the key name: Python<pre><code>context[\"item_Id\"] = 123  # Set with capital I\ncontext[\"item_id\"]        # Get with lowercase i - KeyError!\n</code></pre></p> </li> </ol> <p>Fix: Use defensive programming: Python<pre><code>def get_item(client, context):\n    item_id = context.get(\"item_id\")\n    if not item_id:\n        raise ValueError(\"item_id not set - did create_item succeed?\")\n    return client.get(f\"/items/{item_id}\")\n</code></pre></p> <p>Q: How do I debug a failing step?</p> <p>A: Use verbose mode and add logging:</p> <ol> <li> <p>Run with verbose output: Bash<pre><code>venomqa run my_journey --verbose\n</code></pre></p> </li> <li> <p>Add logging to your actions: Python<pre><code>def create_item(client, context):\n    print(f\"Creating item with context: {dict(context._data)}\")\n    response = client.post(\"/items\", json={...})\n    print(f\"Response: {response.status_code} - {response.text}\")\n    return response\n</code></pre></p> </li> <li> <p>Check the response content: Python<pre><code>def create_item(client, context):\n    response = client.post(\"/items\", json={\"name\": \"test\"})\n    if response.status_code != 201:\n        print(f\"Unexpected status: {response.status_code}\")\n        print(f\"Response body: {response.json()}\")\n    return response\n</code></pre></p> </li> </ol> <p>Q: My step times out. How do I increase the timeout?</p> <p>A: Set timeout at the step or journey level:</p> Python<pre><code># Per-step timeout\nStep(\n    name=\"long_operation\",\n    action=long_operation,\n    timeout=120.0,  # 2 minutes\n)\n\n# Default timeout for all steps in journey\njourney = Journey(\n    name=\"my_journey\",\n    timeout=60.0,  # 1 minute default\n    steps=[...]\n)\n</code></pre> <p>Or in <code>venomqa.yaml</code>: YAML<pre><code>timeout: 60  # Global default in seconds\n</code></pre></p>"},{"location":"faq/#advanced-usage","title":"Advanced Usage","text":"<p>Q: How do I run the same journey with different data?</p> <p>A: Use the <code>args</code> parameter on steps:</p> Python<pre><code>def login(client, context, email, password):\n    return client.post(\"/login\", json={\"email\": email, \"password\": password})\n\n# Reuse the same action with different credentials\njourney = Journey(\n    name=\"multi_user_test\",\n    steps=[\n        Step(name=\"login_admin\", action=login, args={\"email\": \"admin@example.com\", \"password\": \"admin123\"}),\n        Step(name=\"logout\", action=logout),\n        Step(name=\"login_user\", action=login, args={\"email\": \"user@example.com\", \"password\": \"user123\"}),\n    ]\n)\n</code></pre> <p>Q: How do I test authentication flows?</p> <p>A: Store the token in context and use <code>client.set_auth_token()</code>:</p> Python<pre><code>def login(client, context):\n    response = client.post(\"/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n    if response.status_code == 200:\n        token = response.json()[\"access_token\"]\n        context[\"token\"] = token\n        client.set_auth_token(token)  # Sets Authorization: Bearer header\n    return response\n\ndef protected_action(client, context):\n    # Client automatically includes the auth header\n    return client.get(\"/api/protected\")\n</code></pre> <p>Q: Can I use VenomQA with GraphQL APIs?</p> <p>A: Yes! Use the GraphQL client:</p> Python<pre><code>from venomqa.clients.graphql import GraphQLClient\n\nclient = GraphQLClient(\"http://localhost:8000/graphql\")\n\ndef get_users(client, context):\n    query = \"\"\"\n    query {\n        users {\n            id\n            name\n            email\n        }\n    }\n    \"\"\"\n    return client.query(query)\n\ndef create_user(client, context):\n    mutation = \"\"\"\n    mutation CreateUser($name: String!, $email: String!) {\n        createUser(name: $name, email: $email) {\n            id\n            name\n        }\n    }\n    \"\"\"\n    return client.query(mutation, variables={\"name\": \"Test\", \"email\": \"test@example.com\"})\n</code></pre> <p>Q: How do I integrate VenomQA with CI/CD?</p> <p>A: VenomQA works with any CI system. Here's an example for GitHub Actions:</p> YAML<pre><code># .github/workflows/test.yml\nname: API Tests\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    services:\n      api:\n        image: your-api:latest\n        ports:\n          - 8000:8000\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install VenomQA\n        run: pip install venomqa\n\n      - name: Run tests\n        run: venomqa run --all\n\n      - name: Generate report\n        if: always()\n        run: venomqa report --format junit --output results.xml\n\n      - name: Upload results\n        uses: actions/upload-artifact@v3\n        with:\n          name: test-results\n          path: results.xml\n</code></pre> <p>Q: How do I test error handling in my API?</p> <p>A: Use <code>expect_failure=True</code> on steps that should fail:</p> Python<pre><code>journey = Journey(\n    name=\"error_handling\",\n    steps=[\n        # Test 401 Unauthorized\n        Step(\n            name=\"access_without_auth\",\n            action=lambda c, ctx: c.get(\"/api/protected\"),\n            expect_failure=True,\n        ),\n\n        # Test 404 Not Found\n        Step(\n            name=\"get_nonexistent\",\n            action=lambda c, ctx: c.get(\"/api/items/99999\"),\n            expect_failure=True,\n        ),\n\n        # Test 422 Validation Error\n        Step(\n            name=\"invalid_input\",\n            action=lambda c, ctx: c.post(\"/api/items\", json={\"price\": \"not_a_number\"}),\n            expect_failure=True,\n        ),\n    ]\n)\n</code></pre>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":"<p>Q: VenomQA is slow. How do I speed it up?</p> <p>A: Try these optimizations:</p> <ol> <li> <p>Use <code>--no-infra</code> if services are already running: Bash<pre><code>venomqa run --no-infra\n</code></pre></p> </li> <li> <p>Reduce unnecessary waits: Python<pre><code># Don't wait unnecessarily\nStep(name=\"fast_check\", action=fast_check, timeout=5.0)\n</code></pre></p> </li> <li> <p>Run tests in parallel (coming soon): Bash<pre><code>venomqa run --parallel 4\n</code></pre></p> </li> <li> <p>Use targeted test runs: Bash<pre><code>venomqa run specific_journey  # Instead of --all\n</code></pre></p> </li> </ol> <p>Q: Where can I get help?</p> <p>A: You have several options:</p> <ol> <li>Check the documentation: https://venomqa.dev/docs</li> <li>Search existing issues: https://github.com/namanag97/venomqa/issues</li> <li>Open a new issue: https://github.com/namanag97/venomqa/issues/new</li> <li>Join the community: (Coming soon)</li> </ol> <p>When reporting issues, include: - VenomQA version (<code>venomqa --version</code>) - Python version (<code>python --version</code>) - Your <code>venomqa.yaml</code> config (remove secrets) - The full error message and traceback</p>"},{"location":"plugins/","title":"VenomQA Plugin System","text":"<p>VenomQA provides a comprehensive plugin architecture that enables you to extend the framework's functionality. Plugins can add custom reporters, service adapters, data generators, reusable actions, and lifecycle hooks.</p>"},{"location":"plugins/#overview","title":"Overview","text":"<p>The plugin system supports five main extension points:</p> <ol> <li>Reporters - Custom output formats (Slack, DataDog, custom formats)</li> <li>Adapters - Service integrations (databases, caches, queues)</li> <li>Generators - Data generation (domain-specific test data)</li> <li>Actions - Reusable action sets (common test patterns)</li> <li>Hooks - Lifecycle callbacks (notifications, metrics, logging)</li> </ol>"},{"location":"plugins/#creating-a-plugin","title":"Creating a Plugin","text":""},{"location":"plugins/#basic-plugin-structure","title":"Basic Plugin Structure","text":"<p>All plugins inherit from <code>VenomQAPlugin</code>:</p> Python<pre><code>from venomqa.plugins import VenomQAPlugin, PluginType, HookPriority\n\nclass MyPlugin(VenomQAPlugin):\n    # Required: Plugin identifier\n    name = \"my-plugin\"\n    version = \"1.0.0\"\n\n    # Optional: Plugin type (default: HOOK)\n    plugin_type = PluginType.HOOK\n    description = \"My custom plugin\"\n    author = \"Your Name\"\n    priority = HookPriority.NORMAL\n\n    def on_load(self, config: dict) -&gt; None:\n        \"\"\"Called when plugin is loaded.\"\"\"\n        super().on_load(config)\n        self.api_key = config.get(\"api_key\")\n\n    def on_journey_start(self, context):\n        \"\"\"Called before each journey.\"\"\"\n        print(f\"Starting: {context.journey.name}\")\n\n    def on_failure(self, context):\n        \"\"\"Called when a test fails.\"\"\"\n        self.send_alert(context.error)\n</code></pre>"},{"location":"plugins/#plugin-types","title":"Plugin Types","text":""},{"location":"plugins/#hook-plugin","title":"Hook Plugin","text":"<p>For plugins that only need lifecycle callbacks:</p> Python<pre><code>from venomqa.plugins import HookPlugin, HookPriority\n\nclass NotifierPlugin(HookPlugin):\n    name = \"notifier\"\n    version = \"1.0.0\"\n    priority = HookPriority.LOW  # Run after other plugins\n\n    def on_failure(self, context):\n        self.send_notification(context)\n</code></pre>"},{"location":"plugins/#reporter-plugin","title":"Reporter Plugin","text":"<p>For plugins that provide custom report formats:</p> Python<pre><code>from venomqa.plugins import ReporterPlugin\nfrom venomqa.reporters.base import BaseReporter\n\nclass MyReporter(BaseReporter):\n    @property\n    def file_extension(self) -&gt; str:\n        return \".html\"\n\n    def generate(self, results):\n        return \"&lt;html&gt;...&lt;/html&gt;\"\n\nclass MyReporterPlugin(ReporterPlugin):\n    name = \"my-reporter\"\n    version = \"1.0.0\"\n\n    def get_reporter(self) -&gt; BaseReporter:\n        return MyReporter()\n</code></pre>"},{"location":"plugins/#adapter-plugin","title":"Adapter Plugin","text":"<p>For plugins that provide service adapters:</p> Python<pre><code>from venomqa.plugins import AdapterPlugin\n\nclass MongoDBPlugin(AdapterPlugin):\n    name = \"mongodb\"\n    version = \"1.0.0\"\n    provides_adapters = [\"database\"]\n\n    def get_adapter(self, port_type: str):\n        if port_type == \"database\":\n            return MongoDBAdapter(self.config)\n        return None\n</code></pre>"},{"location":"plugins/#action-plugin","title":"Action Plugin","text":"<p>For plugins that provide reusable actions:</p> Python<pre><code>from venomqa.plugins import ActionPlugin\n\nclass AuthActionsPlugin(ActionPlugin):\n    name = \"auth-actions\"\n    version = \"1.0.0\"\n\n    def get_actions(self) -&gt; dict:\n        return {\n            \"auth.login\": self._login,\n            \"auth.logout\": self._logout,\n            \"auth.refresh\": self._refresh_token,\n        }\n\n    def _login(self, client, ctx, **kwargs):\n        return client.post(\"/auth/login\", json=kwargs)\n</code></pre>"},{"location":"plugins/#available-hooks","title":"Available Hooks","text":""},{"location":"plugins/#plugin-lifecycle","title":"Plugin Lifecycle","text":"Hook Method Called When <code>ON_LOAD</code> <code>on_load(config)</code> Plugin is loaded <code>ON_UNLOAD</code> <code>on_unload()</code> Plugin is unloaded"},{"location":"plugins/#journey-lifecycle","title":"Journey Lifecycle","text":"Hook Method Called When <code>BEFORE_JOURNEY</code> <code>on_journey_start(context)</code> Before journey execution <code>AFTER_JOURNEY</code> <code>on_journey_complete(journey, result, context)</code> After journey completes <code>ON_JOURNEY_ERROR</code> <code>on_journey_error(journey, error, context)</code> Journey fails with exception"},{"location":"plugins/#step-lifecycle","title":"Step Lifecycle","text":"Hook Method Called When <code>BEFORE_STEP</code> <code>on_step_start(step, context)</code> Before step execution <code>AFTER_STEP</code> <code>on_step_complete(step, result, context)</code> After step completes <code>ON_STEP_ERROR</code> <code>on_step_error(step, error, context)</code> Step fails with exception"},{"location":"plugins/#branch-lifecycle","title":"Branch Lifecycle","text":"Hook Method Called When <code>BEFORE_BRANCH</code> <code>on_branch_start(branch, context)</code> Before branch exploration <code>AFTER_BRANCH</code> <code>on_branch_complete(branch, result, context)</code> After all paths complete <code>BEFORE_PATH</code> <code>on_path_start(path, context)</code> Before path execution <code>AFTER_PATH</code> <code>on_path_complete(path, result, context)</code> After path completes"},{"location":"plugins/#state-lifecycle","title":"State Lifecycle","text":"Hook Method Called When <code>ON_CHECKPOINT</code> <code>on_checkpoint(checkpoint_name, context)</code> Checkpoint created <code>ON_ROLLBACK</code> <code>on_rollback(checkpoint_name, context)</code> Rolling back to checkpoint"},{"location":"plugins/#error-handling","title":"Error Handling","text":"Hook Method Called When <code>ON_FAILURE</code> <code>on_failure(context)</code> Test failure captured <code>ON_RETRY</code> <code>on_retry(step, attempt, max_attempts, error, context)</code> Step being retried <code>ON_TIMEOUT</code> <code>on_timeout(step, timeout, context)</code> Step times out"},{"location":"plugins/#plugin-configuration","title":"Plugin Configuration","text":""},{"location":"plugins/#yaml-configuration","title":"YAML Configuration","text":"<p>Configure plugins in <code>venomqa.yaml</code>:</p> YAML<pre><code>plugins:\n  # Auto-discover plugins from entry points\n  auto_discover: true\n\n  # Local plugins directory\n  local_plugins_path: qa/plugins\n\n  # Plugin configurations\n  plugins:\n    # Reference by entry point name\n    - name: venomqa-slack\n      enabled: true\n      priority: low\n      config:\n        webhook_url: https://hooks.slack.com/services/...\n        channel: \"#qa-alerts\"\n\n    # Reference by module path\n    - name: venomqa.plugins.examples.timing_analyzer\n      config:\n        threshold_warning_ms: 1000\n\n    # Reference local file\n    - name: ./qa/plugins/custom.py\n      enabled: true\n</code></pre>"},{"location":"plugins/#programmatic-configuration","title":"Programmatic Configuration","text":"Python<pre><code>from venomqa.plugins import (\n    PluginManager,\n    PluginsConfig,\n    PluginConfig,\n    HookPriority,\n)\n\nconfig = PluginsConfig(\n    auto_discover=True,\n    local_plugins_path=\"qa/plugins\",\n    plugins=[\n        PluginConfig(\n            name=\"my-plugin\",\n            enabled=True,\n            priority=HookPriority.HIGH,\n            config={\"api_key\": \"xxx\"},\n        ),\n    ],\n)\n\nmanager = PluginManager()\nmanager.load_plugins_from_config(config)\n</code></pre>"},{"location":"plugins/#plugin-discovery","title":"Plugin Discovery","text":"<p>Plugins are discovered from multiple sources:</p>"},{"location":"plugins/#1-entry-points-recommended","title":"1. Entry Points (Recommended)","text":"<p>Register plugins in <code>pyproject.toml</code>:</p> TOML<pre><code>[project.entry-points.\"venomqa.plugins\"]\nmy-plugin = \"my_package.plugin:MyPlugin\"\n</code></pre> <p>Install the package and VenomQA will auto-discover it.</p>"},{"location":"plugins/#2-local-directory","title":"2. Local Directory","text":"<p>Place Python files in <code>qa/plugins/</code>:</p> Python<pre><code># qa/plugins/custom.py\nfrom venomqa.plugins import VenomQAPlugin\n\nclass CustomPlugin(VenomQAPlugin):\n    name = \"custom\"\n    version = \"1.0.0\"\n    ...\n\n# Either export directly:\nplugin = CustomPlugin()\n\n# Or use 'Plugin' class name:\nPlugin = CustomPlugin\n</code></pre>"},{"location":"plugins/#3-module-import","title":"3. Module Import","text":"<p>Load by module path:</p> Python<pre><code>manager.load_plugin(\"my_package.plugins.custom\")\n</code></pre>"},{"location":"plugins/#built-in-example-plugins","title":"Built-in Example Plugins","text":"<p>VenomQA includes several example plugins:</p>"},{"location":"plugins/#console-logger","title":"Console Logger","text":"<p>Rich console output during test execution:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.console_logger\n    config:\n      level: debug\n      color: true\n      show_timestamps: true\n</code></pre>"},{"location":"plugins/#timing-analyzer","title":"Timing Analyzer","text":"<p>Analyze step execution times:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.timing_analyzer\n    config:\n      threshold_warning_ms: 1000\n      threshold_critical_ms: 5000\n      track_percentiles: [50, 90, 95, 99]\n</code></pre>"},{"location":"plugins/#slack-notifier","title":"Slack Notifier","text":"<p>Send Slack notifications:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.slack_notifier\n    config:\n      webhook_url: ${SLACK_WEBHOOK_URL}\n      channel: \"#qa-alerts\"\n      notify_on_failure: true\n      mention_on_failure: \"@qa-team\"\n</code></pre>"},{"location":"plugins/#datadog-metrics","title":"DataDog Metrics","text":"<p>Report metrics to DataDog:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.datadog_metrics\n    config:\n      api_key: ${DATADOG_API_KEY}\n      prefix: venomqa\n      tags:\n        - env:production\n        - team:qa\n</code></pre>"},{"location":"plugins/#custom-assertions","title":"Custom Assertions","text":"<p>Additional assertion helpers:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.custom_assertions\n    config:\n      strict_mode: false\n</code></pre> <p>Use in steps:</p> Python<pre><code>from venomqa.plugins import get_plugin_manager\n\nmanager = get_plugin_manager()\nassertions = manager.get_assertion(\"assert_json_path\")\n\ndef my_step(client, ctx):\n    response = client.get(\"/api/users\")\n    assertions[\"assert_json_path\"](response, \"data.users.0.name\", \"John\")\n</code></pre>"},{"location":"plugins/#hook-priority","title":"Hook Priority","text":"<p>Control hook execution order with priorities:</p> Python<pre><code>from venomqa.plugins import HookPriority\n\nclass EarlyPlugin(VenomQAPlugin):\n    priority = HookPriority.HIGHEST  # Run first (0)\n\nclass LatePlugin(VenomQAPlugin):\n    priority = HookPriority.LOWEST   # Run last (100)\n</code></pre> <p>Priority levels: - <code>HIGHEST</code> (0) - <code>HIGH</code> (25) - <code>NORMAL</code> (50) - default - <code>LOW</code> (75) - <code>LOWEST</code> (100)</p>"},{"location":"plugins/#error-handling_1","title":"Error Handling","text":"<p>Plugin errors are isolated by default:</p> Python<pre><code># In PluginManager\nmanager = PluginManager(fail_on_plugin_error=False)  # Default\n\n# If True, plugin errors propagate and abort test execution\nmanager = PluginManager(fail_on_plugin_error=True)\n</code></pre>"},{"location":"plugins/#context-objects","title":"Context Objects","text":""},{"location":"plugins/#journeycontext","title":"JourneyContext","text":"Python<pre><code>@dataclass\nclass JourneyContext:\n    journey: Journey          # The Journey object\n    client: Client           # HTTP client\n    state_manager: Any       # State manager (optional)\n    context: ExecutionContext  # Shared state\n</code></pre>"},{"location":"plugins/#stepcontext","title":"StepContext","text":"Python<pre><code>@dataclass\nclass StepContext:\n    journey_name: str\n    path_name: str\n    step_name: str\n    step_number: int\n    step: Step\n    context: ExecutionContext\n</code></pre>"},{"location":"plugins/#failurecontext","title":"FailureContext","text":"Python<pre><code>@dataclass\nclass FailureContext:\n    journey_name: str\n    path_name: str\n    step_name: str\n    error: Exception | str\n    request: dict | None\n    response: dict | None\n    traceback: str | None\n</code></pre>"},{"location":"plugins/#best-practices","title":"Best Practices","text":"<ol> <li>Keep plugins focused - Each plugin should do one thing well</li> <li>Use appropriate priority - Logging plugins should run early, notifications late</li> <li>Handle errors gracefully - Don't let plugin failures break tests</li> <li>Document configuration - Clearly document required and optional config</li> <li>Version your plugins - Follow semantic versioning</li> <li>Test your plugins - Write unit tests for plugin logic</li> </ol>"},{"location":"preflight-configuration/","title":"Preflight Configuration","text":"<p>VenomQA's preflight system runs quick smoke tests against your API before executing a full test suite. This guide explains how to configure those tests using a YAML file so you can reuse the same checks across environments.</p>"},{"location":"preflight-configuration/#quick-start","title":"Quick Start","text":"<p>Generate a starter config:</p> Bash<pre><code>venomqa smoke-test --init &gt; preflight.yaml\n</code></pre> <p>Run smoke tests from the config:</p> Bash<pre><code>venomqa smoke-test --config preflight.yaml\n</code></pre>"},{"location":"preflight-configuration/#configuration-file-format","title":"Configuration File Format","text":"<p>A preflight config is a single YAML file with the following top-level keys:</p> YAML<pre><code>base_url: \"http://localhost:8000\"\ntimeout: 10.0\n\nauth:\n  token_env_var: \"API_TOKEN\"\n  header: \"Authorization\"\n  prefix: \"Bearer\"\n\nhealth_checks: [...]\nauth_checks: [...]\ncrud_checks: [...]\nlist_checks: [...]\ncustom_checks: [...]\n</code></pre>"},{"location":"preflight-configuration/#base-settings","title":"Base Settings","text":"Field Type Default Description <code>base_url</code> string <code>http://localhost:8000</code> Root URL of the API under test <code>timeout</code> float <code>10.0</code> HTTP timeout in seconds"},{"location":"preflight-configuration/#authentication","title":"Authentication","text":"YAML<pre><code>auth:\n  token_env_var: \"API_TOKEN\"   # Read token from this env var\n  # token: \"eyJ...\"           # Or hardcode a token\n  header: \"Authorization\"      # HTTP header name\n  prefix: \"Bearer\"             # Prefix before the token value\n</code></pre> Field Type Default Description <code>token</code> string - Hardcoded auth token <code>token_env_var</code> string - Env var name containing the token <code>header</code> string <code>Authorization</code> HTTP header to set <code>prefix</code> string <code>Bearer</code> Prefix before the token value <p>If both <code>token</code> and <code>token_env_var</code> are set, the explicit <code>token</code> takes precedence.</p>"},{"location":"preflight-configuration/#health-checks","title":"Health Checks","text":"<p>Verify the API is running and healthy.</p> YAML<pre><code>health_checks:\n  - path: /health\n    expected_status: [200]\n    expected_json:\n      status: \"healthy\"\n    timeout: 5.0  # Override global timeout\n\n  - path: /health/ready\n    expected_status: [200]\n</code></pre> Field Type Default Description <code>path</code> string <code>/health</code> Endpoint path <code>expected_status</code> list[int] <code>[200]</code> HTTP status codes treated as success <code>expected_json</code> dict - Response body must be a superset <code>timeout</code> float - Per-check timeout override"},{"location":"preflight-configuration/#auth-checks","title":"Auth Checks","text":"<p>Verify that authenticated requests succeed.</p> YAML<pre><code>auth_checks:\n  - path: /api/v1/me\n    expected_status: [200]\n\n  - path: /api/v1/workspaces\n    method: GET\n    expected_status: [200]\n</code></pre> Field Type Default Description <code>path</code> string <code>/api/v1/me</code> Auth-protected endpoint <code>method</code> string <code>GET</code> HTTP method <code>expected_status</code> list[int] <code>[200]</code> Success status codes"},{"location":"preflight-configuration/#crud-checks","title":"CRUD Checks","text":"<p>Verify resource creation works.</p> YAML<pre><code>crud_checks:\n  - name: \"Create workspace\"\n    path: /api/v1/workspaces\n    method: POST\n    payload:\n      name: \"Preflight Test ${RANDOM}\"\n    expected_status: [201, 409]\n    cleanup_path: /api/v1/workspaces/${id}\n</code></pre> Field Type Default Description <code>name</code> string - Human-readable label <code>path</code> string <code>/api/v1/resources</code> POST endpoint path <code>method</code> string <code>POST</code> HTTP method <code>payload</code> dict <code>{}</code> JSON body to send <code>expected_status</code> list[int] <code>[200, 201, 409]</code> Success status codes <code>cleanup_path</code> string - DELETE path template (future)"},{"location":"preflight-configuration/#list-checks","title":"List Checks","text":"<p>Verify list/pagination endpoints return data.</p> YAML<pre><code>list_checks:\n  - path: /api/v1/items\n    expected_type: array\n\n  - path: /api/v1/orders\n    expected_type: paginated\n</code></pre> Field Type Default Description <code>path</code> string <code>/api/v1/resources</code> GET endpoint path <code>expected_status</code> list[int] <code>[200]</code> Success status codes <code>expected_type</code> string <code>array</code> <code>\"array\"</code> or <code>\"paginated\"</code>"},{"location":"preflight-configuration/#custom-checks","title":"Custom Checks","text":"<p>Run any arbitrary HTTP request with validation.</p> YAML<pre><code>custom_checks:\n  - name: \"OpenAPI spec available\"\n    method: GET\n    path: /openapi.json\n    expected_status: [200]\n    expected_json:\n      openapi: \"3.0.0\"\n\n  - name: \"Create via PUT\"\n    method: PUT\n    path: /api/v1/settings\n    payload:\n      theme: \"dark\"\n    headers:\n      X-Custom: \"value\"\n    expected_status: [200, 204]\n</code></pre> Field Type Default Description <code>name</code> string <code>Custom check</code> Human-readable label <code>method</code> string <code>GET</code> HTTP method <code>path</code> string <code>/</code> Endpoint path <code>payload</code> dict - JSON body (for POST/PUT/PATCH) <code>headers</code> dict - Extra HTTP headers <code>expected_status</code> list[int] <code>[200]</code> Success status codes <code>expected_json</code> dict - Response must be a superset"},{"location":"preflight-configuration/#environment-variable-substitution","title":"Environment Variable Substitution","text":"<p>All string values in the YAML support <code>${VAR}</code> substitution.</p> Syntax Behavior <code>${VAR}</code> Replaced with env var value; error if not set <code>${VAR:default}</code> Replaced with env var value or <code>default</code> <code>${RANDOM}</code> Random 8-character hex string <code>${UUID}</code> Random UUID4 string <code>${TIMESTAMP}</code> Current UNIX timestamp <p>Example:</p> YAML<pre><code>base_url: \"${API_URL:http://localhost:8000}\"\ncrud_checks:\n  - path: /api/v1/items\n    payload:\n      name: \"test-${RANDOM}\"\n      id: \"${UUID}\"\n</code></pre>"},{"location":"preflight-configuration/#cli-usage","title":"CLI Usage","text":"Bash<pre><code># Run from config file\nvenomqa smoke-test --config preflight.yaml\n\n# Override base URL (e.g., for staging)\nvenomqa smoke-test --config preflight.yaml --base-url http://staging:8000\n\n# Override token\nvenomqa smoke-test --config preflight.yaml --token $STAGING_TOKEN\n\n# JSON output (for CI)\nvenomqa smoke-test --config preflight.yaml --json\n\n# Generate example config\nvenomqa smoke-test --init &gt; preflight.yaml\n</code></pre>"},{"location":"preflight-configuration/#programmatic-usage","title":"Programmatic Usage","text":"Python<pre><code>from venomqa.preflight import SmokeTest, PreflightConfig\n\n# From YAML file\nsmoke = SmokeTest.from_yaml(\"preflight.yaml\")\nreport = smoke.run_all()\nreport.print_report()\n\n# From config object\nconfig = PreflightConfig(\n    base_url=\"http://localhost:8000\",\n    health_checks=[HealthCheckConfig(path=\"/health\")],\n    crud_checks=[CRUDCheckConfig(path=\"/items\", payload={\"name\": \"test\"})],\n)\nsmoke = SmokeTest.from_config(config)\nreport = smoke.run_all()\n\n# From dict (e.g., loaded from another source)\nconfig = PreflightConfig.from_dict({\n    \"base_url\": \"http://localhost:8000\",\n    \"health_checks\": [{\"path\": \"/health\"}],\n})\nsmoke = SmokeTest.from_config(config)\n</code></pre>"},{"location":"preflight-configuration/#example-configs","title":"Example Configs","text":"<p>VenomQA includes pre-built configs for common frameworks in <code>examples/preflight_configs/</code>:</p> <ul> <li><code>generic_rest_api.yaml</code> -- Minimal config for any REST API</li> <li><code>fastapi_app.yaml</code> -- FastAPI with OpenAPI docs</li> <li><code>django_app.yaml</code> -- Django REST Framework</li> <li><code>dip_api.yaml</code> -- DIP API (the original use case)</li> </ul> <p>Copy one as a starting point:</p> Bash<pre><code>cp examples/preflight_configs/fastapi_app.yaml preflight.yaml\n# Edit to match your API\nvenomqa smoke-test --config preflight.yaml\n</code></pre>"},{"location":"roadmap/","title":"VenomQA Development Roadmap","text":""},{"location":"roadmap/#current-sprint-comprehensive-enhancement","title":"Current Sprint: Comprehensive Enhancement","text":"<p>Status: 22 parallel workstreams in progress</p>"},{"location":"roadmap/#workstreams","title":"Workstreams","text":""},{"location":"roadmap/#core-framework-improvements","title":"Core Framework Improvements","text":"# Task Status Description 1 Performance Optimization \ud83d\udd04 In Progress Connection pooling, parallel execution fix, caching, benchmarking 2 Retry and Timeout \ud83d\udd04 In Progress Configurable retries, timeouts, circuit breakers 3 Error Messages \ud83d\udd04 In Progress Better errors, debug mode, step-through mode"},{"location":"roadmap/#real-world-validation","title":"Real-World Validation","text":"# Task Status Description 4 Medusa Setup \ud83d\udd04 In Progress Clone, Docker setup, API exploration 5 Medusa Integration \ud83d\udd04 In Progress Full test suite with actions, fixtures, journeys 6 Test Scenarios \ud83d\udd04 In Progress Deep branching, concurrent users, failure recovery"},{"location":"roadmap/#developer-experience","title":"Developer Experience","text":"# Task Status Description 7 Watch Mode \ud83d\udd04 In Progress File watching, auto-rerun on changes 8 OpenAPI Import \ud83d\udd04 In Progress Auto-generate actions from API specs 9 Data Generation \ud83d\udd04 In Progress Faker integration, reproducible test data 10 Data Seeding \ud83d\udd04 In Progress Seed files, auto cleanup, isolation"},{"location":"roadmap/#reporting-and-output","title":"Reporting and Output","text":"# Task Status Description 11 CLI Output \ud83d\udd04 In Progress Real-time progress, better formatting 12 Result Persistence \ud83d\udd04 In Progress Save to database, history command 13 Run Comparison \ud83d\udd04 In Progress Diff between runs, baseline snapshots 14 Notifications \ud83d\udd04 In Progress Slack, email, PagerDuty alerts"},{"location":"roadmap/#testing-capabilities","title":"Testing Capabilities","text":"# Task Status Description 15 Load Testing \ud83d\udd04 In Progress Concurrent users, metrics, assertions 16 Security Testing \ud83d\udd04 In Progress OWASP checks, injection testing 17 Service Mocking \ud83d\udd04 In Progress Mock Stripe, SendGrid, etc. 18 GraphQL Support \ud83d\udd04 In Progress Enhanced queries, subscriptions"},{"location":"roadmap/#infrastructure","title":"Infrastructure","text":"# Task Status Description 19 CI/CD Examples \ud83d\udd04 In Progress GitHub Actions, GitLab CI, Docker 20 Environment Mgmt \ud83d\udd04 In Progress Multi-env configs, secrets 21 Plugin System \ud83d\udd04 In Progress Extensible architecture 22 Documentation \ud83d\udd04 In Progress MkDocs site, tutorials"},{"location":"roadmap/#previously-completed","title":"Previously Completed","text":"Task Status Fix CLI init bootstrap \u2705 Complete Fix optional imports \u2705 Complete Fix verbose flag \u2705 Complete Create examples README \u2705 Complete Document parallel limitation \u2705 Complete"},{"location":"roadmap/#success-metrics","title":"Success Metrics","text":""},{"location":"roadmap/#for-10-release","title":"For 1.0 Release","text":"<ul> <li> VenomQA runs successfully against Medusa e-commerce</li> <li> All 22 workstreams completed and tested</li> <li> Documentation site live</li> <li> PyPI package published</li> <li> At least 3 real-world examples working</li> <li> Test suite &gt;90% passing</li> <li> Performance: 100+ steps/second</li> </ul>"},{"location":"roadmap/#quality-gates","title":"Quality Gates","text":"<ul> <li>All new code has tests</li> <li>No regressions in existing tests</li> <li>Documentation updated</li> <li>Examples verified working</li> </ul>"},{"location":"roadmap/#timeline","title":"Timeline","text":"<ul> <li>Week 1-2: Core improvements, real-world validation</li> <li>Week 3-4: Developer experience, reporting</li> <li>Week 5-6: Testing capabilities, infrastructure</li> <li>Week 7-8: Polish, documentation, release</li> </ul>"},{"location":"roadmap/#architecture-goals","title":"Architecture Goals","text":"<ol> <li>Language Agnostic: Test any API (REST, GraphQL, gRPC)</li> <li>State Management: Database checkpoints and rollback</li> <li>Branching: Explore multiple paths from same state</li> <li>Extensible: Plugin system for customization</li> <li>Observable: Rich reporting and persistence</li> <li>Performant: Fast execution, parallel support</li> </ol>"},{"location":"advanced/","title":"Advanced Topics","text":"<p>Deep dives into VenomQA's architecture, extension points, and optimization techniques.</p>"},{"location":"advanced/#overview","title":"Overview","text":"<p>This section covers advanced topics for users who want to extend VenomQA, optimize performance, or understand the internals.</p> <p>Prerequisites</p> <p>Before diving into advanced topics, ensure you're comfortable with:</p> <ul> <li>Core Concepts - Actions, Invariants, World</li> <li>Basic Usage - Running explorations</li> <li>State Management - Context and checkpoints</li> </ul>"},{"location":"advanced/#topics","title":"Topics","text":"<ul> <li> <p> Performance Tuning</p> <p>Optimize exploration speed, memory usage, and CI integration. Learn about parallel exploration, state pruning, and benchmarking.</p> <p> Performance Guide</p> </li> <li> <p> Custom Reporters</p> <p>Create custom output formats for Slack, Discord, or your own dashboards. Implement the Reporter protocol.</p> <p> Custom Reporters</p> </li> <li> <p> Custom Backends</p> <p>Add support for MongoDB, Elasticsearch, or custom data stores. Implement the SystemAdapter protocol.</p> <p> Custom Backends</p> </li> <li> <p> Testing Patterns</p> <p>Common patterns for testing CRUD operations, auth flows, payment systems, and multi-tenant applications.</p> <p> Testing Patterns</p> </li> </ul>"},{"location":"advanced/#when-to-use-advanced-features","title":"When to Use Advanced Features","text":"Scenario Recommended Topic Exploration too slow Performance Tuning Need Slack/Discord alerts Custom Reporters Using MongoDB, Elasticsearch Custom Backends Complex business logic Testing Patterns Large state space Performance Tuning CI/CD integration Performance Tuning"},{"location":"advanced/#architecture-overview","title":"Architecture Overview","text":"Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Agent                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Strategy   \u2502  \u2502   Invariants \u2502  \u2502    Graph      \u2502  \u2502\n\u2502  \u2502 (BFS/DFS/..)\u2502  \u2502   Checker    \u2502  \u2502   (States)    \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        World                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502    API      \u2502  \u2502   Context    \u2502  \u2502    Systems    \u2502  \u2502\n\u2502  \u2502  (HTTP/ASGI)\u2502  \u2502  (Key-Value) \u2502  \u2502  (DB/Cache)   \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Rollbackable Systems                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 PostgreSQL  \u2502  \u2502    Redis     \u2502  \u2502  Custom DB    \u2502  \u2502\n\u2502  \u2502 (SAVEPOINT) \u2502  \u2502 (DUMP/RESTORE)\u2502  \u2502 (Your Impl)  \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/#extension-points","title":"Extension Points","text":"<p>VenomQA is designed for extensibility at every layer:</p> Layer Extension Point Protocol/Class Exploration Custom strategies <code>ExplorationStrategy</code> Reporting Custom reporters Callable or class State Custom backends <code>Rollbackable</code> Actions Custom action logic Callable <code>(api, context)</code> Invariants Custom checks Callable <code>(world)</code>"},{"location":"advanced/#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Discussions - Ask questions</li> <li>GitHub Issues - Report bugs</li> <li>Examples - Code examples</li> </ul>"},{"location":"advanced/custom-backends/","title":"Custom Backends","text":"<p>Add support for MongoDB, Elasticsearch, or custom data stores by implementing the <code>Rollbackable</code> protocol.</p>"},{"location":"advanced/custom-backends/#overview","title":"Overview","text":"<p>VenomQA uses adapters to communicate with external systems (databases, caches, message queues). Each adapter implements checkpoint/rollback semantics so exploration can branch cleanly.</p>"},{"location":"advanced/custom-backends/#the-rollbackable-protocol","title":"The Rollbackable Protocol","text":"<p>All system adapters must implement the <code>Rollbackable</code> protocol:</p> Python<pre><code>from typing import Protocol, runtime_checkable, Any\nfrom venomqa.sandbox import Observation\n\nSystemCheckpoint = Any\n\n@runtime_checkable\nclass Rollbackable(Protocol):\n    \"\"\"Protocol for systems that can checkpoint and rollback.\"\"\"\n\n    def checkpoint(self, name: str) -&gt; SystemCheckpoint:\n        \"\"\"Save current state and return checkpoint data.\"\"\"\n        ...\n\n    def rollback(self, checkpoint: SystemCheckpoint) -&gt; None:\n        \"\"\"Restore state to a previous checkpoint.\"\"\"\n        ...\n\n    def observe(self) -&gt; Observation:\n        \"\"\"Get current state as an Observation.\"\"\"\n        ...\n</code></pre>"},{"location":"advanced/custom-backends/#minimal-implementation","title":"Minimal Implementation","text":"<p>A simple in-memory adapter:</p> Python<pre><code>import copy\nfrom venomqa.sandbox import Observation\n\nclass InMemoryAdapter:\n    \"\"\"Simple in-memory adapter for testing.\"\"\"\n\n    def __init__(self, initial_data: dict | None = None):\n        self._data = initial_data or {}\n        self._snapshots: dict[str, dict] = {}\n\n    def checkpoint(self, name: str) -&gt; str:\n        snapshot = copy.deepcopy(self._data)\n        self._snapshots[name] = snapshot\n        return name\n\n    def rollback(self, checkpoint: str) -&gt; None:\n        self._data = copy.deepcopy(self._snapshots[checkpoint])\n\n    def observe(self) -&gt; Observation:\n        return Observation.create(\n            system=\"memory\",\n            data={\"keys\": list(self._data.keys()), \"count\": len(self._data)},\n        )\n\n    # Custom methods for your application\n    def get(self, key: str) -&gt; Any:\n        return self._data.get(key)\n\n    def set(self, key: str, value: Any) -&gt; None:\n        self._data[key] = value\n\n    def delete(self, key: str) -&gt; None:\n        self._data.pop(key, None)\n</code></pre>"},{"location":"advanced/custom-backends/#using-custom-adapters","title":"Using Custom Adapters","text":"<p>Register your adapter with <code>World</code>:</p> Python<pre><code>from venomqa import Agent, World, Action, Invariant, Severity\nfrom myapp.adapters import InMemoryAdapter\n\nadapter = InMemoryAdapter(initial_data={\"users\": []})\n\nworld = World(\n    api=api,\n    systems={\"storage\": adapter},\n)\n\nagent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n)\n\nresult = agent.explore()\n</code></pre> <p>Access the adapter in actions:</p> Python<pre><code>def create_user(api, context):\n    storage = context.world.systems[\"storage\"]\n    user_id = str(uuid.uuid4())\n    storage.set(f\"user:{user_id}\", {\"id\": user_id, \"created\": datetime.utcnow()})\n    context.set(\"user_id\", user_id)\n    return api.post(\"/users\", json={\"id\": user_id})\n</code></pre>"},{"location":"advanced/custom-backends/#example-mongodb-adapter","title":"Example: MongoDB Adapter","text":"<p>Full implementation for MongoDB:</p> Python<pre><code>from __future__ import annotations\n\nimport copy\nfrom datetime import datetime\nfrom typing import Any\n\nfrom venomqa.sandbox import Observation\n\nclass MongoDBAdapter:\n    \"\"\"MongoDB adapter with checkpoint/rollback via collection snapshots.\n\n    This adapter creates in-memory snapshots of collections for rollback.\n    Suitable for small-to-medium datasets. For large datasets, consider\n    using MongoDB transactions or database clones.\n\n    Example:\n        from pymongo import MongoClient\n\n        client = MongoClient(\"mongodb://localhost:27017\")\n        db = client[\"testdb\"]\n\n        adapter = MongoDBAdapter(\n            db=db,\n            collections=[\"users\", \"orders\", \"products\"],\n        )\n\n        world = World(api=api, systems={\"mongo\": adapter})\n    \"\"\"\n\n    def __init__(\n        self,\n        db,\n        collections: list[str],\n        checkpoint_mode: str = \"memory\",\n    ):\n        \"\"\"Initialize MongoDB adapter.\n\n        Args:\n            db: PyMongo database instance.\n            collections: List of collection names to track.\n            checkpoint_mode: \"memory\" for in-memory snapshots,\n                           \"drop_restore\" for temp collections (slower, less memory).\n        \"\"\"\n        self.db = db\n        self.collections = collections\n        self.checkpoint_mode = checkpoint_mode\n        self._snapshots: dict[str, dict[str, list[dict]]] = {}\n        self._counter = 0\n\n    def checkpoint(self, name: str) -&gt; str:\n        \"\"\"Create a snapshot of tracked collections.\"\"\"\n        self._counter += 1\n        checkpoint_id = f\"{name}_{self._counter}\"\n\n        if self.checkpoint_mode == \"memory\":\n            snapshot = {}\n            for coll_name in self.collections:\n                snapshot[coll_name] = list(self.db[coll_name].find())\n            self._snapshots[checkpoint_id] = snapshot\n\n        else:  # drop_restore mode\n            for coll_name in self.collections:\n                temp_name = f\"_temp_{checkpoint_id}_{coll_name}\"\n                self.db[coll_name].aggregate([{\"$out\": temp_name}])\n            self._snapshots[checkpoint_id] = {\"mode\": \"drop_restore\"}\n\n        return checkpoint_id\n\n    def rollback(self, checkpoint: str) -&gt; None:\n        \"\"\"Restore collections to checkpoint state.\"\"\"\n        snapshot = self._snapshots[checkpoint]\n\n        if snapshot.get(\"mode\") == \"drop_restore\":\n            # Restore from temp collections\n            for coll_name in self.collections:\n                temp_name = f\"_temp_{checkpoint}_{coll_name}\"\n                self.db[coll_name].drop()\n                self.db[temp_name].aggregate([{\"$out\": coll_name}])\n                self.db[temp_name].drop()\n        else:\n            # Restore from memory snapshot\n            for coll_name in self.collections:\n                self.db[coll_name].delete_many({})\n                if coll_name in snapshot and snapshot[coll_name]:\n                    self.db[coll_name].insert_many(snapshot[coll_name])\n\n    def observe(self) -&gt; Observation:\n        \"\"\"Get observation data for state hashing.\"\"\"\n        data = {}\n        for coll_name in self.collections:\n            data[f\"{coll_name}_count\"] = self.db[coll_name].count_documents({})\n\n        # Add some document hashes for better state discrimination\n        for coll_name in self.collections[:3]:  # Limit for performance\n            sample = list(self.db[coll_name].find().limit(10))\n            if sample:\n                data[f\"{coll_name}_sample_ids\"] = [str(doc.get(\"_id\", \"\")) for doc in sample]\n\n        return Observation.create(\n            system=\"mongodb\",\n            data=data,\n            metadata={\"checkpoint_mode\": self.checkpoint_mode},\n        )\n\n    def query(self, collection: str, filter: dict | None = None) -&gt; list[dict]:\n        \"\"\"Query a collection (helper method).\"\"\"\n        return list(self.db[collection].find(filter or {}))\n\n    def insert(self, collection: str, document: dict) -&gt; str:\n        \"\"\"Insert a document and return its ID.\"\"\"\n        result = self.db[collection].insert_one(document)\n        return str(result.inserted_id)\n\n    def update(self, collection: str, filter: dict, update: dict) -&gt; int:\n        \"\"\"Update documents and return count.\"\"\"\n        result = self.db[collection].update_many(filter, {\"$set\": update})\n        return result.modified_count\n\n    def delete(self, collection: str, filter: dict) -&gt; int:\n        \"\"\"Delete documents and return count.\"\"\"\n        result = self.db[collection].delete_many(filter)\n        return result.deleted_count\n</code></pre> <p>Usage:</p> Python<pre><code>from pymongo import MongoClient\nfrom venomqa import Agent, World, Action, Invariant, Severity\nfrom myapp.adapters.mongodb import MongoDBAdapter\n\nclient = MongoClient(\"mongodb://localhost:27017\")\ndb = client[\"testdb\"]\n\nadapter = MongoDBAdapter(\n    db=db,\n    collections=[\"users\", \"orders\", \"products\"],\n)\n\nworld = World(api=api, systems={\"db\": adapter})\n\ndef create_order(api, context):\n    db = context.world.systems[\"db\"]\n    order_id = db.insert(\"orders\", {\n        \"user_id\": context.get(\"user_id\"),\n        \"amount\": 100,\n        \"status\": \"pending\",\n        \"created_at\": datetime.utcnow(),\n    })\n    context.set(\"order_id\", order_id)\n    return api.post(\"/orders\", json={\"id\": order_id})\n\ndef fulfill_order(api, context):\n    order_id = context.get(\"order_id\")\n    db = context.world.systems[\"db\"]\n    db.update(\"orders\", {\"_id\": ObjectId(order_id)}, {\"status\": \"fulfilled\"})\n    return api.post(f\"/orders/{order_id}/fulfill\")\n</code></pre>"},{"location":"advanced/custom-backends/#example-elasticsearch-adapter","title":"Example: Elasticsearch Adapter","text":"Python<pre><code>from __future__ import annotations\n\nimport copy\nfrom typing import Any\n\nfrom venomqa.sandbox import Observation\n\nclass ElasticsearchAdapter:\n    \"\"\"Elasticsearch adapter with scroll-based snapshots.\n\n    Uses scroll API to snapshot documents, restores via bulk delete/insert.\n\n    Example:\n        from elasticsearch import Elasticsearch\n\n        client = Elasticsearch([\"http://localhost:9200\"])\n\n        adapter = ElasticsearchAdapter(\n            client=client,\n            indices=[\"users\", \"orders\"],\n        )\n\n        world = World(api=api, systems={\"es\": adapter})\n    \"\"\"\n\n    def __init__(\n        self,\n        client,\n        indices: list[str],\n        batch_size: int = 1000,\n    ):\n        \"\"\"Initialize Elasticsearch adapter.\n\n        Args:\n            client: Elasticsearch client instance.\n            indices: List of index names to track.\n            batch_size: Batch size for scroll operations.\n        \"\"\"\n        self.client = client\n        self.indices = indices\n        self.batch_size = batch_size\n        self._snapshots: dict[str, dict[str, list[dict]]] = {}\n        self._counter = 0\n\n    def checkpoint(self, name: str) -&gt; str:\n        \"\"\"Create a snapshot of tracked indices.\"\"\"\n        self._counter += 1\n        checkpoint_id = f\"{name}_{self._counter}\"\n\n        snapshot = {}\n        for index in self.indices:\n            snapshot[index] = self._snapshot_index(index)\n\n        self._snapshots[checkpoint_id] = snapshot\n        return checkpoint_id\n\n    def _snapshot_index(self, index: str) -&gt; list[dict]:\n        \"\"\"Snapshot all documents from an index.\"\"\"\n        documents = []\n\n        response = self.client.search(\n            index=index,\n            body={\"query\": {\"match_all\": {}}},\n            size=self.batch_size,\n            scroll=\"2m\",\n        )\n\n        scroll_id = response.get(\"_scroll_id\")\n        hits = response[\"hits\"][\"hits\"]\n\n        while hits:\n            documents.extend(hits)\n            response = self.client.scroll(scroll_id=scroll_id, scroll=\"2m\")\n            scroll_id = response.get(\"_scroll_id\")\n            hits = response[\"hits\"][\"hits\"]\n\n        if scroll_id:\n            try:\n                self.client.clear_scroll(scroll_id=scroll_id)\n            except Exception:\n                pass\n\n        return documents\n\n    def rollback(self, checkpoint: str) -&gt; None:\n        \"\"\"Restore indices to checkpoint state.\"\"\"\n        snapshot = self._snapshots[checkpoint]\n\n        for index in self.indices:\n            # Delete all documents\n            self.client.delete_by_query(\n                index=index,\n                body={\"query\": {\"match_all\": {}}},\n                conflicts=\"proceed\",\n            )\n\n            # Restore documents\n            if snapshot[index]:\n                actions = []\n                for doc in snapshot[index]:\n                    actions.append({\n                        \"_index\": index,\n                        \"_id\": doc[\"_id\"],\n                        \"_source\": doc[\"_source\"],\n                    })\n\n                from elasticsearch.helpers import bulk\n                bulk(self.client, actions)\n\n    def observe(self) -&gt; Observation:\n        \"\"\"Get observation data for state hashing.\"\"\"\n        data = {}\n\n        for index in self.indices:\n            count = self.client.count(index=index)[\"count\"]\n            data[f\"{index}_count\"] = count\n\n            # Sample some IDs\n            if count &gt; 0:\n                sample = self.client.search(\n                    index=index,\n                    body={\"query\": {\"match_all\": {}}},\n                    size=5,\n                    _source=False,\n                )\n                data[f\"{index}_sample_ids\"] = [hit[\"_id\"] for hit in sample[\"hits\"][\"hits\"]]\n\n        return Observation.create(\n            system=\"elasticsearch\",\n            data=data,\n        )\n\n    def search(self, index: str, query: dict) -&gt; list[dict]:\n        \"\"\"Search an index (helper method).\"\"\"\n        response = self.client.search(index=index, body=query)\n        return response[\"hits\"][\"hits\"]\n\n    def index_document(self, index: str, doc: dict, id: str | None = None) -&gt; str:\n        \"\"\"Index a document and return its ID.\"\"\"\n        body = doc.copy()\n        response = self.client.index(index=index, id=id, body=body)\n        return response[\"_id\"]\n\n    def delete_document(self, index: str, id: str) -&gt; bool:\n        \"\"\"Delete a document by ID.\"\"\"\n        try:\n            self.client.delete(index=index, id=id)\n            return True\n        except Exception:\n            return False\n</code></pre>"},{"location":"advanced/custom-backends/#example-redis-adapter-advanced","title":"Example: Redis Adapter (Advanced)","text":"<p>Redis adapter using Lua scripts for atomic snapshots:</p> Python<pre><code>from __future__ import annotations\n\nfrom typing import Any\n\nfrom venomqa.sandbox import Observation\n\nclass RedisAdapter:\n    \"\"\"Redis adapter with atomic dump/restore.\n\n    Uses Redis DUMP/RESTORE for atomic checkpoint/rollback.\n    Handles strings, hashes, sets, and sorted sets.\n\n    Example:\n        import redis\n\n        client = redis.Redis(host=\"localhost\", port=6379, db=0)\n\n        adapter = RedisAdapter(\n            client=client,\n            key_prefix=\"myapp:\",\n        )\n\n        world = World(api=api, systems={\"redis\": adapter})\n    \"\"\"\n\n    def __init__(\n        self,\n        client,\n        key_prefix: str = \"\",\n        scan_count: int = 1000,\n    ):\n        \"\"\"Initialize Redis adapter.\n\n        Args:\n            client: Redis client instance.\n            key_prefix: Only track keys with this prefix.\n            scan_count: Batch size for SCAN operations.\n        \"\"\"\n        self.client = client\n        self.key_prefix = key_prefix\n        self.scan_count = scan_count\n        self._snapshots: dict[str, dict[str, bytes]] = {}\n        self._counter = 0\n\n    def _get_keys(self) -&gt; list[str]:\n        \"\"\"Get all keys matching prefix.\"\"\"\n        keys = []\n        cursor = 0\n        pattern = f\"{self.key_prefix}*\" if self.key_prefix else \"*\"\n\n        while True:\n            cursor, batch = self.client.scan(cursor, match=pattern, count=self.scan_count)\n            keys.extend(batch)\n            if cursor == 0:\n                break\n\n        return keys\n\n    def checkpoint(self, name: str) -&gt; str:\n        \"\"\"Dump all keys atomically.\"\"\"\n        self._counter += 1\n        checkpoint_id = f\"{name}_{self._counter}\"\n\n        keys = self._get_keys()\n        snapshot = {}\n\n        for key in keys:\n            dump = self.client.dump(key)\n            if dump:\n                snapshot[key] = dump\n            ttl = self.client.ttl(key)\n            snapshot[f\"__ttl__{key}\"] = ttl\n\n        self._snapshots[checkpoint_id] = snapshot\n        return checkpoint_id\n\n    def rollback(self, checkpoint: str) -&gt; None:\n        \"\"\"Restore all keys from dump.\"\"\"\n        snapshot = self._snapshots[checkpoint]\n\n        # Delete current keys\n        keys = self._get_keys()\n        if keys:\n            self.client.delete(*keys)\n\n        # Restore from snapshot\n        for key, dump in snapshot.items():\n            if key.startswith(\"__ttl__\"):\n                continue\n\n            ttl = snapshot.get(f\"__ttl__{key}\", -1)\n            if ttl == -2:  # Key had no expiry\n                ttl = 0\n\n            try:\n                self.client.restore(key, ttl, dump, replace=True)\n            except Exception:\n                pass\n\n    def observe(self) -&gt; Observation:\n        \"\"\"Get observation data for state hashing.\"\"\"\n        keys = self._get_keys()\n\n        data = {\n            \"key_count\": len(keys),\n            \"keys\": sorted(keys)[:50],  # Sample for hashing\n        }\n\n        # Add type counts\n        type_counts = {}\n        for key in keys[:100]:\n            key_type = self.client.type(key)\n            type_counts[key_type] = type_counts.get(key_type, 0) + 1\n        data[\"type_counts\"] = type_counts\n\n        return Observation.create(\n            system=\"redis\",\n            data=data,\n        )\n\n    def get(self, key: str) -&gt; Any:\n        \"\"\"Get a value (helper method).\"\"\"\n        return self.client.get(self.key_prefix + key)\n\n    def set(self, key: str, value: Any, ttl: int | None = None) -&gt; None:\n        \"\"\"Set a value (helper method).\"\"\"\n        full_key = self.key_prefix + key\n        if ttl:\n            self.client.setex(full_key, ttl, value)\n        else:\n            self.client.set(full_key, value)\n\n    def delete(self, key: str) -&gt; None:\n        \"\"\"Delete a key (helper method).\"\"\"\n        self.client.delete(self.key_prefix + key)\n</code></pre>"},{"location":"advanced/custom-backends/#best-practices","title":"Best Practices","text":""},{"location":"advanced/custom-backends/#1-minimize-snapshot-size","title":"1. Minimize Snapshot Size","text":"Python<pre><code>def checkpoint(self, name: str) -&gt; str:\n    snapshot = {}\n    for coll in self.collections:\n        # Only snapshot essential fields\n        snapshot[coll] = [\n            {\"_id\": doc[\"_id\"], \"status\": doc.get(\"status\")}\n            for doc in self.db[coll].find()\n        ]\n    return snapshot\n</code></pre>"},{"location":"advanced/custom-backends/#2-handle-large-datasets","title":"2. Handle Large Datasets","text":"Python<pre><code>class LargeDatasetAdapter:\n    def __init__(self, db, collections: list[str], max_docs: int = 10000):\n        self.max_docs = max_docs\n\n    def checkpoint(self, name: str) -&gt; str:\n        # Warn if dataset is too large\n        total_docs = sum(self.db[c].count_documents({}) for c in self.collections)\n        if total_docs &gt; self.max_docs:\n            warnings.warn(f\"Large dataset ({total_docs} docs). Consider sharding.\")\n</code></pre>"},{"location":"advanced/custom-backends/#3-use-efficient-queries","title":"3. Use Efficient Queries","text":"Python<pre><code>def observe(self) -&gt; Observation:\n    # Use aggregation for counts instead of fetching all docs\n    pipeline = [{\"$count\": \"total\"}]\n    counts = {c: list(self.db[c].aggregate(pipeline))[0][\"total\"]\n              for c in self.collections}\n</code></pre>"},{"location":"advanced/custom-backends/#4-clean-up-resources","title":"4. Clean Up Resources","text":"Python<pre><code>def close(self) -&gt; None:\n    \"\"\"Close connections when exploration ends.\"\"\"\n    self.client.close()\n</code></pre>"},{"location":"advanced/custom-backends/#5-provide-useful-observations","title":"5. Provide Useful Observations","text":"Python<pre><code>def observe(self) -&gt; Observation:\n    return Observation.create(\n        system=\"mongodb\",\n        data={\n            \"users_count\": 5,\n            \"users_statuses\": {\"active\": 3, \"pending\": 2},  # Good for dedup\n            \"orders_count\": 10,\n        },\n    )\n</code></pre>"},{"location":"advanced/custom-backends/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/custom-backends/#rollback-didnt-restore-state","title":"\"Rollback didn't restore state\"","text":"<p>Ensure you're deep-copying data:</p> Python<pre><code>import copy\n\ndef checkpoint(self, name: str) -&gt; str:\n    # Bad: shallow copy\n    snapshot = self._data.copy()\n\n    # Good: deep copy\n    snapshot = copy.deepcopy(self._data)\n</code></pre>"},{"location":"advanced/custom-backends/#state-explosion-with-adapter","title":"\"State explosion with adapter\"","text":"<p>Add meaningful fields to observations:</p> Python<pre><code>def observe(self) -&gt; Observation:\n    return Observation.create(\n        system=\"mydb\",\n        data={\n            \"order_count\": self.count(\"orders\"),\n            \"max_order_id\": self.max_id(\"orders\"),  # Helps distinguish states\n        },\n    )\n</code></pre>"},{"location":"advanced/custom-backends/#checkpoint-too-slow","title":"\"Checkpoint too slow\"","text":"<p>Consider lazy checkpointing:</p> Python<pre><code>def checkpoint(self, name: str) -&gt; str:\n    # Just record the name, snapshot on first rollback\n    self._pending_checkpoint = name\n    return name\n</code></pre>"},{"location":"advanced/custom-reporters/","title":"Custom Reporters","text":"<p>Create custom output formats for Slack, Discord, or your own dashboards.</p>"},{"location":"advanced/custom-reporters/#overview","title":"Overview","text":"<p>Reporters receive the <code>ExplorationResult</code> after exploration completes and format it for output. VenomQA includes several built-in reporters, and you can create your own.</p>"},{"location":"advanced/custom-reporters/#built-in-reporters","title":"Built-in Reporters","text":"Reporter Output Use Case <code>ConsoleReporter</code> Terminal Local development <code>JSONReporter</code> JSON file CI/CD, programmatic access <code>HTMLTraceReporter</code> HTML with D3 graph Visual debugging <code>JUnitReporter</code> JUnit XML CI/CD integration <code>MarkdownReporter</code> Markdown Documentation"},{"location":"advanced/custom-reporters/#reporter-protocol","title":"Reporter Protocol","text":"<p>A reporter is any callable that accepts an <code>ExplorationResult</code>:</p> Python<pre><code>from venomqa import ExplorationResult\n\ndef my_reporter(result: ExplorationResult) -&gt; str:\n    \"\"\"Format exploration result as string.\"\"\"\n    return f\"Found {len(result.violations)} violations\"\n</code></pre> <p>For more complex reporters, use a class:</p> Python<pre><code>from venomqa import ExplorationResult\n\nclass MyReporter:\n    def __init__(self, output_file: str = \"report.txt\"):\n        self.output_file = output_file\n\n    def __call__(self, result: ExplorationResult) -&gt; str:\n        output = self._format(result)\n        with open(self.output_file, \"w\") as f:\n            f.write(output)\n        return output\n\n    def _format(self, result: ExplorationResult) -&gt; str:\n        lines = [\n            f\"States: {result.states_visited}\",\n            f\"Violations: {len(result.violations)}\",\n        ]\n        for v in result.violations:\n            lines.append(f\"  - {v.invariant_name}: {v.message}\")\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"advanced/custom-reporters/#using-custom-reporters","title":"Using Custom Reporters","text":"<p>Pass your reporter to <code>explore()</code>:</p> Python<pre><code>from venomqa import Agent, World, Action, Invariant, Severity\nfrom myapp.reporters import MyReporter\n\nagent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n)\n\nresult = agent.explore()\n\nreporter = MyReporter(\"report.txt\")\nreporter(result)\n</code></pre> <p>Or use multiple reporters:</p> Python<pre><code>reporters = [\n    ConsoleReporter(),\n    JSONReporter(\"results.json\"),\n    MyReporter(\"custom.txt\"),\n]\n\nfor reporter in reporters:\n    reporter(result)\n</code></pre>"},{"location":"advanced/custom-reporters/#example-slack-reporter","title":"Example: Slack Reporter","text":"<p>Send violations to a Slack channel:</p> Python<pre><code>import json\nimport urllib.request\nfrom venomqa import ExplorationResult\n\nclass SlackReporter:\n    \"\"\"Post exploration results to Slack.\"\"\"\n\n    def __init__(\n        self,\n        webhook_url: str,\n        channel: str = \"#qa-alerts\",\n        only_violations: bool = True,\n    ):\n        self.webhook_url = webhook_url\n        self.channel = channel\n        self.only_violations = only_violations\n\n    def __call__(self, result: ExplorationResult) -&gt; str:\n        if self.only_violations and result.success:\n            return \"Skipped (no violations)\"\n\n        payload = self._build_payload(result)\n        self._send(payload)\n        return f\"Posted to {self.channel}\"\n\n    def _build_payload(self, result: ExplorationResult) -&gt; dict:\n        if result.success:\n            return {\n                \"channel\": self.channel,\n                \"attachments\": [{\n                    \"color\": \"good\",\n                    \"title\": \"VenomQA: All Invariants Passed\",\n                    \"fields\": [\n                        {\"title\": \"States Visited\", \"value\": str(result.states_visited), \"short\": True},\n                        {\"title\": \"Duration\", \"value\": f\"{result.duration_ms}ms\", \"short\": True},\n                    ],\n                }],\n            }\n\n        critical = len(result.critical_violations)\n        high = len(result.high_violations)\n\n        fields = [\n            {\"title\": \"Critical\", \"value\": str(critical), \"short\": True},\n            {\"title\": \"High\", \"value\": str(high), \"short\": True},\n            {\"title\": \"States\", \"value\": str(result.states_visited), \"short\": True},\n            {\"title\": \"Duration\", \"value\": f\"{result.duration_ms}ms\", \"short\": True},\n        ]\n\n        violations_text = []\n        for v in result.violations[:5]:\n            path = \" \u2192 \".join(t.action_name for t in v.reproduction_path)\n            violations_text.append(f\"\u2022 *{v.invariant_name}*: {v.message}\")\n            violations_text.append(f\"  Path: `{path}`\")\n\n        return {\n            \"channel\": self.channel,\n            \"attachments\": [{\n                \"color\": \"danger\",\n                \"title\": f\"VenomQA: {len(result.violations)} Violations Found\",\n                \"fields\": fields,\n                \"text\": \"\\n\".join(violations_text),\n                \"mrkdwn_in\": [\"text\"],\n            }],\n        }\n\n    def _send(self, payload: dict) -&gt; None:\n        data = json.dumps(payload).encode(\"utf-8\")\n        req = urllib.request.Request(\n            self.webhook_url,\n            data=data,\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        urllib.request.urlopen(req)\n</code></pre> <p>Usage:</p> Python<pre><code>reporter = SlackReporter(\n    webhook_url=\"https://hooks.slack.com/services/YOUR/WEBHOOK/URL\",\n    channel=\"#qa-alerts\",\n)\nreporter(result)\n</code></pre>"},{"location":"advanced/custom-reporters/#example-discord-reporter","title":"Example: Discord Reporter","text":"<p>Send results to a Discord channel via webhook:</p> Python<pre><code>import json\nimport urllib.request\nfrom venomqa import ExplorationResult\n\nclass DiscordReporter:\n    \"\"\"Post exploration results to Discord.\"\"\"\n\n    def __init__(\n        self,\n        webhook_url: str,\n        only_violations: bool = True,\n    ):\n        self.webhook_url = webhook_url\n        self.only_violations = only_violations\n\n    def __call__(self, result: ExplorationResult) -&gt; str:\n        if self.only_violations and result.success:\n            return \"Skipped (no violations)\"\n\n        payload = self._build_payload(result)\n        self._send(payload)\n        return \"Posted to Discord\"\n\n    def _build_payload(self, result: ExplorationResult) -&gt; dict:\n        color = 5763719 if result.success else 15548997\n\n        fields = [\n            {\"name\": \"States Visited\", \"value\": str(result.states_visited), \"inline\": True},\n            {\"name\": \"Transitions\", \"value\": str(result.transitions_taken), \"inline\": True},\n            {\"name\": \"Coverage\", \"value\": f\"{result.action_coverage_percent:.0f}%\", \"inline\": True},\n            {\"name\": \"Duration\", \"value\": f\"{result.duration_ms}ms\", \"inline\": True},\n        ]\n\n        if not result.success:\n            fields.append({\n                \"name\": f\"Violations ({len(result.violations)})\",\n                \"value\": self._format_violations(result.violations[:5]),\n                \"inline\": False,\n            })\n\n        return {\n            \"embeds\": [{\n                \"title\": \"VenomQA Exploration Results\",\n                \"color\": color,\n                \"fields\": fields,\n                \"footer\": {\"text\": \"VenomQA\"},\n            }],\n        }\n\n    def _format_violations(self, violations) -&gt; str:\n        lines = []\n        for v in violations:\n            severity = v.severity.value.upper()\n            lines.append(f\"**[{severity}]** {v.invariant_name}\")\n            if v.message:\n                lines.append(f\"&gt; {v.message[:100]}\")\n        return \"\\n\".join(lines) or \"None\"\n\n    def _send(self, payload: dict) -&gt; None:\n        data = json.dumps(payload).encode(\"utf-8\")\n        req = urllib.request.Request(\n            self.webhook_url,\n            data=data,\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        urllib.request.urlopen(req)\n</code></pre>"},{"location":"advanced/custom-reporters/#example-custom-json-format","title":"Example: Custom JSON Format","text":"<p>Generate a custom JSON structure:</p> Python<pre><code>import json\nfrom datetime import datetime\nfrom venomqa import ExplorationResult\n\nclass CustomJSONReporter:\n    \"\"\"Export results in a custom JSON schema.\"\"\"\n\n    def __init__(self, output_path: str, include_traces: bool = True):\n        self.output_path = output_path\n        self.include_traces = include_traces\n\n    def __call__(self, result: ExplorationResult) -&gt; str:\n        data = {\n            \"metadata\": {\n                \"timestamp\": datetime.utcnow().isoformat(),\n                \"duration_ms\": result.duration_ms,\n                \"success\": result.success,\n            },\n            \"statistics\": {\n                \"states_visited\": result.states_visited,\n                \"transitions_taken\": result.transitions_taken,\n                \"action_coverage_percent\": result.action_coverage_percent,\n                \"truncated\": result.truncated_by_max_steps,\n            },\n            \"violations\": [\n                self._format_violation(v)\n                for v in result.violations\n            ],\n        }\n\n        if self.include_traces:\n            data[\"trace\"] = self._extract_trace(result)\n\n        with open(self.output_path, \"w\") as f:\n            json.dump(data, f, indent=2)\n\n        return f\"Wrote {self.output_path}\"\n\n    def _format_violation(self, violation) -&gt; dict:\n        return {\n            \"id\": violation.id,\n            \"invariant\": violation.invariant_name,\n            \"severity\": violation.severity.value,\n            \"message\": violation.message,\n            \"path\": [t.action_name for t in violation.reproduction_path],\n            \"action\": violation.action.name if violation.action else None,\n            \"request\": self._format_request(violation.action_result),\n            \"response\": self._format_response(violation.action_result),\n        }\n\n    def _format_request(self, action_result) -&gt; dict | None:\n        if not action_result:\n            return None\n        req = action_result.request\n        return {\n            \"method\": req.method,\n            \"url\": req.url,\n        }\n\n    def _format_response(self, action_result) -&gt; dict | None:\n        if not action_result or not action_result.response:\n            return None\n        resp = action_result.response\n        return {\n            \"status_code\": resp.status_code,\n            \"ok\": resp.ok,\n        }\n\n    def _extract_trace(self, result: ExplorationResult) -&gt; list[dict]:\n        trace = []\n        for transition in result.graph.iter_transitions():\n            trace.append({\n                \"from_state\": transition.from_state_id[:8],\n                \"action\": transition.action_name,\n                \"to_state\": transition.to_state_id[:8],\n            })\n        return trace\n</code></pre>"},{"location":"advanced/custom-reporters/#example-prometheus-metrics","title":"Example: Prometheus Metrics","text":"<p>Export metrics for monitoring:</p> Python<pre><code>from venomqa import ExplorationResult\n\nclass PrometheusMetricsReporter:\n    \"\"\"Export Prometheus-compatible metrics.\"\"\"\n\n    def __init__(self, output_path: str = \"metrics.prom\"):\n        self.output_path = output_path\n\n    def __call__(self, result: ExplorationResult) -&gt; str:\n        metrics = [\n            f\"venomqa_states_visited {result.states_visited}\",\n            f\"venomqa_transitions_taken {result.transitions_taken}\",\n            f\"venomqa_action_coverage_percent {result.action_coverage_percent}\",\n            f\"venomqa_duration_ms {result.duration_ms}\",\n            f\"venomqa_violations_total {len(result.violations)}\",\n            f\"venomqa_violations_critical {len(result.critical_violations)}\",\n            f\"venomqa_violations_high {len(result.high_violations)}\",\n            f\"venomqa_success {1 if result.success else 0}\",\n        ]\n\n        output = \"\\n\".join(metrics) + \"\\n\"\n\n        with open(self.output_path, \"w\") as f:\n            f.write(output)\n\n        return f\"Wrote {self.output_path}\"\n</code></pre>"},{"location":"advanced/custom-reporters/#accessing-result-data","title":"Accessing Result Data","text":"<p>The <code>ExplorationResult</code> provides:</p> Python<pre><code>result.success              # bool - all invariants passed\nresult.states_visited       # int - unique states explored\nresult.transitions_taken    # int - total transitions\nresult.violations           # list[Violation] - all violations\nresult.critical_violations  # list[Violation] - CRITICAL severity\nresult.high_violations      # list[Violation] - HIGH severity\nresult.duration_ms          # float - exploration time\nresult.graph                # Graph - full state graph\nresult.truncated_by_max_steps  # bool - hit step limit\n\n# Violation properties\nviolation.invariant_name    # str - which invariant failed\nviolation.severity          # Severity - CRITICAL/HIGH/MEDIUM/LOW\nviolation.message           # str - description\nviolation.reproduction_path # list[Transition] - how to reproduce\nviolation.action            # Action | None - triggering action\nviolation.action_result     # ActionResult | None - HTTP details\n</code></pre>"},{"location":"advanced/custom-reporters/#best-practices","title":"Best Practices","text":"<ol> <li>Fail gracefully - Network issues shouldn't crash your tests</li> <li>Rate limit - Don't spam channels on large violation counts</li> <li>Include context - Path, severity, and message help debugging</li> <li>Filter noise - Only post what's actionable</li> <li>Test locally - Verify reporter output before CI</li> </ol> Python<pre><code>class RobustSlackReporter:\n    def __call__(self, result: ExplorationResult) -&gt; str:\n        try:\n            if result.success:\n                return \"Skipped (success)\"\n            return self._send_report(result)\n        except Exception as e:\n            return f\"Failed to send: {e}\"\n</code></pre>"},{"location":"advanced/performance/","title":"Performance Tuning","text":"<p>Optimize exploration speed, memory usage, and CI integration.</p>"},{"location":"advanced/performance/#overview","title":"Overview","text":"<p>VenomQA explores state spaces that can grow exponentially. This guide covers strategies to keep exploration fast and efficient.</p>"},{"location":"advanced/performance/#key-metrics","title":"Key Metrics","text":"Metric Description Target States/sec States explored per second &gt; 10/sec Memory RAM usage during exploration &lt; 1GB Coverage Action coverage achieved &gt; 80% Time to Bug Steps until first violation &lt; 100 steps"},{"location":"advanced/performance/#exploration-strategy-selection","title":"Exploration Strategy Selection","text":"<p>Different strategies have different performance characteristics:</p> Strategy Memory Speed Best For DFS Low Fast Deep exploration, PostgresAdapter BFS Medium Fast Shortest reproduction paths CoverageGuided Low Medium Maximum action coverage Random Low Fast Quick fuzzing MCTS Medium Medium Bug-focused exploration Weighted Low Fast Prioritized actions <p>PostgreSQL + BFS incompatibility</p> <p>PostgreSQL SAVEPOINTs are stack-based. Use DFS strategy with PostgresAdapter to avoid \"savepoint does not exist\" errors.</p> Python<pre><code>from venomqa import Agent, DFS\n\nagent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n    strategy=DFS(),  # Use DFS with PostgreSQL\n    max_steps=500,\n)\n</code></pre>"},{"location":"advanced/performance/#controlling-exploration-depth","title":"Controlling Exploration Depth","text":""},{"location":"advanced/performance/#step-limits","title":"Step Limits","text":"Python<pre><code>agent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n    max_steps=100,  # Stop after 100 actions\n)\n</code></pre>"},{"location":"advanced/performance/#coverage-targets","title":"Coverage Targets","text":"<p>Stop when action coverage reaches a threshold:</p> Python<pre><code>agent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n    coverage_target=0.8,  # Stop at 80% action coverage\n)\n</code></pre>"},{"location":"advanced/performance/#action-preconditions","title":"Action Preconditions","text":"<p>Limit actions to valid states:</p> Python<pre><code>from venomqa import Action\n\nrefund_order = Action(\n    name=\"refund_order\",\n    execute=refund_fn,\n    preconditions=[\"create_order\"],  # Only valid after create_order\n    max_calls=2,  # Call at most twice per state\n)\n</code></pre>"},{"location":"advanced/performance/#state-pruning","title":"State Pruning","text":""},{"location":"advanced/performance/#deduplication-with-context","title":"Deduplication with Context","text":"<p>Tell VenomQA what defines a \"unique\" state:</p> Python<pre><code>world = World(\n    api=api,\n    state_from_context=[\"user_id\", \"order_id\", \"order_status\"],\n)\n</code></pre> <p>Without this, VenomQA may explore identical logical states multiple times.</p>"},{"location":"advanced/performance/#observation-filtering","title":"Observation Filtering","text":"<p>Customize what goes into state observations:</p> Python<pre><code>from venomqa.adapters.postgres import PostgresAdapter\n\ndb = PostgresAdapter(\n    \"postgresql://localhost/test\",\n    observe_tables=[\"orders\", \"users\"],  # Only track these\n)\n\n# Add custom observation for key state\ndb.add_observation_query(\n    \"max_order_id\",\n    \"SELECT COALESCE(MAX(id), 0) FROM orders\",\n)\n</code></pre>"},{"location":"advanced/performance/#loop-detection","title":"Loop Detection","text":"<p>VenomQA automatically detects actions that don't change state:</p> Text Only<pre><code>Loop detected: 'check_status' from state abc123 has been called 3 times\nwithout changing state. This action likely needs a precondition guard.\n</code></pre> <p>Fix with preconditions:</p> Python<pre><code>check_status = Action(\n    name=\"check_status\",\n    execute=check_fn,\n    preconditions=[\"create_order\"],  # Only valid when order exists\n)\n</code></pre>"},{"location":"advanced/performance/#memory-optimization","title":"Memory Optimization","text":""},{"location":"advanced/performance/#reduce-state-storage","title":"Reduce State Storage","text":"Python<pre><code># Bad: Storing full response in context\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order\", resp.json())  # Full object\n    return resp\n\n# Good: Only store what's needed\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])  # Just the ID\n    return resp\n</code></pre>"},{"location":"advanced/performance/#clear-unused-context","title":"Clear Unused Context","text":"Python<pre><code>def cleanup_order(api, context):\n    order_id = context.get(\"order_id\")\n    api.delete(f\"/orders/{order_id}\")\n    context.delete(\"order_id\")  # Free memory\n</code></pre>"},{"location":"advanced/performance/#database-connection-pooling","title":"Database Connection Pooling","text":"Python<pre><code>from psycopg_pool import ConnectionPool\n\npool = ConnectionPool(\"postgresql://localhost/test\", min_size=2, max_size=10)\n\ndb = PostgresAdapter(pool)\n</code></pre>"},{"location":"advanced/performance/#parallel-exploration","title":"Parallel Exploration","text":"<p>Note</p> <p>Parallel exploration requires careful state isolation. Each worker needs its own database connection or transaction.</p>"},{"location":"advanced/performance/#multiple-agents","title":"Multiple Agents","text":"<p>Run independent explorations in parallel:</p> Python<pre><code>import concurrent.futures\nfrom venomqa import Agent, Random\n\ndef run_exploration(seed: int) -&gt; ExplorationResult:\n    strategy = Random(seed=seed)\n    agent = Agent(\n        world=World(api=api, systems={\"db\": PostgresAdapter(db_url)}),\n        actions=actions,\n        invariants=invariants,\n        strategy=strategy,\n        max_steps=100,\n    )\n    return agent.explore()\n\nwith concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:\n    results = list(executor.map(run_exploration, range(4)))\n\n# Aggregate violations\nall_violations = [v for r in results for v in r.violations]\n</code></pre>"},{"location":"advanced/performance/#sharded-state-space","title":"Sharded State Space","text":"<p>Divide actions across workers:</p> Python<pre><code>def explore_actions(action_subset: list[Action]) -&gt; ExplorationResult:\n    agent = Agent(\n        world=World(api=api, systems={\"db\": PostgresAdapter(db_url)}),\n        actions=action_subset,\n        invariants=invariants,\n        strategy=BFS(),\n        max_steps=200,\n    )\n    return agent.explore()\n\n# Split actions into chunks\nchunks = [actions[i::4] for i in range(4)]\n\nwith concurrent.futures.ProcessPoolExecutor(max_workers=4) as executor:\n    results = list(executor.map(explore_actions, chunks))\n</code></pre>"},{"location":"advanced/performance/#cicd-optimization","title":"CI/CD Optimization","text":""},{"location":"advanced/performance/#fast-fail","title":"Fast Fail","text":"<p>Stop on first critical violation:</p> Python<pre><code>class FailFastAgent:\n    \"\"\"Wrapper that exits on CRITICAL violations.\"\"\"\n\n    def __init__(self, agent: Agent):\n        self.agent = agent\n\n    def explore(self) -&gt; ExplorationResult:\n        result = self.agent.explore()\n        if result.critical_violations:\n            # Exit immediately with non-zero code\n            import sys\n            print(f\"CRITICAL: {len(result.critical_violations)} violations found\")\n            sys.exit(1)\n        return result\n</code></pre>"},{"location":"advanced/performance/#time-limits","title":"Time Limits","text":"Python<pre><code>import signal\n\nclass TimeoutError(Exception):\n    pass\n\ndef timeout_handler(signum, frame):\n    raise TimeoutError(\"Exploration timed out\")\n\nsignal.signal(signal.SIGALRM, timeout_handler)\nsignal.alarm(300)  # 5 minutes\n\ntry:\n    result = agent.explore()\nfinally:\n    signal.alarm(0)\n</code></pre>"},{"location":"advanced/performance/#incremental-exploration","title":"Incremental Exploration","text":"Python<pre><code>import hashlib\n\ndef get_state_fingerprint(actions: list[Action]) -&gt; str:\n    \"\"\"Generate fingerprint for action definitions.\"\"\"\n    content = \"\".join(f\"{a.name}:{a.preconditions}\" for a in actions)\n    return hashlib.md5(content.encode()).hexdigest()[:8]\n\ndef run_incremental(agent: Agent, cache_dir: str = \".venomqa_cache\"):\n    \"\"\"Skip exploration if actions haven't changed.\"\"\"\n    import os\n    import json\n\n    fingerprint = get_state_fingerprint(agent.graph.actions)\n    cache_file = f\"{cache_dir}/{fingerprint}.json\"\n\n    if os.path.exists(cache_file):\n        print(\"Skipping: actions unchanged\")\n        return json.load(open(cache_file))\n\n    result = agent.explore()\n\n    os.makedirs(cache_dir, exist_ok=True)\n    json.dump({\"violations\": len(result.violations)}, open(cache_file, \"w\"))\n\n    return result\n</code></pre>"},{"location":"advanced/performance/#matrix-configuration","title":"Matrix Configuration","text":"YAML<pre><code># .github/workflows/venomqa.yml\njobs:\n  explore:\n    strategy:\n      matrix:\n        strategy: [dfs, bfs, coverage]\n        max_steps: [100, 500, 1000]\n        exclude:\n          - strategy: bfs\n            max_steps: 1000  # Too slow\n    runs-on: ubuntu-latest\n    steps:\n      - run: venomqa explore --strategy ${{ matrix.strategy }} --max-steps ${{ matrix.max_steps }}\n</code></pre>"},{"location":"advanced/performance/#benchmarks","title":"Benchmarks","text":""},{"location":"advanced/performance/#test-environment","title":"Test Environment","text":"<ul> <li>Python 3.11</li> <li>PostgreSQL 15</li> <li>8 CPU cores, 16GB RAM</li> <li>Local network</li> </ul>"},{"location":"advanced/performance/#simple-api-5-actions","title":"Simple API (5 actions)","text":"Strategy Steps States Time Memory DFS 50 12 0.8s 45MB BFS 50 12 0.9s 48MB CoverageGuided 50 14 1.1s 42MB Random 50 18 0.7s 40MB"},{"location":"advanced/performance/#medium-api-15-actions","title":"Medium API (15 actions)","text":"Strategy Steps States Time Memory DFS 200 45 4.2s 120MB BFS 200 43 4.8s 180MB CoverageGuided 200 52 5.1s 95MB Random 200 67 3.9s 88MB"},{"location":"advanced/performance/#complex-api-30-actions","title":"Complex API (30 actions)","text":"Strategy Steps States Time Memory DFS 500 89 18s 340MB BFS 500 85 24s 520MB CoverageGuided 500 112 22s 280MB Random 500 156 15s 210MB"},{"location":"advanced/performance/#postgresql-vs-sqlite","title":"PostgreSQL vs SQLite","text":"Database 100 Steps 500 Steps Notes PostgreSQL 2.1s 12s Requires DFS strategy SQLite 4.8s 38s File copy overhead In-Memory 0.3s 1.8s No rollback guarantee"},{"location":"advanced/performance/#performance-checklist","title":"Performance Checklist","text":"<ul> <li> Use appropriate strategy (DFS for PostgreSQL)</li> <li> Set <code>max_steps</code> or <code>coverage_target</code></li> <li> Add <code>state_from_context</code> for deduplication</li> <li> Use action <code>preconditions</code> to prune invalid paths</li> <li> Store minimal data in context</li> <li> Consider parallel exploration for large state spaces</li> <li> Profile with <code>progress_every=N</code> to monitor progress</li> </ul>"},{"location":"advanced/performance/#profiling","title":"Profiling","text":"<p>Enable progress output:</p> Python<pre><code>agent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n    max_steps=500,\n    progress_every=50,  # Print every 50 steps\n)\n\nresult = agent.explore()\n</code></pre> <p>Output:</p> Text Only<pre><code>  step 50/500 | states 12 | coverage 60% | violations 0\n  step 100/500 | states 23 | coverage 80% | violations 1\n  step 150/500 | states 31 | coverage 93% | violations 1\n</code></pre>"},{"location":"advanced/performance/#troubleshooting-slow-exploration","title":"Troubleshooting Slow Exploration","text":""},{"location":"advanced/performance/#symptoms-and-fixes","title":"Symptoms and Fixes","text":"Symptom Likely Cause Fix Exploration never finishes Infinite loop Add preconditions Memory grows unbounded State explosion Add <code>state_from_context</code> Steps execute but no new states Poor state hashing Improve observations DB operations slow Missing indexes Index observed tables API timeouts Slow endpoints Mock external services"},{"location":"advanced/testing-patterns/","title":"Testing Patterns","text":"<p>Common patterns for testing CRUD operations, auth flows, payment systems, and multi-tenant applications.</p>"},{"location":"advanced/testing-patterns/#overview","title":"Overview","text":"<p>This guide covers battle-tested patterns for testing different types of APIs with VenomQA.</p>"},{"location":"advanced/testing-patterns/#crud-testing","title":"CRUD Testing","text":"<p>The most common pattern: testing Create, Read, Update, Delete operations.</p>"},{"location":"advanced/testing-patterns/#basic-crud","title":"Basic CRUD","text":"Python<pre><code>from venomqa import Action, Agent, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"item_id\"])\n\n# Create\ndef create_item(api, context):\n    resp = api.post(\"/items\", json={\"name\": \"test\", \"value\": 100})\n    context.set(\"item_id\", resp.json()[\"id\"])\n    context.set(\"item_name\", \"test\")\n    return resp\n\n# Read\ndef get_item(api, context):\n    item_id = context.get(\"item_id\")\n    if not item_id:\n        return None  # Skip: no item exists\n    return api.get(f\"/items/{item_id}\")\n\n# Update\ndef update_item(api, context):\n    item_id = context.get(\"item_id\")\n    if not item_id:\n        return None\n    return api.patch(f\"/items/{item_id}\", json={\"value\": 200})\n\n# Delete\ndef delete_item(api, context):\n    item_id = context.get(\"item_id\")\n    if not item_id:\n        return None\n    resp = api.delete(f\"/items/{item_id}\")\n    if resp.ok:\n        context.delete(\"item_id\")\n    return resp\n\n# List\ndef list_items(api, context):\n    return api.get(\"/items\")\n\nactions = [\n    Action(name=\"create_item\", execute=create_item),\n    Action(name=\"get_item\", execute=get_item, preconditions=[\"create_item\"]),\n    Action(name=\"update_item\", execute=update_item, preconditions=[\"create_item\"]),\n    Action(name=\"delete_item\", execute=delete_item, preconditions=[\"create_item\"]),\n    Action(name=\"list_items\", execute=list_items),\n]\n\n# Invariants\ndef item_consistency(world):\n    \"\"\"GET should return same data as created.\"\"\"\n    item_id = world.context.get(\"item_id\")\n    if not item_id:\n        return True\n    resp = world.api.get(f\"/items/{item_id}\")\n    if not resp.ok:\n        return True  # Item deleted, OK\n    return resp.json()[\"name\"] == world.context.get(\"item_name\")\n\ndef no_500_errors(world):\n    \"\"\"No server errors allowed.\"\"\"\n    return world.context.get(\"last_status\", 200) &lt; 500\n\ninvariants = [\n    Invariant(\"item_consistency\", item_consistency, Severity.HIGH),\n    Invariant(\"no_500_errors\", no_500_errors, Severity.CRITICAL),\n]\n\nagent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n    max_steps=100,\n)\nresult = agent.explore()\n</code></pre>"},{"location":"advanced/testing-patterns/#crud-with-pagination","title":"CRUD with Pagination","text":"Python<pre><code>def list_items_paginated(api, context):\n    page = context.get(\"page\", 1)\n    resp = api.get(\"/items\", params={\"page\": page, \"limit\": 10})\n    context.set(\"page\", page + 1)\n    return resp\n\ndef next_page(api, context):\n    page = context.get(\"page\", 1)\n    return api.get(\"/items\", params={\"page\": page, \"limit\": 10})\n</code></pre>"},{"location":"advanced/testing-patterns/#auth-flow-testing","title":"Auth Flow Testing","text":""},{"location":"advanced/testing-patterns/#loginlogout-pattern","title":"Login/Logout Pattern","text":"Python<pre><code>world = World(\n    api=api,\n    state_from_context=[\"user_id\", \"logged_in\"],\n)\n\ndef register(api, context):\n    email = f\"test_{uuid.uuid4().hex[:8]}@example.com\"\n    resp = api.post(\"/auth/register\", json={\n        \"email\": email,\n        \"password\": \"password123\",\n    })\n    if resp.ok:\n        context.set(\"user_email\", email)\n    return resp\n\ndef login(api, context):\n    email = context.get(\"user_email\")\n    if not email:\n        return None\n    resp = api.post(\"/auth/login\", json={\n        \"email\": email,\n        \"password\": \"password123\",\n    })\n    if resp.ok:\n        token = resp.json()[\"token\"]\n        context.set(\"auth_token\", token)\n        context.set(\"logged_in\", True)\n        api.set_header(\"Authorization\", f\"Bearer {token}\")\n    return resp\n\ndef logout(api, context):\n    if not context.get(\"logged_in\"):\n        return None\n    resp = api.post(\"/auth/logout\")\n    if resp.ok:\n        context.delete(\"auth_token\")\n        context.set(\"logged_in\", False)\n        api.remove_header(\"Authorization\")\n    return resp\n\ndef get_profile(api, context):\n    if not context.get(\"logged_in\"):\n        return None\n    return api.get(\"/auth/profile\")\n\ndef delete_account(api, context):\n    if not context.get(\"logged_in\"):\n        return None\n    resp = api.delete(\"/auth/account\")\n    if resp.ok:\n        context.delete(\"user_email\")\n        context.delete(\"auth_token\")\n        context.set(\"logged_in\", False)\n    return resp\n\nactions = [\n    Action(name=\"register\", execute=register),\n    Action(name=\"login\", execute=login, preconditions=[\"register\"]),\n    Action(name=\"logout\", execute=logout, preconditions=[\"login\"]),\n    Action(name=\"get_profile\", execute=get_profile, preconditions=[\"login\"]),\n    Action(name=\"delete_account\", execute=delete_account, preconditions=[\"login\"]),\n]\n\n# Invariant: can't access protected routes after logout\ndef auth_enforcement(world):\n    if not world.context.get(\"logged_in\"):\n        return True  # Not logged in, nothing to check\n\n    # Try accessing protected route\n    resp = world.api.get(\"/auth/profile\")\n    if resp.status_code == 401:\n        # Good: properly rejected\n        return True\n    return resp.ok  # Should succeed if logged in\n\ninvariants = [\n    Invariant(\"auth_enforcement\", auth_enforcement, Severity.CRITICAL),\n]\n</code></pre>"},{"location":"advanced/testing-patterns/#token-refresh-pattern","title":"Token Refresh Pattern","text":"Python<pre><code>def refresh_token(api, context):\n    token = context.get(\"auth_token\")\n    if not token:\n        return None\n    resp = api.post(\"/auth/refresh\")\n    if resp.ok:\n        context.set(\"auth_token\", resp.json()[\"token\"])\n    return resp\n\ndef use_expired_token(api, context):\n    \"\"\"Test that expired tokens are rejected.\"\"\"\n    old_token = context.get(\"auth_token\")\n    if not old_token:\n        return None\n\n    # Simulate expired token\n    api.set_header(\"Authorization\", \"Bearer expired_token_xyz\")\n    resp = api.get(\"/auth/profile\")\n    api.set_header(\"Authorization\", f\"Bearer {old_token}\")\n\n    return resp\n\n# Invariant: expired tokens should return 401\ndef expired_token_rejected(world):\n    last_status = world.context.get(\"last_status\", 200)\n    if world.context.get(\"testing_expired\"):\n        return last_status == 401\n    return True\n</code></pre>"},{"location":"advanced/testing-patterns/#payment-flow-testing","title":"Payment Flow Testing","text":""},{"location":"advanced/testing-patterns/#order-payment-refund","title":"Order \u2192 Payment \u2192 Refund","text":"Python<pre><code>world = World(\n    api=api,\n    state_from_context=[\"order_id\", \"payment_id\", \"order_status\"],\n)\n\n# Order creation\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\n        \"amount\": 10000,  # $100.00 in cents\n        \"currency\": \"USD\",\n    })\n    if resp.ok:\n        context.set(\"order_id\", resp.json()[\"id\"])\n        context.set(\"order_amount\", 10000)\n        context.set(\"order_status\", \"pending\")\n    return resp\n\n# Payment\ndef pay_order(api, context):\n    order_id = context.get(\"order_id\")\n    if not order_id or context.get(\"order_status\") != \"pending\":\n        return None\n\n    resp = api.post(f\"/orders/{order_id}/pay\", json={\n        \"payment_method\": \"card\",\n        \"card_token\": \"test_token\",\n    })\n    if resp.ok:\n        context.set(\"payment_id\", resp.json()[\"payment_id\"])\n        context.set(\"order_status\", \"paid\")\n        context.set(\"amount_paid\", resp.json().get(\"amount\", 10000))\n    return resp\n\n# Refund\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    payment_id = context.get(\"payment_id\")\n    if not order_id or not payment_id:\n        return None\n\n    amount = context.get(\"refund_amount\", 10000)\n    resp = api.post(f\"/orders/{order_id}/refund\", json={\n        \"payment_id\": payment_id,\n        \"amount\": amount,\n    })\n    if resp.ok:\n        refunded = context.get(\"total_refunded\", 0) + amount\n        context.set(\"total_refunded\", refunded)\n    return resp\n\n# Partial refund\ndef partial_refund(api, context):\n    context.set(\"refund_amount\", 5000)  # $50.00\n    return refund_order(api, context)\n\n# Full refund\ndef full_refund(api, context):\n    context.set(\"refund_amount\", 10000)  # $100.00\n    return refund_order(api, context)\n\n# Cancel\ndef cancel_order(api, context):\n    order_id = context.get(\"order_id\")\n    if not order_id:\n        return None\n\n    resp = api.post(f\"/orders/{order_id}/cancel\")\n    if resp.ok:\n        context.set(\"order_status\", \"canceled\")\n    return resp\n\nactions = [\n    Action(name=\"create_order\", execute=create_order),\n    Action(name=\"pay_order\", execute=pay_order, preconditions=[\"create_order\"]),\n    Action(name=\"partial_refund\", execute=partial_refund, preconditions=[\"pay_order\"]),\n    Action(name=\"full_refund\", execute=full_refund, preconditions=[\"pay_order\"]),\n    Action(name=\"cancel_order\", execute=cancel_order, preconditions=[\"create_order\"]),\n]\n\n# Invariants\ndef no_over_refund(world):\n    \"\"\"Total refunded should not exceed order amount.\"\"\"\n    total_refunded = world.context.get(\"total_refunded\", 0)\n    order_amount = world.context.get(\"order_amount\", 0)\n    return total_refunded &lt;= order_amount\n\ndef no_refund_unpaid(world):\n    \"\"\"Can't refund an unpaid order.\"\"\"\n    order_status = world.context.get(\"order_status\")\n    if order_status == \"pending\":\n        last_status = world.context.get(\"last_status\", 200)\n        # Refund attempt should fail with 400 or 403\n        return last_status &gt;= 400\n    return True\n\ndef cancel_prevents_refund(world):\n    \"\"\"Can't refund a canceled order.\"\"\"\n    order_status = world.context.get(\"order_status\")\n    if order_status == \"canceled\":\n        last_status = world.context.get(\"last_status\", 200)\n        # Any refund attempt should fail\n        if world.context.get(\"refund_attempted\"):\n            return last_status &gt;= 400\n    return True\n\ninvariants = [\n    Invariant(\"no_over_refund\", no_over_refund, Severity.CRITICAL),\n    Invariant(\"no_refund_unpaid\", no_refund_unpaid, Severity.HIGH),\n    Invariant(\"cancel_prevents_refund\", cancel_prevents_refund, Severity.HIGH),\n]\n</code></pre>"},{"location":"advanced/testing-patterns/#multi-tenant-testing","title":"Multi-Tenant Testing","text":""},{"location":"advanced/testing-patterns/#tenant-isolation","title":"Tenant Isolation","text":"Python<pre><code>world = World(\n    api=api,\n    state_from_context=[\"tenant_a_id\", \"tenant_b_id\", \"resource_id\"],\n)\n\n# Setup tenants\ndef setup_tenant_a(api, context):\n    resp = api.post(\"/tenants\", json={\"name\": \"Tenant A\"})\n    if resp.ok:\n        context.set(\"tenant_a_id\", resp.json()[\"id\"])\n        context.set(\"tenant_a_token\", resp.json()[\"api_key\"])\n    return resp\n\ndef setup_tenant_b(api, context):\n    resp = api.post(\"/tenants\", json={\"name\": \"Tenant B\"})\n    if resp.ok:\n        context.set(\"tenant_b_id\", resp.json()[\"id\"])\n        context.set(\"tenant_b_token\", resp.json()[\"api_key\"])\n    return resp\n\ndef create_resource_as_a(api, context):\n    token = context.get(\"tenant_a_token\")\n    if not token:\n        return None\n\n    resp = api.post(\n        \"/resources\",\n        json={\"name\": \"A's resource\"},\n        headers={\"X-API-Key\": token},\n    )\n    if resp.ok:\n        context.set(\"resource_id\", resp.json()[\"id\"])\n        context.set(\"resource_owner\", \"A\")\n    return resp\n\ndef try_access_as_b(api, context):\n    \"\"\"Tenant B tries to access Tenant A's resource.\"\"\"\n    resource_id = context.get(\"resource_id\")\n    token_b = context.get(\"tenant_b_token\")\n\n    if not resource_id or not token_b:\n        return None\n\n    context.set(\"cross_tenant_attempt\", True)\n    resp = api.get(\n        f\"/resources/{resource_id}\",\n        headers={\"X-API-Key\": token_b},\n    )\n    context.set(\"cross_tenant_status\", resp.status_code)\n    return resp\n\nactions = [\n    Action(name=\"setup_tenant_a\", execute=setup_tenant_a),\n    Action(name=\"setup_tenant_b\", execute=setup_tenant_b, preconditions=[\"setup_tenant_a\"]),\n    Action(name=\"create_resource_as_a\", execute=create_resource_as_a, preconditions=[\"setup_tenant_a\"]),\n    Action(name=\"try_access_as_b\", execute=try_access_as_b, preconditions=[\"create_resource_as_a\", \"setup_tenant_b\"]),\n]\n\n# Invariant: tenants can't access each other's resources\ndef tenant_isolation(world):\n    if world.context.get(\"cross_tenant_attempt\"):\n        status = world.context.get(\"cross_tenant_status\", 200)\n        # Should be 403 or 404\n        return status in [403, 404]\n    return True\n\ninvariants = [\n    Invariant(\"tenant_isolation\", tenant_isolation, Severity.CRITICAL),\n]\n</code></pre>"},{"location":"advanced/testing-patterns/#state-machine-testing","title":"State Machine Testing","text":""},{"location":"advanced/testing-patterns/#order-state-machine","title":"Order State Machine","text":"Text Only<pre><code>pending \u2192 paid \u2192 fulfilled\n    \u2193        \u2193\ncanceled  refunded\n</code></pre> Python<pre><code>world = World(api=api, state_from_context=[\"order_id\", \"status\"])\n\n# Define valid transitions\nVALID_TRANSITIONS = {\n    None: [\"create\"],\n    \"pending\": [\"pay\", \"cancel\"],\n    \"paid\": [\"fulfill\", \"refund\"],\n    \"fulfilled\": [],  # Terminal\n    \"canceled\": [],   # Terminal\n    \"refunded\": [],   # Terminal\n}\n\ndef create_order(api, context):\n    if context.get(\"order_id\"):\n        return None  # Already have an order\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    if resp.ok:\n        context.set(\"order_id\", resp.json()[\"id\"])\n        context.set(\"status\", \"pending\")\n    return resp\n\ndef pay_order(api, context):\n    if context.get(\"status\") != \"pending\":\n        return None\n    resp = api.post(f\"/orders/{context.get('order_id')}/pay\")\n    if resp.ok:\n        context.set(\"status\", \"paid\")\n    return resp\n\ndef fulfill_order(api, context):\n    if context.get(\"status\") != \"paid\":\n        return None\n    resp = api.post(f\"/orders/{context.get('order_id')}/fulfill\")\n    if resp.ok:\n        context.set(\"status\", \"fulfilled\")\n    return resp\n\ndef refund_order(api, context):\n    if context.get(\"status\") != \"paid\":\n        return None\n    resp = api.post(f\"/orders/{context.get('order_id')}/refund\")\n    if resp.ok:\n        context.set(\"status\", \"refunded\")\n    return resp\n\ndef cancel_order(api, context):\n    if context.get(\"status\") != \"pending\":\n        return None\n    resp = api.post(f\"/orders/{context.get('order_id')}/cancel\")\n    if resp.ok:\n        context.set(\"status\", \"canceled\")\n    return resp\n\n# Invariant: only valid transitions allowed\ndef state_transition_validity(world):\n    \"\"\"All transitions must follow the state machine.\"\"\"\n    last_status = world.context.get(\"last_status\", 200)\n    if last_status &gt;= 400:\n        # Request failed - acceptable if it was an invalid transition\n        return True\n\n    # If request succeeded, transition was valid\n    return True\n\ninvariants = [\n    Invariant(\"state_transition_validity\", state_transition_validity, Severity.HIGH),\n]\n</code></pre>"},{"location":"advanced/testing-patterns/#rate-limiting","title":"Rate Limiting","text":"Python<pre><code>import time\n\nclass RateLimitedAction:\n    \"\"\"Action wrapper that respects rate limits.\"\"\"\n\n    def __init__(self, action, min_interval_ms: int = 100):\n        self.action = action\n        self.min_interval_ms = min_interval_ms\n        self.last_call = 0\n\n    def __call__(self, api, context):\n        now = time.time() * 1000\n        elapsed = now - self.last_call\n        if elapsed &lt; self.min_interval_ms:\n            time.sleep((self.min_interval_ms - elapsed) / 1000)\n\n        self.last_call = time.time() * 1000\n        return self.action(api, context)\n\n# Wrap actions\nactions = [\n    Action(\"create\", RateLimitedAction(create_fn, min_interval_ms=200)),\n    Action(\"update\", RateLimitedAction(update_fn, min_interval_ms=200)),\n]\n</code></pre>"},{"location":"advanced/testing-patterns/#best-practices-summary","title":"Best Practices Summary","text":"Pattern Key Insight CRUD Use preconditions for Read/Update/Delete Auth Track <code>logged_in</code> state in context Payment Track cumulative values (total_refunded) Multi-tenant Test cross-tenant access explicitly State machine Define valid transitions upfront Rate limiting Wrap actions or use sleep"},{"location":"advanced/testing-patterns/#common-invariants","title":"Common Invariants","text":"Python<pre><code># No server errors\nInvariant(\"no_500s\", lambda w: w.context.get(\"last_status\", 200) &lt; 500, Severity.CRITICAL)\n\n# Idempotency\nInvariant(\"create_idempotent\", lambda w: count_items() &lt;= expected, Severity.HIGH)\n\n# Data consistency\nInvariant(\"api_db_sync\", lambda w: api_count() == db_count(), Severity.HIGH)\n\n# Business rules\nInvariant(\"positive_balance\", lambda w: get_balance() &gt;= 0, Severity.CRITICAL)\n\n# Security\nInvariant(\"no_unauthorized_access\", lambda w: not (was_unauthorized and succeeded), Severity.CRITICAL)\n</code></pre>"},{"location":"blog/","title":"Blog","text":"<p>Articles on API testing, state machines, and quality engineering.</p>"},{"location":"blog/#latest-posts","title":"Latest Posts","text":"<ul> <li> <p> Math of State Exploration</p> <p>Understanding the combinatorics behind API state exploration with ASCII diagrams.</p> <p> Read</p> </li> <li> <p> Why Sequence Bugs Hide</p> <p>The bugs that pass every unit test but still reach production.</p> <p> Read</p> </li> <li> <p> State Machines in API Testing</p> <p>Modeling your API as a finite automaton for systematic testing.</p> <p> Read</p> </li> <li> <p> Property-Based Testing Comparison</p> <p>When to use Hypothesis vs VenomQA vs both together.</p> <p> Read</p> </li> <li> <p> API Testing Tools Compared</p> <p>Comprehensive comparison of VenomQA, Schemathesis, Postman, pytest, and more.</p> <p> Read</p> </li> <li> <p> Database Rollback Testing</p> <p>Deep dive on PostgreSQL SAVEPOINT mechanics for parallel exploration.</p> <p> Read</p> </li> <li> <p> CI/CD API Testing</p> <p>Complete guide to automated API testing in GitHub Actions, GitLab CI, Jenkins.</p> <p> Read</p> </li> </ul>"},{"location":"blog/#categories","title":"Categories","text":"Category Description Theory Mathematical foundations and algorithms Tutorials Step-by-step guides and examples Comparisons Tool comparisons and when to use what Best Practices Production-ready patterns"},{"location":"blog/#subscribe","title":"Subscribe","text":"<p>Stay updated on new posts and releases:</p> <ul> <li>GitHub: Watch releases</li> <li>PyPI: Subscribe to updates</li> </ul>"},{"location":"blog/2024-01-15-math-of-state-exploration/","title":"The Mathematics of Graph Exploration in API Testing","text":"<p>When you write a unit test, you're testing one endpoint in isolation. But real bugs often hide in sequences\u2014<code>create \u2192 refund \u2192 refund</code> might crash your payment system, even though each operation works individually. </p> <p>This is why VenomQA treats your API as a state graph and explores it systematically. Let's dive into the mathematics that makes this work.</p>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#1-state-graphs-as-mathematical-objects","title":"1. State Graphs as Mathematical Objects","text":"","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#formal-definition","title":"Formal Definition","text":"<p>An API's behavior can be modeled as a directed labeled graph:</p> \\[G = (V, E, \\Sigma, \\ell)\\] <p>Where:</p> <ul> <li>\\(V\\) = Set of all reachable application states</li> <li>\\(E \\subseteq V \\times V\\) = Set of state transitions</li> <li>\\(\\Sigma\\) = Set of action labels (API operations)</li> <li>\\(\\ell: E \\to \\Sigma\\) = Labeling function mapping edges to actions</li> </ul>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#example-e-commerce-api-state-graph","title":"Example: E-commerce API State Graph","text":"Text Only<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502         State Space V               \u2502\n                    \u2502                                     \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u2502\n    \u2502  START   \u2502\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u25b6\u2502  Empty  \u2502                       \u2502\n    \u2502  (v\u2080)    \u2502    \u2502   \u2502  Cart   \u2502                       \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518                       \u2502\n                    \u2502        \u2502                            \u2502\n                    \u2502        \u2502 addItem                    \u2502\n                    \u2502        \u25bc                            \u2502\n                    \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    checkout            \u2502\n                    \u2502   \u2502  Cart   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n                    \u2502   \u2502 w/ Item \u2502                 \u2502      \u2502\n                    \u2502   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518                 \u2502      \u2502\n                    \u2502        \u2502                      \u25bc      \u2502\n                    \u2502        \u2502 addItem         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n                    \u2502        \u25bc                 \u2502  Order  \u2502 \u2502\n                    \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502 Created \u2502 \u2502\n                    \u2502   \u2502  Cart   \u2502            \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2502\n                    \u2502   \u2502 2 Items \u2502                 \u2502      \u2502\n                    \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            refund\u2502      \u2502\n                    \u2502                          \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\u2502\n                    \u2502                          \u2502  Order   \u2502\u2502\n                    \u2502                          \u2502 Refunded \u2502\u2502\n                    \u2502                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Vertices V = {v\u2080, Empty, Cart\u2081, Cart\u2082, OrderCreated, OrderRefunded}\n    Edges E = {(v\u2080,Empty), (Empty,Cart\u2081), (Cart\u2081,Cart\u2082), ...}\n    Labels \u03a3 = {addItem, checkout, refund}\n</code></pre>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#state-encoding","title":"State Encoding","text":"<p>Each state \\(v \\in V\\) encodes:</p> Python<pre><code>state = {\n    \"cart_items\": int,      # 0, 1, 2, ...\n    \"order_id\": str | None, # null or \"ord_abc123\"\n    \"order_status\": str,    # \"none\", \"created\", \"refunded\"\n    \"user_balance\": float,  # monetary state\n}\n</code></pre> <p>The cardinality of V grows combinatorially with the number of tracked variables. If we track 5 integer fields each ranging 0-100, we have \\(|V| \\leq 101^5 \\approx 10^{10}\\) potential states.</p>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#2-combinatorial-explosion-the-fundamental-challenge","title":"2. Combinatorial Explosion: The Fundamental Challenge","text":"","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#path-counting","title":"Path Counting","text":"<p>Given \\(n\\) available actions and maximum depth \\(d\\), the number of possible execution paths is:</p> \\[|\\text{Paths}| = \\sum_{k=0}^{d} n^k = \\frac{n^{d+1} - 1}{n - 1} \\approx n^d \\quad \\text{(for large d)}\\]","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#visualizing-exponential-growth","title":"Visualizing Exponential Growth","text":"Text Only<pre><code>Depth d=1:              Depth d=2:              Depth d=3:\n\n     A                     A                       A\n    \u2571 \u2572                   \u2571 \u2572                     \u2571 \u2572\n   B   C                 B   C                   B   C\n                        \u2571\u2572 \u2571\u2572                   \u2571\u2572 \u2571\u2572\n                       D E F G                 D E F G\n                                               \u2571\u2572\u2571\u2572\u2571\u2572\u2571\u2572\n                                              H I J K L M\n\nn=3 actions:\n  d=1: 1 + 3 = 4 paths\n  d=2: 1 + 3 + 9 = 13 paths\n  d=3: 1 + 3 + 9 + 27 = 40 paths\n  d=10: 88,573 paths\n  d=20: 1,744,394,723 paths (1.7 billion!)\n</code></pre>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#real-numbers-payment-api-example","title":"Real Numbers: Payment API Example","text":"Actions (n) Depth (d) Total Paths Time @ 100ms/path Time @ 10ms/path 5 5 3,906 6.5 minutes 39 seconds 5 10 12,207,031 14 days 34 hours 5 15 38,146,972,656 121 years 12 years 10 10 11,111,111,111 35 years 3.5 years 20 10 10,000,000,000,000 31,700 years 3,170 years <p>Conclusion: Naive exhaustive exploration is computationally infeasible for real APIs. We need smarter strategies.</p>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#3-bfs-vs-dfs-algorithmic-trade-offs","title":"3. BFS vs DFS: Algorithmic Trade-offs","text":"","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#breadth-first-search-bfs","title":"Breadth-First Search (BFS)","text":"Text Only<pre><code>Traversal order (level-by-level):\n\n    Level 0:       A \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502                 \u2502 visited 1st\n    Level 1:      B\u2500C\u2500D              \u2502\n                 \u2199 \u2502 \u2198               \u2502 visited 2nd\n    Level 2:    E F G H I J          \u2502\n                                    \u2502 visited 3rd\n    Queue: [A] \u2192 [B,C,D] \u2192 [E,F,G,H,I,J] \u2192 ...\n</code></pre> <p>Implementation:</p> Python<pre><code>from collections import deque\n\ndef bfs_explore(start_state, actions, max_depth):\n    queue = deque([(start_state, [])])  # (state, path)\n    visited = {hash_state(start_state)}\n\n    while queue:\n        state, path = queue.popleft()\n\n        if len(path) &gt;= max_depth:\n            continue\n\n        for action in actions:\n            if action.precondition(state):\n                new_state = action.execute(state)\n\n                if hash_state(new_state) not in visited:\n                    visited.add(hash_state(new_state))\n                    queue.append((new_state, path + [action]))\n\n    return visited\n</code></pre> <p>Properties:</p> <ul> <li>Time Complexity: \\(O(|V| + |E|)\\)</li> <li>Space Complexity: \\(O(|V|)\\) \u2014 stores entire frontier</li> <li>Guarantee: Finds shortest path to each state</li> <li>Best for: Finding shallowest bugs, coverage guarantees</li> </ul>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#depth-first-search-dfs","title":"Depth-First Search (DFS)","text":"Text Only<pre><code>Traversal order (deep-first):\n\n    A \u2500\u2500\u25b6 B \u2500\u2500\u25b6 E \u2500\u2500\u25b6 (backtrack)\n          \u2502\n          \u2514\u2500\u2500\u25b6 F \u2500\u2500\u25b6 (backtrack)\n          \u2502\n          \u2514\u2500\u2500\u25b6 G \u2500\u2500\u25b6 (backtrack)\n\n    C \u2500\u2500\u25b6 H \u2500\u2500\u25b6 ...\n\n    Stack: [A] \u2192 [B,C,D] \u2192 [E,F,G,C,D] \u2192 ...\n\n    Visits deepest nodes first, then backtracks.\n</code></pre> <p>Implementation:</p> Python<pre><code>def dfs_explore(state, actions, max_depth, visited=None, path=None):\n    if visited is None:\n        visited = set()\n    if path is None:\n        path = []\n\n    state_hash = hash_state(state)\n    if state_hash in visited or len(path) &gt;= max_depth:\n        return visited\n\n    visited.add(state_hash)\n\n    for action in actions:\n        if action.precondition(state):\n            new_state = action.execute(state)\n            dfs_explore(new_state, actions, max_depth, visited, path + [action])\n\n    return visited\n</code></pre> <p>Properties:</p> <ul> <li>Time Complexity: \\(O(|V| + |E|)\\)</li> <li>Space Complexity: \\(O(d_{max})\\) \u2014 only stores current path</li> <li>Guarantee: Explores deeply before widening</li> <li>Best for: Memory-constrained environments, finding deep bugs</li> </ul>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#comparison-table","title":"Comparison Table","text":"Property BFS DFS Frontier Storage All states at current depth Single path Memory Usage High: \\(O(b^d)\\) Low: \\(O(d)\\) Shortest Path \u2713 Guaranteed \u2717 Not guaranteed Deep Bugs Found later Found earlier Implementation Iterative (queue) Recursive or iterative (stack) Parallelization Easy (independent levels) Harder (dependent paths)","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#when-to-use-each","title":"When to Use Each","text":"Python<pre><code># Use BFS when:\n# - Memory is not a constraint\n# - You want the shortest reproduction path\n# - You need systematic coverage guarantees\nagent = Agent(world, actions, strategy=BFS(), max_steps=50)\n\n# Use DFS when:\n# - Memory is limited\n# - You suspect bugs appear in long sequences\n# - Quick exploration is prioritized over completeness\nagent = Agent(world, actions, strategy=DFS(), max_steps=50)\n</code></pre>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#4-state-deduplication-reducing-the-search-space","title":"4. State Deduplication: Reducing the Search Space","text":"","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#the-key-insight","title":"The Key Insight","text":"<p>Many different action sequences lead to the same state:</p> Text Only<pre><code>Path 1: addItem(item_A) \u2192 addItem(item_B) \u2192 removeItem(item_B)\nPath 2: addItem(item_A)\n\nBoth result in: Cart = [item_A]\n</code></pre> <p>By recognizing state equivalence, we avoid redundant exploration.</p>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#hash-based-state-identification","title":"Hash-Based State Identification","text":"Python<pre><code>def hash_state(state: dict) -&gt; str:\n    \"\"\"\n    Compute canonical hash of application state.\n\n    Requirements:\n    1. Deterministic: same state \u2192 same hash\n    2. Order-independent: {a:1, b:2} == {b:2, a:1}\n    3. Fast: O(|state|) computation\n    \"\"\"\n    # Sort keys for order-independence\n    canonical = json.dumps(state, sort_keys=True, default=str)\n    return hashlib.sha256(canonical.encode()).hexdigest()[:16]\n</code></pre>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#before-and-after-deduplication","title":"Before and After Deduplication","text":"Text Only<pre><code>WITHOUT DEDUPLICATION:              WITH DEDUPLICATION:\n\n     Start                               Start\n       \u2502                                   \u2502\n       \u25bc                                   \u25bc\n    \u250c\u2500\u2500\u2534\u2500\u2500\u2510                             \u250c\u2500\u2500\u2534\u2500\u2500\u2510\n    \u2502  A  \u2502                             \u2502  A  \u2502\n    \u2514\u2500\u2500\u252c\u2500\u2500\u2518                             \u2514\u2500\u2500\u252c\u2500\u2500\u2518\n      \u2571 \u2572                                 \u2502\n     B   C                                \u2502 (C leads to same state as B)\n    \u2571\u2502   \u2502\u2572                               \u25bc\n   D E   F G                           \u250c\u2500\u2500\u2534\u2500\u2500\u2510\n   \u2502\u2502   \u2502\u2502                             \u2502  B  \u2502\n   ...  ...                            \u2514\u2500\u2500\u252c\u2500\u2500\u2518\n                                        \u2571 \u2572\n    15 unique paths                      D   E\n    15 state visits                      \u2502   \u2502\n                                         ... ...\n\n                                      7 unique states\n                                      7 state visits\n\n    Savings: 53% reduction\n</code></pre>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#mathematical-impact","title":"Mathematical Impact","text":"<p>If the state space collapse ratio is \\(r\\) (fraction of paths leading to unique states):</p> \\[\\text{Effective States} = r \\cdot n^d\\] <p>For well-structured APIs with strong invariants, \\(r \\approx 0.01\\) to \\(0.1\\), yielding 10-100x reduction in exploration cost.</p>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#state-abstraction","title":"State Abstraction","text":"<p>Sometimes exact equality is too strict. We use abstraction functions:</p> Python<pre><code>def abstract_state(state: dict) -&gt; dict:\n    \"\"\"\n    Map concrete state to abstract representation.\n\n    Example: \"cart has 3 items\" instead of exact item IDs\n    \"\"\"\n    return {\n        \"cart_count\": len(state.get(\"cart\", [])),\n        \"has_order\": state.get(\"order_id\") is not None,\n        \"order_status\": state.get(\"order_status\", \"none\"),\n        # Ignore: specific item IDs, timestamps, UUIDs\n    }\n\n# Two states are equivalent if their abstractions match\ndef states_equivalent(s1, s2):\n    return abstract_state(s1) == abstract_state(s2)\n</code></pre> <p>This trades precision for coverage\u2014you might miss bugs that depend on specific item combinations, but you'll explore many more abstract scenarios.</p>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#5-pruning-strategies-cutting-branches-early","title":"5. Pruning Strategies: Cutting Branches Early","text":"","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#51-precondition-checking","title":"5.1 Precondition Checking","text":"<p>Idea: Don't execute actions that can't possibly succeed.</p> Python<pre><code>class Action:\n    def __init__(self, name, execute, precondition=None):\n        self.name = name\n        self.execute = execute\n        self.precondition = precondition or (lambda ctx: True)\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None  # Skip \u2014 no order to refund\n    return api.post(f\"/orders/{order_id}/refund\")\n\nrefund_action = Action(\n    name=\"refund_order\",\n    execute=refund_order,\n    precondition=lambda ctx: ctx.get(\"order_id\") is not None\n)\n</code></pre> <p>Impact: Reduces branching factor from \\(n\\) to \\(n_{\\text{valid}}\\) at each state.</p>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#52-invariant-early-exit","title":"5.2 Invariant Early-Exit","text":"<p>Idea: Stop exploring a path as soon as it violates an invariant.</p> Text Only<pre><code>Path: create \u2192 refund \u2192 refund\n                       \u2191\n                  Invariant violated!\n                  \"Cannot refund already-refunded order\"\n\nStop here \u2014 no need to explore deeper from this state.\n</code></pre> Python<pre><code>class Invariant:\n    def __init__(self, name, check, severity):\n        self.name = name\n        self.check = check  # (world) -&gt; bool\n        self.severity = severity\n\ndef explore_with_early_exit(agent):\n    for state, action_sequence in agent.strategy.generate_paths():\n        # Execute action sequence\n        for action in action_sequence:\n            result = action.execute(agent.world)\n\n            # Check invariants after each action\n            for invariant in agent.invariants:\n                if not invariant.check(agent.world):\n                    # Violation found \u2014 log and skip this branch\n                    yield Violation(\n                        invariant=invariant,\n                        path=action_sequence,\n                        state=agent.world.get_state()\n                    )\n                    break  # Early exit from this path\n            else:\n                continue\n            break  # Early exit from outer loop too\n</code></pre> <p>Impact: Prunes entire subtrees rooted at violating states.</p>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#53-budget-limiting","title":"5.3 Budget Limiting","text":"<p>Idea: Cap resources to ensure termination.</p> Python<pre><code>agent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n    strategy=BFS(),\n    max_steps=1000,        # Maximum actions per path\n    max_states=10000,      # Maximum unique states to visit\n    max_time_seconds=300,  # 5-minute timeout\n)\n</code></pre>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#combined-pruning-impact","title":"Combined Pruning Impact","text":"Text Only<pre><code>Original search space:        After pruning:\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  n^d paths  \u2502              \u2502   Reduced   \u2502\n    \u2502             \u2502   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6  \u2502   Search    \u2502\n    \u2502 (billions)  \u2502              \u2502   Space     \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                        \u2502\n                                        \u25bc\n                                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                 \u2502  ~r\u00b7n^d     \u2502\n                                 \u2502  states     \u2502\n                                 \u2502 (thousands) \u2502\n                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTypical reduction: 10^6 to 10^3 (1000x improvement)\n</code></pre>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#6-coverage-guarantees-what-we-can-prove","title":"6. Coverage Guarantees: What We Can Prove","text":"","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#theorem-1-bfs-completeness","title":"Theorem 1: BFS Completeness","text":"<p>Statement: Given infinite resources, BFS will eventually visit every reachable state.</p> <p>Proof Sketch:</p> <ol> <li>BFS explores states in order of distance from \\(v_0\\)</li> <li>Every reachable state \\(v\\) has finite distance \\(d(v, v_0)\\)</li> <li>By induction, BFS visits all states at distance \\(k\\) before distance \\(k+1\\)</li> <li>Therefore, state \\(v\\) at distance \\(d(v, v_0)\\) will be visited at iteration \\(d(v, v_0)\\)</li> </ol> \\[\\forall v \\in V_{\\text{reachable}}: \\exists t \\text{ such that BFS visits } v \\text{ at time } t\\]","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#theorem-2-shortest-path-guarantee","title":"Theorem 2: Shortest Path Guarantee","text":"<p>Statement: BFS finds the shortest path to each visited state.</p> <p>Proof:</p> <p>Let \\(v\\) be a state first visited at BFS level \\(k\\). By BFS construction, all states at level \\(k-1\\) have been visited. Any path to \\(v\\) must pass through some level \\(k-1\\) state, requiring at least \\(k\\) edges. The BFS path has exactly \\(k\\) edges, thus it is minimal.</p> \\[\\text{dist}(v_0, v) = \\min_{\\text{path } p} |p| = \\text{BFS level of } v\\]","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#what-bfsdfs-do-not-guarantee","title":"What BFS/DFS Do NOT Guarantee","text":"<ol> <li>Full coverage with budget: With <code>max_states &lt; |V|</code>, some states will be missed</li> <li>Bug detection: If bugs only manifest in unexplored states, they won't be found</li> <li>Action coverage: Some actions might never be applicable (preconditions never met)</li> </ol>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#coverage-metrics","title":"Coverage Metrics","text":"Python<pre><code>@dataclass\nclass CoverageReport:\n    states_visited: int          # Unique states explored\n    states_known: int            # States we know exist\n    actions_executed: int        # Total action invocations\n    actions_available: int       # Total defined actions\n    max_depth_reached: int       # Deepest path explored\n\n    @property\n    def state_coverage(self) -&gt; float:\n        \"\"\"Fraction of known states visited\"\"\"\n        return self.states_visited / self.states_known\n\n    @property\n    def action_coverage(self) -&gt; float:\n        \"\"\"Fraction of actions executed at least once\"\"\"\n        return self.actions_executed / self.actions_available\n</code></pre>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#formal-coverage-statement","title":"Formal Coverage Statement","text":"\\[\\text{Coverage} = \\frac{|V_{\\text{visited}}|}{|V_{\\text{reachable}}|} \\leq 1\\] <p>With state deduplication and pruning:</p> \\[\\text{Coverage} = \\frac{|V_{\\text{visited}}|}{\\min(|V_{\\text{reachable}}|, \\text{max\\_states})}\\]","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#putting-it-all-together-venomqas-approach","title":"Putting It All Together: VenomQA's Approach","text":"Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\n# Define actions with preconditions\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None  # Precondition: order must exist\n    return api.post(f\"/orders/{order_id}/refund\")\n\n# Define invariants for early-exit\nno_500s = Invariant(\n    name=\"no_server_errors\",\n    check=lambda world: world.context.get(\"last_status\", 200) &lt; 500,\n    severity=Severity.CRITICAL,\n)\n\n# Configure agent with pruning strategies\napi = HttpClient(base_url=\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\nagent = Agent(\n    world=world,\n    actions=[\n        Action(name=\"create_order\", execute=create_order),\n        Action(name=\"refund_order\", execute=refund_order),\n    ],\n    invariants=[no_500s],\n    strategy=BFS(),\n    max_steps=50,      # Budget limit\n)\n\nresult = agent.explore()\n\nprint(f\"States: {result.states_visited}\")\nprint(f\"Paths:  {result.paths_explored}\")\nprint(f\"Coverage: {result.coverage_ratio:.1%}\")\n</code></pre>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#what-this-gives-you","title":"What This Gives You","text":"<ol> <li>Systematic exploration: BFS ensures you don't miss shallow bugs</li> <li>Memory efficiency: State deduplication prevents redundant work</li> <li>Early termination: Invariants and preconditions prune bad paths</li> <li>Reproducibility: Shortest paths to bugs are guaranteed</li> <li>Bounded resources: Budget limits ensure the run terminates</li> </ol>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#conclusion","title":"Conclusion","text":"<p>API testing is fundamentally a graph exploration problem. By applying:</p> <ul> <li>Graph theory (state graphs, reachability)</li> <li>Combinatorics (path counting, complexity analysis)</li> <li>Algorithms (BFS, DFS, state hashing)</li> <li>Pruning techniques (preconditions, early-exit, budgeting)</li> </ul> <p>...we can systematically explore API state spaces that would be impossible to test manually or with naive automation.</p> <p>The key insight: bugs live in sequences, not endpoints. Understanding the mathematics helps us find them efficiently.</p>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-15-math-of-state-exploration/#further-reading","title":"Further Reading","text":"<ul> <li>VenomQA Architecture Guide</li> <li>Invariant-Based Testing</li> <li>Graph Theory and Model Checking</li> <li>Combinatorial Test Coverage</li> </ul> <p>Have questions about the math behind VenomQA? Open an issue or join our community discussions!</p>","tags":["graph-algorithms","state-machines","api-testing","combinatorics","bfs","dfs"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/","title":"Why Your Tests Pass But Your API Still Breaks: The Hidden World of Sequence Bugs","text":"<p>It was 3 AM when the PagerDuty alert woke Sarah. The payment service was returning 500 errors. Again.</p> <p>She pulled up the logs and stared at the stack trace. A customer had been refunded twice for the same order. The first refund worked fine. The second one\u2014the one that happened 47 seconds later\u2014crashed the entire service.</p> <p>Sarah did what any engineer would do. She ran the test suite.</p> Text Only<pre><code>450 tests passed \u2713\n0 failures \u2717\nCoverage: 94%\n</code></pre> <p>Every single test passed. The <code>refund_order</code> endpoint had 12 dedicated test cases. All green. So how did this bug make it to production?</p> <p>Here's the uncomfortable truth: the bug only appeared when you refunded an already-refunded order.</p> <p>Not when you refund once. Not when you refund an invalid order. Only in that specific sequence.</p> <p>This is a sequence bug. And traditional testing is blind to them.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#the-illusion-of-passing-tests","title":"The Illusion of Passing Tests","text":"<p>Let's look at what Sarah's test suite actually tested:</p> Python<pre><code>def test_refund_order_success():\n    order = create_order(amount=100)\n    response = api.post(f\"/orders/{order.id}/refund\")\n    assert response.status_code == 200\n    assert response.json()[\"status\"] == \"refunded\"\n\ndef test_refund_nonexistent_order():\n    response = api.post(\"/orders/99999/refund\")\n    assert response.status_code == 404\n\ndef test_refund_already_refunded():\n    order = create_order(amount=100)\n    api.post(f\"/orders/{order.id}/refund\")  # First refund\n    response = api.post(f\"/orders/{order.id}/refund\")  # Second refund\n    assert response.status_code == 400  # Expected: bad request\n</code></pre> <p>Wait\u2014there's even a test for double refunds! So what happened?</p> <p>The test passed because it was testing with a fresh database. After the first test ran, the database was wiped clean. The order was created fresh for each test.</p> <p>But in production? Orders sit in the database for weeks. Customers click refund buttons multiple times (accidentally or not). Background jobs retry failed requests.</p> <p>The test didn't fail because the test and production had different state.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#why-unit-tests-miss-these-bugs","title":"Why Unit Tests Miss These Bugs","text":"<p>Unit tests are designed for isolation. This is their strength and their blindness.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#1-fresh-fixtures-fresh-problems","title":"1. Fresh Fixtures, Fresh Problems","text":"<p>Every test gets a pristine world:</p> Python<pre><code>@pytest.fixture\ndef clean_db():\n    db.begin_transaction()\n    yield db\n    db.rollback()  # Everything goes away\n</code></pre> <p>This means no state carries over between tests. Which is great for repeatability\u2014but terrible for catching bugs that only emerge from accumulated state.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#2-linear-thinking-non-linear-bugs","title":"2. Linear Thinking, Non-Linear Bugs","text":"<p>Unit tests are written linearly:</p> Python<pre><code>def test_checkout():\n    cart = add_to_cart(item_id=123)  # Step 1\n    checkout = process_payment(cart)  # Step 2\n    assert checkout.status == \"success\"  # Verify\n</code></pre> <p>But users don't behave linearly. They:</p> <ul> <li>Add items, remove them, add them again</li> <li>Start checkout, cancel, start again</li> <li>Click buttons multiple times \"just to be sure\"</li> <li>Open multiple tabs with the same session</li> </ul>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#3-the-combinatorial-explosion","title":"3. The Combinatorial Explosion","text":"<p>If your API has just 5 actions (create, read, update, delete, refund), how many sequences should you test?</p> <ul> <li>Sequences of length 2: 25 combinations</li> <li>Sequences of length 3: 125 combinations</li> <li>Sequences of length 5: 3,125 combinations</li> <li>Sequences of length 10: 9,765,625 combinations</li> </ul> <p>Nobody writes 10 million test cases. So we test the happy path, a few edge cases, and hope.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#real-world-sequence-bugs-that-made-it-to-production","title":"Real-World Sequence Bugs (That Made It to Production)","text":"","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#the-double-refund-stripe-style","title":"The Double Refund (Stripe-style)","text":"Python<pre><code># Bug: Race condition in refund processing\ndef process_refund(order_id):\n    order = db.get_order(order_id)\n    if order.status == \"refunded\":\n        raise AlreadyRefundedError()\n\n    # \u26a0\ufe0f Time gap here \u2014 another request can slip in\n\n    payment_gateway.refund(order.payment_id)\n    order.status = \"refunded\"\n    db.save(order)\n</code></pre> <p>Two requests arrive simultaneously. Both pass the <code>if order.status == \"refunded\"</code> check. Both issue refunds. Customer gets double their money back.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#the-stale-cache-after-delete","title":"The Stale Cache After Delete","text":"Python<pre><code># Bug: Cache not invalidated after delete\ndef delete_user(user_id):\n    db.delete_user(user_id)\n    # Forgot: cache.delete(f\"user:{user_id}\")\n\ndef get_user(user_id):\n    cached = cache.get(f\"user:{user_id}\")\n    if cached:\n        return cached  # Returns deleted user!\n    return db.get_user(user_id)\n</code></pre> <p>Unit tests pass because they don't test the sequence <code>delete \u2192 get</code>. They test delete. They test get. But not together.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#the-idempotency-violation","title":"The Idempotency Violation","text":"Python<pre><code># Bug: Idempotency key not checked atomically\ndef charge_customer(amount, idempotency_key):\n    if cache.exists(idempotency_key):\n        return cache.get(idempotency_key)\n\n    # \u26a0\ufe0f Gap between check and charge\n\n    result = stripe.charge(amount)\n    cache.set(idempotency_key, result)\n    return result\n</code></pre> <p>Customer's payment times out, they retry, and get charged twice.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#the-zombie-subscription","title":"The Zombie Subscription","text":"Python<pre><code># Bug: Cancel doesn't stop renewal job\ndef cancel_subscription(sub_id):\n    sub = db.get_subscription(sub_id)\n    sub.status = \"cancelled\"\n    db.save(sub)\n    # Forgot: scheduler.cancel(sub.renewal_job_id)\n\n# Two months later...\n@renewal_job\ndef renew_subscription(sub_id):\n    sub = db.get_subscription(sub_id)\n    charge_customer(sub.amount)  # Charges cancelled subscription!\n</code></pre>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#the-testing-gap","title":"The Testing Gap","text":"<p>Here's what popular testing tools actually check:</p> Tool Tests Misses pytest Individual functions Sequences of operations Schemathesis Schema compliance, types Business logic violations Postman Manual sequences you write Sequences you didn't think of k6/Locust Performance under load Correctness of behavior Chaos Engineering System resilience Logic bugs in happy paths <p>They're all valuable. But none of them systematically explore what happens when you combine actions in unexpected orders.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#the-human-factor","title":"The Human Factor","text":"<p>Even if tools supported sequence testing, there's a more fundamental problem: humans are bad at imagining all the sequences.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#cognitive-biases","title":"Cognitive Biases","text":"<ol> <li>Happy Path Bias: We test what should work, not what could go wrong</li> <li>Linear Thinking: We imagine users following the \"normal\" flow</li> <li>Confirmation Bias: Once we find a bug, we stop looking for others</li> <li>Anchoring: We copy test patterns from existing tests</li> </ol>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#the-math-of-edge-cases","title":"The Math of Edge Cases","text":"<p>For 3 actions, there are 27 possible sequences of length 3. But most engineers write:</p> Python<pre><code>def test_action_a(): ...\ndef test_action_b(): ...\ndef test_action_c(): ...\n</code></pre> <p>That's 3 tests. Not 27. We're testing 11% of the state space.</p> <p>Add just 2 more actions? Now there are 3,125 sequences of length 5. Nobody writes 3,125 tests.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#how-to-fix-it-stateful-api-testing","title":"How to Fix It: Stateful API Testing","text":"<p>The solution isn't more unit tests. The solution is exploration, not enumeration.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#model-based-testing","title":"Model-Based Testing","text":"<p>Instead of writing individual test cases, you define:</p> <ol> <li>Actions: What can users do?</li> <li>Invariants: What must always be true?</li> </ol> Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\n# Define what users CAN do\nactions = [\n    Action(name=\"create_order\", execute=lambda api, ctx: \n        api.post(\"/orders\", json={\"amount\": 100})),\n    Action(name=\"refund_order\", execute=lambda api, ctx:\n        api.post(f\"/orders/{ctx.get('order_id')}/refund\") \n        if ctx.get('order_id') else None),\n    Action(name=\"delete_order\", execute=lambda api, ctx:\n        api.delete(f\"/orders/{ctx.get('order_id')}\") \n        if ctx.get('order_id') else None),\n]\n\n# Define what MUST be true\ninvariants = [\n    Invariant(\n        name=\"no_500_errors\",\n        check=lambda world: world.context.get(\"last_status\", 200) &lt; 500,\n        severity=Severity.CRITICAL,\n    ),\n    Invariant(\n        name=\"refunded_orders_cant_be_deleted\",\n        check=lambda world: not (\n            world.context.get(\"order_refunded\") and \n            world.context.get(\"last_action\") == \"delete_order\" and\n            world.context.get(\"last_status\") == 200\n        ),\n        severity=Severity.HIGH,\n    ),\n]\n\n# Let the agent explore EVERY sequence\napi = HttpClient(base_url=\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\", \"order_refunded\"])\n\nagent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n    strategy=BFS(),\n    max_steps=100,\n)\n\nresult = agent.explore()\nprint(f\"Explored {result.states_visited} states\")\nprint(f\"Found {len(result.violations)} violations\")\n</code></pre> <p>The agent explores systematically: <code>create \u2192 refund \u2192 refund</code>, <code>create \u2192 delete \u2192 refund</code>, <code>create \u2192 refund \u2192 delete</code>, and so on.</p> <p>When it finds a violation, it reports the exact sequence that caused it:</p> Text Only<pre><code>INVARIANT VIOLATION: no_500_errors\n  Sequence: create_order \u2192 refund_order \u2192 refund_order\n  State transition:\n    - Order #1234 created\n    - Order #1234 refunded (status=200)\n    - Order #1234 refunded (status=500) \u2190 BUG!\n</code></pre>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#state-exploration-with-rollback","title":"State Exploration with Rollback","text":"<p>The key innovation is database rollback between sequences:</p> Python<pre><code># Test sequence 1: create \u2192 refund \u2192 refund\ncheckpoint()  # Save state\ncreate_order()\nrefund_order()\nrefund_order()  # \u2190 This might crash!\nrollback()  # Restore state\n\n# Test sequence 2: create \u2192 delete \u2192 refund\ncheckpoint()  # Fresh start\ncreate_order()\ndelete_order()\nrefund_order()  # \u2190 Different bug might appear!\nrollback()\n</code></pre> <p>This lets you test thousands of sequences against the same database, without contaminating state between tests.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#invariant-checking","title":"Invariant Checking","text":"<p>Instead of asserting specific outcomes, you define global properties:</p> Python<pre><code># \"Total money in = total money out\" (conservation)\ndef money_conserved(world):\n    created = sum(o.amount for o in world.created_orders)\n    refunded = sum(o.amount for o in world.refunded_orders)\n    return refunded &lt;= created  # Can't refund more than created\n\n# \"No operation takes &gt; 5 seconds\" (performance)\ndef response_time_ok(world):\n    return world.context.get(\"last_response_time\", 0) &lt; 5.0\n\n# \"No sensitive data in responses\" (security)\ndef no_pii_leak(world):\n    response = world.context.get(\"last_response\", \"\")\n    return not any(pii in response for pii in [\"ssn\", \"credit_card\"])\n</code></pre> <p>These invariants are checked after every action in every sequence.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#the-takeaway","title":"The Takeaway","text":"<p>Traditional testing catches bugs in components. Sequence bugs hide in the interactions between components.</p> <ul> <li>Unit tests: \"Does <code>refund()</code> work?\"</li> <li>Integration tests: \"Do <code>refund()</code> and <code>stripe_charge()</code> work together?\"</li> <li>Stateful testing: \"What happens when <code>create \u2192 refund \u2192 refund \u2192 delete \u2192 create</code>?\"</li> </ul> <p>You need all three.</p> <p>The good news? You don't have to write a million test cases. You define the rules, and let the computer explore the combinations.</p> <p>Because the bug that crashed your production at 3 AM? It's already there, hiding in a sequence you haven't tested yet.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-20-why-sequence-bugs-hide/#start-finding-sequence-bugs-today","title":"Start Finding Sequence Bugs Today","text":"<p>VenomQA is an open-source tool that explores your API's state graph automatically. Define actions, define invariants, and let it find the bugs your tests missed.</p> Bash<pre><code>pip install venomqa\nvenomqa demo  # See it find a sequence bug in 30 seconds\n</code></pre> <p>Or check out the examples to see it find real bugs in a payment system.</p> <p>Found this helpful? Star us on GitHub and follow for more on API testing, stateful testing, and automated QA.</p>","tags":["API testing","sequence bugs","stateful testing","integration testing","automated testing"]},{"location":"blog/2024-01-25-state-machines-in-api-testing/","title":"Modeling APIs as State Machines for Exhaustive Testing","text":"<p>Every API is a state machine. Most teams just don't realize it\u2014and their tests suffer because of it.</p> <p>When you test an API endpoint in isolation, you're testing a single transition. But bugs often hide in the sequences: what happens when you refund a refunded order? Ship before payment? Pay twice?</p> <p>This post shows how to model APIs as explicit state machines for testing, finding bugs that only appear in specific orderings of operations.</p>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#what-is-a-state-machine","title":"What is a State Machine?","text":"<p>A finite state machine (or finite automata) is a mathematical model of computation consisting of:</p> <ul> <li>States: Discrete conditions the system can be in</li> <li>Transitions: Rules for moving between states</li> <li>Events: Triggers that cause transitions</li> <li>Initial state: Where the machine starts</li> <li>Final states: Terminal conditions (optional)</li> </ul> <p>Formally, a state machine is a 5-tuple <code>(Q, \u03a3, \u03b4, q\u2080, F)</code> where:</p> <ul> <li><code>Q</code> = finite set of states</li> <li><code>\u03a3</code> = alphabet (input symbols/events)</li> <li><code>\u03b4</code> = transition function <code>Q \u00d7 \u03a3 \u2192 Q</code></li> <li><code>q\u2080</code> = initial state</li> <li><code>F</code> = set of accepting states</li> </ul>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#why-apis-are-implicit-state-machines","title":"Why APIs Are Implicit State Machines","text":"<p>Consider a typical order API:</p> Text Only<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502                                             \u2502\n                    \u25bc                                             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  create  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  pay   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  ship  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [empty]\u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502[pending]\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502[paid] \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502[shipped] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502                  \u2502\n                         \u2502 cancel           \u2502 refund\n                         \u25bc                  \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502[canceled]\u2502      \u2502[refunded] \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Every order exists in exactly one state. Operations like <code>pay</code>, <code>ship</code>, and <code>refund</code> are transitions. The API is a state machine, but the state machine is implicit\u2014encoded in scattered <code>if</code> statements across your codebase:</p> Python<pre><code>def refund_order(order_id):\n    order = db.get_order(order_id)\n    if order.status != \"paid\":\n        raise BadRequestError(\"Can only refund paid orders\")\n    # ... refund logic\n</code></pre> <p>This <code>if</code> statement is enforcing a state transition rule. There are probably dozens more like it, each encoding a tiny piece of the state machine.</p>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#explicit-vs-implicit-state","title":"Explicit vs Implicit State","text":""},{"location":"blog/2024-01-25-state-machines-in-api-testing/#the-problem-with-implicit-state","title":"The Problem with Implicit State","text":"<p>Most APIs don't document their state machine. Instead:</p> <ol> <li>State is scattered: Status fields, boolean flags, timestamps</li> <li>Rules are hidden: Validation logic buried in controllers</li> <li>Edge cases are missed: What should happen in impossible scenarios?</li> <li>Testing is incomplete: Each endpoint tested in isolation</li> </ol> <p>You end up reverse-engineering the state machine from behavior:</p> Python<pre><code># What states exist?\nGET /orders/{id}  # Look at the status field\n\n# What transitions are valid?\n# Try every operation in every state and see what fails\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#why-explicit-is-better","title":"Why Explicit is Better","text":"<p>When you model the state machine explicitly:</p> Python<pre><code>from enum import Enum\n\nclass OrderState(str, Enum):\n    EMPTY = \"empty\"\n    PENDING = \"pending\"\n    PAID = \"paid\"\n    SHIPPED = \"shipped\"\n    CANCELED = \"canceled\"\n    REFUNDED = \"refunded\"\n\nVALID_TRANSITIONS = {\n    OrderState.EMPTY: {\"create\": OrderState.PENDING},\n    OrderState.PENDING: {\"pay\": OrderState.PAID, \"cancel\": OrderState.CANCELED},\n    OrderState.PAID: {\"ship\": OrderState.SHIPPED, \"refund\": OrderState.REFUNDED},\n    OrderState.SHIPPED: set(),  # Terminal\n    OrderState.CANCELED: set(), # Terminal\n    OrderState.REFUNDED: set(), # Terminal\n}\n</code></pre> <p>Now you can:</p> <ol> <li>Generate tests from the state graph</li> <li>Validate that implementation matches model</li> <li>Document behavior automatically</li> <li>Find impossible states that shouldn't exist</li> </ol>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#state-machine-testing-patterns","title":"State Machine Testing Patterns","text":"<p>State machine testing (a form of model-based testing) follows a simple pattern:</p>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#1-model-the-states","title":"1. Model the States","text":"<p>Define all possible states your resource can be in:</p> Python<pre><code>class OrderState(str, Enum):\n    EMPTY = \"empty\"\n    PENDING = \"pending\"\n    PAID = \"paid\"\n    SHIPPED = \"shipped\"\n    CANCELED = \"canceled\"\n    REFUNDED = \"refunded\"\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#2-define-valid-transitions","title":"2. Define Valid Transitions","text":"<p>Map which operations are valid in which states:</p> Python<pre><code>TRANSITIONS = {\n    OrderState.EMPTY: {\n        \"create\": OrderState.PENDING,\n    },\n    OrderState.PENDING: {\n        \"pay\": OrderState.PAID,\n        \"cancel\": OrderState.CANCELED,\n    },\n    OrderState.PAID: {\n        \"ship\": OrderState.SHIPPED,\n        \"refund\": OrderState.REFUNDED,\n    },\n    OrderState.SHIPPED: {},  # Terminal\n    OrderState.CANCELED: {}, # Terminal\n    OrderState.REFUNDED: {}, # Terminal\n}\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#3-check-invariants-at-each-state","title":"3. Check Invariants at Each State","text":"<p>Define properties that must hold in each state:</p> Python<pre><code>INVARIANTS = {\n    OrderState.PENDING: [\n        lambda order: order.amount &gt; 0,\n        lambda order: order.created_at is not None,\n    ],\n    OrderState.PAID: [\n        lambda order: order.paid_at is not None,\n        lambda order: order.payment_id is not None,\n    ],\n    OrderState.SHIPPED: [\n        lambda order: order.tracking_number is not None,\n    ],\n    OrderState.REFUNDED: [\n        lambda order: order.refunded_at is not None,\n        lambda order: order.refund_amount &gt; 0,\n    ],\n}\n\n# Universal invariants (always true)\nUNIVERSAL_INVARIANTS = [\n    lambda order: order.amount &gt;= 0,\n    lambda order: order.id is not None,\n]\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#example-order-lifecycle-testing","title":"Example: Order Lifecycle Testing","text":"<p>Let's build a complete state machine test for an order API using the VenomQA framework:</p> Python<pre><code>from venomqa import Action, Agent, Invariant, World, BFS, Severity\nfrom venomqa.adapters.http import HttpClient\nfrom enum import Enum\nfrom typing import Optional\nimport httpx\n\nclass OrderState(str, Enum):\n    EMPTY = \"empty\"\n    PENDING = \"pending\"\n    PAID = \"paid\"\n    SHIPPED = \"shipped\"\n    CANCELED = \"canceled\"\n    REFUNDED = \"refunded\"\n\nclass OrderContext:\n    \"\"\"Tracks current state and order data\"\"\"\n    def __init__(self):\n        self.state: OrderState = OrderState.EMPTY\n        self.order_id: Optional[str] = None\n        self.amount: Optional[int] = None\n        self.payment_id: Optional[str] = None\n        self.tracking_number: Optional[str] = None\n\n# --- State Guards ---\n\ndef require_state(*allowed_states: OrderState):\n    \"\"\"Decorator that skips action if not in allowed state\"\"\"\n    def decorator(func):\n        def wrapper(api, context):\n            if context.state not in allowed_states:\n                return None  # Skip this action\n            return func(api, context)\n        wrapper.__name__ = func.__name__\n        return wrapper\n    return decorator\n\n# --- Actions ---\n\n@require_state(OrderState.EMPTY)\ndef create_order(api: HttpClient, context: OrderContext) -&gt; Optional[httpx.Response]:\n    \"\"\"Create a new pending order\"\"\"\n    response = api.post(\"/orders\", json={\"amount\": 100})\n\n    if response.status_code == 201:\n        data = response.json()\n        context.order_id = data[\"id\"]\n        context.amount = data[\"amount\"]\n        context.state = OrderState.PENDING\n\n    return response\n\n@require_state(OrderState.PENDING)\ndef pay_order(api: HttpClient, context: OrderContext) -&gt; Optional[httpx.Response]:\n    \"\"\"Pay for a pending order\"\"\"\n    response = api.post(\n        f\"/orders/{context.order_id}/pay\",\n        json={\"payment_method\": \"card\"}\n    )\n\n    if response.status_code == 200:\n        data = response.json()\n        context.payment_id = data.get(\"payment_id\")\n        context.state = OrderState.PAID\n\n    return response\n\n@require_state(OrderState.PENDING)\ndef cancel_order(api: HttpClient, context: OrderContext) -&gt; Optional[httpx.Response]:\n    \"\"\"Cancel a pending order\"\"\"\n    response = api.post(f\"/orders/{context.order_id}/cancel\")\n\n    if response.status_code == 200:\n        context.state = OrderState.CANCELED\n\n    return response\n\n@require_state(OrderState.PAID)\ndef ship_order(api: HttpClient, context: OrderContext) -&gt; Optional[httpx.Response]:\n    \"\"\"Ship a paid order\"\"\"\n    response = api.post(\n        f\"/orders/{context.order_id}/ship\",\n        json={\"carrier\": \"fedex\"}\n    )\n\n    if response.status_code == 200:\n        data = response.json()\n        context.tracking_number = data.get(\"tracking_number\")\n        context.state = OrderState.SHIPPED\n\n    return response\n\n@require_state(OrderState.PAID)\ndef refund_order(api: HttpClient, context: OrderContext) -&gt; Optional[httpx.Response]:\n    \"\"\"Refund a paid order\"\"\"\n    response = api.post(f\"/orders/{context.order_id}/refund\")\n\n    if response.status_code == 200:\n        context.state = OrderState.REFUNDED\n\n    return response\n\n# --- Invariants ---\n\ndef no_500_errors(world: World) -&gt; bool:\n    \"\"\"Server should never return 5xx errors\"\"\"\n    return world.context.get(\"last_status\", 200) &lt; 500\n\ndef amount_positive(world: World) -&gt; bool:\n    \"\"\"Order amount must always be positive\"\"\"\n    ctx = world.context\n    if ctx.state == OrderState.EMPTY:\n        return True  # No order yet\n    return ctx.amount is not None and ctx.amount &gt; 0\n\ndef paid_orders_have_payment_id(world: World) -&gt; bool:\n    \"\"\"Paid/shipped orders must have a payment ID\"\"\"\n    ctx = world.context\n    if ctx.state in (OrderState.PAID, OrderState.SHIPPED, OrderState.REFUNDED):\n        return ctx.payment_id is not None\n    return True\n\ndef shipped_orders_have_tracking(world: World) -&gt; bool:\n    \"\"\"Shipped orders must have a tracking number\"\"\"\n    ctx = world.context\n    if ctx.state == OrderState.SHIPPED:\n        return ctx.tracking_number is not None\n    return True\n\ndef terminal_states_are_final(world: World) -&gt; bool:\n    \"\"\"Terminal states shouldn't allow further transitions\"\"\"\n    ctx = world.context\n    if ctx.state in (OrderState.CANCELED, OrderState.REFUNDED):\n        # These states should have no valid outgoing transitions\n        return ctx.state not in TRANSITIONS.get(ctx.state, {})\n    return True\n\n# --- Setup Agent ---\n\napi = HttpClient(base_url=\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"state\", \"order_id\"])\n\nagent = Agent(\n    world=world,\n    actions=[\n        Action(name=\"create_order\", execute=create_order),\n        Action(name=\"pay_order\", execute=pay_order),\n        Action(name=\"cancel_order\", execute=cancel_order),\n        Action(name=\"ship_order\", execute=ship_order),\n        Action(name=\"refund_order\", execute=refund_order),\n    ],\n    invariants=[\n        Invariant(name=\"no_500s\", check=no_500_errors, severity=Severity.CRITICAL),\n        Invariant(name=\"amount_positive\", check=amount_positive, severity=Severity.ERROR),\n        Invariant(name=\"paid_has_payment\", check=paid_orders_have_payment_id),\n        Invariant(name=\"shipped_has_tracking\", check=shipped_orders_have_tracking),\n        Invariant(name=\"terminal_final\", check=terminal_states_are_final),\n    ],\n    strategy=BFS(),\n    max_steps=100,\n)\n\n# Run exploration\nresult = agent.explore()\nprint(f\"States visited: {result.states_visited}\")\nprint(f\"Violations found: {len(result.violations)}\")\n\nfor violation in result.violations:\n    print(f\"  [{violation.severity}] {violation.name}: {violation.message}\")\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#what-this-tests","title":"What This Tests","text":"<p>This exploration will discover:</p> <ol> <li>All valid paths: <code>create \u2192 pay \u2192 ship</code>, <code>create \u2192 pay \u2192 refund</code>, <code>create \u2192 cancel</code></li> <li>Invalid transitions: Trying to ship a pending order, refund a shipped order</li> <li>Edge cases: Double payment, refund after refund, cancel after payment</li> <li>Invariant violations: Missing payment IDs, negative amounts, server errors</li> </ol> <p>The state graph explored:</p> Text Only<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 [empty] \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n                         \u2502 create\n                         \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502[pending]\u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502          \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518         \u2502\n         \u2502               \u2502              \u2502\n         \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n         \u2502         \u2502           \u2502        \u2502\n         \u2502      pay\u2502        cancel      \u2502\n         \u2502         \u25bc           \u25bc        \u2502\n         \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n         \u2502    \u2502[paid] \u2502   \u2502[canceled]\u2502  \u2502\n         \u2502    \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n         \u2502        \u2502                     \u2502\n         \u2502   \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510                \u2502\n         \u2502   \u2502         \u2502                \u2502\n         \u2502ship      refund              \u2502\n         \u2502   \u25bc         \u25bc                \u2502\n         \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n         \u2502\u2502[shipped] \u2502\u2502[refunded] \u2502     \u2502\n         \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n         \u2502                               \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              (no valid transitions)\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#handling-complex-states","title":"Handling Complex States","text":"<p>Real-world APIs often have more complex state machines than a simple linear flow.</p>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#composite-states","title":"Composite States","text":"<p>Sometimes a resource has multiple independent state dimensions:</p> Python<pre><code>class OrderStatus(str, Enum):\n    PENDING = \"pending\"\n    PAID = \"paid\"\n    SHIPPED = \"shipped\"\n    CANCELED = \"canceled\"\n\nclass FulfillmentStatus(str, Enum):\n    UNFULFILLED = \"unfulfilled\"\n    PROCESSING = \"processing\"\n    FULFILLED = \"fulfilled\"\n    RETURNED = \"returned\"\n\nclass Order:\n    status: OrderStatus\n    fulfillment: FulfillmentStatus\n\n    # Composite state = (status, fulfillment)\n    # Valid: (PAID, UNFULFILLED), (PAID, PROCESSING), (SHIPPED, FULFILLED)\n    # Invalid: (PENDING, FULFILLED), (CANCELED, PROCESSING)\n</code></pre> <p>Model these as tuples:</p> Python<pre><code>COMPOSITE_TRANSITIONS = {\n    (OrderStatus.PENDING, FulfillmentStatus.UNFULFILLED): {\n        \"pay\": (OrderStatus.PAID, FulfillmentStatus.UNFULFILLED),\n        \"cancel\": (OrderStatus.CANCELED, FulfillmentStatus.UNFULFILLED),\n    },\n    (OrderStatus.PAID, FulfillmentStatus.UNFULFILLED): {\n        \"start_fulfillment\": (OrderStatus.PAID, FulfillmentStatus.PROCESSING),\n        \"ship\": (OrderStatus.SHIPPED, FulfillmentStatus.FULFILLED),\n        \"refund\": (OrderStatus.CANCELED, FulfillmentStatus.UNFULFILLED),\n    },\n    # ... etc\n}\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#parallel-state-machines","title":"Parallel State Machines","text":"<p>When resources have independent lifecycles:</p> Text Only<pre><code>Order: [created] \u2192 [paid] \u2192 [fulfilled] \u2192 [delivered]\n                 \u2198 [canceled]\n\nPayment: [pending] \u2192 [processing] \u2192 [completed]\n                          \u2198 [failed]\n\nInvoice: [draft] \u2192 [sent] \u2192 [paid] \u2192 [archived]\n</code></pre> <p>Test each machine independently, then test interactions:</p> Python<pre><code>def test_payment_failure_cancels_order():\n    \"\"\"Payment state machine affects order state machine\"\"\"\n    order = create_order()\n    payment = create_payment(order.id)\n\n    # Simulate payment failure\n    payment.fail()\n\n    # Order should be canceled\n    order.refresh()\n    assert order.status == OrderStatus.CANCELED\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#hierarchical-states","title":"Hierarchical States","text":"<p>Some states contain sub-states:</p> Text Only<pre><code>[active]\n  \u251c\u2500\u2500 [trial]\n  \u251c\u2500\u2500 [subscribed]\n  \u2502     \u251c\u2500\u2500 [monthly]\n  \u2502     \u2514\u2500\u2500 [annual]\n  \u2514\u2500\u2500 [past_due]\n\n[canceled]\n  \u251c\u2500\u2500 [expired]\n  \u2514\u2500\u2500 [churned]\n</code></pre> <p>Model with nested state machines:</p> Python<pre><code>from typing import Union\n\nclass ActiveSubstate(str, Enum):\n    TRIAL = \"trial\"\n    SUBSCRIBED = \"subscribed\"\n    PAST_DUE = \"past_due\"\n\nclass CanceledSubstate(str, Enum):\n    EXPIRED = \"expired\"\n    CHURNED = \"churned\"\n\nclass AccountState:\n    top_level: Union[Literal[\"active\"], Literal[\"canceled\"]]\n    substate: Union[ActiveSubstate, CanceledSubstate, None]\n\n    def can_upgrade(self) -&gt; bool:\n        return (\n            self.top_level == \"active\" and \n            self.substate in (ActiveSubstate.TRIAL, ActiveSubstate.SUBSCRIBED)\n        )\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#benefits-of-state-machine-testing","title":"Benefits of State Machine Testing","text":""},{"location":"blog/2024-01-25-state-machines-in-api-testing/#1-finds-impossible-states","title":"1. Finds Impossible States","text":"<p>Traditional tests check happy paths. State machine testing finds:</p> Python<pre><code># This shouldn't exist, but does it?\norder = Order(status=\"pending\", shipped_at=\"2024-01-25\")\n\n# Invariant catches it\nassert not (order.status == \"pending\" and order.shipped_at is not None)\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#2-catches-missing-transitions","title":"2. Catches Missing Transitions","text":"<p>When you enumerate all states and transitions, gaps become obvious:</p> Text Only<pre><code>State: REFUNDED\nValid transitions: {}  # Empty!\n\nBut what if the customer wants to re-order?\nMaybe we need: REFUNDED \u2192 \"reorder\" \u2192 PENDING (with new order_id)\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#3-documents-behavior","title":"3. Documents Behavior","text":"<p>The state machine is the documentation:</p> Python<pre><code># This tells you everything about order lifecycle\nORDER_STATE_MACHINE = {\n    OrderState.EMPTY: {\"create\": OrderState.PENDING},\n    OrderState.PENDING: {\"pay\": OrderState.PAID, \"cancel\": OrderState.CANCELED},\n    OrderState.PAID: {\"ship\": OrderState.SHIPPED, \"refund\": OrderState.REFUNDED},\n    OrderState.SHIPPED: {},\n    OrderState.CANCELED: {},\n    OrderState.REFUNDED: {},\n}\n</code></pre> <p>Generate diagrams from it:</p> Python<pre><code>import graphviz\n\ndef render_state_machine(transitions, filename=\"state_machine\"):\n    dot = graphviz.Digraph()\n\n    for from_state, edges in transitions.items():\n        for event, to_state in edges.items():\n            dot.edge(from_state.value, to_state.value, label=event)\n\n    dot.render(filename, format=\"png\")\n</code></pre>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#4-enables-property-based-testing","title":"4. Enables Property-Based Testing","text":"<p>With an explicit state model, you can generate arbitrary sequences:</p> Python<pre><code>from hypothesis import strategies as st\nfrom hypothesis.stateful import RuleBasedStateMachine, rule\n\nclass OrderStateMachine(RuleBasedStateMachine):\n    def __init__(self):\n        super().__init__()\n        self.state = OrderState.EMPTY\n        self.order_id = None\n\n    @rule()\n    def create(self):\n        if self.state == OrderState.EMPTY:\n            self.state = OrderState.PENDING\n            self.order_id = \"order_123\"\n\n    @rule()\n    def pay(self):\n        if self.state == OrderState.PENDING:\n            self.state = OrderState.PAID\n\n    @rule()\n    def ship(self):\n        if self.state == OrderState.PAID:\n            self.state = OrderState.SHIPPED\n\n    @rule()\n    def refund(self):\n        if self.state == OrderState.PAID:\n            self.state = OrderState.REFUNDED\n\n    @rule()\n    def cancel(self):\n        if self.state == OrderState.PENDING:\n            self.state = OrderState.CANCELED\n\nTestOrderStateMachine = OrderStateMachine.TestCase\n</code></pre> <p>Hypothesis will generate thousands of random sequences, finding edge cases you'd never think to test.</p>"},{"location":"blog/2024-01-25-state-machines-in-api-testing/#conclusion","title":"Conclusion","text":"<p>Every API is a state machine. The question is whether you model it explicitly or let it emerge implicitly from scattered conditionals.</p> <p>Explicit state machine modeling gives you:</p> <ul> <li>Completeness: Test all paths, not just the ones you thought of</li> <li>Clarity: The model is the documentation</li> <li>Confidence: Invariants checked at every state</li> <li>Maintainability: Changes to state logic are localized</li> </ul> <p>The order lifecycle example in this post is simple, but the pattern scales. Payment systems with 20+ states, subscription lifecycles with parallel state machines, multi-tenant SaaS with hierarchical permissions\u2014all can be modeled and exhaustively tested.</p> <p>Your API is already a state machine. You might as well make it explicit.</p> <p>VenomQA automates state machine testing for APIs. Define actions and invariants, and it explores every path through your state graph. Get started \u2192</p>"},{"location":"blog/2024-02-01-property-based-testing-comparison/","title":"VenomQA vs Property-Based Testing: A Practical Comparison","text":"<p>Property-based testing revolutionized how we find bugs by automatically generating thousands of test cases. Tools like QuickCheck, Hypothesis, and similar frameworks have become essential for discovering edge cases that humans miss.</p> <p>But here's the thing: property-based testing excels at fuzzing inputs, while VenomQA excels at exploring sequences. They solve different problems, and understanding when to use each can dramatically improve your testing strategy.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#1-what-is-property-based-testing","title":"1. What is Property-Based Testing?","text":"","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#the-quickcheck-revolution","title":"The QuickCheck Revolution","text":"<p>Property-based testing originated with QuickCheck (Claesson &amp; Hughes, 2000), a Haskell tool that turned testing on its head. Instead of writing individual test cases, you describe properties that should always hold, and the framework generates random inputs to try to falsify them.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#how-it-works","title":"How It Works","text":"Python<pre><code>from hypothesis import given, strategies as st\n\n@given(st.integers(), st.integers())\ndef test_addition_commutative(x, y):\n    assert x + y == y + x\n</code></pre> <p>The framework generates hundreds of random <code>(x, y)</code> pairs: - Positive integers - Negative integers - Zero - Very large numbers - Edge cases at type boundaries</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#core-concepts","title":"Core Concepts","text":"<ol> <li>Generators: Strategies that produce random values (<code>st.integers()</code>, <code>st.text()</code>, custom strategies)</li> <li>Properties: Invariants that should hold for all generated inputs</li> <li>Shrinking: When a bug is found, automatically reduce to the minimal failing case</li> </ol> <p>Hypothesis (Python), QuickCheck (Haskell), ScalaCheck, fast-check (JavaScript) \u2014 they all follow this pattern.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#2-what-property-based-testing-does-well","title":"2. What Property-Based Testing Does Well","text":"<p>Property-based testing shines when you need to explore the input space of individual functions or endpoints.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#input-fuzzing","title":"Input Fuzzing","text":"Python<pre><code>@given(st.text())\ndef test_parse_never_crashes(input_string):\n    result = parse_json(input_string)\n    assert result is not None or input_string is not None\n</code></pre> <p>Hypothesis will try: - Empty strings - Unicode characters - Very long strings (megabytes) - Malformed JSON - Control characters - Null bytes</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#edge-cases-in-parsing","title":"Edge Cases in Parsing","text":"<p>Property-based testing finds bugs at type boundaries:</p> Python<pre><code>@given(st.integers(min_value=0, max_value=2**31-1))\ndef test_user_age_reasonable(age):\n    user = create_user(age=age)\n    assert user.age &gt;= 0\n    assert user.age &lt; 150  # Wait, what about overflow?\n</code></pre>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#schema-validation","title":"Schema Validation","text":"Python<pre><code>from hypothesis import given, strategies as st\n\nuser_strategy = st.fixed_dictionaries({\n    'name': st.text(min_size=1, max_size=100),\n    'email': st.from_regex(r'[a-z]+@[a-z]+\\.[a-z]+'),\n    'age': st.integers(min_value=0, max_value=120),\n})\n\n@given(user_strategy)\ndef test_user_schema_valid(user_data):\n    validated = UserSchema(**user_data)\n    assert validated.name == user_data['name']\n</code></pre>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#type-boundary-conditions","title":"Type Boundary Conditions","text":"Python<pre><code>@given(st.integers())\ndef test_int_serialization_roundtrip(n):\n    serialized = json.dumps(n)\n    deserialized = json.loads(serialized)\n    assert deserialized == n  # Catches integer overflow in JSON\n</code></pre> <p>Summary: Property-based testing is a fuzzer for inputs. It asks: \"Given random inputs, does my function behave correctly?\"</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#3-what-property-based-testing-misses","title":"3. What Property-Based Testing Misses","text":"<p>Here's the gap: real bugs often hide in sequences of operations, not in individual function calls.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#the-sequence-problem","title":"The Sequence Problem","text":"<p>Consider a payment API:</p> Python<pre><code>order = create_order(amount=100)      # \u2713 Works\nrefund_order(order.id, amount=100)    # \u2713 Works  \nrefund_order(order.id, amount=100)    # \ud83d\udca5 Double refund!\n</code></pre> <p>Property-based testing with Hypothesis can't easily find this because:</p> <ol> <li>Stateful testing is hard: You need <code>RuleBasedStateMachine</code>, which is verbose</li> <li>No automatic rollback: Can't branch from intermediate states</li> <li>Sequence exploration isn't the focus: Hypothesis optimizes for input diversity, not path coverage</li> </ol>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#order-dependent-bugs","title":"Order-Dependent Bugs","text":"Python<pre><code># These work in isolation\nupdate_user(user_id, role=\"admin\")   # \u2713\ndelete_user(user_id)                  # \u2713\n\n# But this sequence exposes a bug\ndelete_user(user_id)\nupdate_user(user_id, role=\"admin\")    # \ud83d\udca5 Updates deleted user!\n</code></pre> <p>Hypothesis can test stateful systems with <code>RuleBasedStateMachine</code>, but it's:</p> Python<pre><code>class PaymentMachine(RuleBasedStateMachine):\n    def __init__(self):\n        super().__init__()\n        self.orders = {}\n\n    @rule(amount=st.integers(min_value=1, max_value=10000))\n    def create(self, amount):\n        order_id = create_order(amount)\n        self.orders[order_id] = amount\n\n    @rule(order_id=st.sampled_from(...))\n    def refund(self, order_id):\n        # But how do we test refund -&gt; refund?\n        # How do we branch and explore ALL sequences?\n        pass\n</code></pre> <p>It works, but it's not designed for exhaustive sequence exploration.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#multi-step-workflows","title":"Multi-Step Workflows","text":"Python<pre><code># E-commerce checkout flow\nadd_to_cart(item_id)      # State: cart has item\napply_coupon(\"SAVE20\")    # State: discount applied\ncheckout()                # State: order created\nship_order()              # State: order shipped\ndeliver_order()           # State: order delivered\ncancel_order()            # \ud83d\udca5 Can't cancel delivered order!\n</code></pre> <p>Testing <code>cancel</code> at each state requires: - 5 different starting states - Each state has different valid next actions - Combinatorial explosion of paths</p> <p>Property-based testing doesn't provide tools for systematic state graph exploration.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#4-venomqas-approach","title":"4. VenomQA's Approach","text":"<p>VenomQA was designed specifically for sequence exploration with automatic state management.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#focused-on-sequences-not-inputs","title":"Focused on Sequences, Not Inputs","text":"Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, World\nfrom venomqa.adapters.http import HttpClient\n\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None  # Skip - precondition not met\n    return api.post(f\"/orders/{order_id}/refund\")\n\napi = HttpClient(base_url=\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\nagent = Agent(\n    world=world,\n    actions=[\n        Action(name=\"create_order\", execute=create_order),\n        Action(name=\"refund_order\", execute=refund_order),\n    ],\n    invariants=[...],\n    strategy=BFS(),\n    max_steps=50,\n)\n\nagent.explore()\n</code></pre> <p>VenomQA will explore: - <code>create_order</code> - <code>create_order \u2192 refund_order</code> - <code>create_order \u2192 refund_order \u2192 refund_order</code> (finds double refund bug!) - And more paths...</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#state-graph-exploration","title":"State Graph Exploration","text":"<p>VenomQA treats your API as a directed graph:</p> Text Only<pre><code>         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502   START     \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502 create_order\n                \u25bc\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 order_id=123\u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502         \u2502\n   refund  \u2502         \u2502 refund\n           \u25bc         \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 refunded \u2502  \u2502 double refund\u2502 \u2190 BUG!\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#database-rollback-for-branching","title":"Database Rollback for Branching","text":"<p>The key innovation: database savepoints let VenomQA branch and reset:</p> Python<pre><code># Explore path: create \u2192 refund \u2192 refund\ncheckpoint()        # Save state\nrefund_order()      # First refund\nrefund_order()      # Second refund - find bug!\nrollback()          # Reset to before refunds\n\n# Now explore: create \u2192 cancel\ncancel_order()      # Different path from same state\n</code></pre> <p>Without rollback, you'd need to: 1. Start fresh server 2. Recreate all state 3. Run one path 4. Repeat for each path</p> <p>With rollback: one test run, thousands of paths explored.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#5-comparison-table","title":"5. Comparison Table","text":"Aspect Hypothesis VenomQA Focus Input fuzzing Sequence exploration State Stateless (or manual stateful) Stateful with auto-rollback Rollback No built-in rollback Database savepoint/restore Test Style Generate random inputs Explore action sequences Bug Type Edge cases in parsing/validation Workflow logic bugs Best For Libraries, parsers, pure functions APIs, state machines, workflows Learning Curve Low (decorators) Medium (actions/invariants) Stateful Testing Via <code>RuleBasedStateMachine</code> Native design Shrinking Yes (minimal failing input) Yes (minimal failing sequence) Integration Pytest plugin Standalone + reporters","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#6-using-both-together","title":"6. Using Both Together","text":"<p>The best testing strategy uses both tools for their strengths.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#hypothesis-for-input-validation","title":"Hypothesis for Input Validation","text":"Python<pre><code># tests/test_schemas.py\nfrom hypothesis import given, strategies as st\n\n@given(st.integers(min_value=1, max_value=1000000))\ndef test_order_amount_valid(amount):\n    \"\"\"Ensure amount validation handles all edge cases.\"\"\"\n    order = create_order_sync(amount)\n    assert order.amount == amount\n\n@given(st.text())\ndef test_product_name_never_crashes(name):\n    \"\"\"Fuzz product names for injection/crashes.\"\"\"\n    product = create_product(name)\n    assert product is not None\n</code></pre>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#venomqa-for-workflow-testing","title":"VenomQA for Workflow Testing","text":"Python<pre><code># tests/test_workflows.py\nfrom venomqa import Action, Agent, BFS, Invariant, World\n\n# Define workflow actions\nactions = [\n    Action(name=\"create_order\", execute=create_order),\n    Action(name=\"refund_order\", execute=refund_order),\n    Action(name=\"cancel_order\", execute=cancel_order),\n    Action(name=\"ship_order\", execute=ship_order),\n]\n\n# Define invariants\ninvariants = [\n    Invariant(\n        name=\"no_500_errors\",\n        check=lambda world: world.context.get(\"last_status\", 200) &lt; 500,\n    ),\n    Invariant(\n        name=\"order_consistency\",\n        check=check_order_state_consistent,\n    ),\n]\n\n# Run exploration\nagent = Agent(\n    world=World(api=api, state_from_context=[\"order_id\"]),\n    actions=actions,\n    invariants=invariants,\n    strategy=BFS(),\n    max_steps=100,\n)\nresult = agent.explore()\n</code></pre>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#example-ci-setup","title":"Example CI Setup","text":"YAML<pre><code># .github/workflows/test.yml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  unit-and-property:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Run tests with Hypothesis\n        run: pytest tests/ --hypothesis-profile=ci\n\n  workflow-exploration:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_PASSWORD: test\n      api:\n        image: myapp:test\n    steps:\n      - uses: actions/checkout@v4\n      - name: Run VenomQA exploration\n        run: venomqa run --config venomqa.yaml --max-steps 500\n</code></pre> <p>Run Hypothesis on every commit (fast, catches input bugs). Run VenomQA nightly or on PRs (slower, catches workflow bugs).</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#7-when-to-choose-which","title":"7. When to Choose Which","text":"","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#use-hypothesis-when","title":"Use Hypothesis When:","text":"<ul> <li>\u2705 Testing pure functions (no state)</li> <li>\u2705 Fuzzing input parsers (JSON, CSV, custom formats)</li> <li>\u2705 Validating schemas with many edge cases</li> <li>\u2705 Testing type boundaries (int overflow, string lengths)</li> <li>\u2705 You need fast feedback in unit tests</li> <li>\u2705 Your code is mostly stateless logic</li> </ul> <p>Example: A JSON parser, a date formatting library, a calculator API.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#use-venomqa-when","title":"Use VenomQA When:","text":"<ul> <li>\u2705 Testing stateful APIs (CRUD, e-commerce, payments)</li> <li>\u2705 Finding bugs in workflows (checkout flows, approval chains)</li> <li>\u2705 Testing order-dependent behavior</li> <li>\u2705 Exploring all possible paths through a system</li> <li>\u2705 You have a database that supports savepoints</li> <li>\u2705 Testing multi-step user journeys</li> </ul> <p>Example: A payment processor, an e-commerce platform, a booking system.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#use-both-when","title":"Use Both When:","text":"<ul> <li>\u2705 You have a stateful API with complex input validation</li> <li>\u2705 You want comprehensive coverage of both inputs and workflows</li> <li>\u2705 You're building a critical system where bugs are expensive</li> <li>\u2705 You have time for thorough testing in CI</li> </ul> <p>Example: A fintech API, a healthcare system, an e-commerce platform.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#summary","title":"Summary","text":"Testing Need Tool \"Does this function handle weird inputs?\" Hypothesis \"Does this workflow handle all sequences?\" VenomQA \"Both!\" Use both <p>Property-based testing and stateful exploration are complementary, not competing. Hypothesis finds bugs in what data you accept. VenomQA finds bugs in what sequences of operations you support.</p> <p>Use them together for a testing strategy that covers both the input space and the state space.</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-01-property-based-testing-comparison/#further-reading","title":"Further Reading","text":"<ul> <li>Hypothesis Documentation</li> <li>QuickCheck: A Lightweight Tool for Random Testing</li> <li>VenomQA: Stateful API Testing</li> <li>Testing Stateful Systems with Hypothesis</li> </ul> <p>Keywords: property-based testing, Hypothesis Python, QuickCheck, generative testing, fuzzing, stateful testing, API testing, sequence exploration</p>","tags":["property-based-testing","hypothesis","quickcheck","generative-testing","fuzzing","stateful-testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/","title":"API Testing Tools Comparison: Which One Should You Choose?","text":"<p>Choosing the right API testing tool can feel overwhelming. Do you need contract testing? Load testing? Sequence exploration? Manual testing? The answer depends on what you're building, your team's expertise, and how much time you can invest.</p> <p>This guide compares 6 popular API testing tools to help you make an informed decision.</p>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#quick-overview","title":"Quick Overview","text":"Tool Primary Use Stateful Auto-Generate Tests CI/CD Ready Learning Curve VenomQA Sequence &amp; workflow testing \u2705 Yes (with rollback) \u2705 From OpenAPI \u2705 Yes Medium Schemathesis Contract &amp; schema fuzzing \u274c No \u2705 From OpenAPI \u2705 Yes Low Postman Manual &amp; automated API testing \u274c Manual \u274c No \u26a0\ufe0f Via Newman Low pytest Unit &amp; integration testing \u274c Manual \u274c No \u2705 Yes Low Dredd API contract testing \u274c No \u2705 From API Blueprint \u2705 Yes Medium Karate BDD-style API testing \u26a0\ufe0f Limited \u274c No \u2705 Yes Medium","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#tool-by-tool-deep-dive","title":"Tool-by-Tool Deep Dive","text":"","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#1-venomqa","title":"1. VenomQA","text":"<p>Best for: Finding bugs in API workflows and sequences</p> <p>VenomQA is designed for stateful API testing. Instead of testing endpoints in isolation, it explores sequences of operations to find bugs that only appear in specific orderings.</p>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#strengths","title":"Strengths","text":"<ul> <li>Sequence exploration: Automatically tests <code>create \u2192 refund \u2192 refund</code> and thousands of other paths</li> <li>Database rollback: Uses PostgreSQL SAVEPOINTs to reset state between test paths</li> <li>State graph coverage: Explores the entire state space systematically</li> <li>Invariant checking: Define rules that must always hold, regardless of sequence</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#code-example","title":"Code Example","text":"Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, World\nfrom venomqa.adapters.http import HttpClient\n\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None\n    return api.post(f\"/orders/{order_id}/refund\")\n\napi = HttpClient(base_url=\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\nagent = Agent(\n    world=world,\n    actions=[\n        Action(name=\"create_order\", execute=create_order),\n        Action(name=\"refund_order\", execute=refund_order),\n    ],\n    invariants=[\n        Invariant(\n            name=\"no_500_errors\",\n            check=lambda world: world.context.get(\"last_status\", 200) &lt; 500,\n        ),\n    ],\n    strategy=BFS(),\n    max_steps=50,\n)\n\nresult = agent.explore()\nprint(f\"Found {len(result.violations)} violations in {result.states_visited} states\")\n</code></pre>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#ideal-use-cases","title":"Ideal Use Cases","text":"<ul> <li>Payment systems with complex refund/cancel flows</li> <li>E-commerce platforms with order state machines</li> <li>Any API where order of operations matters</li> <li>Finding bugs that unit tests miss</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#limitations","title":"Limitations","text":"<ul> <li>Requires database that supports savepoints (PostgreSQL, SQLite)</li> <li>Not designed for load/performance testing</li> <li>More setup than schema-based fuzzers</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#2-schemathesis","title":"2. Schemathesis","text":"<p>Best for: Schema compliance and input fuzzing</p> <p>Schemathesis automatically generates test cases from your OpenAPI specification. It focuses on finding inputs that violate your API's contract.</p>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#strengths_1","title":"Strengths","text":"<ul> <li>Zero setup: Point it at your OpenAPI spec and run</li> <li>Automatic fuzzing: Generates thousands of edge case inputs</li> <li>Schema validation: Catches responses that don't match your spec</li> <li>Great CI integration: Built-in GitHub Actions, GitLab CI templates</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#code-example_1","title":"Code Example","text":"Bash<pre><code># CLI usage - simplest approach\npip install schemathesis\nst run http://localhost:8000/openapi.json\n\n# Python API for more control\nimport schemathesis\nfrom hypothesis import settings\n\nschema = schemathesis.from_path(\"openapi.yaml\")\n\n@schema.parametrize()\n@settings(max_examples=100)\ndef test_api(case):\n    response = case.call()\n    case.validate_response(response)\n</code></pre>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#ideal-use-cases_1","title":"Ideal Use Cases","text":"<ul> <li>Validating OpenAPI spec compliance</li> <li>Finding input validation bugs</li> <li>Contract testing between services</li> <li>Quick setup for new APIs</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#limitations_1","title":"Limitations","text":"<ul> <li>Doesn't test sequences of operations</li> <li>Stateful testing requires manual setup</li> <li>Doesn't catch business logic bugs</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#3-postman","title":"3. Postman","text":"<p>Best for: Manual API testing and team collaboration</p> <p>Postman is the most widely-used API testing tool. It provides a GUI for building requests, organizing collections, and sharing tests with your team.</p>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#strengths_2","title":"Strengths","text":"<ul> <li>Visual interface: Build tests without coding</li> <li>Team collaboration: Share collections, environments, workspaces</li> <li>Extensive features: Mock servers, API documentation, monitoring</li> <li>Large ecosystem: Pre-built collections for popular APIs</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#code-example_2","title":"Code Example","text":"JavaScript<pre><code>// Postman test script (JavaScript)\npm.test(\"Status code is 200\", function () {\n    pm.response.to.have.status(200);\n});\n\npm.test(\"Response has order ID\", function () {\n    const json = pm.response.json();\n    pm.expect(json).to.have.property(\"id\");\n    pm.environment.set(\"order_id\", json.id);\n});\n\n// Test sequence: use order_id in next request\n// GET /orders/{{order_id}}\n</code></pre>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#ideal-use-cases_2","title":"Ideal Use Cases","text":"<ul> <li>Manual API exploration and debugging</li> <li>Team-based API development</li> <li>Non-developers who need to test APIs</li> <li>API documentation and mocking</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#limitations_2","title":"Limitations","text":"<ul> <li>Manual test writing (doesn't auto-generate)</li> <li>CI/CD requires Newman CLI (extra setup)</li> <li>Not designed for exhaustive exploration</li> <li>Sequences require manual chaining</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#4-pytest","title":"4. pytest","text":"<p>Best for: Python developers building comprehensive test suites</p> <p>pytest is the de facto standard for Python testing. While not API-specific, its flexibility makes it a solid choice for API testing when combined with <code>requests</code> or <code>httpx</code>.</p>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#strengths_3","title":"Strengths","text":"<ul> <li>Familiar to Python developers: No new tool to learn</li> <li>Excellent fixtures: Setup/teardown for database, auth, etc.</li> <li>Huge plugin ecosystem: pytest-asyncio, pytest-django, hypothesis integration</li> <li>Powerful assertions: Detailed failure messages</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#code-example_3","title":"Code Example","text":"Python<pre><code>import pytest\nimport httpx\n\n@pytest.fixture\ndef api_client():\n    return httpx.Client(base_url=\"http://localhost:8000\")\n\n@pytest.fixture\ndef auth_headers():\n    return {\"Authorization\": \"Bearer test-token\"}\n\ndef test_create_order(api_client, auth_headers):\n    response = api_client.post(\n        \"/orders\",\n        json={\"amount\": 100},\n        headers=auth_headers\n    )\n    assert response.status_code == 201\n    data = response.json()\n    assert \"id\" in data\n\ndef test_refund_order(api_client, auth_headers):\n    # Create order first\n    order = api_client.post(\"/orders\", json={\"amount\": 100}, headers=auth_headers)\n    order_id = order.json()[\"id\"]\n\n    # Then refund\n    response = api_client.post(f\"/orders/{order_id}/refund\", headers=auth_headers)\n    assert response.status_code == 200\n</code></pre>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#ideal-use-cases_3","title":"Ideal Use Cases","text":"<ul> <li>Teams already using pytest</li> <li>APIs built with Python frameworks (FastAPI, Django, Flask)</li> <li>Integration with existing test infrastructure</li> <li>Custom test scenarios</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#limitations_3","title":"Limitations","text":"<ul> <li>Manual test writing</li> <li>No automatic test generation</li> <li>Sequence testing requires explicit setup</li> <li>No built-in state management</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#5-dredd","title":"5. Dredd","text":"<p>Best for: API Blueprint contract testing</p> <p>Dredd validates your API implementation against its documentation. It's particularly popular with teams using API Blueprint format.</p>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#strengths_4","title":"Strengths","text":"<ul> <li>Documentation-driven: Tests verify docs match reality</li> <li>API Blueprint &amp; OpenAPI: Supports both formats</li> <li>Hooks for setup: Prepare database state before tests</li> <li>CI/CD friendly: Designed for automated pipelines</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#code-example_4","title":"Code Example","text":"YAML<pre><code># dredd.yml\ndry-run: null\nhookfiles: hooks.py\nlanguage: python\nserver: python app.py\nserver-wait: 3\ninit: false\ncustom: {}\nnames: false\nonly: []\nreporter: apiary\noutput: []\nheader: []\nsorted: false\nuser: null\ninline-errors: false\ndetails: false\nmethod: []\ncolor: true\nlevel: info\ntimestamp: false\nsilent: false\npath: []\nblueprint: apiary.apib\nendpoint: 'http://localhost:3000'\n</code></pre> Python<pre><code># hooks.py - setup/teardown for Dredd tests\nimport dredd_hooks as hooks\n\n@hooks.before_each\ndef my_hook(transaction):\n    # Setup test data before each request\n    transaction['request']['headers']['Authorization'] = 'Bearer test-token'\n</code></pre>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#ideal-use-cases_4","title":"Ideal Use Cases","text":"<ul> <li>API Blueprint users</li> <li>Documentation-first development</li> <li>Catching API drift</li> <li>Contract testing</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#limitations_4","title":"Limitations","text":"<ul> <li>Primarily for contract testing, not exploration</li> <li>Limited to documented endpoints</li> <li>Hooks can become complex</li> <li>Less active development recently</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#6-karate","title":"6. Karate","text":"<p>Best for: BDD-style API testing with minimal code</p> <p>Karate combines API testing, UI automation, and performance testing in a BDD-style framework. Tests are written in Gherkin-like syntax without requiring Java knowledge.</p>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#strengths_5","title":"Strengths","text":"<ul> <li>No Java knowledge needed: Tests written in domain-specific language</li> <li>All-in-one: API, UI, and performance testing</li> <li>Data-driven testing: Built-in support for parameterization</li> <li>Rich assertions: JSON/XML path matching built-in</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#code-example_5","title":"Code Example","text":"Gherkin<pre><code># order-api.feature\nFeature: Order API Testing\n\nBackground:\n  * url 'http://localhost:8000'\n  * header Authorization = 'Bearer ' + authToken\n\nScenario: Create and refund order\n  Given path 'orders'\n  And request { amount: 100 }\n  When method post\n  Then status 201\n  And match response contains { id: '#number' }\n\n  * def orderId = response.id\n\n  Given path 'orders', orderId, 'refund'\n  When method post\n  Then status 200\n  And match response.status == 'refunded'\n\nScenario: Double refund should fail\n  Given path 'orders'\n  And request { amount: 100 }\n  When method post\n  Then status 201\n  * def orderId = response.id\n\n  Given path 'orders', orderId, 'refund'\n  When method post\n  Then status 200\n\n  Given path 'orders', orderId, 'refund'\n  When method post\n  Then status 400\n</code></pre>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#ideal-use-cases_5","title":"Ideal Use Cases","text":"<ul> <li>Teams wanting BDD-style tests without code</li> <li>Combining API and UI testing</li> <li>Data-driven test scenarios</li> <li>Teams without strong programming skills</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#limitations_5","title":"Limitations","text":"<ul> <li>Custom DSL has learning curve</li> <li>Debugging can be challenging</li> <li>Less flexible than code-based solutions</li> <li>No automatic test generation</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#comparison-matrix","title":"Comparison Matrix","text":"","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#by-testing-capability","title":"By Testing Capability","text":"Capability VenomQA Schemathesis Postman pytest Dredd Karate Input fuzzing \u26a0\ufe0f Manual \u2705 Auto \u274c No \u26a0\ufe0f Via Hypothesis \u26a0\ufe0f Limited \u26a0\ufe0f Manual Sequence testing \u2705 Native \u274c No \u26a0\ufe0f Manual \u26a0\ufe0f Manual \u274c No \u26a0\ufe0f Manual Contract testing \u274c No \u2705 Yes \u274c No \u274c No \u2705 Yes \u26a0\ufe0f Limited State management \u2705 Rollback \u274c No \u274c No \u26a0\ufe0f Fixtures \u274c No \u26a0\ufe0f Limited Performance testing \u274c No \u274c No \u26a0\ufe0f Limited \u274c No \u274c No \u2705 Yes","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#by-team-fit","title":"By Team Fit","text":"Team Type Best Tool(s) Why Python backend team VenomQA + pytest + Schemathesis Native Python, covers sequences and inputs Node.js team Schemathesis + Postman Language-agnostic, easy CI QA team (no coders) Postman + Karate GUI or low-code options Enterprise Java team Karate + Schemathesis BDD + contract testing Startup, move fast Schemathesis Zero setup, catches common bugs Fintech / Critical systems VenomQA + Schemathesis + pytest Comprehensive coverage","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#by-api-type","title":"By API Type","text":"API Type Primary Tool Secondary Tool RESTful CRUD Schemathesis Postman Stateful workflows VenomQA pytest Event-driven / Async pytest Custom GraphQL Postman pytest Microservices Schemathesis + Dredd VenomQA","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#when-to-use-each-tool","title":"When to Use Each Tool","text":"","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#use-venomqa-when","title":"Use VenomQA When:","text":"<ul> <li>\u2705 Your API has complex state machines (orders, payments, bookings)</li> <li>\u2705 Bugs hide in sequences (<code>create \u2192 refund \u2192 refund</code>)</li> <li>\u2705 You have PostgreSQL and want database rollback</li> <li>\u2705 You're finding bugs in production that tests missed</li> <li>\u2705 You need to explore all possible paths through your API</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#use-schemathesis-when","title":"Use Schemathesis When:","text":"<ul> <li>\u2705 You have an OpenAPI spec and want instant test coverage</li> <li>\u2705 You need contract testing between services</li> <li>\u2705 You want to find input validation bugs automatically</li> <li>\u2705 Your team is small and needs low-maintenance testing</li> <li>\u2705 You're getting started with automated API testing</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#use-postman-when","title":"Use Postman When:","text":"<ul> <li>\u2705 Your team includes non-developers who need to test APIs</li> <li>\u2705 You need API documentation and mocking</li> <li>\u2705 Manual exploration is your primary use case</li> <li>\u2705 Collaboration and sharing are priorities</li> <li>\u2705 You're testing third-party APIs</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#use-pytest-when","title":"Use pytest When:","text":"<ul> <li>\u2705 You're a Python team with existing pytest infrastructure</li> <li>\u2705 You need fine-grained control over test scenarios</li> <li>\u2705 You want to integrate with hypothesis for input fuzzing</li> <li>\u2705 Your tests need complex fixtures and setup</li> <li>\u2705 You're testing Python web frameworks (FastAPI, Django, Flask)</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#use-dredd-when","title":"Use Dredd When:","text":"<ul> <li>\u2705 You use API Blueprint format</li> <li>\u2705 Documentation accuracy is a priority</li> <li>\u2705 You need contract testing</li> <li>\u2705 Your API is relatively simple</li> <li>\u2705 You want tests derived from documentation</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#use-karate-when","title":"Use Karate When:","text":"<ul> <li>\u2705 You want BDD-style tests without writing code</li> <li>\u2705 You need API + UI testing in one tool</li> <li>\u2705 Your team prefers declarative test syntax</li> <li>\u2705 You need data-driven testing</li> <li>\u2705 You want performance testing built-in</li> </ul>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#combining-tools-for-comprehensive-coverage","title":"Combining Tools for Comprehensive Coverage","text":"<p>The best API testing strategies use multiple tools together:</p>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#recommended-stack-for-python-apis","title":"Recommended Stack for Python APIs","text":"Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Test Pyramid                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Level 3: Workflow Exploration (VenomQA)            \u2502\n\u2502  - Sequence testing                                  \u2502\n\u2502  - State graph coverage                              \u2502\n\u2502  - Nightly CI runs                                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Level 2: Contract Testing (Schemathesis)           \u2502\n\u2502  - Schema compliance                                 \u2502\n\u2502  - Input fuzzing                                     \u2502\n\u2502  - Every PR                                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Level 1: Unit Tests (pytest)                       \u2502\n\u2502  - Individual endpoint logic                         \u2502\n\u2502  - Business rules                                    \u2502\n\u2502  - Every commit                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#sample-ci-configuration","title":"Sample CI Configuration","text":"YAML<pre><code># .github/workflows/api-tests.yml\nname: API Tests\n\non: [push, pull_request]\n\njobs:\n  unit-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - run: pytest tests/unit -v\n\n  contract-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - run: pip install schemathesis\n      - run: st run http://localhost:8000/openapi.json\n\n  workflow-tests:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n    steps:\n      - uses: actions/checkout@v4\n      - run: pip install venomqa\n      - run: venomqa run --config venomqa.yaml --max-steps 500\n</code></pre>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#decision-flowchart","title":"Decision Flowchart","text":"Text Only<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 Need to test APIs?  \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                \u2502                \u2502\n              \u25bc                \u25bc                \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Have     \u2502    \u2502 Need      \u2502    \u2502 Team     \u2502\n        \u2502 OpenAPI? \u2502    \u2502 sequences?\u2502    \u2502 prefers  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518    \u2502 no code? \u2502\n             \u2502                \u2502          \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502                \u2502               \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n        \u2502         \u2502      \u2502         \u2502     \u2502         \u2502\n        \u25bc         \u25bc      \u25bc         \u25bc     \u25bc         \u25bc\n   Schemathesis  \u2502   VenomQA    \u2502   Postman  Karate\n                 \u2502              \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n            \u2502 Python  \u2502    \u2502 Complex \u2502\n            \u2502 team?   \u2502    \u2502 setup?  \u2502\n            \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n                 \u2502              \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510         \u2502\n            \u2502         \u2502         \u2502\n            \u25bc         \u25bc         \u25bc\n          pytest   Dredd   Manual\n</code></pre>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#summary","title":"Summary","text":"Need Primary Recommendation Quick start with OpenAPI Schemathesis Find workflow bugs VenomQA Team collaboration Postman Python integration pytest Contract testing Dredd or Schemathesis BDD without code Karate Comprehensive coverage VenomQA + Schemathesis + pytest <p>There's no single best tool\u2014the right choice depends on your API's complexity, your team's skills, and what bugs you're trying to prevent.</p> <p>Start simple: Add Schemathesis for contract testing first. Then add VenomQA when you start finding sequence bugs in production. Use pytest for custom scenarios that need fine-grained control.</p>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-05-api-testing-tools-comparison/#further-reading","title":"Further Reading","text":"<ul> <li>VenomQA Documentation</li> <li>Schemathesis Documentation</li> <li>Postman Learning Center</li> <li>pytest Documentation</li> <li>Dredd Documentation</li> <li>Karate Documentation</li> </ul> <p>Keywords: API testing tools, REST API testing, API automation, Schemathesis, Postman, pytest, Dredd, Karate, automated API testing, contract testing, API testing comparison</p>","tags":["API testing tools","REST API testing","API automation","Schemathesis","Postman","pytest","Dredd","Karate","automated testing","contract testing"]},{"location":"blog/2024-02-10-database-rollback-testing/","title":"Database Rollback Testing: The Secret to Exhaustive State Exploration","text":"<p>What if you could test your API against a clean database for every single test case\u2014without waiting for database resets between tests?</p> <p>That's what database rollback testing enables. Instead of recreating state for each test, you create a checkpoint, run your test, and instantly reset to that checkpoint. This makes it practical to test thousands of sequences in seconds.</p> <p>This deep dive covers how rollback testing works, the PostgreSQL mechanics behind it, and why it's essential for stateful API testing.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#the-problem-test-state-contamination","title":"The Problem: Test State Contamination","text":"<p>Traditional API tests have a state contamination problem.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#the-naive-approach","title":"The Naive Approach","text":"Python<pre><code>def test_create_order():\n    response = api.post(\"/orders\", json={\"amount\": 100})\n    assert response.status_code == 201\n    # Database now has order #1\n\ndef test_refund_order():\n    # Database still has order #1 from previous test!\n    response = api.post(\"/orders/1/refund\")  # Which order #1?\n    assert response.status_code == 200\n</code></pre> <p>Tests become dependent on execution order. Run them in a different order, and they fail.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#the-cleanup-approach","title":"The Cleanup Approach","text":"Python<pre><code>@pytest.fixture(autouse=True)\ndef clean_database():\n    # Before test\n    db.execute(\"DELETE FROM orders\")\n    db.execute(\"DELETE FROM users\")\n    yield\n    # After test\n    db.execute(\"DELETE FROM orders\")\n    db.execute(\"DELETE FROM users\")\n</code></pre> <p>Problems:</p> <ol> <li>Slow: DELETE operations take time, especially with foreign keys</li> <li>Incomplete: Easy to miss tables, cascades, triggers</li> <li>Can't branch: Each test starts from empty, can't explore from intermediate states</li> </ol>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#the-reset-database-approach","title":"The Reset Database Approach","text":"Python<pre><code>@pytest.fixture(scope=\"function\")\ndef fresh_db():\n    subprocess.run([\"pg_restore\", \"--clean\", \"test_db.backup\"])\n</code></pre> <p>Problems:</p> <ol> <li>Very slow: Full database restore takes seconds to minutes</li> <li>Resource intensive: I/O heavy</li> <li>Still can't branch: Every test starts from the same baseline</li> </ol>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#the-solution-transaction-rollback","title":"The Solution: Transaction Rollback","text":"<p>The key insight: PostgreSQL transactions can be nested via SAVEPOINTs.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#how-savepoints-work","title":"How SAVEPOINTs Work","text":"SQL<pre><code>BEGIN;\n\n-- Create baseline state\nINSERT INTO users (id, email) VALUES (1, 'test@example.com');\nINSERT INTO products (id, name, price) VALUES (101, 'Widget', 50.00);\n\n-- Create a savepoint\nSAVEPOINT test_checkpoint_1;\n\n-- Make changes\nINSERT INTO orders (id, user_id, product_id, amount) VALUES (1001, 1, 101, 50.00);\n\n-- Oops, want to try a different path\nROLLBACK TO SAVEPOINT test_checkpoint_1;\n\n-- Now try a different path\nINSERT INTO orders (id, user_id, product_id, amount) VALUES (1002, 1, 101, 100.00);\n\nCOMMIT;\n</code></pre> <p>The <code>ROLLBACK TO SAVEPOINT</code> instantly undoes all changes after the savepoint\u2014without committing the transaction or touching disk.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#why-this-matters-for-testing","title":"Why This Matters for Testing","text":"Text Only<pre><code>Test 1: create_order \u2192 refund_order\n        \u251c\u2500\u2500 checkpoint at \"empty DB\"\n        \u251c\u2500\u2500 create_order (order #1 created)\n        \u251c\u2500\u2500 refund_order (order #1 refunded)\n        \u2514\u2500\u2500 rollback to checkpoint (DB empty again!)\n\nTest 2: create_order \u2192 delete_order  \n        \u251c\u2500\u2500 (already at checkpoint \"empty DB\")\n        \u251c\u2500\u2500 create_order (order #1 created)\n        \u251c\u2500\u2500 delete_order (order #1 deleted)\n        \u2514\u2500\u2500 rollback to checkpoint (DB empty again!)\n\nTime: milliseconds, not seconds\n</code></pre> <p>Each test path starts from a known state, but you only set up that state once.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#postgresql-savepoint-mechanics","title":"PostgreSQL SAVEPOINT Mechanics","text":"","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#transaction-fundamentals","title":"Transaction Fundamentals","text":"<p>PostgreSQL transactions are ACID:</p> <ul> <li>Atomic: All or nothing</li> <li>Consistent: Database constraints maintained</li> <li>Isolated: Transactions don't see each other's uncommitted changes</li> <li>Durable: Committed changes survive crashes</li> </ul> <p>For testing, Atomicity and Isolation are key.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#savepoint-syntax","title":"SAVEPOINT Syntax","text":"SQL<pre><code>-- Start transaction (do this once per test session)\nBEGIN;\n\n-- Create initial state\nINSERT INTO users VALUES (1, 'alice');\nSAVEPOINT baseline;\n\n-- Path 1: Create order\nINSERT INTO orders VALUES (100, 1, 'pending');\nSAVEPOINT order_created;\n\n-- Path 1a: Refund the order\nUPDATE orders SET status = 'refunded' WHERE id = 100;\n-- Check invariants here\n\n-- Reset to try different path from order_created\nROLLBACK TO SAVEPOINT order_created;\n\n-- Path 1b: Cancel the order\nUPDATE orders SET status = 'cancelled' WHERE id = 100;\n-- Check invariants here\n\n-- Reset to try different path from baseline\nROLLBACK TO SAVEPOINT baseline;\n\n-- Path 2: Delete user first\nDELETE FROM users WHERE id = 1;\n-- Check invariants here\n\n-- Clean up\nROLLBACK;  -- Or COMMIT if you want to keep changes\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#savepoint-depth-and-naming","title":"Savepoint Depth and Naming","text":"<p>PostgreSQL supports nested savepoints:</p> SQL<pre><code>BEGIN;\nSAVEPOINT level_1;\nSAVEPOINT level_2;\nSAVEPOINT level_3;\n\nROLLBACK TO SAVEPOINT level_2;  -- Undoes level_3 changes\nROLLBACK TO SAVEPOINT level_1;  -- Undoes level_2 changes\n</code></pre> <p>For testing, we typically use a flat checkpoint model:</p> Python<pre><code>class DatabaseCheckpoint:\n    def __init__(self, conn, name):\n        self.conn = conn\n        self.name = name\n\n    def save(self):\n        self.conn.execute(f\"SAVEPOINT {self.name}\")\n\n    def restore(self):\n        self.conn.execute(f\"ROLLBACK TO SAVEPOINT {self.name}\")\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#performance-characteristics","title":"Performance Characteristics","text":"Operation Time (typical) Notes <code>SAVEPOINT</code> &lt; 1ms Just marks a point in WAL <code>ROLLBACK TO SAVEPOINT</code> 1-10ms Undoes in-memory changes <code>BEGIN</code> &lt; 1ms Starts transaction <code>ROLLBACK</code> (full) 1-50ms Depends on amount of changes <code>pg_restore</code> 1-60s Full database restore <p>Rollback is 100-1000x faster than database restore.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#implementing-rollback-testing","title":"Implementing Rollback Testing","text":"","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#basic-postgresql-adapter","title":"Basic PostgreSQL Adapter","text":"Python<pre><code>import psycopg\nfrom contextlib import contextmanager\n\nclass PostgresTestAdapter:\n    def __init__(self, connection_string: str):\n        self.conn_string = connection_string\n        self.conn = None\n        self.checkpoint_counter = 0\n\n    def connect(self):\n        self.conn = psycopg.connect(self.conn_string)\n        self.conn.autocommit = False\n        # Start the long-running transaction\n        self.conn.execute(\"BEGIN\")\n\n    def checkpoint(self) -&gt; str:\n        \"\"\"Create a savepoint and return its name.\"\"\"\n        self.checkpoint_counter += 1\n        name = f\"ckpt_{self.checkpoint_counter}\"\n        self.conn.execute(f\"SAVEPOINT {name}\")\n        return name\n\n    def rollback(self, checkpoint_name: str):\n        \"\"\"Restore to a previously created savepoint.\"\"\"\n        self.conn.execute(f\"ROLLBACK TO SAVEPOINT {checkpoint_name}\")\n\n    @contextmanager\n    def isolated_test(self):\n        \"\"\"Context manager for isolated test execution.\"\"\"\n        checkpoint = self.checkpoint()\n        try:\n            yield\n        finally:\n            self.rollback(checkpoint)\n\n    def close(self):\n        if self.conn:\n            self.conn.execute(\"ROLLBACK\")\n            self.conn.close()\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#using-the-adapter-for-api-testing","title":"Using the Adapter for API Testing","text":"Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\nfrom venomqa.adapters.postgres import PostgresAdapter\n\n# Set up database adapter with rollback support\ndb = PostgresAdapter(\"postgresql://test:test@localhost/test_db\")\ndb.connect()\n\n# Seed baseline data\ndb.execute(\"INSERT INTO products (id, name, price) VALUES (1, 'Widget', 100)\")\ncheckpoint_id = db.checkpoint()  # Save baseline state\n\n# Define API actions\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"product_id\": 1, \"quantity\": 1})\n    if resp.status_code == 201:\n        context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None\n    return api.post(f\"/orders/{order_id}/refund\")\n\ndef cancel_order(api, context):\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None\n    return api.post(f\"/orders/{order_id}/cancel\")\n\n# Define invariants\ninvariants = [\n    Invariant(\n        name=\"no_server_errors\",\n        check=lambda world: world.context.get(\"last_status\", 200) &lt; 500,\n        severity=Severity.CRITICAL,\n    ),\n    Invariant(\n        name=\"refunded_orders_unchangeable\",\n        check=lambda world: not (\n            context.get(\"order_refunded\") and\n            context.get(\"last_action\") in [\"cancel_order\", \"ship_order\"]\n        ),\n        severity=Severity.HIGH,\n    ),\n]\n\n# Create world with database rollback\napi = HttpClient(base_url=\"http://localhost:8000\")\nworld = World(\n    api=api,\n    systems={\"db\": db},  # Pass the database adapter\n)\n\n# Run exploration\nagent = Agent(\n    world=world,\n    actions=[\n        Action(name=\"create_order\", execute=create_order),\n        Action(name=\"refund_order\", execute=refund_order),\n        Action(name=\"cancel_order\", execute=cancel_order),\n    ],\n    invariants=invariants,\n    strategy=BFS(),\n    max_steps=100,\n)\n\nresult = agent.explore()\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#how-venomqa-uses-rollback","title":"How VenomQA Uses Rollback","text":"<p>VenomQA's agent explores paths like this:</p> Text Only<pre><code>Path 1: create_order \u2192 refund_order\n  1. checkpoint() \u2192 \"path_1_start\"\n  2. create_order() \u2192 order #1 created\n  3. refund_order() \u2192 order #1 refunded \u2713\n  4. check invariants \u2713\n  5. rollback(\"path_1_start\") \u2192 DB reset\n\nPath 2: create_order \u2192 refund_order \u2192 refund_order  \n  1. (start from previous checkpoint or create new)\n  2. create_order() \u2192 order #1 created\n  3. refund_order() \u2192 order #1 refunded \u2713\n  4. refund_order() \u2192 \ud83d\udca5 500 ERROR!\n  5. check invariants \u2192 VIOLATION FOUND\n  6. rollback() \u2192 DB reset\n</code></pre> <p>Every path starts clean, but the baseline setup happens only once.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#why-rollback-enables-parallel-exploration","title":"Why Rollback Enables Parallel Exploration","text":"","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#the-branching-problem","title":"The Branching Problem","text":"<p>Consider testing all sequences of 3 actions from a state:</p> Text Only<pre><code>                \u250c\u2500\u2500\u2500 A \u2500\u2500\u2500\u2510\n                \u2502         \u2502\n         \u250c\u2500\u2500 B \u253c\u2500\u2500\u2500 B \u2500\u2500\u2500\u253c\u2500\u2500 B \u2500\u2500\u2500\u2510\n         \u2502     \u2502         \u2502        \u2502\n    START     \u2514\u2500\u2500\u2500 C \u2500\u2500\u2500\u2518        END\n         \u2502                          \n         \u2514\u2500\u2500 C \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Without rollback, you'd need to:</p> <ol> <li>Reset database</li> <li>Run <code>START \u2192 A \u2192 B</code></li> <li>Reset database  </li> <li>Run <code>START \u2192 A \u2192 C</code></li> <li>Reset database</li> <li>Run <code>START \u2192 B \u2192 ...</code></li> <li>And so on...</li> </ol> <p>With rollback:</p> <ol> <li>Checkpoint at <code>START</code></li> <li>Run <code>START \u2192 A</code> \u2192 checkpoint</li> <li>Run <code>A \u2192 B</code> \u2192 rollback to <code>A</code></li> <li>Run <code>A \u2192 C</code> \u2192 rollback to <code>START</code></li> <li>Run <code>START \u2192 B</code> \u2192 checkpoint</li> <li>And so on...</li> </ol> <p>Each branch point can be explored without full resets.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#memory-considerations","title":"Memory Considerations","text":"<p>PostgreSQL maintains transaction state in memory and WAL (Write-Ahead Log):</p> Text Only<pre><code>Memory: Modified pages held in shared_buffers\nWAL: All changes logged to disk (but not applied to tables)\n</code></pre> <p>For test databases, this is typically fine:</p> <ul> <li>1000 test paths \u00d7 10 rows modified = ~10,000 rows in transaction</li> <li>Memory impact: ~10-50MB</li> <li>WAL growth: ~100MB (temp files, discarded on rollback)</li> </ul> <p>Best practice: For very long test runs, periodically commit and start a new transaction:</p> Python<pre><code>if test_count % 1000 == 0:\n    db.execute(\"ROLLBACK\")  # End transaction\n    db.execute(\"BEGIN\")     # Start fresh\n    seed_baseline_data()\n    db.checkpoint()         # New baseline\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#rollback-vs-other-approaches","title":"Rollback vs Other Approaches","text":"","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#comparison-table","title":"Comparison Table","text":"Approach Speed Isolation Branching Setup Complexity TRUNCATE/DELETE Slow (100ms-1s) Good No Low Database restore Very slow (1-60s) Perfect No Medium Docker containers Medium (1-5s) Perfect Limited High Transaction ROLLBACK Fast (1-10ms) Perfect Yes Low SAVEPOINT rollback Very fast (&lt; 1ms) Perfect Yes Low","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#when-rollback-isnt-enough","title":"When Rollback Isn't Enough","text":"<p>Rollback doesn't help with:</p> <ol> <li>External services: Stripe, SendGrid, etc. can't be rolled back</li> <li>File system changes: Uploaded files persist</li> <li>Non-transactional databases: MongoDB, Redis (without special handling)</li> <li>Asynchronous operations: Jobs that have already been queued</li> </ol> <p>For these cases, use mocking or dedicated test accounts.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#advanced-patterns","title":"Advanced Patterns","text":"","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#nested-rollback-for-state-trees","title":"Nested Rollback for State Trees","text":"Python<pre><code>class StateTreeExplorer:\n    def __init__(self, db):\n        self.db = db\n        self.checkpoints = {}  # state_id -&gt; checkpoint_name\n\n    def explore_from(self, state_id, actions):\n        \"\"\"Explore all actions from a given state.\"\"\"\n        if state_id not in self.checkpoints:\n            self.checkpoints[state_id] = self.db.checkpoint()\n\n        for action in actions:\n            self.db.rollback(self.checkpoints[state_id])\n            result = action.execute()\n            new_state_id = f\"{state_id}_{action.name}\"\n            self.checkpoints[new_state_id] = self.db.checkpoint()\n            yield new_state_id, result\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#selective-rollback-with-release","title":"Selective Rollback with Release","text":"<p>PostgreSQL supports <code>RELEASE SAVEPOINT</code> to free memory:</p> SQL<pre><code>SAVEPOINT temp_check;\n-- Do some work\nROLLBACK TO SAVEPOINT temp_check;\nRELEASE SAVEPOINT temp_check;  -- Free the savepoint memory\n</code></pre> <p>For long exploration runs:</p> Python<pre><code>def explore_with_cleanup(db, max_depth=10):\n    stack = [(\"start\", db.checkpoint())]\n\n    while stack:\n        state_id, checkpoint = stack.pop()\n\n        if len(state_id.split(\"_\")) &gt;= max_depth:\n            db.execute(f\"RELEASE SAVEPOINT {checkpoint}\")\n            continue\n\n        for action in get_actions():\n            db.rollback(checkpoint)\n            result = action.execute()\n            new_ckpt = db.checkpoint()\n            stack.append((f\"{state_id}_{action.name}\", new_ckpt))\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#multi-database-rollback","title":"Multi-Database Rollback","text":"<p>For microservices with multiple databases:</p> Python<pre><code>class MultiDatabaseCheckpoint:\n    def __init__(self, databases: dict):\n        self.databases = databases  # name -&gt; adapter\n\n    def checkpoint(self) -&gt; dict:\n        \"\"\"Create checkpoints across all databases.\"\"\"\n        return {\n            name: db.checkpoint()\n            for name, db in self.databases.items()\n        }\n\n    def rollback(self, checkpoints: dict):\n        \"\"\"Rollback all databases to their checkpoints.\"\"\"\n        for name, ckpt in checkpoints.items():\n            self.databases[name].rollback(ckpt)\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#testing-best-practices-with-rollback","title":"Testing Best Practices with Rollback","text":"","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#1-seed-data-once","title":"1. Seed Data Once","text":"Python<pre><code># Good: Seed once at session start\n@pytest.fixture(scope=\"session\")\ndef db_with_baseline():\n    db = PostgresAdapter(CONNECTION_STRING)\n    db.connect()\n    seed_reference_data(db)  # Products, categories, etc.\n    db.checkpoint(\"baseline\")\n    yield db\n    db.close()\n\n# Bad: Seed for every test\n@pytest.fixture\ndef db_fresh():\n    db = PostgresAdapter(CONNECTION_STRING)\n    seed_reference_data(db)  # Wasteful!\n    yield db\n    db.close()\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#2-use-deterministic-ids","title":"2. Use Deterministic IDs","text":"Python<pre><code># Good: Predictable IDs for assertions\ndef test_create_order(db_with_baseline):\n    with db_with_baseline.isolated_test():\n        order_id = create_order(product_id=1)\n        assert order_id == expected_id  # Know what to expect\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#3-check-invariants-after-rollback","title":"3. Check Invariants After Rollback","text":"Python<pre><code>def test_rollback_restores_state(db_adapter):\n    db_adapter.execute(\"INSERT INTO orders VALUES (1, ...)\")\n    checkpoint = db_adapter.checkpoint()\n\n    db_adapter.execute(\"DELETE FROM orders\")\n    assert count_orders() == 0\n\n    db_adapter.rollback(checkpoint)\n    assert count_orders() == 1  # Restored!\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#4-monitor-transaction-size","title":"4. Monitor Transaction Size","text":"Python<pre><code>def test_long_running_exploration(db_adapter):\n    for i in range(10000):\n        with db_adapter.isolated_test():\n            create_and_delete_test_data()\n\n        if i % 1000 == 0:\n            # Check transaction isn't growing unboundedly\n            size = db_adapter.execute(\n                \"SELECT pg_transaction_size()\").scalar()\n            assert size &lt; 100_000_000  # 100MB limit\n</code></pre>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#conclusion","title":"Conclusion","text":"<p>Database rollback via PostgreSQL SAVEPOINTs enables a fundamentally different approach to testing:</p> <ol> <li>Speed: Milliseconds instead of seconds per test isolation</li> <li>Branching: Explore multiple paths from intermediate states</li> <li>Simplicity: No cleanup code needed, no state contamination</li> <li>Coverage: Test thousands of sequences that would be impractical otherwise</li> </ol> <p>This is the core technology that makes VenomQA's exhaustive state exploration possible. By treating your database as a mutable sandbox that can be instantly reset, you can test every path through your API's state machine\u2014not just the happy paths you thought to write tests for.</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-10-database-rollback-testing/#further-reading","title":"Further Reading","text":"<ul> <li>PostgreSQL SAVEPOINT Documentation</li> <li>PostgreSQL Transaction Isolation</li> <li>VenomQA Architecture Guide</li> <li>Test Isolation Strategies</li> </ul> <p>Keywords: database testing, test isolation, PostgreSQL testing, SAVEPOINT, transaction rollback, stateful testing, API testing, database checkpoint, PostgreSQL transaction</p>","tags":["database testing","test isolation","PostgreSQL testing","SAVEPOINT","transaction rollback","stateful testing","API testing"]},{"location":"blog/2024-02-15-ci-cd-api-testing/","title":"CI/CD API Testing: From Local to Production","text":"<p>API testing in CI/CD is the difference between catching bugs before they ship and waking up to production incidents at 3 AM.</p> <p>This guide covers everything you need to set up comprehensive API testing in your CI/CD pipeline:</p> <ul> <li>Test environment setup with Docker Compose</li> <li>GitHub Actions, GitLab CI, and Jenkins configurations</li> <li>Test reporting and notifications</li> <li>Strategies for different testing phases</li> </ul>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#the-cicd-testing-landscape","title":"The CI/CD Testing Landscape","text":"","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#testing-stages","title":"Testing Stages","text":"Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        CI/CD Pipeline                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  Commit \u2500\u2500\u25ba Build \u2500\u2500\u25ba Unit Tests \u2500\u2500\u25ba API Tests \u2500\u2500\u25ba Deploy       \u2502\n\u2502                           \u2502              \u2502                       \u2502\n\u2502                           \u2502              \u251c\u2500\u2500 Contract Tests      \u2502\n\u2502                           \u2502              \u251c\u2500\u2500 Integration Tests   \u2502\n\u2502                           \u2502              \u2514\u2500\u2500 Workflow Tests      \u2502\n\u2502                           \u2502                                      \u2502\n\u2502                        &lt; 5 min       5-30 min                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#testing-types-in-ci","title":"Testing Types in CI","text":"Test Type Speed Coverage When to Run Unit Tests Fast (seconds) Individual functions Every commit Contract Tests Medium (1-5 min) API schema compliance Every PR Integration Tests Medium (5-15 min) Service interactions Every PR Workflow Tests Slower (15-30 min) End-to-end sequences Nightly / main branch Performance Tests Slow (30+ min) Load and latency Weekly / releases","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#test-environment-setup","title":"Test Environment Setup","text":"","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#docker-compose-for-ci","title":"Docker Compose for CI","text":"<p>Create a reproducible test environment:</p> YAML<pre><code># docker-compose.test.yml\nversion: '3.8'\n\nservices:\n  api:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - \"8000:8000\"\n    environment:\n      - DATABASE_URL=postgresql://test:test@postgres:5432/testdb\n      - REDIS_URL=redis://redis:6379\n      - ENVIRONMENT=testing\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_started\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 5s\n      timeout: 3s\n      retries: 10\n\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      - POSTGRES_USER=test\n      - POSTGRES_PASSWORD=test\n      - POSTGRES_DB=testdb\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U test -d testdb\"]\n      interval: 2s\n      timeout: 2s\n      retries: 10\n\n  redis:\n    image: redis:7-alpine\n\n  # Test runner container\n  test-runner:\n    build:\n      context: .\n      dockerfile: Dockerfile.test\n    environment:\n      - API_URL=http://api:8000\n      - DATABASE_URL=postgresql://test:test@postgres:5432/testdb\n    depends_on:\n      api:\n        condition: service_healthy\n    volumes:\n      - ./test-results:/results\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#test-runner-dockerfile","title":"Test Runner Dockerfile","text":"Docker<pre><code># Dockerfile.test\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Install test dependencies\nCOPY requirements-test.txt .\nRUN pip install --no-cache-dir -r requirements-test.txt\n\n# Copy test configuration\nCOPY venomqa.yaml .\nCOPY tests/ ./tests/\n\n# Default command\nCMD [\"venomqa\", \"run\", \"--config\", \"venomqa.yaml\", \"--output\", \"/results\"]\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#venomqa-configuration-for-ci","title":"VenomQA Configuration for CI","text":"YAML<pre><code># venomqa.yaml\napi:\n  base_url: ${API_URL:-http://localhost:8000}\n  timeout: 30\n\ndatabase:\n  url: ${DATABASE_URL:-postgresql://test:test@localhost:5432/testdb}\n\nactions:\n  - name: create_order\n    method: POST\n    path: /orders\n    body:\n      amount: 100\n      product_id: 1\n    capture:\n      order_id: \"$.id\"\n\n  - name: refund_order\n    method: POST\n    path: /orders/{order_id}/refund\n    requires:\n      - order_id\n\n  - name: cancel_order\n    method: POST\n    path: /orders/{order_id}/cancel\n    requires:\n      - order_id\n\ninvariants:\n  - name: no_500_errors\n    severity: critical\n    check: \"response.status &lt; 500\"\n\n  - name: response_time_under_5s\n    severity: warning\n    check: \"response.time &lt; 5000\"\n\nexploration:\n  strategy: bfs\n  max_steps: 500\n  max_depth: 10\n\nreporting:\n  output_dir: /results\n  formats:\n    - json\n    - html\n    - junit\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#github-actions-configuration","title":"GitHub Actions Configuration","text":"","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#basic-api-testing-workflow","title":"Basic API Testing Workflow","text":"YAML<pre><code># .github/workflows/api-tests.yml\nname: API Tests\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  contract-tests:\n    name: Contract Tests\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n          cache: 'pip'\n\n      - name: Install dependencies\n        run: |\n          pip install schemathesis\n\n      - name: Start API\n        run: |\n          docker-compose -f docker-compose.test.yml up -d api postgres\n          sleep 10\n\n      - name: Run contract tests\n        run: |\n          st run http://localhost:8000/openapi.json \\\n            --checks all \\\n            --max-examples 100 \\\n            --report junit.xml \\\n            --report-html report/\n\n      - name: Upload results\n        uses: actions/upload-artifact@v4\n        if: always()\n        with:\n          name: contract-test-results\n          path: |\n            junit.xml\n            report/\n\n      - name: Cleanup\n        if: always()\n        run: docker-compose -f docker-compose.test.yml down -v\n\n  workflow-tests:\n    name: Workflow Tests (VenomQA)\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n          cache: 'pip'\n\n      - name: Install VenomQA\n        run: pip install venomqa\n\n      - name: Run test environment\n        run: |\n          docker-compose -f docker-compose.test.yml up -d\n          sleep 15  # Wait for services to be healthy\n\n      - name: Run VenomQA exploration\n        run: |\n          venomqa run \\\n            --api-url http://localhost:8000 \\\n            --database-url postgresql://test:test@localhost:5432/testdb \\\n            --max-steps 500 \\\n            --output ./results\n\n      - name: Upload VenomQA report\n        uses: actions/upload-artifact@v4\n        if: always()\n        with:\n          name: venomqa-report\n          path: results/\n\n      - name: Check for violations\n        run: |\n          if [ -f results/violations.json ] &amp;&amp; [ -s results/violations.json ]; then\n            echo \"::error::VenomQA found invariant violations\"\n            cat results/violations.json\n            exit 1\n          fi\n\n      - name: Cleanup\n        if: always()\n        run: docker-compose -f docker-compose.test.yml down -v\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#advanced-github-actions-with-matrix","title":"Advanced GitHub Actions with Matrix","text":"YAML<pre><code># .github/workflows/api-tests-matrix.yml\nname: API Tests (Matrix)\n\non:\n  push:\n    branches: [main]\n  schedule:\n    - cron: '0 2 * * *'  # Nightly at 2 AM\n\njobs:\n  workflow-tests:\n    name: Workflow Tests - ${{ matrix.config.name }}\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        config:\n          - name: Shallow Exploration\n            max_steps: 200\n            max_depth: 5\n          - name: Deep Exploration\n            max_steps: 1000\n            max_depth: 15\n          - name: Coverage Guided\n            strategy: coverage-guided\n            max_steps: 500\n\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_USER: test\n          POSTGRES_PASSWORD: test\n          POSTGRES_DB: testdb\n        ports:\n          - 5432:5432\n        options: &gt;-\n          --health-cmd pg_isready\n          --health-interval 2s\n          --health-timeout 2s\n          --health-retries 10\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n\n      - name: Install dependencies\n        run: |\n          pip install -e \".[dev]\"\n          pip install venomqa\n\n      - name: Start API\n        run: |\n          docker build -t api-test .\n          docker run -d --name api \\\n            -e DATABASE_URL=postgresql://test:test@localhost:5432/testdb \\\n            -p 8000:8000 \\\n            api-test\n          sleep 10\n\n      - name: Run VenomQA\n        run: |\n          venomqa run \\\n            --config venomqa.yaml \\\n            --strategy ${{ matrix.config.strategy || 'bfs' }} \\\n            --max-steps ${{ matrix.config.max_steps }} \\\n            --max-depth ${{ matrix.config.max_depth }} \\\n            --output ./results/${{ matrix.config.name }}\n        env:\n          DATABASE_URL: postgresql://test:test@localhost:5432/testdb\n          API_URL: http://localhost:8000\n\n      - name: Upload results\n        uses: actions/upload-artifact@v4\n        if: always()\n        with:\n          name: results-${{ matrix.config.name }}\n          path: results/\n\n      - name: Cleanup\n        if: always()\n        run: docker stop api &amp;&amp; docker rm api\n\n  notify-on-failure:\n    name: Notify on Failure\n    needs: [workflow-tests]\n    if: failure()\n    runs-on: ubuntu-latest\n    steps:\n      - name: Send Slack notification\n        uses: slackapi/slack-github-action@v1\n        with:\n          payload: |\n            {\n              \"text\": \"API Tests failed in ${{ github.repository }}\",\n              \"blocks\": [\n                {\n                  \"type\": \"section\",\n                  \"text\": {\n                    \"type\": \"mrkdwn\",\n                    \"text\": \":x: *API Tests Failed*\\nRepository: ${{ github.repository }}\\nBranch: ${{ github.ref_name }}\\n&lt;${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run&gt;\"\n                  }\n                }\n              ]\n            }\n        env:\n          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#gitlab-ci-configuration","title":"GitLab CI Configuration","text":"","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#complete-gitlab-ci-pipeline","title":"Complete GitLab CI Pipeline","text":"YAML<pre><code># .gitlab-ci.yml\n\nstages:\n  - build\n  - test\n  - report\n  - deploy\n\nvariables:\n  POSTGRES_USER: test\n  POSTGRES_PASSWORD: test\n  POSTGRES_DB: testdb\n  DOCKER_TLS_CERTDIR: \"\"\n\n# Build stage\nbuild-api:\n  stage: build\n  image: docker:24\n  services:\n    - docker:24-dind\n  script:\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n\n# Unit tests\nunit-tests:\n  stage: test\n  image: python:3.11\n  script:\n    - pip install -e \".[dev]\"\n    - pytest tests/unit -v --junitxml=reports/unit.xml\n  artifacts:\n    reports:\n      junit: reports/unit.xml\n    expire_in: 1 week\n\n# Contract tests with Schemathesis\ncontract-tests:\n  stage: test\n  image: python:3.11\n  services:\n    - name: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n      alias: api\n    - name: postgres:15\n      alias: postgres\n  variables:\n    DATABASE_URL: postgresql://test:test@postgres:5432/testdb\n  before_script:\n    - pip install schemathesis\n    - sleep 15  # Wait for API to start\n  script:\n    - st run http://api:8000/openapi.json\n        --checks all\n        --max-examples 100\n        --hypothesis-seed=$CI_COMMIT_SHA\n        --report junit.xml\n        --report-html schemathesis-report/\n  artifacts:\n    paths:\n      - schemathesis-report/\n      - junit.xml\n    reports:\n      junit: junit.xml\n    expire_in: 1 week\n    when: always\n\n# Workflow tests with VenomQA\nworkflow-tests:\n  stage: test\n  image: python:3.11\n  services:\n    - name: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n      alias: api\n    - name: postgres:15\n      alias: postgres\n    - name: redis:7\n      alias: redis\n  variables:\n    API_URL: http://api:8000\n    DATABASE_URL: postgresql://test:test@postgres:5432/testdb\n  before_script:\n    - pip install venomqa\n    - sleep 15\n  script:\n    - venomqa run\n        --config venomqa.yaml\n        --max-steps 500\n        --output ./results\n    - |\n      if [ -f results/violations.json ] &amp;&amp; [ -s results/violations.json ]; then\n        echo \"VenomQA found violations!\"\n        cat results/violations.json\n        exit 1\n      fi\n  artifacts:\n    paths:\n      - results/\n    expire_in: 1 week\n    when: always\n  allow_failure: false\n\n# Nightly deep exploration\nnightly-workflow-tests:\n  stage: test\n  image: python:3.11\n  services:\n    - name: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n      alias: api\n    - name: postgres:15\n      alias: postgres\n  variables:\n    API_URL: http://api:8000\n    DATABASE_URL: postgresql://test:test@postgres:5432/testdb\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"\n  before_script:\n    - pip install venomqa\n    - sleep 15\n  script:\n    - venomqa run\n        --config venomqa.yaml\n        --strategy coverage-guided\n        --max-steps 2000\n        --max-depth 20\n        --output ./results/nightly\n  artifacts:\n    paths:\n      - results/\n    expire_in: 30 days\n\n# Generate combined report\ntest-report:\n  stage: report\n  image: python:3.11\n  needs:\n    - unit-tests\n    - contract-tests\n    - workflow-tests\n  script:\n    - pip install junitparser\n    - python scripts/combine_reports.py\n  artifacts:\n    paths:\n      - combined-report/\n    expire_in: 30 days\n  when: always\n\n# Deploy (only if all tests pass)\ndeploy-staging:\n  stage: deploy\n  image: docker:24\n  services:\n    - docker:24-dind\n  rules:\n    - if: $CI_COMMIT_BRANCH == \"develop\"\n  needs:\n    - build-api\n    - unit-tests\n    - contract-tests\n    - workflow-tests\n  script:\n    - echo \"Deploying to staging...\"\n    # Add deployment commands here\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#gitlab-ci-templates","title":"GitLab CI Templates","text":"<p>Create reusable templates for API testing:</p> YAML<pre><code># .gitlab/ci/api-testing.yml\n\n.api-test-base:\n  image: python:3.11\n  services:\n    - name: postgres:15\n      alias: postgres\n  variables:\n    POSTGRES_USER: test\n    POSTGRES_PASSWORD: test\n    POSTGRES_DB: testdb\n  before_script:\n    - pip install venomqa schemathesis pytest\n    - sleep 10\n\n.venomqa-test:\n  extends: .api-test-base\n  script:\n    - venomqa run --config venomqa.yaml --output ./results\n    - |\n      if [ -f results/violations.json ] &amp;&amp; [ -s results/violations.json ]; then\n        exit 1\n      fi\n  artifacts:\n    paths:\n      - results/\n    when: always\n\n.schemathesis-test:\n  extends: .api-test-base\n  script:\n    - st run ${API_URL}/openapi.json --report junit.xml --report-html report/\n  artifacts:\n    paths:\n      - report/\n    reports:\n      junit: junit.xml\n    when: always\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#jenkins-pipeline-configuration","title":"Jenkins Pipeline Configuration","text":"","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#jenkinsfile-for-api-testing","title":"Jenkinsfile for API Testing","text":"Groovy<pre><code>// Jenkinsfile\npipeline {\n    agent {\n        docker {\n            image 'python:3.11'\n            args '--network host'\n        }\n    }\n\n    environment {\n        DOCKER_IMAGE = 'api-test'\n        COMPOSE_FILE = 'docker-compose.test.yml'\n    }\n\n    stages {\n        stage('Build') {\n            steps {\n                sh 'docker build -t ${DOCKER_IMAGE} .'\n            }\n        }\n\n        stage('Start Environment') {\n            steps {\n                sh 'docker-compose -f ${COMPOSE_FILE} up -d'\n                sh 'sleep 15'\n                sh 'docker-compose -f ${COMPOSE_FILE} ps'\n            }\n        }\n\n        stage('Unit Tests') {\n            steps {\n                sh 'pip install -e \".[dev]\"'\n                sh 'pytest tests/unit -v --junitxml=reports/unit.xml'\n            }\n            post {\n                always {\n                    junit 'reports/unit.xml'\n                }\n            }\n        }\n\n        stage('Contract Tests') {\n            steps {\n                sh 'pip install schemathesis'\n                sh '''\n                    st run http://localhost:8000/openapi.json \\\n                        --checks all \\\n                        --max-examples 100 \\\n                        --report junit.xml \\\n                        --report-html schemathesis-report/\n                '''\n            }\n            post {\n                always {\n                    junit 'junit.xml'\n                    publishHTML([\n                        allowMissing: false,\n                        alwaysLinkToLastBuild: true,\n                        keepAll: true,\n                        reportDir: 'schemathesis-report',\n                        reportFiles: 'index.html',\n                        reportName: 'Schemathesis Report'\n                    ])\n                }\n            }\n        }\n\n        stage('Workflow Tests') {\n            steps {\n                sh 'pip install venomqa'\n                sh '''\n                    venomqa run \\\n                        --config venomqa.yaml \\\n                        --max-steps 500 \\\n                        --output ./results\n                '''\n            }\n            post {\n                always {\n                    publishHTML([\n                        allowMissing: false,\n                        alwaysLinkToLastBuild: true,\n                        keepAll: true,\n                        reportDir: 'results',\n                        reportFiles: 'index.html',\n                        reportName: 'VenomQA Report'\n                    ])\n\n                    script {\n                        if (fileExists('results/violations.json')) {\n                            def violations = readFile('results/violations.json')\n                            if (violations.trim()) {\n                                error \"VenomQA found invariant violations\"\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        stage('Deploy') {\n            when {\n                branch 'main'\n            }\n            steps {\n                echo 'Deploying to production...'\n                // Add deployment steps\n            }\n        }\n    }\n\n    post {\n        always {\n            sh 'docker-compose -f ${COMPOSE_FILE} down -v'\n            cleanWs()\n        }\n\n        failure {\n            mail(\n                to: 'team@example.com',\n                subject: \"API Tests Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}\",\n                body: \"\"\"\n                    API tests have failed.\n\n                    Job: ${env.JOB_NAME}\n                    Build: ${env.BUILD_NUMBER}\n                    URL: ${env.BUILD_URL}\n\n                    Please investigate.\n                \"\"\"\n            )\n        }\n    }\n}\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#jenkins-with-parallel-testing","title":"Jenkins with Parallel Testing","text":"Groovy<pre><code>// Jenkinsfile.parallel\npipeline {\n    agent any\n\n    stages {\n        stage('Test') {\n            parallel {\n                stage('Unit Tests') {\n                    agent {\n                        docker { image 'python:3.11' }\n                    }\n                    steps {\n                        sh 'pip install -e \".[dev]\"'\n                        sh 'pytest tests/unit --junitxml=unit.xml'\n                    }\n                    post {\n                        always {\n                            junit 'unit.xml'\n                        }\n                    }\n                }\n\n                stage('Contract Tests') {\n                    agent {\n                        docker { image 'python:3.11' }\n                    }\n                    steps {\n                        sh '''\n                            docker-compose -f docker-compose.test.yml up -d api postgres\n                            sleep 15\n                            pip install schemathesis\n                            st run http://localhost:8000/openapi.json --report junit.xml\n                        '''\n                    }\n                    post {\n                        always {\n                            junit 'junit.xml'\n                            sh 'docker-compose -f docker-compose.test.yml down -v'\n                        }\n                    }\n                }\n\n                stage('Workflow Tests (Shallow)') {\n                    agent {\n                        docker { image 'python:3.11' }\n                    }\n                    steps {\n                        sh '''\n                            docker-compose -f docker-compose.test.yml up -d\n                            sleep 15\n                            pip install venomqa\n                            venomqa run --config venomqa.yaml --max-steps 200 --output ./results/shallow\n                        '''\n                    }\n                    post {\n                        always {\n                            archiveArtifacts artifacts: 'results/**', allowEmptyArchive: true\n                            sh 'docker-compose -f docker-compose.test.yml down -v'\n                        }\n                    }\n                }\n            }\n        }\n\n        stage('Deep Exploration') {\n            when {\n                anyOf {\n                    branch 'main'\n                    triggeredBy 'TimerTrigger'\n                }\n            }\n            agent {\n                docker { image 'python:3.11' }\n            }\n            steps {\n                sh '''\n                    docker-compose -f docker-compose.test.yml up -d\n                    sleep 15\n                    pip install venomqa\n                    venomqa run --config venomqa.yaml --max-steps 2000 --output ./results/deep\n                '''\n            }\n            post {\n                always {\n                    archiveArtifacts artifacts: 'results/**', allowEmptyArchive: true\n                    sh 'docker-compose -f docker-compose.test.yml down -v'\n                }\n            }\n        }\n    }\n}\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#reporting-and-notifications","title":"Reporting and Notifications","text":"","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#combined-report-generation","title":"Combined Report Generation","text":"Python<pre><code># scripts/combine_reports.py\nimport json\nfrom pathlib import Path\nfrom datetime import datetime\n\ndef combine_reports():\n    results = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"tests\": {}\n    }\n\n    # Load unit test results\n    unit_xml = Path(\"reports/unit.xml\")\n    if unit_xml.exists():\n        results[\"tests\"][\"unit\"] = parse_junit_xml(unit_xml)\n\n    # Load Schemathesis results\n    st_json = Path(\"schemathesis-report/results.json\")\n    if st_json.exists():\n        results[\"tests\"][\"contract\"] = json.loads(st_json.read_text())\n\n    # Load VenomQA results\n    venomqa_json = Path(\"results/summary.json\")\n    if venomqa_json.exists():\n        results[\"tests\"][\"workflow\"] = json.loads(venomqa_json.read_text())\n\n    # Generate summary\n    summary = {\n        \"total_tests\": sum(\n            t.get(\"total\", 0) for t in results[\"tests\"].values()\n        ),\n        \"passed\": sum(\n            t.get(\"passed\", 0) for t in results[\"tests\"].values()\n        ),\n        \"failed\": sum(\n            t.get(\"failed\", 0) for t in results[\"tests\"].values()\n        ),\n        \"violations\": results[\"tests\"]\n            .get(\"workflow\", {})\n            .get(\"violations\", 0)\n    }\n\n    results[\"summary\"] = summary\n\n    # Write combined report\n    Path(\"combined-report/results.json\").write_text(\n        json.dumps(results, indent=2)\n    )\n\n    # Generate HTML summary\n    html = generate_html_summary(results)\n    Path(\"combined-report/index.html\").write_text(html)\n\n    return summary\n\ndef generate_html_summary(results):\n    return f\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;API Test Report&lt;/title&gt;\n        &lt;style&gt;\n            body {{ font-family: system-ui; max-width: 800px; margin: 0 auto; padding: 20px; }}\n            .summary {{ display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }}\n            .card {{ padding: 15px; border-radius: 8px; text-align: center; }}\n            .total {{ background: #e3f2fd; }}\n            .passed {{ background: #e8f5e9; }}\n            .failed {{ background: #ffebee; }}\n            .violations {{ background: #fff3e0; }}\n            .number {{ font-size: 2em; font-weight: bold; }}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;API Test Report&lt;/h1&gt;\n        &lt;p&gt;Generated: {results['timestamp']}&lt;/p&gt;\n\n        &lt;div class=\"summary\"&gt;\n            &lt;div class=\"card total\"&gt;\n                &lt;div class=\"number\"&gt;{results['summary']['total_tests']}&lt;/div&gt;\n                &lt;div&gt;Total Tests&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"card passed\"&gt;\n                &lt;div class=\"number\"&gt;{results['summary']['passed']}&lt;/div&gt;\n                &lt;div&gt;Passed&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"card failed\"&gt;\n                &lt;div class=\"number\"&gt;{results['summary']['failed']}&lt;/div&gt;\n                &lt;div&gt;Failed&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"card violations\"&gt;\n                &lt;div class=\"number\"&gt;{results['summary']['violations']}&lt;/div&gt;\n                &lt;div&gt;Violations&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\nif __name__ == \"__main__\":\n    combine_reports()\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#slack-notifications","title":"Slack Notifications","text":"YAML<pre><code># .github/workflows/api-tests.yml (notification section)\n  notify:\n    name: Notify Results\n    needs: [unit-tests, contract-tests, workflow-tests]\n    if: always()\n    runs-on: ubuntu-latest\n    steps:\n      - name: Determine status\n        id: status\n        run: |\n          if [ \"${{ needs.workflow-tests.result }}\" == \"failure\" ]; then\n            echo \"status=failure\" &gt;&gt; $GITHUB_OUTPUT\n            echo \"emoji=:x:\" &gt;&gt; $GITHUB_OUTPUT\n          else\n            echo \"status=success\" &gt;&gt; $GITHUB_OUTPUT\n            echo \"emoji=:white_check_mark:\" &gt;&gt; $GITHUB_OUTPUT\n          fi\n\n      - name: Send Slack notification\n        uses: slackapi/slack-github-action@v1\n        with:\n          channel-id: 'api-tests'\n          payload: |\n            {\n              \"blocks\": [\n                {\n                  \"type\": \"header\",\n                  \"text\": {\n                    \"type\": \"plain_text\",\n                    \"text\": \"${{ steps.status.outputs.emoji }} API Tests: ${{ steps.status.outputs.status }}\"\n                  }\n                },\n                {\n                  \"type\": \"section\",\n                  \"fields\": [\n                    {\n                      \"type\": \"mrkdwn\",\n                      \"text\": \"*Repository:*\\n${{ github.repository }}\"\n                    },\n                    {\n                      \"type\": \"mrkdwn\",\n                      \"text\": \"*Branch:*\\n${{ github.ref_name }}\"\n                    },\n                    {\n                      \"type\": \"mrkdwn\",\n                      \"text\": \"*Commit:*\\n${{ github.sha }}\"\n                    },\n                    {\n                      \"type\": \"mrkdwn\",\n                      \"text\": \"*Actor:*\\n${{ github.actor }}\"\n                    }\n                  ]\n                },\n                {\n                  \"type\": \"actions\",\n                  \"elements\": [\n                    {\n                      \"type\": \"button\",\n                      \"text\": {\n                        \"type\": \"plain_text\",\n                        \"text\": \"View Results\"\n                      },\n                      \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"\n                    }\n                  ]\n                }\n              ]\n            }\n        env:\n          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#github-pr-comments","title":"GitHub PR Comments","text":"YAML<pre><code># .github/workflows/pr-comment.yml\nname: PR Test Results\n\non:\n  workflow_run:\n    workflows: [\"API Tests\"]\n    types:\n      - completed\n\njobs:\n  comment:\n    if: github.event.workflow_run.event == 'pull_request'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Download artifacts\n        uses: actions/github-script@v7\n        with:\n          script: |\n            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              run_id: context.payload.workflow_run.id,\n            });\n\n            const matchArtifact = artifacts.data.artifacts.find(\n              artifact =&gt; artifact.name === 'venomqa-report'\n            );\n\n            if (matchArtifact) {\n              const download = await github.rest.actions.downloadArtifact({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                artifact_id: matchArtifact.id,\n                archive_format: 'zip',\n              });\n\n              // Process and create PR comment\n              const summary = await processResults(download.data);\n\n              await github.rest.issues.createComment({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                issue_number: context.payload.workflow_run.pull_requests[0].number,\n                body: summary,\n              });\n            }\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#best-practices","title":"Best Practices","text":"","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#1-fast-feedback-loops","title":"1. Fast Feedback Loops","text":"Text Only<pre><code>Commit \u2500\u2500\u25ba Unit Tests (&lt; 2 min)\n              \u2502\n              \u251c\u2500\u2500 Pass \u2500\u2500\u25ba Contract Tests (&lt; 5 min)\n              \u2502                \u2502\n              \u2502                \u251c\u2500\u2500 Pass \u2500\u2500\u25ba PR Approved\n              \u2502                \u2502\n              \u2502                \u2514\u2500\u2500 Fail \u2500\u2500\u25ba Block PR\n              \u2502\n              \u2514\u2500\u2500 Fail \u2500\u2500\u25ba Block immediately\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#2-layered-testing-strategy","title":"2. Layered Testing Strategy","text":"Layer Tests Speed Trigger L1: Unit pytest &lt; 2 min Every commit L2: Contract Schemathesis &lt; 5 min Every PR L3: Integration VenomQA shallow &lt; 15 min Every PR L4: Deep VenomQA deep &lt; 60 min Main branch, nightly","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#3-test-data-management","title":"3. Test Data Management","text":"Python<pre><code># tests/conftest.py\nimport pytest\nfrom venomqa.adapters.postgres import PostgresAdapter\n\n@pytest.fixture(scope=\"session\")\ndef test_database():\n    \"\"\"Create test database once per session.\"\"\"\n    db = PostgresAdapter(TEST_DATABASE_URL)\n    db.connect()\n\n    # Seed reference data (products, categories, etc.)\n    seed_reference_data(db)\n\n    # Create baseline checkpoint\n    db.checkpoint(\"baseline\")\n\n    yield db\n\n    db.close()\n\n@pytest.fixture\ndef clean_db(test_database):\n    \"\"\"Reset to baseline for each test.\"\"\"\n    test_database.rollback(\"baseline\")\n    yield test_database\n    test_database.rollback(\"baseline\")\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#4-resource-cleanup","title":"4. Resource Cleanup","text":"<p>Always clean up Docker resources:</p> YAML<pre><code># In every workflow\npost:\n  always:\n    - name: Cleanup\n      run: docker-compose -f docker-compose.test.yml down -v --remove-orphans\n</code></pre>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#summary","title":"Summary","text":"CI/CD Platform Best For Key Features GitHub Actions Open source, small teams Matrix builds, marketplace actions GitLab CI Enterprise, GitLab users Auto DevOps, built-in container registry Jenkins Complex pipelines, enterprise Extensive plugins, fine-grained control","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#recommended-setup","title":"Recommended Setup","text":"<ol> <li>Every commit: Unit tests + linting</li> <li>Every PR: Contract tests + shallow VenomQA exploration</li> <li>Main branch: Deep VenomQA exploration + performance tests</li> <li>Nightly: Full regression suite with 2000+ steps</li> </ol>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"blog/2024-02-15-ci-cd-api-testing/#further-reading","title":"Further Reading","text":"<ul> <li>VenomQA Documentation</li> <li>Schemathesis CI Integration</li> <li>GitHub Actions Documentation</li> <li>GitLab CI/CD Documentation</li> <li>Jenkins Pipeline Documentation</li> </ul> <p>Keywords: CI/CD testing, automated API testing, continuous testing, GitHub Actions, GitLab CI, Jenkins, Docker Compose, API testing automation, test pipeline, CI/CD best practices</p>","tags":["CI/CD testing","automated API testing","continuous testing","GitHub Actions","GitLab CI","Jenkins","Docker Compose","API testing automation"]},{"location":"concepts/","title":"Concepts","text":"<p>Understand the mental model behind VenomQA.</p>"},{"location":"concepts/#the-core-insight","title":"The Core Insight","text":"<p>Traditional API testing is stateless. Each test runs in isolation with a fresh fixture and a predetermined assertion. But real applications are stateful \u2014 what happened before affects what happens next.</p> Text Only<pre><code>Traditional Testing:\n  Test 1: POST /orders  \u2192 201 \u2713\n  Test 2: POST /refund  \u2192 200 \u2713\n  (Each test runs independently)\n\nReal Usage:\n  User: POST /orders  \u2192 201 \u2713\n  User: POST /refund  \u2192 200 \u2713\n  User: POST /refund  \u2192 200 \u2713  \u2190 Bug: double refund!\n</code></pre> <p>VenomQA models your API as a state graph and explores every path through it.</p>"},{"location":"concepts/#the-three-primitives","title":"The Three Primitives","text":"<p>Everything in VenomQA is built from three concepts:</p> Primitive Purpose Analogy Action One thing your API can do A button the user clicks Invariant A rule that must always hold A business constraint World The sandbox with rollback The test environment"},{"location":"concepts/#actions","title":"Actions","text":"<p>An action is a Python function that makes one API call:</p> Python<pre><code>def create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])  # Store for later\n    return resp\n</code></pre> <p>Actions can:</p> <ul> <li>Make HTTP requests</li> <li>Read/write to the context</li> <li>Return <code>None</code> to skip (precondition not met)</li> </ul>"},{"location":"concepts/#invariants","title":"Invariants","text":"<p>An invariant is a rule checked after every action:</p> Python<pre><code>no_over_refund = Invariant(\n    \"no_over_refund\",\n    lambda world: get_total_refunded() &lt;= get_order_total(),\n    Severity.CRITICAL,\n)\n</code></pre> <p>Invariants catch bugs that only appear in specific sequences.</p>"},{"location":"concepts/#world","title":"World","text":"<p>The world holds the API client, database connections, and context:</p> Python<pre><code>world = World(\n    api=HttpClient(\"http://localhost:8000\"),\n    state_from_context=[\"order_id\"],\n)\n</code></pre> <p>Worlds support checkpoint/rollback for branching exploration.</p>"},{"location":"concepts/#the-exploration-model","title":"The Exploration Model","text":"<p>VenomQA treats your API as a state machine:</p> Text Only<pre><code>         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502   [empty]    \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502 create_order\n                \u25bc\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 [has_order]  \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n        \u2502               \u2502       \u2502\n   refund          cancel       \u2502\n        \u25bc               \u25bc       \u2502\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n  \u2502[refunded]\u2502  \u2502 [canceled] \u2502\u2500\u2500\u2518\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The agent explores this graph using BFS, DFS, or coverage-guided strategies. At each node, it:</p> <ol> <li>Saves the world state (checkpoint)</li> <li>Tries each applicable action</li> <li>Checks all invariants</li> <li>Rolls back and tries the next branch</li> </ol>"},{"location":"concepts/#why-this-finds-bugs-others-miss","title":"Why This Finds Bugs Others Miss","text":"Bug Type pytest Schemathesis VenomQA Double refund \u2717 \u2717 \u2713 Stale cache after delete \u2717 \u2717 \u2713 Idempotency violation \u2717 \u2717 \u2713 Race condition in sequence \u2717 \u2717 \u2713 Schema validation \u2713 \u2713 \u2713 Fuzzing edge cases \u2717 \u2713 \u2717 <p>VenomQA complements, not replaces, your existing tests. Use Schemathesis for schema fuzzing, pytest for unit tests, and VenomQA for sequence bugs.</p>"},{"location":"concepts/#topics","title":"Topics","text":"<ul> <li> <p> The Theory</p> <p>Why sequence testing matters and what bugs it catches.</p> <p> Read more</p> </li> <li> <p> Journeys</p> <p>How actions chain together with automatic context flow.</p> <p> Read more</p> </li> <li> <p> Checkpoints &amp; Branching</p> <p>Database rollback for true parallel exploration.</p> <p> Read more</p> </li> <li> <p> State Management</p> <p>Context, checkpoints, and state extraction.</p> <p> Read more</p> </li> <li> <p> Ports &amp; Adapters</p> <p>Clean architecture for testable code.</p> <p> Read more</p> </li> </ul>"},{"location":"concepts/branching/","title":"Checkpoints &amp; Branching","text":"<p>Database rollback enables true parallel exploration.</p>"},{"location":"concepts/branching/#the-problem","title":"The Problem","text":"<p>To explore all paths through your API, you need to test from the same starting point:</p> Text Only<pre><code>[empty] \u2192 create \u2192 [has order] \u2192 refund \u2192 [refunded]\n                        \u2193\n                      cancel \u2192 [canceled]\n                        \u2193\n                      update \u2192 [modified]\n</code></pre> <p>Without rollback, each path would leave the database polluted:</p> Text Only<pre><code>Path 1: create \u2192 refund \u2192 (order still exists)\nPath 2: create \u2192 cancel \u2192 (order still exists, conflicts!)\n</code></pre>"},{"location":"concepts/branching/#the-solution-savepoint-rollback","title":"The Solution: Savepoint Rollback","text":"<p>VenomQA uses database savepoints to branch cleanly:</p> Python<pre><code># PostgreSQL\nSAVEPOINT vq_checkpoint_1;\n-- ... run actions ...\nROLLBACK TO SAVEPOINT vq_checkpoint_1;\n-- Database is now back to original state\n</code></pre> <p>This enables true exploration:</p> Text Only<pre><code>Start: [empty database]\n  \u2502\n  \u251c\u2500\u2500 create \u2192 [has order A]\n  \u2502     \u2502\n  \u2502     \u251c\u2500\u2500 refund \u2192 [refunded A] \u2713\n  \u2502     \u2502\n  \u2502     \u251c\u2500\u2500 cancel \u2192 [canceled A] \u2713\n  \u2502     \u2502\n  \u2502     \u2514\u2500\u2500 update \u2192 [modified A] \u2713\n  \u2502\n  \u2514\u2500\u2500 (rollback to empty)\n        \u2502\n        \u251c\u2500\u2500 create \u2192 [has order B]\n        \u2502     \u2514\u2500\u2500 ...\n</code></pre> <p>Each branch starts from a clean state.</p>"},{"location":"concepts/branching/#how-it-works","title":"How It Works","text":""},{"location":"concepts/branching/#1-checkpoint-before-branch","title":"1. Checkpoint Before Branch","text":"<p>When the agent reaches a state with multiple possible actions:</p> Python<pre><code># Internal: VenomQA calls world.checkpoint()\ncheckpoint_id = world.checkpoint()\n</code></pre>"},{"location":"concepts/branching/#2-try-each-action","title":"2. Try Each Action","text":"Python<pre><code>for action in possible_actions:\n    result = action.execute(api, context)\n    # ... check invariants ...\n    world.rollback(checkpoint_id)  # Reset for next branch\n</code></pre>"},{"location":"concepts/branching/#3-restore-clean-state","title":"3. Restore Clean State","text":"<p>The database is exactly as it was before the action.</p>"},{"location":"concepts/branching/#database-support","title":"Database Support","text":""},{"location":"concepts/branching/#postgresql-recommended","title":"PostgreSQL (Recommended)","text":"Python<pre><code>from venomqa.adapters.postgres import PostgresAdapter\n\ndb = PostgresAdapter(\"postgresql://user:pass@localhost/testdb\")\nworld = World(api=api, systems={\"db\": db})\n</code></pre> <p>Implementation:</p> <ul> <li>Entire exploration runs in one uncommitted transaction</li> <li>Uses <code>SAVEPOINT</code> / <code>ROLLBACK TO SAVEPOINT</code></li> <li>Zero test pollution</li> </ul> <p>Requirements:</p> <ul> <li><code>pip install psycopg[binary]</code></li> <li>PostgreSQL 12+</li> </ul>"},{"location":"concepts/branching/#mysql","title":"MySQL","text":"Python<pre><code>from venomqa.adapters.mysql import MySQLAdapter\n\ndb = MySQLAdapter(host=\"localhost\", user=\"root\", database=\"testdb\")\nworld = World(api=api, systems={\"db\": db})\n</code></pre> <p>Implementation:</p> <ul> <li>Uses <code>SAVEPOINT</code> / <code>ROLLBACK TO SAVEPOINT</code></li> <li>Similar to PostgreSQL</li> </ul>"},{"location":"concepts/branching/#sqlite","title":"SQLite","text":"Python<pre><code>from venomqa.adapters.sqlite import SQLiteAdapter\n\ndb = SQLiteAdapter(path=\"/path/to/test.db\")\nworld = World(api=api, systems={\"db\": db})\n</code></pre> <p>Implementation:</p> <ul> <li>Copies database file on checkpoint</li> <li>Restores file on rollback</li> <li>Good for local development</li> </ul>"},{"location":"concepts/branching/#redis","title":"Redis","text":"Python<pre><code>from venomqa.adapters.redis_adapter import RedisAdapter\n\nredis = RedisAdapter(host=\"localhost\", port=6379)\nworld = World(api=api, systems={\"redis\": redis})\n</code></pre> <p>Implementation:</p> <ul> <li><code>DUMP</code> all keys \u2192 <code>FLUSHALL</code> + <code>RESTORE</code> on rollback</li> </ul>"},{"location":"concepts/branching/#in-memory-testing","title":"In-Memory (Testing)","text":"Python<pre><code>from venomqa.adapters.mock import MockSystem\n\nmock_db = MockSystem(initial_state={\"users\": []})\nworld = World(api=api, systems={\"db\": mock_db})\n</code></pre> <p>Implementation:</p> <ul> <li>Deep copy on checkpoint</li> <li>Assign copy on rollback</li> </ul>"},{"location":"concepts/branching/#when-rollback-matters","title":"When Rollback Matters","text":""},{"location":"concepts/branching/#without-rollback","title":"Without Rollback","text":"Python<pre><code># This won't work correctly\ndef test_refund_twice():\n    create_order()  # Order #1 created\n    refund_order()  # Order #1 refunded\n    # Database now has a refunded order\n\n    # Next test starts with polluted state\n    test_cancel_order()  # Order #1 already refunded!\n</code></pre>"},{"location":"concepts/branching/#with-rollback","title":"With Rollback","text":"Python<pre><code># VenomQA explores correctly\n[empty]\n  \u2502\n  \u2514\u2500\u2500 create_order(#1) \u2192 [has #1]\n        \u2502\n        \u251c\u2500\u2500 refund_order(#1) \u2192 [refunded #1] \u2713\n        \u2502     \u2514\u2500\u2500 (rollback to [has #1])\n        \u2502\n        \u2514\u2500\u2500 refund_order(#1) \u2192 [refunded #1 again] \u2190 BUG\n              \u2514\u2500\u2500 (rollback to [has #1])\n\n        \u2514\u2500\u2500 cancel_order(#1) \u2192 [canceled #1] \u2713\n              \u2514\u2500\u2500 (rollback to [has #1])\n</code></pre>"},{"location":"concepts/branching/#checkpoint-granularity","title":"Checkpoint Granularity","text":""},{"location":"concepts/branching/#per-action-default","title":"Per-Action (Default)","text":"Python<pre><code>world = World(api=api, systems={\"db\": db})\n# Checkpoint before every action\n</code></pre>"},{"location":"concepts/branching/#manual-checkpoints","title":"Manual Checkpoints","text":"Python<pre><code># Take manual control\ncp1 = world.checkpoint()\naction1.execute(api, context)\nworld.rollback(cp1)\n</code></pre>"},{"location":"concepts/branching/#performance-considerations","title":"Performance Considerations","text":"Database Checkpoint Cost Rollback Cost Best For PostgreSQL ~1ms ~1ms Production CI MySQL ~2ms ~2ms MySQL shops SQLite ~50ms (file copy) ~50ms Local dev Redis ~5ms ~10ms Cache testing Mock ~0.1ms ~0.1ms Unit tests"},{"location":"concepts/branching/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/branching/#reset-between-tests","title":"Reset Between Tests","text":"Python<pre><code>import pytest\n\n@pytest.fixture\ndef clean_world():\n    world = World(api=api, systems={\"db\": db})\n    yield world\n    # Automatic cleanup via transaction rollback\n</code></pre>"},{"location":"concepts/branching/#nested-branching","title":"Nested Branching","text":"Python<pre><code># VenomQA handles nested checkpoints automatically\ncp1 = world.checkpoint()\n    action_a.execute()\n    cp2 = world.checkpoint()\n        action_b.execute()\n    world.rollback(cp2)\n    action_c.execute()\nworld.rollback(cp1)\n</code></pre>"},{"location":"concepts/branching/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/branching/#savepoint-does-not-exist","title":"\"Savepoint does not exist\"","text":"<p>The transaction was committed or rolled back externally. Ensure no other code is managing transactions.</p>"},{"location":"concepts/branching/#database-file-locked-sqlite","title":"\"Database file locked\" (SQLite)","text":"<p>SQLite doesn't handle concurrent writes well. Use PostgreSQL for parallel exploration.</p>"},{"location":"concepts/branching/#slow-rollback","title":"Slow Rollback","text":"<p>If checkpoints are slow:</p> <ol> <li>Check database connection pooling</li> <li>Reduce initial data volume</li> <li>Use PostgreSQL over SQLite</li> </ol>"},{"location":"concepts/branching/#next-steps","title":"Next Steps","text":"<ul> <li>State Management - Context and state extraction</li> <li>Adapters Reference - Full adapter docs</li> <li>Examples - Real-world patterns</li> </ul>"},{"location":"concepts/journeys/","title":"Journeys","text":"<p>Chain actions together with automatic context flow.</p>"},{"location":"concepts/journeys/#what-is-a-journey","title":"What Is a Journey?","text":"<p>A journey is a sequence of actions that represents a user flow through your application:</p> Text Only<pre><code>Login \u2192 Create Cart \u2192 Add Item \u2192 Checkout \u2192 Pay\n</code></pre> <p>In VenomQA, journeys emerge naturally from your action definitions. You don't explicitly define them \u2014 the exploration discovers them.</p>"},{"location":"concepts/journeys/#context-the-glue-between-actions","title":"Context: The Glue Between Actions","text":"<p>The context is a key-value store that persists between actions:</p> Python<pre><code>def create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])  # Store\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")  # Retrieve\n    if order_id is None:\n        return None  # Skip - no order to refund\n    return api.post(f\"/orders/{order_id}/refund\")\n</code></pre>"},{"location":"concepts/journeys/#how-context-flows","title":"How Context Flows","text":"Text Only<pre><code>Action 1: create_order\n  \u2514\u2500 context.set(\"order_id\", \"abc123\")\n\nAction 2: refund_order\n  \u2514\u2500 context.get(\"order_id\") \u2192 \"abc123\"\n\nAction 3: cancel_order\n  \u2514\u2500 context.get(\"order_id\") \u2192 \"abc123\"\n</code></pre> <p>The context survives across actions in the same exploration path.</p>"},{"location":"concepts/journeys/#writing-context-aware-actions","title":"Writing Context-Aware Actions","text":""},{"location":"concepts/journeys/#pattern-1-store-on-create","title":"Pattern 1: Store on Create","text":"Python<pre><code>def create_user(api, context):\n    resp = api.post(\"/users\", json={\"email\": \"test@example.com\"})\n    context.set(\"user_id\", resp.json()[\"id\"])\n    context.set(\"user_email\", resp.json()[\"email\"])\n    return resp\n</code></pre>"},{"location":"concepts/journeys/#pattern-2-skip-when-missing","title":"Pattern 2: Skip When Missing","text":"Python<pre><code>def delete_user(api, context):\n    user_id = context.get(\"user_id\")\n    if user_id is None:\n        return None  # No user to delete\n    return api.delete(f\"/users/{user_id}\")\n</code></pre>"},{"location":"concepts/journeys/#pattern-3-derived-values","title":"Pattern 3: Derived Values","text":"Python<pre><code>def get_user_orders(api, context):\n    user_id = context.get(\"user_id\")\n    if user_id is None:\n        return None\n    return api.get(f\"/users/{user_id}/orders\")\n</code></pre>"},{"location":"concepts/journeys/#pattern-4-update-context","title":"Pattern 4: Update Context","text":"Python<pre><code>def create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef pay_order(api, context):\n    order_id = context.get(\"order_id\")\n    resp = api.post(f\"/orders/{order_id}/pay\")\n    context.set(\"payment_id\", resp.json()[\"payment_id\"])\n    return resp\n</code></pre>"},{"location":"concepts/journeys/#state-extraction","title":"State Extraction","text":"<p>VenomQA can extract state from context to detect duplicate states:</p> Python<pre><code>from venomqa import World\n\nworld = World(\n    api=api,\n    state_from_context=[\"order_id\", \"user_id\"],\n)\n</code></pre> <p>This tells VenomQA: \"Two states are identical if they have the same <code>order_id</code> and <code>user_id</code>.\"</p>"},{"location":"concepts/journeys/#why-this-matters","title":"Why This Matters","text":"<p>Without state extraction:</p> Text Only<pre><code>create_order \u2192 [has order] \u2192 refund \u2192 [refunded]\n                              \u2193\n                        cancel (skip)\n                              \u2193\n                        refund (skip)\n</code></pre> <p>With state extraction, VenomQA recognizes that revisiting <code>[has order]</code> with the same <code>order_id</code> is redundant.</p>"},{"location":"concepts/journeys/#common-journey-patterns","title":"Common Journey Patterns","text":""},{"location":"concepts/journeys/#crud-cycle","title":"CRUD Cycle","text":"Python<pre><code>actions = [\n    Action(\"create\", create_item),   # Sets item_id\n    Action(\"read\", read_item),       # Uses item_id\n    Action(\"update\", update_item),   # Uses item_id\n    Action(\"delete\", delete_item),   # Uses item_id\n]\n</code></pre> <p>Explores: create\u2192read, create\u2192update, create\u2192delete, create\u2192read\u2192update\u2192delete, etc.</p>"},{"location":"concepts/journeys/#state-machine","title":"State Machine","text":"Python<pre><code>actions = [\n    Action(\"create\", create_order),\n    Action(\"pay\", pay_order),        # Requires: order_id\n    Action(\"ship\", ship_order),      # Requires: order_id, paid\n    Action(\"refund\", refund_order),  # Requires: order_id\n    Action(\"cancel\", cancel_order),  # Requires: order_id\n]\n</code></pre>"},{"location":"concepts/journeys/#multi-resource","title":"Multi-Resource","text":"Python<pre><code>actions = [\n    Action(\"create_user\", create_user),     # Sets user_id\n    Action(\"create_order\", create_order),   # Sets order_id\n    Action(\"add_item\", add_item),           # Uses order_id\n    Action(\"checkout\", checkout),           # Uses order_id\n]\n</code></pre>"},{"location":"concepts/journeys/#context-vs-world-state","title":"Context vs. World State","text":"Aspect Context World State Storage Key-value dict Database, files, etc. Scope Per exploration path Shared across paths Checkpoint Copied on branch Rolled back on branch Use case IDs, tokens DB rows, files <p>Context is for passing data between actions. World state is for the actual system under test.</p>"},{"location":"concepts/journeys/#example-full-e-commerce-journey","title":"Example: Full E-commerce Journey","text":"Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"user_id\", \"cart_id\", \"order_id\"])\n\ndef create_user(api, context):\n    resp = api.post(\"/users\", json={\"email\": \"test@example.com\"})\n    context.set(\"user_id\", resp.json()[\"id\"])\n    return resp\n\ndef create_cart(api, context):\n    user_id = context.get(\"user_id\")\n    if user_id is None:\n        return None\n    resp = api.post(f\"/users/{user_id}/carts\")\n    context.set(\"cart_id\", resp.json()[\"id\"])\n    return resp\n\ndef add_item(api, context):\n    cart_id = context.get(\"cart_id\")\n    if cart_id is None:\n        return None\n    return api.post(f\"/carts/{cart_id}/items\", json={\"sku\": \"ABC123\", \"qty\": 1})\n\ndef checkout(api, context):\n    cart_id = context.get(\"cart_id\")\n    if cart_id is None:\n        return None\n    resp = api.post(f\"/carts/{cart_id}/checkout\")\n    context.set(\"order_id\", resp.json()[\"order_id\"])\n    return resp\n\nactions = [\n    Action(\"create_user\", create_user),\n    Action(\"create_cart\", create_cart),\n    Action(\"add_item\", add_item),\n    Action(\"checkout\", checkout),\n]\n\nresult = Agent(\n    world=world,\n    actions=actions,\n    invariants=[],\n    strategy=BFS(),\n    max_steps=50,\n).explore()\n</code></pre> <p>This explores paths like:</p> <ul> <li>create_user \u2192 create_cart \u2192 add_item \u2192 checkout</li> <li>create_user \u2192 create_cart \u2192 checkout (empty cart?)</li> <li>create_user \u2192 add_item (no cart - skip)</li> <li>etc.</li> </ul>"},{"location":"concepts/journeys/#next-steps","title":"Next Steps","text":"<ul> <li>Checkpoints &amp; Branching - Database rollback</li> <li>State Management - Context and state extraction</li> <li>Examples - Real-world patterns</li> </ul>"},{"location":"concepts/ports-adapters/","title":"Ports &amp; Adapters","text":"<p>Clean architecture for testable API clients.</p>"},{"location":"concepts/ports-adapters/#the-problem","title":"The Problem","text":"<p>Tightly coupled code is hard to test:</p> Python<pre><code># Bad: Hard to test\ndef create_order():\n    import requests\n    resp = requests.post(\"http://api.example.com/orders\", json={...})\n    return resp.json()\n</code></pre> <p>This code:</p> <ul> <li>Hard-codes the HTTP library (requests)</li> <li>Hard-codes the base URL</li> <li>Can't be mocked easily</li> <li>Can't be reused in different environments</li> </ul>"},{"location":"concepts/ports-adapters/#the-solution-ports-adapters","title":"The Solution: Ports &amp; Adapters","text":"<p>Separate what you do (port) from how you do it (adapter):</p> Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Your Code      \u2502      \u2502  VenomQA Test   \u2502\n\u2502  (Production)   \u2502      \u2502  (Exploration)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                        \u2502\n         \u25bc                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              PORT (Interface)            \u2502\n\u2502  create_order(), refund_order(), ...    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u25bc                       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  HTTP Adapter   \u2502      \u2502  Mock Adapter   \u2502\n\u2502  (Production)   \u2502      \u2502  (Testing)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"concepts/ports-adapters/#ports-interfaces","title":"Ports (Interfaces)","text":"<p>A port defines what operations are possible:</p> Python<pre><code># ports/order_port.py\nfrom abc import ABC, abstractmethod\nfrom typing import Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass Order:\n    id: str\n    amount: int\n    status: str\n\nclass OrderPort(ABC):\n    @abstractmethod\n    def create(self, amount: int) -&gt; Order:\n        \"\"\"Create a new order.\"\"\"\n        pass\n\n    @abstractmethod\n    def refund(self, order_id: str) -&gt; Order:\n        \"\"\"Refund an order.\"\"\"\n        pass\n\n    @abstractmethod\n    def get(self, order_id: str) -&gt; Optional[Order]:\n        \"\"\"Get an order by ID.\"\"\"\n        pass\n\n    @abstractmethod\n    def cancel(self, order_id: str) -&gt; Order:\n        \"\"\"Cancel an order.\"\"\"\n        pass\n</code></pre>"},{"location":"concepts/ports-adapters/#adapters-implementations","title":"Adapters (Implementations)","text":""},{"location":"concepts/ports-adapters/#http-adapter-production","title":"HTTP Adapter (Production)","text":"Python<pre><code># adapters/http_order_adapter.py\nfrom venomqa.adapters.http import HttpClient\n\nclass HTTPOrderAdapter(OrderPort):\n    def __init__(self, base_url: str):\n        self.client = HttpClient(base_url)\n\n    def create(self, amount: int) -&gt; Order:\n        resp = self.client.post(\"/orders\", json={\"amount\": amount})\n        data = resp.json()\n        return Order(id=data[\"id\"], amount=amount, status=\"created\")\n\n    def refund(self, order_id: str) -&gt; Order:\n        resp = self.client.post(f\"/orders/{order_id}/refund\")\n        data = resp.json()\n        return Order(id=data[\"id\"], amount=data[\"amount\"], status=\"refunded\")\n\n    def get(self, order_id: str) -&gt; Optional[Order]:\n        resp = self.client.get(f\"/orders/{order_id}\")\n        if resp.status_code == 404:\n            return None\n        data = resp.json()\n        return Order(id=data[\"id\"], amount=data[\"amount\"], status=data[\"status\"])\n\n    def cancel(self, order_id: str) -&gt; Order:\n        resp = self.client.post(f\"/orders/{order_id}/cancel\")\n        data = resp.json()\n        return Order(id=data[\"id\"], amount=data[\"amount\"], status=\"canceled\")\n</code></pre>"},{"location":"concepts/ports-adapters/#mock-adapter-testing","title":"Mock Adapter (Testing)","text":"Python<pre><code># adapters/mock_order_adapter.py\nclass MockOrderAdapter(OrderPort):\n    def __init__(self):\n        self.orders = {}\n        self.next_id = 1\n\n    def create(self, amount: int) -&gt; Order:\n        order = Order(id=str(self.next_id), amount=amount, status=\"created\")\n        self.orders[order.id] = order\n        self.next_id += 1\n        return order\n\n    def refund(self, order_id: str) -&gt; Order:\n        order = self.orders.get(order_id)\n        if order:\n            order.status = \"refunded\"\n        return order\n\n    def get(self, order_id: str) -&gt; Optional[Order]:\n        return self.orders.get(order_id)\n\n    def cancel(self, order_id: str) -&gt; Order:\n        order = self.orders.get(order_id)\n        if order:\n            order.status = \"canceled\"\n        return order\n</code></pre>"},{"location":"concepts/ports-adapters/#using-in-venomqa","title":"Using in VenomQA","text":""},{"location":"concepts/ports-adapters/#with-http-adapter","title":"With HTTP Adapter","text":"Python<pre><code>from venomqa import Action, Agent, BFS, World\nfrom adapters.http_order_adapter import HTTPOrderAdapter\n\norders = HTTPOrderAdapter(\"http://localhost:8000\")\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\ndef create_order(api, context):\n    order = orders.create(amount=100)\n    context.set(\"order_id\", order.id)\n    return order\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    return orders.refund(order_id)\n\nagent = Agent(\n    world=world,\n    actions=[\n        Action(\"create_order\", create_order),\n        Action(\"refund_order\", refund_order),\n    ],\n    invariants=[...],\n    strategy=BFS(),\n).explore()\n</code></pre>"},{"location":"concepts/ports-adapters/#with-mock-adapter","title":"With Mock Adapter","text":"Python<pre><code>from adapters.mock_order_adapter import MockOrderAdapter\n\norders = MockOrderAdapter()\n\n# Use without real server\ndef test_create_refund_flow():\n    order = orders.create(100)\n    assert order.status == \"created\"\n\n    refunded = orders.refund(order.id)\n    assert refunded.status == \"refunded\"\n</code></pre>"},{"location":"concepts/ports-adapters/#venomqas-built-in-adapters","title":"VenomQA's Built-in Adapters","text":"<p>VenomQA provides ready-to-use adapters:</p>"},{"location":"concepts/ports-adapters/#httpclient","title":"HttpClient","text":"Python<pre><code>from venomqa.adapters.http import HttpClient\n\napi = HttpClient(\n    base_url=\"http://localhost:8000\",\n    headers={\"X-API-Key\": \"secret\"},\n    timeout=30.0,\n)\n\nresp = api.get(\"/orders/123\")\nresp = api.post(\"/orders\", json={\"amount\": 100})\nresp = api.put(\"/orders/123\", json={\"amount\": 200})\nresp = api.delete(\"/orders/123\")\n</code></pre>"},{"location":"concepts/ports-adapters/#postgresadapter","title":"PostgresAdapter","text":"Python<pre><code>from venomqa.adapters.postgres import PostgresAdapter\n\ndb = PostgresAdapter(\"postgresql://localhost/testdb\")\n\nrows = db.query(\"SELECT * FROM orders WHERE status = $1\", [\"pending\"])\ndb.execute(\"UPDATE orders SET status = $1 WHERE id = $2\", [\"shipped\", \"123\"])\n</code></pre>"},{"location":"concepts/ports-adapters/#sqliteadapter","title":"SQLiteAdapter","text":"Python<pre><code>from venomqa.adapters.sqlite import SQLiteAdapter\n\ndb = SQLiteAdapter(\"/path/to/database.db\")\n</code></pre>"},{"location":"concepts/ports-adapters/#benefits","title":"Benefits","text":"Aspect Without Ports With Ports Test without server \u2717 \u2713 Swap implementations \u2717 \u2713 Mock in unit tests Hard Easy VenomQA integration Manual Automatic"},{"location":"concepts/ports-adapters/#when-to-use","title":"When to Use","text":""},{"location":"concepts/ports-adapters/#use-ports-adapters-when","title":"Use Ports &amp; Adapters When:","text":"<ul> <li>Your API has complex business logic</li> <li>You want to test without a running server</li> <li>You need multiple implementations (HTTP, gRPC, etc.)</li> <li>You're building a library, not just a client</li> </ul>"},{"location":"concepts/ports-adapters/#skip-when","title":"Skip When:","text":"<ul> <li>You're testing a simple external API</li> <li>The overhead isn't worth it</li> <li>You only have one implementation</li> </ul>"},{"location":"concepts/ports-adapters/#example-full-stack","title":"Example: Full Stack","text":"Python<pre><code># Application code uses ports\nclass OrderService:\n    def __init__(self, orders: OrderPort):\n        self.orders = orders\n\n    def process_refund(self, order_id: str) -&gt; bool:\n        order = self.orders.get(order_id)\n        if not order or order.status != \"created\":\n            return False\n        self.orders.refund(order_id)\n        return True\n\n# Production wiring\nservice = OrderService(HTTPOrderAdapter(\"https://api.example.com\"))\n\n# Test wiring\nservice = OrderService(MockOrderAdapter())\n\n# VenomQA wiring\nworld = World(api=api, state_from_context=[\"order_id\"])\n</code></pre>"},{"location":"concepts/ports-adapters/#next-steps","title":"Next Steps","text":"<ul> <li>Adapters Reference - Full adapter docs</li> <li>Examples - Real-world patterns</li> <li>State Management - Context and state</li> </ul>"},{"location":"concepts/state/","title":"State Management","text":"<p>How VenomQA tracks and restores state across exploration paths.</p>"},{"location":"concepts/state/#two-types-of-state","title":"Two Types of State","text":"<p>VenomQA manages two kinds of state:</p> Type What Storage Use Case Context IDs, tokens, references In-memory dict Passing data between actions System State Database rows, cache External systems The actual app state"},{"location":"concepts/state/#context","title":"Context","text":"<p>The context is a simple key-value store that persists across actions:</p> Python<pre><code>def create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    return api.post(f\"/orders/{order_id}/refund\")\n</code></pre>"},{"location":"concepts/state/#context-api","title":"Context API","text":"Python<pre><code># Set a value\ncontext.set(\"key\", value)\n\n# Get a value (returns None if not set)\nvalue = context.get(\"key\")\n\n# Get with default\nvalue = context.get(\"key\", default=\"fallback\")\n\n# Check if exists\nif context.has(\"key\"):\n    ...\n\n# Delete a value\ncontext.delete(\"key\")\n\n# Clear all\ncontext.clear()\n\n# Get all keys\nkeys = context.keys()\n</code></pre>"},{"location":"concepts/state/#context-checkpointing","title":"Context Checkpointing","text":"<p>When the agent branches, context is automatically copied:</p> Python<pre><code># Original path\ncontext.set(\"order_id\", \"A\")\n\n# Branch 1\ncontext.set(\"status\", \"refunded\")  # Has: order_id=A, status=refunded\n\n# Rollback + Branch 2\ncontext.set(\"status\", \"canceled\")  # Has: order_id=A, status=canceled\n# (status=refunded is gone)\n</code></pre>"},{"location":"concepts/state/#state-extraction","title":"State Extraction","text":"<p>State extraction tells VenomQA how to identify \"the same state\":</p> Python<pre><code>world = World(\n    api=api,\n    state_from_context=[\"order_id\", \"user_id\"],\n)\n</code></pre> <p>This means: \"Two states are identical if <code>order_id</code> and <code>user_id</code> are the same.\"</p>"},{"location":"concepts/state/#why-this-matters","title":"Why This Matters","text":"<p>Without state extraction:</p> Text Only<pre><code>create_order \u2192 [order=A]\n    \u2192 refund \u2192 [order=A, refunded=True]\n    \u2192 rollback\n    \u2192 refund \u2192 [order=A, refunded=True]  \u2190 Explored twice!\n</code></pre> <p>With state extraction:</p> Text Only<pre><code>create_order \u2192 [state: order_id=A]\n    \u2192 refund \u2192 [state: order_id=A, refunded=True]\n    \u2192 (skip: already seen this state)\n</code></pre>"},{"location":"concepts/state/#what-to-extract","title":"What to Extract","text":"<p>Extract values that define distinct states:</p> Python<pre><code># Good: Core resource IDs\nstate_from_context=[\"user_id\", \"order_id\", \"cart_id\"]\n\n# Less useful: Transient values\nstate_from_context=[\"request_id\", \"timestamp\"]  # Changes every run\n\n# Too coarse: Missing important dimensions\nstate_from_context=[\"user_id\"]  # Misses order state changes\n</code></pre>"},{"location":"concepts/state/#system-state","title":"System State","text":"<p>System state lives in databases, caches, files \u2014 anything external to VenomQA.</p>"},{"location":"concepts/state/#with-database-adapters","title":"With Database Adapters","text":"Python<pre><code>from venomqa.adapters.postgres import PostgresAdapter\n\ndb = PostgresAdapter(\"postgresql://localhost/testdb\")\nworld = World(api=api, systems={\"db\": db})\n</code></pre> <p>The adapter handles:</p> <ul> <li>Checkpoint: <code>SAVEPOINT vq_xxx</code></li> <li>Rollback: <code>ROLLBACK TO SAVEPOINT vq_xxx</code></li> <li>State query: <code>SELECT * FROM orders WHERE id = ?</code></li> </ul>"},{"location":"concepts/state/#without-database-adapters","title":"Without Database Adapters","text":"<p>If your API is remote or you can't access the DB:</p> Python<pre><code># Use context-only state\nworld = World(api=api, state_from_context=[\"order_id\"])\n</code></pre> <p>You lose:</p> <ul> <li>True rollback (API state persists)</li> <li>State deduplication via DB queries</li> <li>Invariants that check DB state</li> </ul> <p>But you gain:</p> <ul> <li>Ability to test remote APIs</li> <li>No DB setup required</li> </ul>"},{"location":"concepts/state/#state-in-invariants","title":"State in Invariants","text":"<p>Invariants check state to find bugs:</p> Python<pre><code>def check_refund_consistency(world):\n    \"\"\"Refunded amount in API must match database.\"\"\"\n    api_refunded = world.api.get(\"/orders/123\").json()[\"refunded\"]\n    db_refunded = world.systems[\"db\"].query(\n        \"SELECT refunded FROM orders WHERE id = 123\"\n    )\n    return api_refunded == db_refunded\n\nconsistency = Invariant(\n    \"refund_consistency\",\n    check_refund_consistency,\n    Severity.CRITICAL,\n)\n</code></pre>"},{"location":"concepts/state/#common-invariant-patterns","title":"Common Invariant Patterns","text":"Python<pre><code># 1. No 500 errors\nno_500s = Invariant(\n    \"no_server_errors\",\n    lambda w: w.context.get(\"last_status\", 200) &lt; 500,\n    Severity.CRITICAL,\n)\n\n# 2. State consistency\nconsistency = Invariant(\n    \"api_db_consistency\",\n    lambda w: get_api_count() == get_db_count(),\n    Severity.HIGH,\n)\n\n# 3. Business rules\nno_over_refund = Invariant(\n    \"no_over_refund\",\n    lambda w: get_refunded() &lt;= get_order_total(),\n    Severity.CRITICAL,\n)\n\n# 4. Idempotency\nidempotent = Invariant(\n    \"create_is_idempotent\",\n    lambda w: count_orders() == expected_count,\n    Severity.MEDIUM,\n)\n</code></pre>"},{"location":"concepts/state/#state-serialization","title":"State Serialization","text":"<p>For reproducibility, state can be serialized:</p> Python<pre><code># Get snapshot\nsnapshot = world.serialize()\n\n# Restore from snapshot\nworld.deserialize(snapshot)\n</code></pre> <p>This enables:</p> <ul> <li>Recording/replaying exploration</li> <li>Sharing failing states as bug reports</li> <li>CI reproducibility</li> </ul>"},{"location":"concepts/state/#best-practices","title":"Best Practices","text":""},{"location":"concepts/state/#1-extract-meaningful-state","title":"1. Extract Meaningful State","text":"Python<pre><code># Good\nstate_from_context=[\"user_id\", \"order_id\", \"order_status\"]\n\n# Bad (too granular)\nstate_from_context=[\"user_id\", \"order_id\", \"order_status\", \"last_request_time\"]\n</code></pre>"},{"location":"concepts/state/#2-use-context-for-ids-not-state","title":"2. Use Context for IDs, Not State","text":"Python<pre><code># Good: Store reference\ncontext.set(\"order_id\", resp.json()[\"id\"])\n\n# Bad: Store full state\ncontext.set(\"order\", resp.json())  # Gets stale\n</code></pre>"},{"location":"concepts/state/#3-check-system-state-in-invariants","title":"3. Check System State in Invariants","text":"Python<pre><code># Good: Cross-verify\ndef check(world):\n    return world.api.get(\"/count\") == world.db.count_rows()\n\n# Bad: Only check API\ndef check(world):\n    return world.api.get(\"/count\") &gt; 0  # Could be wrong\n</code></pre>"},{"location":"concepts/state/#4-clean-up-transient-state","title":"4. Clean Up Transient State","text":"Python<pre><code>def teardown(api, context):\n    # Remove test data\n    user_id = context.get(\"user_id\")\n    if user_id:\n        api.delete(f\"/users/{user_id}\")\n</code></pre>"},{"location":"concepts/state/#next-steps","title":"Next Steps","text":"<ul> <li>Checkpoints &amp; Branching - Database rollback</li> <li>Invariants Guide - Writing effective invariants</li> <li>Adapters - Database adapter reference</li> </ul>"},{"location":"concepts/theory/","title":"The Theory","text":"<p>Why sequence testing catches bugs that traditional methods miss.</p>"},{"location":"concepts/theory/#the-problem-with-unit-tests","title":"The Problem with Unit Tests","text":"<p>Unit tests are isolated by design. Each test:</p> <ol> <li>Sets up a fresh fixture</li> <li>Makes one request</li> <li>Asserts the response</li> <li>Tears down</li> </ol> <p>This is great for testing individual endpoints, but it misses how users actually use your API.</p>"},{"location":"concepts/theory/#a-real-bug-that-unit-tests-missed","title":"A Real Bug That Unit Tests Missed","text":"Python<pre><code># test_orders.py - All pass \u2713\n\ndef test_create_order():\n    resp = client.post(\"/orders\", json={\"amount\": 100})\n    assert resp.status_code == 201\n\ndef test_refund_order():\n    order = create_order()  # Fresh fixture\n    resp = client.post(f\"/orders/{order.id}/refund\")\n    assert resp.status_code == 200\n    assert resp.json()[\"refunded\"] == 100\n\ndef test_refund_twice():\n    order = create_order()  # Fresh fixture\n    client.post(f\"/orders/{order.id}/refund\")\n    resp = client.post(f\"/orders/{order.id}/refund\")\n    # This test never gets written because:\n    # - It seems redundant\n    # - Developers assume \"idempotency\" without testing\n</code></pre> <p>All tests pass. But in production:</p> Text Only<pre><code>User: POST /orders         \u2192 {\"id\": \"abc123\", \"amount\": 100}\nUser: POST /orders/abc123/refund \u2192 {\"refunded\": 100}\nUser: POST /orders/abc123/refund \u2192 {\"refunded\": 200}  \u2190 BUG\n</code></pre> <p>The API allows multiple refunds. Each individual call looks valid. The bug only appears in the sequence.</p>"},{"location":"concepts/theory/#the-state-graph-model","title":"The State Graph Model","text":"<p>Every stateful API defines an implicit state machine:</p> Text Only<pre><code>States:     What data exists right now\nActions:    What transitions are possible\nInvariants: What must always be true\n</code></pre>"},{"location":"concepts/theory/#example-e-commerce-order","title":"Example: E-commerce Order","text":"Text Only<pre><code>States:\n  - [empty]      No order exists\n  - [created]    Order exists, not paid\n  - [paid]       Order paid, not shipped\n  - [shipped]    Order shipped\n  - [refunded]   Order refunded\n  - [canceled]   Order canceled\n\nActions:\n  - create_order   [empty] \u2192 [created]\n  - pay_order      [created] \u2192 [paid]\n  - ship_order     [paid] \u2192 [shipped]\n  - refund_order   [paid] | [shipped] \u2192 [refunded]\n  - cancel_order   [created] | [paid] \u2192 [canceled]\n\nInvariants:\n  - refunded_amount \u2264 original_amount\n  - cannot_refund_canceled\n  - cannot_ship_unpaid\n</code></pre>"},{"location":"concepts/theory/#why-this-is-hard-to-test-manually","title":"Why This Is Hard to Test Manually","text":"<p>For this simple model, there are 20+ valid sequences:</p> Text Only<pre><code>create \u2192 pay \u2192 ship \u2192 refund\ncreate \u2192 pay \u2192 refund\ncreate \u2192 pay \u2192 ship\ncreate \u2192 cancel\ncreate \u2192 pay \u2192 cancel\ncreate \u2192 pay \u2192 ship \u2192 refund \u2192 refund (?)\n...\n</code></pre> <p>Nobody writes 20 tests. They write 3-5 and call it done.</p> <p>VenomQA explores all 20 automatically.</p>"},{"location":"concepts/theory/#the-combinatorial-explosion","title":"The Combinatorial Explosion","text":"<p>As your API grows, the number of possible sequences explodes:</p> Actions Depth 3 Depth 5 Depth 10 3 27 243 59,049 5 125 3,125 9.7M 10 1,000 100,000 10B <p>VenomQA uses intelligent pruning:</p> <ol> <li>Precondition checks: Skip actions that don't apply</li> <li>State deduplication: Don't revisit identical states</li> <li>Invariant early-exit: Stop exploring violating paths</li> <li>Budget limits: Configurable max depth and steps</li> </ol> <p>This brings exploration from \"impossible\" to \"runs in CI.\"</p>"},{"location":"concepts/theory/#what-bugs-does-this-catch","title":"What Bugs Does This Catch?","text":""},{"location":"concepts/theory/#1-double-operations","title":"1. Double Operations","text":"Python<pre><code># create \u2192 delete \u2192 delete\n# Bug: Second delete returns 200 instead of 404\n</code></pre>"},{"location":"concepts/theory/#2-stale-state","title":"2. Stale State","text":"Python<pre><code># create \u2192 update \u2192 delete \u2192 get\n# Bug: Get returns cached data instead of 404\n</code></pre>"},{"location":"concepts/theory/#3-order-dependent-failures","title":"3. Order-Dependent Failures","text":"Python<pre><code># create_A \u2192 create_B \u2192 delete_A \u2192 get_B\n# Bug: Deleting A corrupts B's state\n</code></pre>"},{"location":"concepts/theory/#4-idempotency-violations","title":"4. Idempotency Violations","text":"Python<pre><code># create \u2192 create (same idempotency key)\n# Bug: Creates two orders instead of one\n</code></pre>"},{"location":"concepts/theory/#5-missing-authorization-checks","title":"5. Missing Authorization Checks","text":"Python<pre><code># create_as_user_A \u2192 delete_as_user_B\n# Bug: User B can delete User A's resource\n</code></pre>"},{"location":"concepts/theory/#6-race-conditions-with-parallel-actions","title":"6. Race Conditions (with parallel actions)","text":"Python<pre><code># create \u2192 [refund_1 || refund_2]\n# Bug: Both refunds succeed simultaneously\n</code></pre>"},{"location":"concepts/theory/#the-complement-not-replacement","title":"The Complement, Not Replacement","text":"<p>VenomQA doesn't replace your existing tests:</p> Tool Catches Misses pytest Logic errors, edge cases Sequences Schemathesis Schema violations, fuzzing Sequences VenomQA Sequence bugs Fuzzing Postman Manual verification Automation <p>Best practice: Run all three in CI.</p> YAML<pre><code># .github/workflows/test.yml\njobs:\n  unit-tests:\n    run: pytest tests/\n\n  schema-tests:\n    run: schemathesis run schema.yaml\n\n  sequence-tests:\n    run: venomqa run qa/\n</code></pre>"},{"location":"concepts/theory/#key-insight","title":"Key Insight","text":"<p>The bug isn't in any single endpoint. It's in the space between them.</p> <p>VenomQA explores that space systematically.</p>"},{"location":"concepts/theory/#next-steps","title":"Next Steps","text":"<ul> <li>Journeys - How to define action chains</li> <li>Checkpoints &amp; Branching - Database rollback</li> <li>Quickstart - Try it yourself</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Real-world VenomQA examples using the exploration API.</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":"<ul> <li> <p> CRUD Operations</p> <p>Complete create\u2192read\u2192update\u2192delete testing with invariants for idempotency, consistency, and state transitions.</p> <p> CRUD Example</p> </li> <li> <p> Authentication Flows</p> <p>Login, logout, token refresh, session management, multi-user scenarios, and permission boundary testing.</p> <p> Auth Example</p> </li> <li> <p> E-commerce Checkout</p> <p>Cart management, payment processing, refunds, order state transitions, and inventory validation.</p> <p> Checkout Example</p> </li> </ul>"},{"location":"examples/#core-pattern","title":"Core Pattern","text":"<p>All examples follow the same structure:</p> Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  1. Define Actions    \u2192  What API calls can be made        \u2502\n\u2502  2. Define Invariants \u2192  What rules must always hold       \u2502\n\u2502  3. Create World      \u2192  API client + state management     \u2502\n\u2502  4. Run Agent         \u2192  Autonomous exploration            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/#minimal-example","title":"Minimal Example","text":"<p>The simplest exploration setup:</p> Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\ndef create_item(api, context):\n    resp = api.post(\"/items\", json={\"name\": \"test\"})\n    context.set(\"item_id\", resp.json()[\"id\"])\n    return resp\n\ndef delete_item(api, context):\n    item_id = context.get(\"item_id\")\n    if item_id is None:\n        return None  # Skip \u2014 no item to delete\n    return api.delete(f\"/items/{item_id}\")\n\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"item_id\"])\n\nagent = Agent(\n    world=world,\n    actions=[\n        Action(\"create_item\", create_item),\n        Action(\"delete_item\", delete_item),\n    ],\n    invariants=[\n        Invariant(\"no_500s\", lambda w: w.context.get(\"last_status\", 200) &lt; 500, Severity.CRITICAL),\n    ],\n    strategy=BFS(),\n    max_steps=50,\n)\n\nresult = agent.explore()\nprint(f\"States: {result.states_visited}, Violations: {len(result.violations)}\")\n</code></pre>"},{"location":"examples/#key-concepts","title":"Key Concepts","text":"Concept Description Action One API operation: <code>(api, context) -&gt; response</code> Invariant Rule checked after every action: <code>(world) -&gt; bool</code> World Sandbox with <code>api</code> client and <code>context</code> store Agent Orchestrates exploration with a strategy BFS() Breadth-first exploration of all sequences"},{"location":"examples/#why-these-patterns-work","title":"Why These Patterns Work","text":""},{"location":"examples/#actions-are-stateless-functions","title":"Actions Are Stateless Functions","text":"<p>Each action is a pure function of the current state. It receives <code>api</code> to make calls and <code>context</code> to read/write shared data:</p> Python<pre><code>def update_item(api, context):\n    item_id = context.get(\"item_id\")\n    if item_id is None:\n        return None  # Precondition not met \u2014 skip this action\n    return api.put(f\"/items/{item_id}\", json={\"name\": \"updated\"})\n</code></pre> <p>Returning <code>None</code> tells the agent to skip \u2014 the precondition wasn't met.</p>"},{"location":"examples/#invariants-are-checked-after-every-step","title":"Invariants Are Checked After Every Step","text":"<p>Unlike unit tests that assert at the end, VenomQA invariants run after every single action:</p> Python<pre><code>def no_negative_balance(world):\n    balance = world.context.get(\"balance\", 0)\n    return balance &gt;= 0\n\ninvariant = Invariant(\"positive_balance\", no_negative_balance, Severity.CRITICAL)\n</code></pre> <p>If <code>create \u2192 refund \u2192 refund</code> makes the balance negative, the invariant fires after the second refund.</p>"},{"location":"examples/#context-tracks-state-between-actions","title":"Context Tracks State Between Actions","text":"<p>Use <code>context.set()</code> to save values and <code>context.get()</code> to retrieve them:</p> Python<pre><code>def create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    context.set(\"order_amount\", resp.json()[\"amount\"])\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    amount = context.get(\"order_amount\", 0)\n    return api.post(f\"/orders/{order_id}/refund\", json={\"amount\": amount})\n</code></pre>"},{"location":"examples/#exploration-tries-all-sequences","title":"Exploration Tries All Sequences","text":"<p>With BFS, the agent explores:</p> <ul> <li><code>create \u2192 read \u2192 delete</code></li> <li><code>create \u2192 delete \u2192 read</code> (should fail)</li> <li><code>create \u2192 update \u2192 delete</code></li> <li><code>create \u2192 update \u2192 update \u2192 delete</code></li> </ul> <p>Every path through the state graph gets tested.</p>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>Each example page includes a complete, runnable Python file. To run:</p> Bash<pre><code># 1. Start your API server (or use the mock servers included)\npython -m your_api_server\n\n# 2. Run the example\npython examples/crud/test_crud.py\n\n# 3. Or use the CLI\nvenomqa run examples/crud/\n</code></pre>"},{"location":"examples/#project-structure","title":"Project Structure","text":"<p>Recommended layout for your QA suite:</p> Text Only<pre><code>qa/\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 items.py      # Item CRUD actions\n\u2502   \u2514\u2500\u2500 users.py      # User management actions\n\u251c\u2500\u2500 invariants/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 rules.py      # Domain invariants\n\u251c\u2500\u2500 test_items.py     # Item exploration\n\u251c\u2500\u2500 test_users.py     # User exploration\n\u2514\u2500\u2500 test_checkout.py  # Checkout flow exploration\n</code></pre>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>CRUD Operations \u2014 Learn the fundamental patterns</li> <li>Authentication Flows \u2014 Multi-user stateful testing</li> <li>E-commerce Checkout \u2014 Complex state machines</li> </ul>"},{"location":"examples/auth/","title":"Authentication Flows","text":"<p>Complete example testing authentication systems: login, logout, token refresh, session expiry, multi-user scenarios, and permission boundaries.</p>"},{"location":"examples/auth/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Multi-role authentication testing</li> <li>Token lifecycle management</li> <li>Permission boundary invariants</li> <li>Session state exploration</li> <li>Security-focused invariant patterns</li> </ul>"},{"location":"examples/auth/#complete-example","title":"Complete Example","text":"Python<pre><code>\"\"\"\nAuthentication Flows Example\n\nTests an authentication API with these endpoints:\n- POST /auth/login          \u2192 Login with email/password\n- POST /auth/logout         \u2192 Invalidate session\n- POST /auth/refresh        \u2192 Refresh access token\n- GET  /users/me            \u2192 Get current user profile\n- GET  /admin/users         \u2192 Admin: list all users\n- DELETE /admin/users/{id}  \u2192 Admin: delete user\n\nRun: python test_auth.py\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom venomqa import (\n    Action,\n    Agent,\n    BFS,\n    Invariant,\n    Severity,\n    World,\n)\nfrom venomqa.adapters.http import HttpClient\n\n\n# =============================================================================\n# CONTEXT KEYS\n# =============================================================================\n# auth_role: \"admin\" | \"user\" | None (current logged-in role)\n# access_token: str | None\n# refresh_token: str | None\n# last_status: int\n# created_user_id: str | None (for admin user creation)\n\n\n# =============================================================================\n# ACTIONS \u2014 AUTHENTICATION\n# =============================================================================\n\ndef login_as_admin(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Login as admin user.\"\"\"\n    resp = api.post(\"/auth/login\", json={\n        \"email\": \"admin@example.com\",\n        \"password\": \"adminpass123\",\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"access_token\", data[\"access_token\"])\n        context.set(\"refresh_token\", data.get(\"refresh_token\"))\n        context.set(\"auth_role\", \"admin\")\n        api.set_auth_token(data[\"access_token\"])\n        return data\n    return None\n\n\ndef login_as_user(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Login as regular user.\"\"\"\n    # First ensure the test user exists\n    resp = api.post(\"/auth/login\", json={\n        \"email\": \"user@example.com\",\n        \"password\": \"userpass123\",\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"access_token\", data[\"access_token\"])\n        context.set(\"refresh_token\", data.get(\"refresh_token\"))\n        context.set(\"auth_role\", \"user\")\n        api.set_auth_token(data[\"access_token\"])\n        return data\n    return None\n\n\ndef logout(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Logout and invalidate session.\n\n    Requires: Must be logged in (access_token exists)\n    \"\"\"\n    if context.get(\"access_token\") is None:\n        return None  # Skip \u2014 not logged in\n\n    resp = api.post(\"/auth/logout\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code in [200, 204]:\n        context.delete(\"access_token\")\n        context.delete(\"refresh_token\")\n        context.delete(\"auth_role\")\n        api.clear_auth_token()\n        return {}\n    return None\n\n\ndef refresh_token(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Refresh access token using refresh token.\n\n    Requires: refresh_token must exist\n    \"\"\"\n    refresh = context.get(\"refresh_token\")\n    if refresh is None:\n        return None  # Skip \u2014 no refresh token\n\n    resp = api.post(\"/auth/refresh\", json={\n        \"refresh_token\": refresh,\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"access_token\", data[\"access_token\"])\n        api.set_auth_token(data[\"access_token\"])\n        return data\n    return None\n\n\n# =============================================================================\n# ACTIONS \u2014 USER OPERATIONS\n# =============================================================================\n\ndef get_profile(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Get current user's profile.\n\n    Requires: Must be logged in\n    \"\"\"\n    if context.get(\"access_token\") is None:\n        return None  # Skip \u2014 not authenticated\n\n    resp = api.get(\"/users/me\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        return resp.json()\n    return None\n\n\ndef access_protected_resource(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Access a protected resource.\n\n    Requires: Must be logged in\n    \"\"\"\n    if context.get(\"access_token\") is None:\n        return None\n\n    resp = api.get(\"/protected\")\n    context.set(\"last_status\", resp.status_code)\n    return resp.json() if resp.status_code == 200 else None\n\n\ndef access_after_logout(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Try to access protected resource after logout.\n\n    This tests that tokens are properly invalidated.\n    \"\"\"\n    # We need to have logged out but still have the old token stored\n    old_token = context.get(\"old_access_token\")\n    if old_token is None:\n        return None\n\n    # Try using the old token\n    api.set_auth_token(old_token)\n    resp = api.get(\"/users/me\")\n    context.set(\"last_status\", resp.status_code)\n\n    # Clear it again\n    api.clear_auth_token()\n    return resp.json() if resp.status_code == 200 else None\n\n\n# =============================================================================\n# ACTIONS \u2014 ADMIN OPERATIONS\n# =============================================================================\n\ndef admin_list_users(api: HttpClient, context) -&gt; list | None:\n    \"\"\"Admin: List all users.\n\n    Requires: Must be logged in as admin\n    \"\"\"\n    if context.get(\"auth_role\") != \"admin\":\n        return None  # Skip \u2014 not admin\n\n    resp = api.get(\"/admin/users\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        return resp.json()\n    return None\n\n\ndef admin_create_user(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Admin: Create a new user.\n\n    Requires: Must be logged in as admin\n    \"\"\"\n    if context.get(\"auth_role\") != \"admin\":\n        return None\n\n    resp = api.post(\"/admin/users\", json={\n        \"email\": \"newuser@example.com\",\n        \"password\": \"newpass123\",\n        \"role\": \"user\",\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code in [200, 201]:\n        data = resp.json()\n        context.set(\"created_user_id\", data[\"id\"])\n        return data\n    return None\n\n\ndef admin_delete_user(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Admin: Delete the created user.\n\n    Requires: Must be admin AND have created a user\n    \"\"\"\n    if context.get(\"auth_role\") != \"admin\":\n        return None\n\n    user_id = context.get(\"created_user_id\")\n    if user_id is None:\n        return None  # No user to delete\n\n    resp = api.delete(f\"/admin/users/{user_id}\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code in [200, 204]:\n        context.delete(\"created_user_id\")\n        return {}\n    return None\n\n\ndef user_try_admin_endpoint(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Regular user attempts to access admin endpoint.\n\n    Requires: Must be logged in as regular user (not admin)\n    This should fail with 403 Forbidden.\n    \"\"\"\n    role = context.get(\"auth_role\")\n    if role != \"user\":\n        return None  # Only test this as regular user\n\n    resp = api.get(\"/admin/users\")\n    context.set(\"last_status\", resp.status_code)\n    context.set(\"tried_admin_as_user\", True)\n    return resp.json() if resp.status_code == 200 else None\n\n\n# =============================================================================\n# INVARIANTS\n# =============================================================================\n\ndef no_server_errors(world: World) -&gt; bool:\n    \"\"\"No 5xx errors should occur.\"\"\"\n    return world.context.get(\"last_status\", 200) &lt; 500\n\n\ndef unauthenticated_cannot_access_protected(world: World) -&gt; bool:\n    \"\"\"Without a token, protected endpoints should return 401.\"\"\"\n    token = world.context.get(\"access_token\")\n    status = world.context.get(\"last_status\", 200)\n\n    # If we tried to access protected without a token\n    if token is None and status in [401, 403]:\n        return True\n    return True  # Pass if condition doesn't apply\n\n\ndef user_cannot_access_admin(world: World) -&gt; bool:\n    \"\"\"Regular users should get 403 on admin endpoints.\"\"\"\n    role = world.context.get(\"auth_role\")\n    tried_admin = world.context.get(\"tried_admin_as_user\")\n    status = world.context.get(\"last_status\")\n\n    if role == \"user\" and tried_admin and status is not None:\n        return status == 403\n    return True\n\n\ndef logout_invalidates_token(world: World) -&gt; bool:\n    \"\"\"After logout, the old token should not work.\"\"\"\n    old_token = world.context.get(\"old_access_token\")\n    status = world.context.get(\"last_status\")\n\n    if old_token is not None and status is not None:\n        return status in [401, 403]\n    return True\n\n\ndef token_refresh_preserves_role(world: World) -&gt; bool:\n    \"\"\"Token refresh should not change user role.\"\"\"\n    role_before = world.context.get(\"auth_role_before_refresh\")\n    role_after = world.context.get(\"auth_role\")\n\n    if role_before is not None and role_after is not None:\n        return role_before == role_after\n    return True\n\n\ndef no_token_leak_in_responses(world: World) -&gt; bool:\n    \"\"\"Sensitive tokens should not leak in response bodies.\n\n    This is a placeholder \u2014 real implementation would check\n    response bodies for token patterns.\n    \"\"\"\n    return True\n\n\n# =============================================================================\n# BUILD INVARIANT OBJECTS\n# =============================================================================\n\nINVARIANTS = [\n    Invariant(\n        name=\"no_server_errors\",\n        check=no_server_errors,\n        message=\"Server returned 5xx error during auth flow\",\n        severity=Severity.CRITICAL,\n    ),\n    Invariant(\n        name=\"user_cannot_access_admin\",\n        check=user_cannot_access_admin,\n        message=\"Regular user accessed admin endpoint\",\n        severity=Severity.CRITICAL,\n    ),\n    Invariant(\n        name=\"logout_invalidates_token\",\n        check=logout_invalidates_token,\n        message=\"Token still valid after logout\",\n        severity=Severity.HIGH,\n    ),\n    Invariant(\n        name=\"unauthenticated_blocked\",\n        check=unauthenticated_cannot_access_protected,\n        message=\"Unauthenticated request was not blocked\",\n        severity=Severity.HIGH,\n    ),\n]\n\n\n# =============================================================================\n# BUILD ACTIONS\n# =============================================================================\n\nACTIONS = [\n    # Authentication\n    Action(\n        name=\"login_as_admin\",\n        execute=login_as_admin,\n        description=\"Login as admin user\",\n        tags=[\"auth\", \"login\"],\n    ),\n    Action(\n        name=\"login_as_user\",\n        execute=login_as_user,\n        description=\"Login as regular user\",\n        tags=[\"auth\", \"login\"],\n    ),\n    Action(\n        name=\"logout\",\n        execute=logout,\n        description=\"Logout and invalidate session\",\n        tags=[\"auth\", \"logout\"],\n    ),\n    Action(\n        name=\"refresh_token\",\n        execute=refresh_token,\n        description=\"Refresh access token\",\n        tags=[\"auth\", \"token\"],\n    ),\n    # User operations\n    Action(\n        name=\"get_profile\",\n        execute=get_profile,\n        description=\"Get current user profile\",\n        tags=[\"user\", \"read\"],\n    ),\n    Action(\n        name=\"access_protected\",\n        execute=access_protected_resource,\n        description=\"Access protected resource\",\n        tags=[\"user\", \"read\"],\n    ),\n    Action(\n        name=\"access_after_logout\",\n        execute=access_after_logout,\n        description=\"Try accessing with invalidated token\",\n        tags=[\"auth\", \"security\"],\n    ),\n    # Admin operations\n    Action(\n        name=\"admin_list_users\",\n        execute=admin_list_users,\n        description=\"Admin: list all users\",\n        tags=[\"admin\", \"read\"],\n    ),\n    Action(\n        name=\"admin_create_user\",\n        execute=admin_create_user,\n        description=\"Admin: create new user\",\n        tags=[\"admin\", \"write\"],\n    ),\n    Action(\n        name=\"admin_delete_user\",\n        execute=admin_delete_user,\n        description=\"Admin: delete user\",\n        tags=[\"admin\", \"write\"],\n    ),\n    Action(\n        name=\"user_try_admin\",\n        execute=user_try_admin_endpoint,\n        description=\"User attempts admin endpoint\",\n        tags=[\"auth\", \"security\"],\n    ),\n]\n\n\n# =============================================================================\n# MAIN\n# =============================================================================\n\nif __name__ == \"__main__\":\n    api = HttpClient(\"http://localhost:8000\")\n    world = World(api=api, state_from_context=[\"access_token\", \"auth_role\"])\n\n    agent = Agent(\n        world=world,\n        actions=ACTIONS,\n        invariants=INVARIANTS,\n        strategy=BFS(),\n        max_steps=150,\n    )\n\n    result = agent.explore()\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"AUTHENTICATION EXPLORATION RESULTS\")\n    print(\"=\" * 60)\n    print(f\"States visited:    {result.states_visited}\")\n    print(f\"Transitions taken: {result.transitions_taken}\")\n    print(f\"Action coverage:   {result.action_coverage_percent:.0f}%\")\n    print(f\"Duration:          {result.duration_ms:.0f} ms\")\n    print(f\"Violations found:  {len(result.violations)}\")\n\n    if result.violations:\n        print(\"\\nVIOLATIONS:\")\n        for v in result.violations:\n            print(f\"  [{v.severity.value.upper()}] {v.invariant_name}\")\n            print(f\"    {v.message}\")\n    else:\n        print(\"\\nNo violations \u2014 all auth invariants passed.\")\n\n    print(\"=\" * 60)\n</code></pre>"},{"location":"examples/auth/#why-these-patterns-matter","title":"Why These Patterns Matter","text":""},{"location":"examples/auth/#role-based-action-preconditions","title":"Role-Based Action Preconditions","text":"<p>Actions check their required role:</p> Python<pre><code>def admin_list_users(api, context):\n    if context.get(\"auth_role\") != \"admin\":\n        return None  # Skip \u2014 not admin\n    ...\n</code></pre> <p>This ensures the agent only runs admin actions when an admin is logged in, and tests permission boundaries by having regular users attempt admin operations.</p>"},{"location":"examples/auth/#token-lifecycle-tracking","title":"Token Lifecycle Tracking","text":"<p>Context tracks the full auth state:</p> Variable Meaning <code>access_token</code> Current valid token <code>refresh_token</code> Token for refreshing <code>auth_role</code> Current user role <code>old_access_token</code> Token after logout (for testing)"},{"location":"examples/auth/#security-invariants","title":"Security Invariants","text":"Python<pre><code>def user_cannot_access_admin(world):\n    role = world.context.get(\"auth_role\")\n    tried_admin = world.context.get(\"tried_admin_as_user\")\n    status = world.context.get(\"last_status\")\n\n    if role == \"user\" and tried_admin and status is not None:\n        return status == 403  # Must be forbidden\n    return True\n</code></pre> <p>This catches privilege escalation bugs where a regular user could access admin endpoints.</p>"},{"location":"examples/auth/#sequences-tested","title":"Sequences Tested","text":"Sequence What It Tests <code>login_as_user \u2192 get_profile</code> Basic auth flow <code>login_as_user \u2192 user_try_admin</code> Permission boundary <code>login_as_admin \u2192 admin_list_users</code> Admin access works <code>login_as_admin \u2192 logout \u2192 access_after_logout</code> Token invalidation <code>login_as_user \u2192 logout \u2192 login_as_admin</code> Role switching <code>login_as_admin \u2192 refresh_token \u2192 admin_list_users</code> Refresh preserves role"},{"location":"examples/auth/#multi-user-state","title":"Multi-User State","text":"<p>For testing interactions between users, use multiple world instances:</p> Python<pre><code>admin_world = World(api=admin_api, state_from_context=[\"access_token\"])\nuser_world = World(api=user_api, state_from_context=[\"access_token\"])\n\n# Run separate explorations, then check cross-user invariants\nadmin_result = Agent(world=admin_world, actions=admin_actions, ...).explore()\nuser_result = Agent(world=user_world, actions=user_actions, ...).explore()\n</code></pre>"},{"location":"examples/auth/#expected-output","title":"Expected Output","text":"Text Only<pre><code>============================================================\nAUTHENTICATION EXPLORATION RESULTS\n============================================================\nStates visited:    18\nTransitions taken: 42\nAction coverage:   100%\nDuration:          234 ms\nViolations found:  0\n\nNo violations \u2014 all auth invariants passed.\n============================================================\n</code></pre>"},{"location":"examples/auth/#common-auth-bugs-found","title":"Common Auth Bugs Found","text":"Bug Sequence That Finds It Token not invalidated on logout <code>login \u2192 logout \u2192 access_protected</code> User can access admin endpoints <code>login_as_user \u2192 user_try_admin</code> Refresh changes role <code>login_as_admin \u2192 refresh_token \u2192 admin_action</code> Old refresh token still works <code>login \u2192 refresh \u2192 use_old_refresh</code> Deleted user token still valid <code>login_as_admin \u2192 delete_user \u2192 deleted_user_access</code>"},{"location":"examples/auth/#next-steps","title":"Next Steps","text":"<ul> <li>E-commerce Checkout \u2014 Complex payment state machines</li> <li>CRUD Operations \u2014 Basic patterns</li> </ul>"},{"location":"examples/checkout/","title":"E-commerce Checkout","text":"<p>Complete example testing e-commerce flows: cart management, payment processing, refunds, order state transitions, and inventory validation.</p>"},{"location":"examples/checkout/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Complex state machine testing</li> <li>Financial invariant patterns</li> <li>Inventory consistency checks</li> <li>Order lifecycle exploration</li> <li>Multi-step transaction testing</li> </ul>"},{"location":"examples/checkout/#complete-example","title":"Complete Example","text":"Python<pre><code>\"\"\"\nE-commerce Checkout Example\n\nTests an e-commerce API with these endpoints:\n- POST   /cart/items              \u2192 Add item to cart\n- GET    /cart                    \u2192 Get cart contents\n- DELETE /cart/items/{id}         \u2192 Remove item from cart\n- POST   /cart/coupon             \u2192 Apply discount coupon\n- POST   /checkout                \u2192 Create order from cart\n- GET    /orders/{id}             \u2192 Get order details\n- POST   /orders/{id}/pay         \u2192 Pay for order\n- POST   /orders/{id}/refund      \u2192 Refund order\n- POST   /orders/{id}/cancel      \u2192 Cancel order\n- GET    /products/{id}/stock     \u2192 Check inventory\n\nRun: python test_checkout.py\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom venomqa import (\n    Action,\n    Agent,\n    BFS,\n    Invariant,\n    Severity,\n    World,\n)\nfrom venomqa.adapters.http import HttpClient\n\n\n# =============================================================================\n# CONTEXT KEYS\n# =============================================================================\n# cart_id: str | None\n# order_id: str | None\n# order_total: float\n# order_paid: float\n# order_refunded: float\n# product_id: str\n# initial_stock: int\n# current_stock: int\n# last_status: int\n\n\n# =============================================================================\n# ACTIONS \u2014 SETUP &amp; AUTH\n# =============================================================================\n\ndef login_customer(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Login as a customer.\"\"\"\n    resp = api.post(\"/auth/login\", json={\n        \"email\": \"customer@example.com\",\n        \"password\": \"customer123\",\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        data = resp.json()\n        api.set_auth_token(data[\"access_token\"])\n        context.set(\"customer_id\", data[\"user\"][\"id\"])\n        return data\n    return None\n\n\ndef get_product_and_stock(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Fetch product info and current stock level.\"\"\"\n    resp = api.get(\"/products\")\n\n    if resp.status_code == 200:\n        products = resp.json()\n        if products and len(products) &gt; 0:\n            product = products[0]\n            context.set(\"product_id\", product[\"id\"])\n            context.set(\"product_price\", product[\"price\"])\n\n            # Get stock\n            stock_resp = api.get(f\"/products/{product['id']}/stock\")\n            if stock_resp.status_code == 200:\n                stock = stock_resp.json()[\"quantity\"]\n                context.set(\"initial_stock\", stock)\n                context.set(\"current_stock\", stock)\n                return product\n    return None\n\n\n# =============================================================================\n# ACTIONS \u2014 CART MANAGEMENT\n# =============================================================================\n\ndef add_to_cart(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Add product to cart.\n\n    Requires: product_id must exist\n    \"\"\"\n    product_id = context.get(\"product_id\")\n    if product_id is None:\n        return None\n\n    quantity = context.get(\"add_quantity\", 1)\n\n    resp = api.post(\"/cart/items\", json={\n        \"product_id\": product_id,\n        \"quantity\": quantity,\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code in [200, 201]:\n        data = resp.json()\n        context.set(\"cart_id\", data.get(\"cart_id\"))\n        context.set(\"cart_total\", data.get(\"total\"))\n        context.set(\"cart_item_count\", data.get(\"item_count\"))\n        return data\n    return None\n\n\ndef add_more_to_cart(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Add another item to the cart.\"\"\"\n    if context.get(\"cart_id\") is None:\n        return None  # No cart yet\n\n    product_id = context.get(\"product_id\")\n    if product_id is None:\n        return None\n\n    resp = api.post(\"/cart/items\", json={\n        \"product_id\": product_id,\n        \"quantity\": 2,\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"cart_total\", data.get(\"total\"))\n        return data\n    return None\n\n\ndef get_cart(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Get current cart contents.\"\"\"\n    if context.get(\"cart_id\") is None:\n        return None\n\n    resp = api.get(\"/cart\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        return resp.json()\n    return None\n\n\ndef remove_from_cart(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Remove item from cart.\"\"\"\n    if context.get(\"cart_id\") is None:\n        return None\n\n    resp = api.delete(\"/cart/items/1\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code in [200, 204]:\n        return {}\n    return None\n\n\ndef apply_coupon(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Apply a discount coupon.\n\n    Requires: cart must exist\n    \"\"\"\n    if context.get(\"cart_id\") is None:\n        return None\n\n    resp = api.post(\"/cart/coupon\", json={\n        \"code\": \"SAVE10\",\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"discount\", data.get(\"discount\"))\n        context.set(\"cart_total\", data.get(\"total\"))\n        return data\n    return None\n\n\ndef clear_cart(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Clear all items from cart.\"\"\"\n    if context.get(\"cart_id\") is None:\n        return None\n\n    resp = api.delete(\"/cart/items\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code in [200, 204]:\n        context.delete(\"cart_total\")\n        return {}\n    return None\n\n\n# =============================================================================\n# ACTIONS \u2014 CHECKOUT &amp; ORDER\n# =============================================================================\n\ndef create_order(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Create order from cart.\n\n    Requires: cart with items must exist\n    \"\"\"\n    if context.get(\"cart_id\") is None:\n        return None\n    if context.get(\"cart_total\", 0) &lt;= 0:\n        return None  # Empty cart\n\n    resp = api.post(\"/checkout\", json={\n        \"shipping_address\": {\n            \"street\": \"123 Main St\",\n            \"city\": \"New York\",\n            \"zip\": \"10001\",\n            \"country\": \"US\",\n        },\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code in [200, 201]:\n        data = resp.json()\n        context.set(\"order_id\", data[\"id\"])\n        context.set(\"order_total\", data[\"total\"])\n        context.set(\"order_status\", data[\"status\"])\n        context.set(\"order_paid\", 0.0)\n        context.set(\"order_refunded\", 0.0)\n        context.delete(\"cart_id\")  # Cart is consumed\n        return data\n    return None\n\n\ndef get_order(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Get order details.\n\n    Requires: order must exist\n    \"\"\"\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None\n\n    resp = api.get(f\"/orders/{order_id}\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"order_status\", data[\"status\"])\n        return data\n    return None\n\n\n# =============================================================================\n# ACTIONS \u2014 PAYMENT\n# =============================================================================\n\ndef pay_order(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Pay for order with credit card.\n\n    Requires: order must exist and be unpaid\n    \"\"\"\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None\n\n    # Check if already paid\n    if context.get(\"order_paid\", 0) &gt;= context.get(\"order_total\", 0):\n        return None  # Already paid\n\n    resp = api.post(f\"/orders/{order_id}/pay\", json={\n        \"method\": \"credit_card\",\n        \"card\": {\n            \"number\": \"4242424242424242\",\n            \"exp_month\": 12,\n            \"exp_year\": 2025,\n            \"cvv\": \"123\",\n        },\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"order_paid\", data.get(\"amount_paid\", context.get(\"order_total\")))\n        context.set(\"order_status\", data.get(\"status\", \"paid\"))\n\n        # Update stock\n        new_stock = context.get(\"current_stock\", 0) - 1\n        context.set(\"current_stock\", max(0, new_stock))\n        return data\n    return None\n\n\ndef pay_with_invalid_card(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Attempt payment with declined card.\n\n    Should fail gracefully.\n    \"\"\"\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None\n\n    resp = api.post(f\"/orders/{order_id}/pay\", json={\n        \"method\": \"credit_card\",\n        \"card\": {\n            \"number\": \"4000000000000002\",  # Test decline card\n            \"exp_month\": 12,\n            \"exp_year\": 2025,\n            \"cvv\": \"123\",\n        },\n    })\n\n    context.set(\"last_status\", resp.status_code)\n    context.set(\"payment_declined\", resp.status_code != 200)\n    return resp.json() if resp.status_code == 200 else None\n\n\n# =============================================================================\n# ACTIONS \u2014 ORDER LIFECYCLE\n# =============================================================================\n\ndef refund_order(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Request full refund for order.\n\n    Requires: order must be paid\n    \"\"\"\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None\n\n    # Must be paid to refund\n    if context.get(\"order_paid\", 0) &lt;= 0:\n        return None\n\n    refund_amount = context.get(\"order_paid\", 0)\n\n    resp = api.post(f\"/orders/{order_id}/refund\", json={\n        \"amount\": refund_amount,\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        data = resp.json()\n        current_refunded = context.get(\"order_refunded\", 0)\n        context.set(\"order_refunded\", current_refunded + refund_amount)\n        context.set(\"order_status\", data.get(\"status\", \"refunded\"))\n        return data\n    return None\n\n\ndef partial_refund(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Request partial refund.\n\n    Requires: order must be paid with remaining refundable amount\n    \"\"\"\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None\n\n    order_paid = context.get(\"order_paid\", 0)\n    already_refunded = context.get(\"order_refunded\", 0)\n    remaining = order_paid - already_refunded\n\n    if remaining &lt;= 0:\n        return None  # Nothing left to refund\n\n    partial_amount = remaining / 2  # Refund half of remaining\n\n    resp = api.post(f\"/orders/{order_id}/refund\", json={\n        \"amount\": partial_amount,\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        context.set(\"order_refunded\", already_refunded + partial_amount)\n        return resp.json()\n    return None\n\n\ndef cancel_order(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Cancel the order.\n\n    Requires: order must exist and be cancellable\n    \"\"\"\n    order_id = context.get(\"order_id\")\n    if order_id is None:\n        return None\n\n    status = context.get(\"order_status\")\n    if status in [\"refunded\", \"cancelled\", \"shipped\"]:\n        return None  # Cannot cancel in these states\n\n    resp = api.post(f\"/orders/{order_id}/cancel\", json={\n        \"reason\": \"Customer request\",\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        context.set(\"order_status\", \"cancelled\")\n        return resp.json()\n    return None\n\n\ndef check_stock_after(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Check product stock level after operations.\"\"\"\n    product_id = context.get(\"product_id\")\n    if product_id is None:\n        return None\n\n    resp = api.get(f\"/products/{product_id}/stock\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        stock = resp.json()[\"quantity\"]\n        context.set(\"actual_stock\", stock)\n        return resp.json()\n    return None\n\n\n# =============================================================================\n# INVARIANTS \u2014 FINANCIAL\n# =============================================================================\n\ndef no_server_errors(world: World) -&gt; bool:\n    \"\"\"No 5xx errors should occur.\"\"\"\n    return world.context.get(\"last_status\", 200) &lt; 500\n\n\ndef refund_cannot_exceed_payment(world: World) -&gt; bool:\n    \"\"\"Total refunds cannot exceed amount paid.\n\n    This catches the classic over-refund bug where:\n    - Order total: $100\n    - Refund 1: $100\n    - Refund 2: $100 (BUG!)\n    \"\"\"\n    paid = world.context.get(\"order_paid\", 0)\n    refunded = world.context.get(\"order_refunded\", 0)\n\n    if paid &gt; 0:\n        return refunded &lt;= paid\n    return True\n\n\ndef order_total_positive(world: World) -&gt; bool:\n    \"\"\"Order total should always be positive.\"\"\"\n    total = world.context.get(\"order_total\")\n    if total is not None:\n        return total &gt; 0\n    return True\n\n\ndef cart_total_matches_items(world: World) -&gt; bool:\n    \"\"\"Cart total should reflect item prices.\n\n    Simplified check \u2014 real implementation would sum item prices.\n    \"\"\"\n    return True\n\n\n# =============================================================================\n# INVARIANTS \u2014 INVENTORY\n# =============================================================================\n\ndef stock_never_negative(world: World) -&gt; bool:\n    \"\"\"Product stock should never go below zero.\"\"\"\n    stock = world.context.get(\"current_stock\", 0)\n    return stock &gt;= 0\n\n\ndef stock_decreases_on_purchase(world: World) -&gt; bool:\n    \"\"\"Stock should decrease when order is paid.\"\"\"\n    initial = world.context.get(\"initial_stock\")\n    current = world.context.get(\"current_stock\")\n    paid = world.context.get(\"order_paid\", 0)\n\n    if initial is not None and current is not None and paid &gt; 0:\n        return current &lt; initial\n    return True\n\n\ndef stock_restored_on_cancel(world: World) -&gt; bool:\n    \"\"\"Stock should be restored if order is cancelled.\n\n    This is a common bug: cancelled orders don't return inventory.\n    \"\"\"\n    status = world.context.get(\"order_status\")\n    initial = world.context.get(\"initial_stock\")\n    current = world.context.get(\"current_stock\")\n    actual = world.context.get(\"actual_stock\")\n\n    if status == \"cancelled\" and actual is not None:\n        return actual &gt;= current\n    return True\n\n\n# =============================================================================\n# INVARIANTS \u2014 STATE TRANSITIONS\n# =============================================================================\n\ndef cannot_pay_cancelled_order(world: World) -&gt; bool:\n    \"\"\"Cancelled orders cannot be paid.\"\"\"\n    status = world.context.get(\"order_status\")\n    last_status = world.context.get(\"last_status\")\n\n    # If we tried to pay a cancelled order, it should fail\n    if status == \"cancelled\" and last_status is not None:\n        # Last action was a payment attempt on cancelled order\n        pass  # Would need to track what action was just attempted\n    return True\n\n\ndef cannot_refund_unpaid_order(world: World) -&gt; bool:\n    \"\"\"Unpaid orders cannot be refunded.\"\"\"\n    paid = world.context.get(\"order_paid\", 0)\n    refunded = world.context.get(\"order_refunded\", 0)\n\n    if refunded &gt; 0 and paid &lt;= 0:\n        return False  # Refunded without paying!\n    return True\n\n\n# =============================================================================\n# BUILD INVARIANT OBJECTS\n# =============================================================================\n\nINVARIANTS = [\n    Invariant(\n        name=\"no_server_errors\",\n        check=no_server_errors,\n        message=\"Server returned 5xx error during checkout\",\n        severity=Severity.CRITICAL,\n    ),\n    Invariant(\n        name=\"refund_cannot_exceed_payment\",\n        check=refund_cannot_exceed_payment,\n        message=\"Total refunds exceeded amount paid \u2014 over-refund bug!\",\n        severity=Severity.CRITICAL,\n    ),\n    Invariant(\n        name=\"stock_never_negative\",\n        check=stock_never_negative,\n        message=\"Product stock went negative\",\n        severity=Severity.CRITICAL,\n    ),\n    Invariant(\n        name=\"order_total_positive\",\n        check=order_total_positive,\n        message=\"Order total became non-positive\",\n        severity=Severity.HIGH,\n    ),\n    Invariant(\n        name=\"cannot_refund_unpaid\",\n        check=cannot_refund_unpaid_order,\n        message=\"Refund was processed for unpaid order\",\n        severity=Severity.HIGH,\n    ),\n    Invariant(\n        name=\"stock_decreases_on_purchase\",\n        check=stock_decreases_on_purchase,\n        message=\"Stock did not decrease after payment\",\n        severity=Severity.HIGH,\n    ),\n]\n\n\n# =============================================================================\n# BUILD ACTIONS\n# =============================================================================\n\nACTIONS = [\n    # Setup\n    Action(\n        name=\"login_customer\",\n        execute=login_customer,\n        description=\"Login as customer\",\n        tags=[\"auth\"],\n    ),\n    Action(\n        name=\"get_product_stock\",\n        execute=get_product_and_stock,\n        description=\"Get product and stock info\",\n        tags=[\"setup\"],\n    ),\n    # Cart\n    Action(\n        name=\"add_to_cart\",\n        execute=add_to_cart,\n        description=\"Add item to cart\",\n        tags=[\"cart\", \"write\"],\n    ),\n    Action(\n        name=\"add_more_to_cart\",\n        execute=add_more_to_cart,\n        description=\"Add more items to cart\",\n        tags=[\"cart\", \"write\"],\n    ),\n    Action(\n        name=\"get_cart\",\n        execute=get_cart,\n        description=\"View cart contents\",\n        tags=[\"cart\", \"read\"],\n    ),\n    Action(\n        name=\"remove_from_cart\",\n        execute=remove_from_cart,\n        description=\"Remove item from cart\",\n        tags=[\"cart\", \"write\"],\n    ),\n    Action(\n        name=\"apply_coupon\",\n        execute=apply_coupon,\n        description=\"Apply discount coupon\",\n        tags=[\"cart\", \"discount\"],\n    ),\n    Action(\n        name=\"clear_cart\",\n        execute=clear_cart,\n        description=\"Clear cart\",\n        tags=[\"cart\", \"write\"],\n    ),\n    # Order\n    Action(\n        name=\"create_order\",\n        execute=create_order,\n        description=\"Create order from cart\",\n        tags=[\"order\", \"write\"],\n    ),\n    Action(\n        name=\"get_order\",\n        execute=get_order,\n        description=\"Get order details\",\n        tags=[\"order\", \"read\"],\n    ),\n    # Payment\n    Action(\n        name=\"pay_order\",\n        execute=pay_order,\n        description=\"Pay for order\",\n        tags=[\"payment\", \"write\"],\n    ),\n    Action(\n        name=\"pay_invalid_card\",\n        execute=pay_with_invalid_card,\n        description=\"Try payment with declined card\",\n        tags=[\"payment\", \"error\"],\n    ),\n    # Lifecycle\n    Action(\n        name=\"refund_order\",\n        execute=refund_order,\n        description=\"Request full refund\",\n        tags=[\"refund\", \"write\"],\n    ),\n    Action(\n        name=\"partial_refund\",\n        execute=partial_refund,\n        description=\"Request partial refund\",\n        tags=[\"refund\", \"write\"],\n    ),\n    Action(\n        name=\"cancel_order\",\n        execute=cancel_order,\n        description=\"Cancel order\",\n        tags=[\"order\", \"write\"],\n    ),\n    Action(\n        name=\"check_stock\",\n        execute=check_stock_after,\n        description=\"Verify stock level\",\n        tags=[\"inventory\", \"read\"],\n    ),\n]\n\n\n# =============================================================================\n# MAIN\n# =============================================================================\n\nif __name__ == \"__main__\":\n    api = HttpClient(\"http://localhost:8000\")\n    world = World(\n        api=api,\n        state_from_context=[\"order_id\", \"order_paid\", \"order_refunded\"],\n    )\n\n    agent = Agent(\n        world=world,\n        actions=ACTIONS,\n        invariants=INVARIANTS,\n        strategy=BFS(),\n        max_steps=200,\n    )\n\n    result = agent.explore()\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"E-COMMERCE CHECKOUT EXPLORATION RESULTS\")\n    print(\"=\" * 60)\n    print(f\"States visited:    {result.states_visited}\")\n    print(f\"Transitions taken: {result.transitions_taken}\")\n    print(f\"Action coverage:   {result.action_coverage_percent:.0f}%\")\n    print(f\"Duration:          {result.duration_ms:.0f} ms\")\n    print(f\"Violations found:  {len(result.violations)}\")\n\n    if result.violations:\n        print(\"\\nVIOLATIONS:\")\n        for v in result.violations:\n            print(f\"  [{v.severity.value.upper()}] {v.invariant_name}\")\n            print(f\"    {v.message}\")\n            if v.path:\n                print(f\"    Path: {' \u2192 '.join(v.path)}\")\n    else:\n        print(\"\\nNo violations \u2014 all checkout invariants passed.\")\n\n    print(\"=\" * 60)\n</code></pre>"},{"location":"examples/checkout/#why-these-patterns-matter","title":"Why These Patterns Matter","text":""},{"location":"examples/checkout/#financial-invariants","title":"Financial Invariants","text":"<p>The most critical invariant catches over-refunds:</p> Python<pre><code>def refund_cannot_exceed_payment(world):\n    paid = world.context.get(\"order_paid\", 0)\n    refunded = world.context.get(\"order_refunded\", 0)\n\n    if paid &gt; 0:\n        return refunded &lt;= paid  # Never refund more than paid\n    return True\n</code></pre> <p>This catches the sequence <code>create_order \u2192 pay \u2192 refund \u2192 refund</code> where each refund succeeds even though the order was already fully refunded.</p>"},{"location":"examples/checkout/#state-machine-tracking","title":"State Machine Tracking","text":"<p>Context tracks the full order lifecycle:</p> Variable Purpose <code>order_status</code> Current order state <code>order_paid</code> Total amount paid <code>order_refunded</code> Total amount refunded <code>order_total</code> Original order total <p>Actions update these values, and invariants check they remain consistent.</p>"},{"location":"examples/checkout/#inventory-consistency","title":"Inventory Consistency","text":"Python<pre><code>def stock_never_negative(world):\n    stock = world.context.get(\"current_stock\", 0)\n    return stock &gt;= 0\n</code></pre> <p>Stock should never go negative, even with concurrent purchases or edge cases in the order flow.</p>"},{"location":"examples/checkout/#sequences-tested","title":"Sequences Tested","text":"Sequence What It Tests <code>add_to_cart \u2192 create_order \u2192 pay</code> Happy path checkout <code>pay \u2192 refund \u2192 refund</code> Over-refund bug <code>create_order \u2192 cancel</code> Cancellation flow <code>pay \u2192 partial_refund \u2192 partial_refund</code> Multiple partial refunds <code>pay \u2192 cancel</code> Cancel after payment <code>add_to_cart \u2192 clear_cart \u2192 create_order</code> Empty cart handling <code>pay_invalid_card \u2192 pay</code> Recovery from declined card"},{"location":"examples/checkout/#expected-output","title":"Expected Output","text":"Text Only<pre><code>============================================================\nE-COMMERCE CHECKOUT EXPLORATION RESULTS\n============================================================\nStates visited:    24\nTransitions taken: 68\nAction coverage:   100%\nDuration:          412 ms\nViolations found:  1\n\nVIOLATIONS:\n  [CRITICAL] refund_cannot_exceed_payment\n    Total refunds exceeded amount paid \u2014 over-refund bug!\n    Path: create_order \u2192 pay_order \u2192 refund_order \u2192 refund_order\n============================================================\n</code></pre>"},{"location":"examples/checkout/#common-e-commerce-bugs-found","title":"Common E-commerce Bugs Found","text":"Bug Sequence That Finds It Over-refund <code>pay \u2192 refund \u2192 refund</code> Negative stock <code>add_to_cart \u00d7 100 \u2192 pay</code> Cancel doesn't restore stock <code>create_order \u2192 cancel \u2192 check_stock</code> Refund unpaid order <code>create_order \u2192 refund</code> Double payment <code>pay \u2192 pay</code> Discount exploits <code>apply_coupon \u2192 apply_coupon</code>"},{"location":"examples/checkout/#database-rollback-for-real-testing","title":"Database Rollback for Real Testing","text":"<p>With PostgreSQL rollback:</p> Python<pre><code>from venomqa.adapters.postgres import PostgresAdapter\n\napi = HttpClient(\"http://localhost:8000\")\ndb = PostgresAdapter(\"postgresql://user:pass@localhost/shop\")\n\nworld = World(\n    api=api,\n    systems={\"db\": db},\n)\n\n# Each exploration branch gets a clean DB state\n# Allows testing: create_order \u2192 pay \u2192 refund\n# Then rollback and test: create_order \u2192 cancel\n</code></pre>"},{"location":"examples/checkout/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication Flows \u2014 Multi-user auth testing</li> <li>CRUD Operations \u2014 Basic patterns</li> </ul>"},{"location":"examples/crud/","title":"CRUD Operations","text":"<p>Complete example testing Create, Read, Update, Delete operations with invariant patterns for consistency, idempotency, and state transitions.</p>"},{"location":"examples/crud/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Action definitions with preconditions</li> <li>Invariants for CRUD-specific rules</li> <li>Testing create\u2192read\u2192update\u2192delete sequences</li> <li>Catching stale state and double-delete bugs</li> </ul>"},{"location":"examples/crud/#complete-example","title":"Complete Example","text":"Python<pre><code>\"\"\"\nCRUD Operations Example\n\nTests a REST API for managing items with these endpoints:\n- POST   /items          \u2192 Create item\n- GET    /items/{id}     \u2192 Read item\n- PUT    /items/{id}     \u2192 Update item\n- DELETE /items/{id}     \u2192 Delete item\n- GET    /items          \u2192 List all items\n\nRun: python test_crud.py\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom venomqa import (\n    Action,\n    Agent,\n    BFS,\n    Invariant,\n    Severity,\n    World,\n)\nfrom venomqa.adapters.http import HttpClient\n\n\n# =============================================================================\n# ACTIONS\n# =============================================================================\n\ndef create_item(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Create a new item.\n\n    Stores the created item_id in context for subsequent actions.\n    \"\"\"\n    resp = api.post(\"/items\", json={\n        \"name\": \"Test Item\",\n        \"price\": 29.99,\n    })\n\n    if resp.status_code in [200, 201]:\n        data = resp.json()\n        context.set(\"item_id\", data[\"id\"])\n        context.set(\"item_name\", data[\"name\"])\n        context.set(\"item_price\", data[\"price\"])\n        context.set(\"last_status\", resp.status_code)\n        return data\n\n    context.set(\"last_status\", resp.status_code)\n    return None\n\n\ndef read_item(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Read the created item by ID.\n\n    Requires: item_id must exist in context (set by create_item)\n    \"\"\"\n    item_id = context.get(\"item_id\")\n    if item_id is None:\n        return None  # Skip \u2014 no item to read\n\n    resp = api.get(f\"/items/{item_id}\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        return resp.json()\n    return None\n\n\ndef update_item(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Update the item's name and price.\n\n    Requires: item_id must exist in context\n    \"\"\"\n    item_id = context.get(\"item_id\")\n    if item_id is None:\n        return None  # Skip \u2014 no item to update\n\n    resp = api.put(f\"/items/{item_id}\", json={\n        \"name\": \"Updated Item\",\n        \"price\": 39.99,\n    })\n\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"item_name\", data[\"name\"])\n        context.set(\"item_price\", data[\"price\"])\n        return data\n    return None\n\n\ndef delete_item(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Delete the item.\n\n    Requires: item_id must exist in context\n    Clears item_id from context after successful deletion.\n    \"\"\"\n    item_id = context.get(\"item_id\")\n    if item_id is None:\n        return None  # Skip \u2014 no item to delete\n\n    resp = api.delete(f\"/items/{item_id}\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code in [200, 204]:\n        context.delete(\"item_id\")  # Mark as deleted\n        return {}\n    return None\n\n\ndef list_items(api: HttpClient, context) -&gt; list | None:\n    \"\"\"List all items.\n\n    No preconditions \u2014 can always run.\n    \"\"\"\n    resp = api.get(\"/items\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 200:\n        items = resp.json()\n        context.set(\"items_count\", len(items) if isinstance(items, list) else 0)\n        return items\n    return None\n\n\ndef read_deleted_item(api: HttpClient, context) -&gt; dict | None:\n    \"\"\"Attempt to read an item that was deleted.\n\n    This action exists to test that deleted items return 404.\n    We track that deletion happened via 'was_deleted' flag.\n    \"\"\"\n    item_id = context.get(\"deleted_item_id\")\n    if item_id is None:\n        return None  # No deleted item to test\n\n    resp = api.get(f\"/items/{item_id}\")\n    context.set(\"last_status\", resp.status_code)\n    return resp.json() if resp.status_code != 404 else None\n\n\n# =============================================================================\n# INVARIANTS\n# =============================================================================\n\ndef no_server_errors(world: World) -&gt; bool:\n    \"\"\"No 5xx server errors should ever occur.\"\"\"\n    return world.context.get(\"last_status\", 200) &lt; 500\n\n\ndef deleted_items_return_404(world: World) -&gt; bool:\n    \"\"\"After deletion, reading the item should return 404.\n\n    This tracks deleted_item_id separately to test after deletion.\n    \"\"\"\n    status = world.context.get(\"last_status\")\n    deleted_id = world.context.get(\"deleted_item_id\")\n\n    # If we just tried to read a deleted item, it should be 404\n    if deleted_id is not None and status is not None:\n        # We're checking if the last read was for a deleted item\n        return status == 404\n    return True\n\n\ndef item_count_consistent(world: World) -&gt; bool:\n    \"\"\"Item count should reflect actual items.\n\n    After create: count increases\n    After delete: count decreases\n    \"\"\"\n    # This is a simplified check \u2014 real implementation would\n    # compare against expected count based on actions taken\n    return True\n\n\ndef update_preserves_id(world: World) -&gt; bool:\n    \"\"\"Updating an item should not change its ID.\"\"\"\n    # This would need to compare original_id vs current_id\n    return True\n\n\ndef price_never_negative(world: World) -&gt; bool:\n    \"\"\"Item price should never be negative.\"\"\"\n    price = world.context.get(\"item_price\")\n    if price is None:\n        return True\n    return price &gt;= 0\n\n\n# =============================================================================\n# BUILD INVARIANT OBJECTS\n# =============================================================================\n\nINVARIANTS = [\n    Invariant(\n        name=\"no_server_errors\",\n        check=no_server_errors,\n        message=\"Server returned 5xx error\",\n        severity=Severity.CRITICAL,\n    ),\n    Invariant(\n        name=\"deleted_returns_404\",\n        check=deleted_items_return_404,\n        message=\"Deleted item did not return 404\",\n        severity=Severity.HIGH,\n    ),\n    Invariant(\n        name=\"price_never_negative\",\n        check=price_never_negative,\n        message=\"Item price became negative\",\n        severity=Severity.HIGH,\n    ),\n]\n\n\n# =============================================================================\n# BUILD ACTIONS\n# =============================================================================\n\nACTIONS = [\n    Action(\n        name=\"create_item\",\n        execute=create_item,\n        description=\"Create a new item\",\n        tags=[\"write\", \"crud\"],\n    ),\n    Action(\n        name=\"read_item\",\n        execute=read_item,\n        description=\"Read item by ID\",\n        tags=[\"read\", \"crud\"],\n    ),\n    Action(\n        name=\"update_item\",\n        execute=update_item,\n        description=\"Update item name and price\",\n        tags=[\"write\", \"crud\"],\n    ),\n    Action(\n        name=\"delete_item\",\n        execute=delete_item,\n        description=\"Delete the item\",\n        tags=[\"write\", \"crud\"],\n    ),\n    Action(\n        name=\"list_items\",\n        execute=list_items,\n        description=\"List all items\",\n        tags=[\"read\", \"crud\"],\n    ),\n]\n\n\n# =============================================================================\n# MAIN\n# =============================================================================\n\nif __name__ == \"__main__\":\n    # Configure API client\n    api = HttpClient(\"http://localhost:8000\")\n\n    # Create world with stateless context tracking\n    world = World(api=api, state_from_context=[\"item_id\"])\n\n    # Create agent\n    agent = Agent(\n        world=world,\n        actions=ACTIONS,\n        invariants=INVARIANTS,\n        strategy=BFS(),\n        max_steps=100,\n    )\n\n    # Run exploration\n    result = agent.explore()\n\n    # Print results\n    print(\"\\n\" + \"=\" * 60)\n    print(\"CRUD EXPLORATION RESULTS\")\n    print(\"=\" * 60)\n    print(f\"States visited:    {result.states_visited}\")\n    print(f\"Transitions taken: {result.transitions_taken}\")\n    print(f\"Action coverage:   {result.action_coverage_percent:.0f}%\")\n    print(f\"Duration:          {result.duration_ms:.0f} ms\")\n    print(f\"Violations found:  {len(result.violations)}\")\n\n    if result.violations:\n        print(\"\\nVIOLATIONS:\")\n        for v in result.violations:\n            print(f\"  [{v.severity.value.upper()}] {v.invariant_name}\")\n            print(f\"    {v.message}\")\n    else:\n        print(\"\\nNo violations \u2014 all invariants passed.\")\n\n    print(\"=\" * 60)\n</code></pre>"},{"location":"examples/crud/#why-these-patterns-matter","title":"Why These Patterns Matter","text":""},{"location":"examples/crud/#precondition-checks","title":"Precondition Checks","text":"<p>Every action checks if its preconditions are met:</p> Python<pre><code>def read_item(api, context):\n    item_id = context.get(\"item_id\")\n    if item_id is None:\n        return None  # Skip \u2014 no item to read\n    ...\n</code></pre> <p>Returning <code>None</code> tells the agent: \"this action doesn't apply in the current state.\" The agent won't waste time exploring paths where preconditions fail.</p>"},{"location":"examples/crud/#context-as-state-machine","title":"Context as State Machine","text":"<p>Context variables track what's happened:</p> Variable Set By Meaning <code>item_id</code> <code>create_item</code> An item exists <code>last_status</code> All actions Last HTTP status code <code>item_price</code> <code>create_item</code>, <code>update_item</code> Current price <p>The agent explores all combinations: with item, without item, after update, after delete.</p>"},{"location":"examples/crud/#invariants-check-domain-rules","title":"Invariants Check Domain Rules","text":"Python<pre><code>def price_never_negative(world):\n    price = world.context.get(\"item_price\")\n    if price is None:\n        return True\n    return price &gt;= 0\n</code></pre> <p>This catches bugs where an update could set a negative price \u2014 something unit tests might miss if they only check happy paths.</p>"},{"location":"examples/crud/#sequences-tested","title":"Sequences Tested","text":"<p>The agent explores all reachable sequences:</p> Sequence What It Tests <code>create \u2192 read</code> Created item is readable <code>create \u2192 update \u2192 read</code> Update persists <code>create \u2192 delete \u2192 read</code> Deleted item returns 404 <code>create \u2192 delete \u2192 delete</code> Double-delete handling <code>create \u2192 create</code> Duplicate creation <code>read</code> (no create) Read non-existent returns 404"},{"location":"examples/crud/#adding-database-rollback","title":"Adding Database Rollback","text":"<p>For real stateful testing with DB rollback:</p> Python<pre><code>from venomqa.adapters.postgres import PostgresAdapter\n\napi = HttpClient(\"http://localhost:8000\")\ndb = PostgresAdapter(\"postgresql://user:pass@localhost/testdb\")\n\nworld = World(\n    api=api,\n    systems={\"db\": db},  # DB will be rolled back between branches\n)\n</code></pre> <p>Now each exploration branch starts from a clean DB state.</p>"},{"location":"examples/crud/#expected-output","title":"Expected Output","text":"Text Only<pre><code>============================================================\nCRUD EXPLORATION RESULTS\n============================================================\nStates visited:    12\nTransitions taken: 28\nAction coverage:   100%\nDuration:          156 ms\nViolations found:  0\n\nNo violations \u2014 all invariants passed.\n============================================================\n</code></pre>"},{"location":"examples/crud/#common-bugs-found","title":"Common Bugs Found","text":"Bug Sequence That Finds It Double-delete succeeds <code>create \u2192 delete \u2192 delete</code> Stale state after update <code>create \u2192 update \u2192 read</code> (returns old data) Deleted item still readable <code>create \u2192 delete \u2192 read</code> Update changes ID <code>create \u2192 update \u2192 read</code> Negative price allowed <code>create \u2192 update(price=-1)</code>"},{"location":"examples/crud/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication Flows \u2014 Multi-user stateful testing</li> <li>E-commerce Checkout \u2014 Complex state machines</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>VenomQA tests what other tools miss: the bugs that appear in sequences of API calls, not individual endpoints.</p>"},{"location":"getting-started/#the-30-second-pitch","title":"The 30-Second Pitch","text":"<p>Your API has state. A user creates an order, requests a refund, then requests another refund. Each call looks valid in isolation. The bug only appears in the sequence.</p> <p>VenomQA explores every sequence automatically.</p> Text Only<pre><code>pytest         \u2192 Tests functions in isolation\nSchemathesis   \u2192 Fuzzes individual endpoints  \nVenomQA        \u2192 Explores all call sequences\n</code></pre>"},{"location":"getting-started/#quick-navigation","title":"Quick Navigation","text":"If you want to... Go to See it work in 30 seconds Quickstart Install and configure Installation Tune settings for your app Configuration"},{"location":"getting-started/#what-youll-need","title":"What You'll Need","text":"<ul> <li>Python 3.10+</li> <li>An API to test (local or remote)</li> <li>Optional: PostgreSQL, MySQL, or SQLite for database rollback</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"Bash<pre><code>pip install venomqa\n</code></pre>"},{"location":"getting-started/#verify-installation","title":"Verify Installation","text":"Bash<pre><code>venomqa --version\nvenomqa doctor\n</code></pre> <p>The <code>doctor</code> command checks your environment and reports any issues.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li> <p> Quickstart</p> <p>Run <code>venomqa demo</code> and find your first bug in 30 seconds.</p> <p> Get started</p> </li> <li> <p> Installation</p> <p>Full installation guide including database adapters.</p> <p> Install</p> </li> <li> <p> Configuration</p> <p>Authentication, timeouts, and environment setup.</p> <p> Configure</p> </li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Configure VenomQA for your API and environment.</p>"},{"location":"getting-started/configuration/#cli-configuration","title":"CLI Configuration","text":""},{"location":"getting-started/configuration/#authentication","title":"Authentication","text":"Bash<pre><code># API Key header\nvenomqa --api-key your-api-key-here\n\n# Bearer token\nvenomqa --auth-token your-bearer-token\n\n# Basic auth\nvenomqa --basic-auth user:password\n</code></pre> <p>Or via environment variables:</p> Bash<pre><code>export VENOMQA_API_KEY=your-key\nexport VENOMQA_AUTH_TOKEN=your-token\n</code></pre>"},{"location":"getting-started/configuration/#skip-preflight-checks","title":"Skip Preflight Checks","text":"Bash<pre><code>venomqa --skip-preflight\n</code></pre> <p>Skips Docker and authentication validation. Useful for CI environments.</p>"},{"location":"getting-started/configuration/#programmatic-configuration","title":"Programmatic Configuration","text":""},{"location":"getting-started/configuration/#httpclient-options","title":"HttpClient Options","text":"Python<pre><code>from venomqa.adapters.http import HttpClient\n\napi = HttpClient(\n    base_url=\"http://localhost:8000\",\n    headers={\"X-Custom\": \"value\"},\n    timeout=30.0,\n    verify_ssl=True,\n    follow_redirects=True,\n)\n</code></pre>"},{"location":"getting-started/configuration/#world-configuration","title":"World Configuration","text":"Python<pre><code>from venomqa import World\nfrom venomqa.adapters.postgres import PostgresAdapter\n\n# Option 1: Context-based state (simple)\nworld = World(\n    api=api,\n    state_from_context=[\"order_id\", \"user_id\"],\n)\n\n# Option 2: System adapters (advanced)\nworld = World(\n    api=api,\n    systems={\n        \"db\": PostgresAdapter(\"postgresql://user:pass@localhost/db\"),\n    },\n)\n</code></pre>"},{"location":"getting-started/configuration/#agent-configuration","title":"Agent Configuration","text":"Python<pre><code>from venomqa import Agent, BFS\n\nagent = Agent(\n    world=world,\n    actions=[...],\n    invariants=[...],\n    strategy=BFS(),\n    max_steps=100,           # Maximum actions per exploration\n    max_depth=20,            # Maximum depth in state tree\n    fail_fast=True,          # Stop on first violation\n    seed=42,                 # Reproducible random choices\n)\n</code></pre>"},{"location":"getting-started/configuration/#strategy-configuration","title":"Strategy Configuration","text":""},{"location":"getting-started/configuration/#bfs-breadth-first-search","title":"BFS (Breadth-First Search)","text":"Python<pre><code>from venomqa import BFS\n\nstrategy = BFS()\n</code></pre> <p>Explores all sequences level by level. Best for finding shortest paths to bugs.</p>"},{"location":"getting-started/configuration/#dfs-depth-first-search","title":"DFS (Depth-First Search)","text":"Python<pre><code>from venomqa import DFS\n\nstrategy = DFS(max_depth=50)\n</code></pre> <p>Goes deep before backtracking. Good for finding deep state transitions.</p>"},{"location":"getting-started/configuration/#coverage-guided","title":"Coverage-Guided","text":"Python<pre><code>from venomqa import CoverageGuided\n\nstrategy = CoverageGuided(\n    target_coverage=0.95,\n    seed_corpus=[],\n)\n</code></pre> <p>Prioritizes unexplored code paths. Requires coverage instrumentation.</p>"},{"location":"getting-started/configuration/#database-configuration","title":"Database Configuration","text":""},{"location":"getting-started/configuration/#postgresql","title":"PostgreSQL","text":"Python<pre><code>from venomqa.adapters.postgres import PostgresAdapter\n\ndb = PostgresAdapter(\n    connection_string=\"postgresql://user:pass@localhost:5432/testdb\",\n    schema=\"public\",\n)\n\nworld = World(api=api, systems={\"db\": db})\n</code></pre>"},{"location":"getting-started/configuration/#mysql","title":"MySQL","text":"Python<pre><code>from venomqa.adapters.mysql import MySQLAdapter\n\ndb = MySQLAdapter(\n    host=\"localhost\",\n    port=3306,\n    user=\"root\",\n    password=\"secret\",\n    database=\"testdb\",\n)\n</code></pre>"},{"location":"getting-started/configuration/#sqlite","title":"SQLite","text":"Python<pre><code>from venomqa.adapters.sqlite import SQLiteAdapter\n\ndb = SQLiteAdapter(\n    path=\"/path/to/database.db\",\n    copy_on_checkpoint=True,\n)\n</code></pre>"},{"location":"getting-started/configuration/#reporter-configuration","title":"Reporter Configuration","text":""},{"location":"getting-started/configuration/#console-reporter","title":"Console Reporter","text":"Python<pre><code>from venomqa.reporters import ConsoleReporter\n\nreporter = ConsoleReporter(\n    verbose=True,\n    color=True,\n    show_timestamps=True,\n)\n</code></pre>"},{"location":"getting-started/configuration/#html-reporter","title":"HTML Reporter","text":"Python<pre><code>from venomqa.reporters import HTMLTraceReporter\n\nreporter = HTMLTraceReporter(\n    output_path=\"reports/trace.html\",\n    include_graph=True,\n    theme=\"dark\",\n)\n</code></pre>"},{"location":"getting-started/configuration/#json-reporter","title":"JSON Reporter","text":"Python<pre><code>from venomqa.reporters import JSONReporter\n\nreporter = JSONReporter(\n    output_path=\"reports/results.json\",\n    pretty_print=True,\n)\n</code></pre>"},{"location":"getting-started/configuration/#environment-specific-config","title":"Environment-Specific Config","text":""},{"location":"getting-started/configuration/#development","title":"Development","text":"Python<pre><code># qa/conftest.py\nimport os\nfrom venomqa import World\nfrom venomqa.adapters.http import HttpClient\n\ndef get_world():\n    api = HttpClient(\n        base_url=os.getenv(\"API_URL\", \"http://localhost:8000\"),\n        timeout=60.0,\n    )\n    return World(api=api, state_from_context=[\"resource_id\"])\n</code></pre>"},{"location":"getting-started/configuration/#cicd","title":"CI/CD","text":"Python<pre><code># qa/conftest_ci.py\nimport os\nfrom venomqa import World\nfrom venomqa.adapters.http import HttpClient\n\ndef get_world():\n    api = HttpClient(\n        base_url=os.environ[\"CI_API_URL\"],\n        headers={\"Authorization\": f\"Bearer {os.environ['CI_API_TOKEN']}\"},\n        timeout=30.0,\n        verify_ssl=False,  # Internal CI\n    )\n    return World(api=api, state_from_context=[\"resource_id\"])\n</code></pre>"},{"location":"getting-started/configuration/#configuration-file-optional","title":"Configuration File (Optional)","text":"<p>Create <code>venomqa.yaml</code> in your project root:</p> YAML<pre><code>api:\n  base_url: http://localhost:8000\n  timeout: 30.0\n  headers:\n    X-API-Version: \"1.0\"\n\ndatabase:\n  type: postgres\n  url: postgresql://localhost/testdb\n\nexploration:\n  strategy: bfs\n  max_steps: 100\n  max_depth: 20\n  fail_fast: false\n\nreporting:\n  console:\n    verbose: true\n  html:\n    output: reports/trace.html\n</code></pre> <p>Load configuration:</p> Bash<pre><code>venomqa run --config venomqa.yaml\n</code></pre>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Quickstart - Try it out</li> <li>Concepts - Understand the model</li> <li>API Reference - Full API docs</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Install VenomQA and set up your testing environment.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"Requirement Version Python 3.10+ pip Latest OS macOS, Linux, Windows"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"Bash<pre><code>pip install venomqa\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"Bash<pre><code>git clone https://github.com/namanag97/venomqa.git\ncd venomqa\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"Bash<pre><code>venomqa --version\n# venomqa 0.6.4\n\nvenomqa doctor\n# \u2713 Python 3.11.5\n# \u2713 httpx installed\n# \u2713 pydantic v2\n# \u2713 All checks passed\n</code></pre>"},{"location":"getting-started/installation/#optional-database-adapters","title":"Optional: Database Adapters","text":"<p>For database rollback support, install the appropriate adapter:</p>"},{"location":"getting-started/installation/#postgresql","title":"PostgreSQL","text":"Bash<pre><code>pip install \"venomqa[postgres]\"\n# or\npip install psycopg[binary]\n</code></pre> <p>Features:</p> <ul> <li><code>SAVEPOINT</code> / <code>ROLLBACK TO SAVEPOINT</code></li> <li>Entire exploration runs in one uncommitted transaction</li> <li>True branching without test pollution</li> </ul>"},{"location":"getting-started/installation/#mysql","title":"MySQL","text":"Bash<pre><code>pip install \"venomqa[mysql]\"\n# or\npip install mysql-connector-python\n</code></pre>"},{"location":"getting-started/installation/#sqlite","title":"SQLite","text":"<p>Built-in. No additional installation required.</p> <p>Features:</p> <ul> <li>File-based copy/restore</li> <li>Works with local development databases</li> </ul>"},{"location":"getting-started/installation/#redis","title":"Redis","text":"Bash<pre><code>pip install \"venomqa[redis]\"\n# or\npip install redis\n</code></pre> <p>Features:</p> <ul> <li><code>DUMP</code> all keys \u2192 <code>FLUSHALL</code> + <code>RESTORE</code></li> <li>State isolation between branches</li> </ul>"},{"location":"getting-started/installation/#project-structure","title":"Project Structure","text":"<p>VenomQA doesn't enforce a specific structure, but this works well:</p> Text Only<pre><code>your-project/\n\u251c\u2500\u2500 app/                    # Your application\n\u251c\u2500\u2500 qa/\n\u2502   \u251c\u2500\u2500 actions/           # VenomQA actions\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 orders.py\n\u2502   \u2502   \u2514\u2500\u2500 users.py\n\u2502   \u251c\u2500\u2500 invariants.py      # Invariant definitions\n\u2502   \u251c\u2500\u2500 conftest.py        # Fixtures and world setup\n\u2502   \u2514\u2500\u2500 test_flows.py      # Test orchestration\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"getting-started/installation/#environment-variables","title":"Environment Variables","text":"Variable Purpose Default <code>VENOMQA_API_KEY</code> X-API-Key header None <code>VENOMQA_AUTH_TOKEN</code> Bearer token None <code>VENOMQA_BASE_URL</code> Default API URL None <code>VENOMQA_DB_URL</code> Database connection None"},{"location":"getting-started/installation/#cli-installation-check","title":"CLI Installation Check","text":"Bash<pre><code># Check if CLI is available\nwhich venomqa\n# /usr/local/bin/venomqa\n\n# Run diagnostics\nvenomqa doctor\n\n# Show help\nvenomqa --help\n</code></pre>"},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/installation/#command-not-found-venomqa","title":"\"command not found: venomqa\"","text":"<p>The CLI entry point wasn't installed correctly. Try:</p> Bash<pre><code>pip install --upgrade venomqa\npython -m venomqa.cli --version\n</code></pre>"},{"location":"getting-started/installation/#importerror-cannot-import-name-httpclient","title":"\"ImportError: cannot import name 'HttpClient'\"","text":"<p>Ensure you're importing from the correct module:</p> Python<pre><code># Correct\nfrom venomqa.adapters.http import HttpClient\n\n# Incorrect (old API)\nfrom venomqa import HttpClient\n</code></pre>"},{"location":"getting-started/installation/#psycopgoperationalerror-postgresql","title":"\"psycopg.OperationalError\" (PostgreSQL)","text":"<p>Install the binary package:</p> Bash<pre><code>pip install \"psycopg[binary]\"\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quickstart - Find your first bug</li> <li>Configuration - Set up authentication and timeouts</li> <li>Concepts - Understand the mental model</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Find your first sequence bug in 30 seconds. No setup required.</p>"},{"location":"getting-started/quickstart/#run-the-demo","title":"Run the Demo","text":"Bash<pre><code>pip install venomqa\nvenomqa demo\n</code></pre>"},{"location":"getting-started/quickstart/#what-youll-see","title":"What You'll See","text":"Text Only<pre><code>  Unit Tests:  3/3 PASS \u2713\n\n  VenomQA Exploration \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  States visited:     8\n  Transitions:        20\n  Invariants checked: 40\n\n  \u256d\u2500 CRITICAL VIOLATION \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n  \u2502 Sequence: create_order \u2192 refund \u2192 refund  \u2502\n  \u2502 Bug:      refunded $200 on a $100 order   \u2502\n  \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n  Summary: 3 tests passed. 1 sequence bug found.\n  Your tests passed. VenomQA found the bug.\n</code></pre> <p>The demo runs against a mock API with a planted bug. It demonstrates the core value proposition: unit tests pass, but sequences fail.</p>"},{"location":"getting-started/quickstart/#what-just-happened","title":"What Just Happened","text":"<ol> <li>Actions defined: <code>create_order</code>, <code>refund_order</code>, <code>cancel_order</code></li> <li>Invariant defined: \"Total refunds cannot exceed order amount\"</li> <li>Exploration ran: BFS traversal through all reachable sequences</li> <li>Bug found: <code>create \u2192 refund \u2192 refund</code> violated the invariant</li> </ol> <p>The mock API accepts both refunds. Each individual call returns <code>200 OK</code>. The bug only surfaces when you call refund twice on the same order.</p>"},{"location":"getting-started/quickstart/#your-first-real-test","title":"Your First Real Test","text":"<p>Create a file <code>qa/test_api.py</code>:</p> Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"resource_id\"])\n\ndef create_item(api, context):\n    resp = api.post(\"/items\", json={\"name\": \"test\"})\n    context.set(\"resource_id\", resp.json()[\"id\"])\n    return resp\n\ndef delete_item(api, context):\n    resource_id = context.get(\"resource_id\")\n    if resource_id is None:\n        return None\n    return api.delete(f\"/items/{resource_id}\")\n\nno_500s = Invariant(\n    \"no_server_errors\",\n    lambda world: world.context.get(\"last_status\", 200) &lt; 500,\n    Severity.CRITICAL,\n)\n\nresult = Agent(\n    world=world,\n    actions=[\n        Action(\"create_item\", create_item),\n        Action(\"delete_item\", delete_item),\n    ],\n    invariants=[no_500s],\n    strategy=BFS(),\n    max_steps=50,\n).explore()\n\nprint(f\"States: {result.states_visited}, Violations: {result.violations}\")\n</code></pre> <p>Run it:</p> Bash<pre><code>python qa/test_api.py\n</code></pre>"},{"location":"getting-started/quickstart/#key-concepts-in-60-seconds","title":"Key Concepts in 60 Seconds","text":"Concept What it is Example Action One API call <code>create_order</code>, <code>refund_order</code> Invariant Rule that must always hold <code>refunds &lt;= order_total</code> World The sandbox with rollback <code>World(api=api, state_from_context=[...])</code> Agent Orchestrates exploration <code>Agent(world, actions, invariants, strategy)</code> Strategy How to traverse states <code>BFS()</code>, <code>DFS()</code>, <code>CoverageGuided()</code>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#skip-when-precondition-not-met","title":"Skip When Precondition Not Met","text":"Python<pre><code>def delete_item(api, context):\n    resource_id = context.get(\"resource_id\")\n    if resource_id is None:\n        return None  # Skip - nothing to delete\n    return api.delete(f\"/items/{resource_id}\")\n</code></pre>"},{"location":"getting-started/quickstart/#context-flows-between-actions","title":"Context Flows Between Actions","text":"Python<pre><code>def create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])  # Store for later\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")  # Retrieved automatically\n    return api.post(f\"/orders/{order_id}/refund\")\n</code></pre>"},{"location":"getting-started/quickstart/#invariant-checks-state","title":"Invariant Checks State","text":"Python<pre><code>no_over_refund = Invariant(\n    \"no_over_refund\",\n    lambda world: get_total_refunded() &lt;= get_order_total(),\n    Severity.CRITICAL,\n)\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Full setup with database adapters</li> <li>Configuration - Auth, timeouts, environment</li> <li>Concepts: The Theory - Why sequences matter</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>Complete reference documentation for VenomQA.</p>"},{"location":"reference/#quick-links","title":"Quick Links","text":""},{"location":"reference/#api-reference","title":"API Reference","text":"<p>Complete documentation for all public classes and functions.</p>"},{"location":"reference/#cli-reference","title":"CLI Reference","text":"<p>Command-line interface documentation.</p>"},{"location":"reference/#configuration","title":"Configuration","text":"<p>All configuration options and environment variables.</p>"},{"location":"reference/#database-backends","title":"Database Backends","text":"<p>Configure state management backends.</p>"},{"location":"reference/#adapters","title":"Adapters","text":"<p>Available adapters for external services.</p>"},{"location":"reference/#reporters","title":"Reporters","text":"<p>Report formats and custom reporters.</p>"},{"location":"reference/#api-overview","title":"API Overview","text":""},{"location":"reference/#core-models","title":"Core Models","text":"Python<pre><code>from venomqa import (\n    Journey,          # Complete user scenario\n    Step,             # Single action\n    Checkpoint,       # Database savepoint\n    Branch,           # Multiple paths\n    Path,             # Path within a branch\n)\n</code></pre>"},{"location":"reference/#results","title":"Results","text":"Python<pre><code>from venomqa import (\n    JourneyResult,    # Journey execution result\n    StepResult,       # Step execution result\n    PathResult,       # Path execution result\n    Issue,            # Captured failure\n    Severity,         # Issue severity level\n)\n</code></pre>"},{"location":"reference/#execution","title":"Execution","text":"Python<pre><code>from venomqa import (\n    JourneyRunner,    # Execute journeys\n    Client,           # HTTP client\n    ExecutionContext, # Shared state\n    QAConfig,         # Configuration\n)\n</code></pre>"},{"location":"reference/#state-management","title":"State Management","text":"Python<pre><code>from venomqa.state import (\n    PostgreSQLStateManager,  # PostgreSQL backend\n    SQLiteStateManager,      # SQLite backend\n    BaseStateManager,        # Base class\n)\n</code></pre>"},{"location":"reference/#ports-adapters","title":"Ports &amp; Adapters","text":"Python<pre><code>from venomqa.ports import (\n    CachePort,        # Cache interface\n    MailPort,         # Email interface\n    QueuePort,        # Queue interface\n    # ... more ports\n)\n\nfrom venomqa.adapters import (\n    RedisCacheAdapter,   # Redis cache\n    MailhogAdapter,      # Mailhog email\n    # ... more adapters\n)\n</code></pre>"},{"location":"reference/#cli-commands","title":"CLI Commands","text":"Command Description <code>venomqa run [JOURNEYS]</code> Run journeys <code>venomqa list</code> List available journeys <code>venomqa report</code> Generate reports <code>venomqa --version</code> Show version <code>venomqa --help</code> Show help"},{"location":"reference/#configuration-quick-reference","title":"Configuration Quick Reference","text":"YAML<pre><code># venomqa.yaml\nbase_url: \"http://localhost:8000\"\ndb_url: \"postgresql://user:pass@host:5432/db\"\ndb_backend: \"postgresql\"\ntimeout: 30\nretry_count: 3\nparallel_paths: 1\nfail_fast: false\nverbose: false\nreport_dir: \"reports\"\nreport_formats: [\"markdown\", \"junit\"]\n</code></pre> <p>Environment variables:</p> Bash<pre><code>VENOMQA_BASE_URL=http://api.example.com\nVENOMQA_DB_URL=postgresql://...\nVENOMQA_TIMEOUT=60\nVENOMQA_VERBOSE=true\n</code></pre>"},{"location":"reference/adapters/","title":"Adapters","text":"<p>HTTP and system adapters for VenomQA.</p>"},{"location":"reference/adapters/#http-adapters","title":"HTTP Adapters","text":""},{"location":"reference/adapters/#httpclient","title":"HttpClient","text":"<p>The primary adapter for making HTTP requests.</p> Python<pre><code>from venomqa.adapters.http import HttpClient\n\napi = HttpClient(\n    base_url=\"http://localhost:8000\",\n    headers={\"X-API-Key\": \"secret\"},\n    timeout=30.0,\n    verify_ssl=True,\n    follow_redirects=True,\n)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>base_url</code> <code>str</code> Required Base URL for all requests <code>headers</code> <code>dict</code> <code>{}</code> Default headers <code>timeout</code> <code>float</code> <code>30.0</code> Request timeout in seconds <code>verify_ssl</code> <code>bool</code> <code>True</code> Verify SSL certificates <code>follow_redirects</code> <code>bool</code> <code>True</code> Follow HTTP redirects <p>Methods:</p> Python<pre><code># GET request\nresp = api.get(\"/users/123\")\nresp = api.get(\"/users\", params={\"page\": 1})\n\n# POST request\nresp = api.post(\"/users\", json={\"name\": \"Alice\"})\nresp = api.post(\"/upload\", files={\"file\": open(\"data.txt\", \"rb\")})\n\n# PUT request\nresp = api.put(\"/users/123\", json={\"name\": \"Alice Updated\"})\n\n# PATCH request\nresp = api.patch(\"/users/123\", json={\"name\": \"Alice\"})\n\n# DELETE request\nresp = api.delete(\"/users/123\")\n\n# Custom request\nresp = api.request(\"OPTIONS\", \"/users\")\n</code></pre> <p>Response Object:</p> Python<pre><code>resp.status_code      # HTTP status code\nresp.headers          # Response headers\nresp.json()           # Parse JSON body\nresp.text             # Raw text body\nresp.content          # Raw bytes\nresp.elapsed          # Time taken (timedelta)\n</code></pre> <p>Context Integration:</p> Python<pre><code>def create_user(api, context):\n    resp = api.post(\"/users\", json={\"name\": \"Alice\"})\n    context.set(\"last_status\", resp.status_code)\n    context.set(\"user_id\", resp.json()[\"id\"])\n    return resp\n</code></pre>"},{"location":"reference/adapters/#authenticatedhttpclient","title":"AuthenticatedHttpClient","text":"<p>Extends HttpClient with automatic authentication.</p> Python<pre><code>from venomqa.adapters.http import AuthenticatedHttpClient\n\napi = AuthenticatedHttpClient(\n    base_url=\"http://localhost:8000\",\n    auth_type=\"bearer\",\n    token=\"your-jwt-token\",\n)\n</code></pre> <p>Auth Types:</p> Python<pre><code># Bearer token\napi = AuthenticatedHttpClient(\n    base_url=\"...\",\n    auth_type=\"bearer\",\n    token=\"jwt-token-here\",\n)\n\n# API Key header\napi = AuthenticatedHttpClient(\n    base_url=\"...\",\n    auth_type=\"api_key\",\n    api_key=\"your-api-key\",\n    api_key_header=\"X-API-Key\",  # Default\n)\n\n# Basic auth\napi = AuthenticatedHttpClient(\n    base_url=\"...\",\n    auth_type=\"basic\",\n    username=\"user\",\n    password=\"pass\",\n)\n</code></pre>"},{"location":"reference/adapters/#database-adapters","title":"Database Adapters","text":""},{"location":"reference/adapters/#postgresadapter","title":"PostgresAdapter","text":"Python<pre><code>from venomqa.adapters.postgres import PostgresAdapter\n\ndb = PostgresAdapter(\n    connection_string=\"postgresql://user:pass@host:5432/db\",\n    schema=\"public\",\n)\n\n# Query\nrows = db.query(\"SELECT * FROM orders WHERE status = %s\", [\"pending\"])\n\n# Execute\ndb.execute(\"UPDATE orders SET status = %s WHERE id = %s\", [\"shipped\", \"123\"])\n\n# Transaction (managed by VenomQA)\n# Do not use explicitly\n</code></pre>"},{"location":"reference/adapters/#mysqladapter","title":"MySQLAdapter","text":"Python<pre><code>from venomqa.adapters.mysql import MySQLAdapter\n\ndb = MySQLAdapter(\n    host=\"localhost\",\n    port=3306,\n    user=\"root\",\n    password=\"secret\",\n    database=\"testdb\",\n)\n\n# Query\nrows = db.query(\"SELECT * FROM orders WHERE status = %s\", [\"pending\"])\n\n# Execute\ndb.execute(\"UPDATE orders SET status = %s\", [\"shipped\"])\n</code></pre>"},{"location":"reference/adapters/#sqliteadapter","title":"SQLiteAdapter","text":"Python<pre><code>from venomqa.adapters.sqlite import SQLiteAdapter\n\ndb = SQLiteAdapter(\n    path=\"/path/to/database.db\",\n    copy_on_checkpoint=True,\n)\n\n# In-memory mode\ndb = SQLiteAdapter(path=\":memory:\")\n</code></pre>"},{"location":"reference/adapters/#cache-adapters","title":"Cache Adapters","text":""},{"location":"reference/adapters/#redisadapter","title":"RedisAdapter","text":"Python<pre><code>from venomqa.adapters.redis_adapter import RedisAdapter\n\nredis = RedisAdapter(\n    host=\"localhost\",\n    port=6379,\n    db=0,\n    password=None,\n)\n\n# Get/Set\nvalue = redis.get(\"key\")\nredis.set(\"key\", \"value\", ttl=3600)\n\n# Delete\nredis.delete(\"key\")\n\n# Clear all\nredis.flush()\n\n# Get all keys\nkeys = redis.keys()\n</code></pre>"},{"location":"reference/adapters/#mock-adapters","title":"Mock Adapters","text":""},{"location":"reference/adapters/#mocksystem","title":"MockSystem","text":"<p>In-memory mock for unit testing.</p> Python<pre><code>from venomqa.adapters.mock import MockSystem\n\nmock = MockSystem(initial_state={\n    \"users\": [{\"id\": 1, \"name\": \"Alice\"}],\n    \"orders\": [],\n})\n\n# Query\nusers = mock.query(\"users\")\n\n# Modify\nmock.execute(\"INSERT INTO users VALUES (?)\", [{\"id\": 2, \"name\": \"Bob\"}])\n\n# Clear\nmock.clear()\n</code></pre>"},{"location":"reference/adapters/#custom-adapters","title":"Custom Adapters","text":"<p>Create custom adapters by implementing the SystemAdapter protocol.</p> Python<pre><code>from typing import Any, Dict\nfrom venomqa.adapters.base import SystemAdapter\n\nclass ElasticsearchAdapter(SystemAdapter):\n    \"\"\"Adapter for Elasticsearch.\"\"\"\n\n    def __init__(self, hosts: list):\n        self.client = Elasticsearch(hosts)\n        self._checkpoint_data = None\n\n    def checkpoint(self) -&gt; str:\n        \"\"\"Save current state.\"\"\"\n        # Dump all indices\n        self._checkpoint_data = {}\n        for index in self.client.indices.get(\"*\"):\n            self._checkpoint_data[index] = self.client.search(\n                index=index,\n                body={\"query\": {\"match_all\": {}}}\n            )\n        return \"es_checkpoint\"\n\n    def rollback(self, checkpoint_id: str) -&gt; None:\n        \"\"\"Restore to checkpoint.\"\"\"\n        # Clear and restore\n        for index in self.client.indices.get(\"*\"):\n            self.client.indices.delete(index=index)\n\n        for index, data in self._checkpoint_data.items():\n            self.client.indices.create(index=index)\n            for doc in data[\"hits\"][\"hits\"]:\n                self.client.index(\n                    index=index,\n                    id=doc[\"_id\"],\n                    body=doc[\"_source\"]\n                )\n\n    def get_state(self) -&gt; Dict[str, Any]:\n        \"\"\"Extract current state for comparison.\"\"\"\n        return {\n            \"doc_count\": self.client.count()[\"count\"]\n        }\n</code></pre> <p>Using Custom Adapters:</p> Python<pre><code>world = World(\n    api=api,\n    systems={\n        \"db\": PostgresAdapter(...),\n        \"search\": ElasticsearchAdapter([\"localhost:9200\"]),\n    },\n)\n</code></pre>"},{"location":"reference/adapters/#adapter-protocol","title":"Adapter Protocol","text":"<p>All adapters must implement:</p> Python<pre><code>class SystemAdapter(Protocol):\n    def checkpoint(self) -&gt; str:\n        \"\"\"Create a checkpoint. Returns checkpoint ID.\"\"\"\n        ...\n\n    def rollback(self, checkpoint_id: str) -&gt; None:\n        \"\"\"Restore to a checkpoint.\"\"\"\n        ...\n\n    def get_state(self) -&gt; Dict[str, Any]:\n        \"\"\"Get current state for comparison.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/adapters/#best-practices","title":"Best Practices","text":""},{"location":"reference/adapters/#1-use-connection-pooling","title":"1. Use Connection Pooling","text":"Python<pre><code># HttpClient reuses connections automatically\napi = HttpClient(base_url=\"http://localhost:8000\")\n</code></pre>"},{"location":"reference/adapters/#2-handle-timeouts","title":"2. Handle Timeouts","text":"Python<pre><code>try:\n    resp = api.get(\"/slow-endpoint\", timeout=60.0)\nexcept httpx.TimeoutException:\n    context.set(\"timeout_occurred\", True)\n    return None\n</code></pre>"},{"location":"reference/adapters/#3-retry-transient-errors","title":"3. Retry Transient Errors","text":"Python<pre><code>import tenacity\n\n@tenacity.retry(\n    stop=tenacity.stop_after_attempt(3),\n    retry=tenacity.retry_if_exception_type(httpx.NetworkError),\n)\ndef create_with_retry(api, context):\n    return api.post(\"/orders\", json={...})\n</code></pre>"},{"location":"reference/adapters/#4-validate-responses","title":"4. Validate Responses","text":"Python<pre><code>def create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n\n    if resp.status_code not in (200, 201):\n        context.set(\"error\", resp.json().get(\"error\"))\n        return None\n\n    data = resp.json()\n    if \"id\" not in data:\n        raise ValueError(\"Response missing 'id' field\")\n\n    context.set(\"order_id\", data[\"id\"])\n    return resp\n</code></pre>"},{"location":"reference/adapters/#next-steps","title":"Next Steps","text":"<ul> <li>Database Backends - Database-specific docs</li> <li>API Reference - Core API</li> <li>Configuration - Setup options</li> </ul>"},{"location":"reference/api/","title":"API Reference","text":"<p>Complete reference for VenomQA's Python API.</p>"},{"location":"reference/api/#core-classes","title":"Core Classes","text":""},{"location":"reference/api/#action","title":"Action","text":"<p>Represents a single operation that can be performed on the API.</p> Python<pre><code>from venomqa import Action\n\naction = Action(\n    name=\"create_order\",           # Unique identifier\n    execute=create_order_fn,        # Callable: (api, context) -&gt; response\n    precondition=None,              # Optional: (context) -&gt; bool\n    cleanup=None,                   # Optional: (api, context) -&gt; None\n)\n</code></pre> <p>Parameters:</p> Parameter Type Required Description <code>name</code> <code>str</code> Yes Unique action identifier <code>execute</code> <code>Callable[[HttpClient, Context], Optional[Any]]</code> Yes Function to execute <code>precondition</code> <code>Callable[[Context], bool]</code> No Skip if returns False <code>cleanup</code> <code>Callable[[HttpClient, Context], None]</code> No Cleanup after execution <p>Execute Function Signature:</p> Python<pre><code>def execute(api: HttpClient, context: Context) -&gt; Optional[Any]:\n    \"\"\"\n    Execute the action.\n\n    Args:\n        api: HTTP client for making requests\n        context: Key-value store for passing data between actions\n\n    Returns:\n        Response data, or None to skip this action\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/api/#invariant","title":"Invariant","text":"<p>A rule that must hold after every action.</p> Python<pre><code>from venomqa import Invariant, Severity\n\ninvariant = Invariant(\n    name=\"no_over_refund\",\n    check=lambda world: get_refunded() &lt;= get_total(),\n    severity=Severity.CRITICAL,\n    description=\"Refunds cannot exceed order total\",\n)\n</code></pre> <p>Parameters:</p> Parameter Type Required Description <code>name</code> <code>str</code> Yes Unique invariant identifier <code>check</code> <code>Callable[[World], bool]</code> Yes Returns True if invariant holds <code>severity</code> <code>Severity</code> No CRITICAL, HIGH, MEDIUM, LOW (default: MEDIUM) <code>description</code> <code>str</code> No Human-readable description <p>Severity Levels:</p> Level Meaning Default Behavior <code>CRITICAL</code> Must fix immediately Fail exploration <code>HIGH</code> Important issue Log and continue <code>MEDIUM</code> Standard issue Log and continue <code>LOW</code> Minor issue Log only"},{"location":"reference/api/#world","title":"World","text":"<p>The sandbox containing API client, systems, and context.</p> Python<pre><code>from venomqa import World\nfrom venomqa.adapters.http import HttpClient\nfrom venomqa.adapters.postgres import PostgresAdapter\n\n# Option 1: Context-only state\nworld = World(\n    api=HttpClient(\"http://localhost:8000\"),\n    state_from_context=[\"order_id\", \"user_id\"],\n)\n\n# Option 2: With database rollback\nworld = World(\n    api=HttpClient(\"http://localhost:8000\"),\n    systems={\n        \"db\": PostgresAdapter(\"postgresql://localhost/test\"),\n    },\n)\n</code></pre> <p>Parameters:</p> Parameter Type Required Description <code>api</code> <code>HttpClient</code> Yes HTTP client for API calls <code>systems</code> <code>Dict[str, SystemAdapter]</code> No Database/cache adapters <code>state_from_context</code> <code>List[str]</code> No Context keys for state extraction <p>Methods:</p> Python<pre><code># Checkpoint/rollback\ncheckpoint_id = world.checkpoint()\nworld.rollback(checkpoint_id)\n\n# Context access\nworld.context.set(\"key\", value)\nvalue = world.context.get(\"key\")\nworld.context.has(\"key\")\n\n# Serialization\nsnapshot = world.serialize()\nworld.deserialize(snapshot)\n</code></pre>"},{"location":"reference/api/#agent","title":"Agent","text":"<p>Orchestrates exploration of the state graph.</p> Python<pre><code>from venomqa import Agent, BFS\n\nagent = Agent(\n    world=world,\n    actions=[action1, action2],\n    invariants=[invariant1],\n    strategy=BFS(),\n    max_steps=100,\n    max_depth=20,\n    fail_fast=True,\n    seed=42,\n)\n\nresult = agent.explore()\n</code></pre> <p>Parameters:</p> Parameter Type Required Description <code>world</code> <code>World</code> Yes The sandbox <code>actions</code> <code>List[Action]</code> Yes Available actions <code>invariants</code> <code>List[Invariant]</code> No Rules to check <code>strategy</code> <code>Strategy</code> No Exploration strategy (default: BFS) <code>max_steps</code> <code>int</code> No Maximum actions to execute (default: 1000) <code>max_depth</code> <code>int</code> No Maximum path depth (default: infinite) <code>fail_fast</code> <code>bool</code> No Stop on first CRITICAL violation (default: True) <code>seed</code> <code>int</code> No Random seed for reproducibility <p>Methods:</p> Python<pre><code># Run exploration\nresult = agent.explore()\n\n# With reporter\nresult = agent.explore(reporter=my_reporter)\n</code></pre>"},{"location":"reference/api/#context","title":"Context","text":"<p>Key-value store for passing data between actions.</p> Python<pre><code># Set value\ncontext.set(\"order_id\", \"abc123\")\n\n# Get value (returns None if not set)\norder_id = context.get(\"order_id\")\n\n# Get with default\norder_id = context.get(\"order_id\", default=\"unknown\")\n\n# Check existence\nif context.has(\"order_id\"):\n    ...\n\n# Delete\ncontext.delete(\"order_id\")\n\n# Clear all\ncontext.clear()\n\n# Get all keys\nkeys = context.keys()\n</code></pre>"},{"location":"reference/api/#result","title":"Result","text":"<p>The result of an exploration run.</p> Python<pre><code>result = agent.explore()\n\n# Properties\nresult.states_visited     # Number of unique states\nresult.transitions        # Number of action executions\nresult.invariants_checked # Number of invariant checks\nresult.violations        # List of Violation objects\nresult.paths_explored    # Number of complete paths\nresult.duration_seconds  # Time taken\n\n# Methods\nresult.summary()         # Human-readable summary\nresult.to_dict()         # Serialize to dict\nresult.to_json()         # Serialize to JSON\n</code></pre>"},{"location":"reference/api/#strategies","title":"Strategies","text":""},{"location":"reference/api/#bfs-breadth-first-search","title":"BFS (Breadth-First Search)","text":"<p>Explores states level by level, finding shortest paths to bugs.</p> Python<pre><code>from venomqa import BFS\n\nstrategy = BFS()\n</code></pre>"},{"location":"reference/api/#dfs-depth-first-search","title":"DFS (Depth-First Search)","text":"<p>Goes deep before backtracking, good for finding deep state issues.</p> Python<pre><code>from venomqa import DFS\n\nstrategy = DFS(max_depth=50)\n</code></pre>"},{"location":"reference/api/#coverageguided","title":"CoverageGuided","text":"<p>Prioritizes unexplored code paths (requires coverage instrumentation).</p> Python<pre><code>from venomqa import CoverageGuided\n\nstrategy = CoverageGuided(\n    target_coverage=0.95,\n    seed_corpus=[],\n)\n</code></pre>"},{"location":"reference/api/#enums","title":"Enums","text":""},{"location":"reference/api/#severity","title":"Severity","text":"Python<pre><code>from venomqa import Severity\n\nSeverity.CRITICAL  # Must fix\nSeverity.HIGH      # Important\nSeverity.MEDIUM    # Standard\nSeverity.LOW       # Minor\n</code></pre>"},{"location":"reference/api/#exceptions","title":"Exceptions","text":""},{"location":"reference/api/#venomqaerror","title":"VenomQAError","text":"<p>Base exception for all VenomQA errors.</p> Python<pre><code>from venomqa import VenomQAError\n</code></pre>"},{"location":"reference/api/#invariantviolation","title":"InvariantViolation","text":"<p>Raised when an invariant fails.</p> Python<pre><code>from venomqa import InvariantViolation\n\ntry:\n    agent.explore()\nexcept InvariantViolation as e:\n    print(f\"Invariant {e.invariant_name} failed: {e.message}\")\n</code></pre>"},{"location":"reference/api/#explorationerror","title":"ExplorationError","text":"<p>Raised when exploration cannot continue.</p> Python<pre><code>from venomqa import ExplorationError\n</code></pre>"},{"location":"reference/api/#complete-example","title":"Complete Example","text":"Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\n# Setup\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\n# Actions\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    context.set(\"last_status\", resp.status_code)\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    if not order_id:\n        return None\n    resp = api.post(f\"/orders/{order_id}/refund\")\n    context.set(\"last_status\", resp.status_code)\n    return resp\n\n# Invariants\nno_500s = Invariant(\n    name=\"no_server_errors\",\n    check=lambda w: w.context.get(\"last_status\", 200) &lt; 500,\n    severity=Severity.CRITICAL,\n)\n\n# Run\nagent = Agent(\n    world=world,\n    actions=[\n        Action(\"create_order\", create_order),\n        Action(\"refund_order\", refund_order),\n    ],\n    invariants=[no_500s],\n    strategy=BFS(),\n    max_steps=50,\n)\n\nresult = agent.explore()\nprint(result.summary())\n</code></pre>"},{"location":"reference/api/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Reference - Command-line interface</li> <li>Adapters - HTTP and database adapters</li> <li>Reporters - Output formats</li> </ul>"},{"location":"reference/backends/","title":"Database Backends","text":"<p>Configure database rollback for true parallel exploration.</p>"},{"location":"reference/backends/#overview","title":"Overview","text":"<p>Database backends enable VenomQA to checkpoint and restore database state between exploration branches. This ensures each path starts from a clean, consistent state.</p> Text Only<pre><code>[empty database]\n  \u2502\n  \u251c\u2500\u2500 create \u2192 [has data A]\n  \u2502     \u251c\u2500\u2500 refund \u2192 [refunded A]\n  \u2502     \u2514\u2500\u2500 cancel \u2192 [canceled A]\n  \u2502\n  \u2514\u2500\u2500 (rollback) \u2192 [empty database]\n        \u2502\n        \u2514\u2500\u2500 create \u2192 [has data B]\n</code></pre>"},{"location":"reference/backends/#supported-backends","title":"Supported Backends","text":"Backend Implementation Best For Rollback Speed PostgreSQL SAVEPOINT Production CI ~1ms MySQL SAVEPOINT MySQL shops ~2ms SQLite File copy Local dev ~50ms Redis DUMP/RESTORE Cache testing ~10ms Mock Deep copy Unit tests ~0.1ms"},{"location":"reference/backends/#postgresql-recommended","title":"PostgreSQL (Recommended)","text":""},{"location":"reference/backends/#installation","title":"Installation","text":"Bash<pre><code>pip install \"venomqa[postgres]\"\n# or\npip install psycopg[binary]\n</code></pre>"},{"location":"reference/backends/#configuration","title":"Configuration","text":"Python<pre><code>from venomqa.adapters.postgres import PostgresAdapter\n\ndb = PostgresAdapter(\n    connection_string=\"postgresql://user:pass@host:5432/dbname\",\n    schema=\"public\",\n)\n</code></pre>"},{"location":"reference/backends/#how-it-works","title":"How It Works","text":"SQL<pre><code>-- Entire exploration runs in one transaction\nBEGIN;\n\n-- VenomQA creates savepoints\nSAVEPOINT vq_checkpoint_1;\n-- ... actions execute ...\nROLLBACK TO SAVEPOINT vq_checkpoint_1;\n-- State is restored\n\n-- Transaction never commits\nROLLBACK;\n</code></pre>"},{"location":"reference/backends/#full-example","title":"Full Example","text":"Python<pre><code>from venomqa import World, Agent, Action, BFS\nfrom venomqa.adapters.http import HttpClient\nfrom venomqa.adapters.postgres import PostgresAdapter\n\napi = HttpClient(\"http://localhost:8000\")\ndb = PostgresAdapter(\"postgresql://localhost/testdb\")\n\nworld = World(\n    api=api,\n    systems={\"db\": db},\n    state_from_context=[\"order_id\"],\n)\n\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef check_db(api, context):\n    order_id = context.get(\"order_id\")\n    rows = db.query(\"SELECT * FROM orders WHERE id = %s\", [order_id])\n    print(f\"DB has {len(rows)} orders\")\n    return None\n\nagent = Agent(\n    world=world,\n    actions=[\n        Action(\"create\", create_order),\n        Action(\"check\", check_db),\n    ],\n    strategy=BFS(),\n).explore()\n</code></pre>"},{"location":"reference/backends/#connection-string-format","title":"Connection String Format","text":"Text Only<pre><code>postgresql://[user[:password]@][host][:port][/dbname][?param1=val1&amp;...]\n</code></pre> <p>Examples:</p> Python<pre><code># Local with defaults\n\"postgresql://localhost/mydb\"\n\n# With credentials\n\"postgresql://user:pass@localhost/mydb\"\n\n# With options\n\"postgresql://user:pass@localhost/mydb?sslmode=require\"\n\n# From environment\nimport os\ndb = PostgresAdapter(os.getenv(\"DATABASE_URL\"))\n</code></pre>"},{"location":"reference/backends/#mysql","title":"MySQL","text":""},{"location":"reference/backends/#installation_1","title":"Installation","text":"Bash<pre><code>pip install \"venomqa[mysql]\"\n# or\npip install mysql-connector-python\n</code></pre>"},{"location":"reference/backends/#configuration_1","title":"Configuration","text":"Python<pre><code>from venomqa.adapters.mysql import MySQLAdapter\n\ndb = MySQLAdapter(\n    host=\"localhost\",\n    port=3306,\n    user=\"root\",\n    password=\"secret\",\n    database=\"testdb\",\n)\n</code></pre> <p>Or with connection string:</p> Python<pre><code>db = MySQLAdapter(\"mysql://user:pass@localhost:3306/testdb\")\n</code></pre>"},{"location":"reference/backends/#full-example_1","title":"Full Example","text":"Python<pre><code>from venomqa import World\nfrom venomqa.adapters.http import HttpClient\nfrom venomqa.adapters.mysql import MySQLAdapter\n\napi = HttpClient(\"http://localhost:8000\")\ndb = MySQLAdapter(host=\"localhost\", user=\"root\", database=\"testdb\")\n\nworld = World(api=api, systems={\"db\": db})\n</code></pre>"},{"location":"reference/backends/#sqlite","title":"SQLite","text":""},{"location":"reference/backends/#installation_2","title":"Installation","text":"<p>Built-in. No additional installation required.</p>"},{"location":"reference/backends/#configuration_2","title":"Configuration","text":"Python<pre><code>from venomqa.adapters.sqlite import SQLiteAdapter\n\ndb = SQLiteAdapter(\n    path=\"/path/to/database.db\",\n    copy_on_checkpoint=True,\n)\n</code></pre>"},{"location":"reference/backends/#how-it-works_1","title":"How It Works","text":"<p>SQLite uses file copying instead of transactions:</p> <ol> <li>Checkpoint: Copy database file to temp location</li> <li>Rollback: Restore from temp copy</li> </ol> <p>This is slower than PostgreSQL but works without special setup.</p>"},{"location":"reference/backends/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Use in-memory mode for fastest tests:   Python<pre><code>db = SQLiteAdapter(path=\":memory:\")\n</code></pre></p> </li> <li> <p>Keep database small (&lt; 100MB) for reasonable rollback times</p> </li> </ul>"},{"location":"reference/backends/#redis","title":"Redis","text":""},{"location":"reference/backends/#installation_3","title":"Installation","text":"Bash<pre><code>pip install redis\n</code></pre>"},{"location":"reference/backends/#configuration_3","title":"Configuration","text":"Python<pre><code>from venomqa.adapters.redis_adapter import RedisAdapter\n\nredis = RedisAdapter(\n    host=\"localhost\",\n    port=6379,\n    db=0,\n    password=None,\n)\n</code></pre>"},{"location":"reference/backends/#how-it-works_2","title":"How It Works","text":"<ol> <li>Checkpoint: <code>DUMP</code> all keys</li> <li>Rollback: <code>FLUSHALL</code> + <code>RESTORE</code> all keys</li> </ol>"},{"location":"reference/backends/#full-example_2","title":"Full Example","text":"Python<pre><code>from venomqa import World\nfrom venomqa.adapters.http import HttpClient\nfrom venomqa.adapters.redis_adapter import RedisAdapter\n\napi = HttpClient(\"http://localhost:8000\")\nredis = RedisAdapter(host=\"localhost\")\n\nworld = World(\n    api=api,\n    systems={\"cache\": redis},\n)\n\ndef clear_cache(api, context):\n    redis.flush()\n    return None\n</code></pre>"},{"location":"reference/backends/#mock-testing","title":"Mock (Testing)","text":"<p>For unit tests without a real database.</p>"},{"location":"reference/backends/#configuration_4","title":"Configuration","text":"Python<pre><code>from venomqa.adapters.mock import MockSystem\n\n# With initial state\nmock = MockSystem(initial_state={\n    \"users\": [],\n    \"orders\": [],\n})\n\nworld = World(api=api, systems={\"db\": mock})\n</code></pre>"},{"location":"reference/backends/#methods","title":"Methods","text":"Python<pre><code># Query\nrows = mock.query(\"users\")  # Returns list\n\n# Execute\nmock.execute(\"INSERT INTO users VALUES (?)\", [{\"name\": \"Alice\"}])\n\n# Clear\nmock.clear()\n</code></pre>"},{"location":"reference/backends/#multiple-systems","title":"Multiple Systems","text":"<p>You can configure multiple database systems:</p> Python<pre><code>from venomqa import World\nfrom venomqa.adapters.postgres import PostgresAdapter\nfrom venomqa.adapters.redis_adapter import RedisAdapter\n\nworld = World(\n    api=api,\n    systems={\n        \"db\": PostgresAdapter(\"postgresql://localhost/app\"),\n        \"cache\": RedisAdapter(host=\"localhost\"),\n    },\n)\n\n# Access in actions\ndef check_consistency(api, context):\n    db_count = world.systems[\"db\"].query(\"SELECT COUNT(*) FROM orders\")[0][0]\n    cache_count = world.systems[\"cache\"].get(\"order_count\")\n    return db_count == cache_count\n</code></pre>"},{"location":"reference/backends/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/backends/#postgresql-savepoint-does-not-exist","title":"PostgreSQL: \"SAVEPOINT does not exist\"","text":"<p>The transaction was committed externally. Ensure no other code commits:</p> Python<pre><code># Bad: External commit\ndb.execute(\"COMMIT\")  # Breaks VenomQA\n\n# Good: Let VenomQA manage transactions\n# (no explicit COMMIT)\n</code></pre>"},{"location":"reference/backends/#sqlite-database-is-locked","title":"SQLite: \"Database is locked\"","text":"<p>SQLite doesn't handle concurrent access well. Solutions:</p> <ol> <li>Use PostgreSQL for parallel exploration</li> <li>Reduce concurrent workers</li> <li>Use WAL mode: <code>PRAGMA journal_mode=WAL;</code></li> </ol>"},{"location":"reference/backends/#mysql-lock-wait-timeout-exceeded","title":"MySQL: \"Lock wait timeout exceeded\"","text":"<p>Long-running transactions can timeout. Increase timeout:</p> Python<pre><code>db = MySQLAdapter(\n    ...,\n    connection_timeout=60,\n)\n</code></pre>"},{"location":"reference/backends/#redis-oom-command-not-allowed","title":"Redis: \"OOM command not allowed\"","text":"<p>Redis is out of memory. Solutions:</p> <ol> <li>Increase Redis memory</li> <li>Use smaller test data</li> <li>Enable eviction: <code>maxmemory-policy allkeys-lru</code></li> </ol>"},{"location":"reference/backends/#next-steps","title":"Next Steps","text":"<ul> <li>Adapters - HTTP and other adapters</li> <li>Checkpoints &amp; Branching - Deep dive</li> <li>CI/CD Integration - Use in pipelines</li> </ul>"},{"location":"reference/cli/","title":"CLI Reference","text":"<p>Command-line interface for VenomQA.</p>"},{"location":"reference/cli/#installation","title":"Installation","text":"Bash<pre><code>pip install venomqa\nvenomqa --version\n</code></pre>"},{"location":"reference/cli/#global-options","title":"Global Options","text":"Bash<pre><code>venomqa [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --version              Show version and exit\n  --help                 Show help and exit\n  --api-key TEXT         X-API-Key header for authentication\n  --auth-token TEXT      Bearer token for authentication\n  --basic-auth TEXT      Basic auth as user:password\n  --skip-preflight       Skip Docker and auth validation\n  --config PATH          Path to venomqa.yaml config file\n  --verbose, -v          Enable verbose output\n  --quiet, -q            Suppress non-error output\n</code></pre>"},{"location":"reference/cli/#commands","title":"Commands","text":""},{"location":"reference/cli/#venomqa-demo","title":"venomqa demo","text":"<p>Run the built-in demo to see VenomQA find a bug.</p> Bash<pre><code>venomqa demo [OPTIONS]\n\nOptions:\n  --bug-type [double_refund|stale_cache|idempotency]\n                        Which bug to demonstrate\n  --steps INTEGER       Maximum steps to explore (default: 50)\n</code></pre> <p>Example:</p> Bash<pre><code>$ venomqa demo\n\n  Unit Tests:  3/3 PASS \u2713\n\n  VenomQA Exploration \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  States visited:     8\n  Transitions:        20\n  Invariants checked: 40\n\n  \u256d\u2500 CRITICAL VIOLATION \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n  \u2502 Sequence: create_order \u2192 refund \u2192 refund  \u2502\n  \u2502 Bug:      refunded $200 on a $100 order   \u2502\n  \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n  Summary: 3 tests passed. 1 sequence bug found.\n</code></pre>"},{"location":"reference/cli/#venomqa-doctor","title":"venomqa doctor","text":"<p>Diagnose your environment and configuration.</p> Bash<pre><code>venomqa doctor [OPTIONS]\n\nOptions:\n  --fix                  Attempt to fix issues automatically\n</code></pre> <p>Example:</p> Bash<pre><code>$ venomqa doctor\n\u2713 Python 3.11.5\n\u2713 httpx 0.25.2\n\u2713 pydantic 2.5.0\n\u2713 psycopg[binary] installed\n\u2713 All checks passed\n</code></pre>"},{"location":"reference/cli/#venomqa-run","title":"venomqa run","text":"<p>Run exploration on a test suite.</p> Bash<pre><code>venomqa run [OPTIONS] PATH\n\nArguments:\n  PATH                   Path to qa/ directory or test file\n\nOptions:\n  --strategy [bfs|dfs|coverage]\n                         Exploration strategy (default: bfs)\n  --max-steps INTEGER    Maximum actions to execute (default: 1000)\n  --max-depth INTEGER    Maximum path depth (default: infinite)\n  --fail-fast            Stop on first CRITICAL violation\n  --continue-on-error    Continue even on CRITICAL violations\n  --report [console|html|json|junit]\n                         Report format(s), can specify multiple\n  --output PATH          Output directory for reports\n  --seed INTEGER         Random seed for reproducibility\n</code></pre> <p>Examples:</p> Bash<pre><code># Basic run\nvenomqa run qa/\n\n# With HTML report\nvenomqa run qa/ --report html --output reports/\n\n# Multiple report formats\nvenomqa run qa/ --report html --report json --report junit\n\n# With limits\nvenomqa run qa/ --max-steps 500 --max-depth 20\n\n# Reproducible run\nvenomqa run qa/ --seed 42\n</code></pre>"},{"location":"reference/cli/#venomqa-init","title":"venomqa init","text":"<p>Initialize a new VenomQA project.</p> Bash<pre><code>venomqa init [OPTIONS] [PATH]\n\nArguments:\n  PATH                   Where to create the project (default: current dir)\n\nOptions:\n  --name TEXT            Project name\n  --api-url TEXT         Base URL for API\n  --with-sample          Include sample actions and invariants\n  --database [postgres|mysql|sqlite|none]\n                         Database adapter to configure\n</code></pre> <p>Example:</p> Bash<pre><code>$ venomqa init my-project --with-sample\nCreating project in my-project/\n  \u251c\u2500\u2500 qa/\n  \u2502   \u251c\u2500\u2500 actions/\n  \u2502   \u2502   \u2514\u2500\u2500 sample.py\n  \u2502   \u251c\u2500\u2500 invariants.py\n  \u2502   \u2514\u2500\u2500 test_sample.py\n  \u251c\u2500\u2500 venomqa.yaml\n  \u2514\u2500\u2500 requirements.txt\n\nRun with: cd my-project &amp;&amp; venomqa run qa/\n</code></pre>"},{"location":"reference/cli/#venomqa-scaffold","title":"venomqa scaffold","text":"<p>Generate code from OpenAPI specifications.</p> Bash<pre><code>venomqa scaffold [OPTIONS] COMMAND\n\nCommands:\n  openapi               Generate actions from OpenAPI spec\n</code></pre>"},{"location":"reference/cli/#venomqa-scaffold-openapi","title":"venomqa scaffold openapi","text":"Bash<pre><code>venomqa scaffold openapi [OPTIONS] SPEC\n\nArguments:\n  SPEC                   Path to OpenAPI spec (JSON or YAML)\n\nOptions:\n  --output PATH          Output directory (default: qa/actions/)\n  --prefix TEXT          Prefix for action names\n  --include PATTERN      Only include paths matching pattern\n  --exclude PATTERN      Exclude paths matching pattern\n  --base-url TEXT        Override base URL from spec\n</code></pre> <p>Example:</p> Bash<pre><code>$ venomqa scaffold openapi api-spec.yaml --output qa/actions/\nGenerated 24 actions:\n  qa/actions/api_keys.py\n  qa/actions/bookings.py\n  qa/actions/users.py\n</code></pre>"},{"location":"reference/cli/#venomqa-explore","title":"venomqa explore","text":"<p>Interactive exploration mode.</p> Bash<pre><code>venomqa explore [OPTIONS] PATH\n\nOptions:\n  --interactive          Enable interactive mode\n  --record PATH          Record session to file\n  --replay PATH          Replay recorded session\n</code></pre>"},{"location":"reference/cli/#venomqa-report","title":"venomqa report","text":"<p>Generate reports from previous runs.</p> Bash<pre><code>venomqa report [OPTIONS] RESULTS\n\nArguments:\n  RESULTS                Path to results.json from previous run\n\nOptions:\n  --format [html|json|junit|console]\n                         Output format\n  --output PATH          Output directory\n</code></pre>"},{"location":"reference/cli/#environment-variables","title":"Environment Variables","text":"Variable Equivalent Option <code>VENOMQA_API_KEY</code> <code>--api-key</code> <code>VENOMQA_AUTH_TOKEN</code> <code>--auth-token</code> <code>VENOMQA_BASE_URL</code> (used in config) <code>VENOMQA_DATABASE_URL</code> (used in config) <code>VENOMQA_CONFIG</code> <code>--config</code>"},{"location":"reference/cli/#configuration-file","title":"Configuration File","text":"<p>Create <code>venomqa.yaml</code> for persistent settings:</p> YAML<pre><code>api:\n  base_url: http://localhost:8000\n  timeout: 30.0\n  headers:\n    X-API-Version: \"1.0\"\n\nexploration:\n  strategy: bfs\n  max_steps: 500\n  max_depth: 25\n  fail_fast: true\n\nreporting:\n  formats:\n    - html\n    - junit\n  output_dir: reports/\n\ndatabase:\n  type: postgres\n  url: ${VENOMQA_DATABASE_URL}\n</code></pre>"},{"location":"reference/cli/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success, no violations 1 Violations found 2 Configuration error 3 Runtime error 4 Authentication error"},{"location":"reference/cli/#examples","title":"Examples","text":""},{"location":"reference/cli/#basic-workflow","title":"Basic Workflow","text":"Bash<pre><code># 1. Initialize project\nvenomqa init my-api-tests --with-sample\ncd my-api-tests\n\n# 2. Check environment\nvenomqa doctor\n\n# 3. Generate from OpenAPI\nvenomqa scaffold openapi ../api-spec.yaml\n\n# 4. Run tests\nvenomqa run qa/ --report html\n\n# 5. View report\nopen reports/trace.html\n</code></pre>"},{"location":"reference/cli/#ci-pipeline","title":"CI Pipeline","text":"Bash<pre><code># Install\npip install venomqa\n\n# Run with limits for fast feedback\nvenomqa run qa/ \\\n  --max-steps 200 \\\n  --report junit \\\n  --output test-results/\n\n# Exit code indicates pass/fail\n</code></pre>"},{"location":"reference/cli/#debugging","title":"Debugging","text":"Bash<pre><code># Verbose output\nvenomqa run qa/ -v\n\n# Reproduce specific issue\nvenomqa run qa/ --seed 12345\n\n# Interactive exploration\nvenomqa explore qa/ --interactive\n</code></pre>"},{"location":"reference/cli/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Python API</li> <li>Configuration - Configuration options</li> <li>CI/CD Integration - Automate in pipelines</li> </ul>"},{"location":"reference/config/","title":"Configuration Reference","text":"<p>Complete reference for all VenomQA configuration options.</p>"},{"location":"reference/config/#configuration-file","title":"Configuration File","text":"<p>VenomQA reads configuration from <code>venomqa.yaml</code> in the project root.</p> YAML<pre><code># venomqa.yaml - Complete configuration reference\n\n# ====================\n# API Configuration\n# ====================\nbase_url: \"http://localhost:8000\"    # Base URL for all API requests\ntimeout: 30                          # Request timeout in seconds\nretry_count: 3                       # Number of retry attempts\nretry_delay: 1.0                     # Base delay between retries (seconds)\n\n# ====================\n# Database Configuration\n# ====================\ndb_url: \"postgresql://qa:secret@localhost:5432/qa_test\"\ndb_backend: \"postgresql\"             # postgresql, sqlite, mysql\n\n# ====================\n# Infrastructure\n# ====================\ndocker_compose_file: \"docker-compose.qa.yml\"\n\n# ====================\n# Execution\n# ====================\nparallel_paths: 1                    # Max concurrent branch paths\nfail_fast: false                     # Stop on first failure\n\n# ====================\n# Logging\n# ====================\nverbose: false                       # Enable verbose/debug output\ncapture_logs: true                   # Capture infrastructure logs\nlog_lines: 50                        # Number of log lines to capture\n\n# ====================\n# Reporting\n# ====================\nreport_dir: \"reports\"                # Output directory for reports\nreport_formats:                      # Report formats to generate\n  - markdown\n  - junit\n</code></pre>"},{"location":"reference/config/#configuration-options","title":"Configuration Options","text":""},{"location":"reference/config/#api-configuration","title":"API Configuration","text":"Option Type Default Environment Variable Description <code>base_url</code> string <code>\"http://localhost:8000\"</code> <code>VENOMQA_BASE_URL</code> Base URL for API requests <code>timeout</code> integer <code>30</code> <code>VENOMQA_TIMEOUT</code> Request timeout (seconds) <code>retry_count</code> integer <code>3</code> <code>VENOMQA_RETRY_COUNT</code> Retry attempts on failure <code>retry_delay</code> float <code>1.0</code> <code>VENOMQA_RETRY_DELAY</code> Base delay between retries"},{"location":"reference/config/#database-configuration","title":"Database Configuration","text":"Option Type Default Environment Variable Description <code>db_url</code> string <code>null</code> <code>VENOMQA_DB_URL</code> Database connection URL <code>db_backend</code> string <code>\"postgresql\"</code> <code>VENOMQA_DB_BACKEND</code> Database backend type <p>Supported backends:</p> <ul> <li><code>postgresql</code> - PostgreSQL with SAVEPOINT support (recommended)</li> <li><code>sqlite</code> - SQLite with limited checkpoint support</li> <li><code>mysql</code> - MySQL with SAVEPOINT support</li> </ul> <p>Connection URL formats:</p> Bash<pre><code># PostgreSQL\npostgresql://user:password@host:5432/database\npostgresql://user:password@host:5432/database?sslmode=require\n\n# SQLite\nsqlite:///path/to/database.db\nsqlite:///:memory:\n\n# MySQL\nmysql://user:password@host:3306/database\n</code></pre>"},{"location":"reference/config/#infrastructure-configuration","title":"Infrastructure Configuration","text":"Option Type Default Environment Variable Description <code>docker_compose_file</code> string <code>\"docker-compose.qa.yml\"</code> <code>VENOMQA_DOCKER_COMPOSE_FILE</code> Docker Compose file path"},{"location":"reference/config/#execution-configuration","title":"Execution Configuration","text":"Option Type Default Environment Variable Description <code>parallel_paths</code> integer <code>1</code> <code>VENOMQA_PARALLEL_PATHS</code> Max concurrent paths <code>fail_fast</code> boolean <code>false</code> <code>VENOMQA_FAIL_FAST</code> Stop on first failure <p>Parallel Execution</p> <p>Using <code>parallel_paths &gt; 1</code> with database state management may cause isolation issues. Use sequential execution (<code>parallel_paths=1</code>) when state isolation is critical.</p>"},{"location":"reference/config/#logging-configuration","title":"Logging Configuration","text":"Option Type Default Environment Variable Description <code>verbose</code> boolean <code>false</code> <code>VENOMQA_VERBOSE</code> Enable debug output <code>capture_logs</code> boolean <code>true</code> <code>VENOMQA_CAPTURE_LOGS</code> Capture infra logs <code>log_lines</code> integer <code>50</code> <code>VENOMQA_LOG_LINES</code> Log lines to capture"},{"location":"reference/config/#reporting-configuration","title":"Reporting Configuration","text":"Option Type Default Environment Variable Description <code>report_dir</code> string <code>\"reports\"</code> <code>VENOMQA_REPORT_DIR</code> Report output directory <code>report_formats</code> list <code>[\"markdown\"]</code> <code>VENOMQA_REPORT_FORMATS</code> Formats to generate <p>Available formats:</p> <ul> <li><code>markdown</code> - Human-readable Markdown</li> <li><code>json</code> - Structured JSON</li> <li><code>junit</code> - JUnit XML for CI/CD</li> <li><code>html</code> - Standalone HTML report</li> <li><code>sarif</code> - SARIF for security tools</li> </ul>"},{"location":"reference/config/#environment-variables","title":"Environment Variables","text":"<p>All configuration options can be overridden with environment variables prefixed with <code>VENOMQA_</code>:</p> Bash<pre><code># API\nexport VENOMQA_BASE_URL=\"http://api.example.com\"\nexport VENOMQA_TIMEOUT=60\nexport VENOMQA_RETRY_COUNT=5\n\n# Database\nexport VENOMQA_DB_URL=\"postgresql://user:pass@host:5432/db\"\nexport VENOMQA_DB_BACKEND=\"postgresql\"\n\n# Execution\nexport VENOMQA_PARALLEL_PATHS=4\nexport VENOMQA_FAIL_FAST=true\nexport VENOMQA_VERBOSE=true\n\n# Reporting\nexport VENOMQA_REPORT_DIR=\"/tmp/reports\"\nexport VENOMQA_REPORT_FORMATS=\"markdown,junit\"\n</code></pre> <p>Type conversion:</p> YAML Type Environment Variable string As-is integer Parsed as int float Parsed as float boolean <code>true</code>/<code>false</code>, <code>1</code>/<code>0</code>, <code>yes</code>/<code>no</code> list Comma-separated values"},{"location":"reference/config/#priority-order","title":"Priority Order","text":"<p>Configuration is loaded in this order (later sources override earlier):</p> <ol> <li>Default values (lowest priority)</li> <li>Configuration file (<code>venomqa.yaml</code>)</li> <li>Environment variables (<code>VENOMQA_*</code>)</li> <li>CLI arguments (highest priority)</li> </ol>"},{"location":"reference/config/#multiple-environments","title":"Multiple Environments","text":""},{"location":"reference/config/#using-different-config-files","title":"Using Different Config Files","text":"Bash<pre><code># Development\nvenomqa run -c venomqa.dev.yaml\n\n# Staging\nvenomqa run -c venomqa.staging.yaml\n\n# Production (read-only tests)\nvenomqa run -c venomqa.prod.yaml\n</code></pre>"},{"location":"reference/config/#example-development-config","title":"Example: Development Config","text":"YAML<pre><code># venomqa.dev.yaml\nbase_url: \"http://localhost:8000\"\ndb_url: \"postgresql://dev:dev@localhost:5432/dev_db\"\nverbose: true\ntimeout: 10\n</code></pre>"},{"location":"reference/config/#example-staging-config","title":"Example: Staging Config","text":"YAML<pre><code># venomqa.staging.yaml\nbase_url: \"https://api.staging.example.com\"\ndb_url: \"postgresql://qa:secret@staging-db:5432/qa_test\"\nverbose: false\ntimeout: 60\n</code></pre>"},{"location":"reference/config/#example-cicd-config","title":"Example: CI/CD Config","text":"YAML<pre><code># venomqa.ci.yaml\nbase_url: \"${API_URL}\"  # Replaced by environment variable\ntimeout: 120\nfail_fast: true\nreport_formats:\n  - junit\n  - html\n</code></pre>"},{"location":"reference/config/#programmatic-configuration","title":"Programmatic Configuration","text":""},{"location":"reference/config/#qaconfig-class","title":"QAConfig Class","text":"Python<pre><code>from venomqa import QAConfig\n\nconfig = QAConfig(\n    base_url=\"http://localhost:8000\",\n    db_url=\"postgresql://qa:secret@localhost:5432/qa_test\",\n    db_backend=\"postgresql\",\n    timeout=30,\n    retry_count=3,\n    retry_delay=1.0,\n    parallel_paths=2,\n    fail_fast=False,\n    verbose=True,\n    capture_logs=True,\n    log_lines=100,\n    report_dir=\"reports\",\n    report_formats=[\"markdown\", \"junit\"],\n)\n</code></pre>"},{"location":"reference/config/#loading-from-file","title":"Loading from File","text":"Python<pre><code>from venomqa.config import load_config\n\n# Load from default location\nconfig = load_config()\n\n# Load from specific path\nconfig = load_config(\"path/to/config.yaml\")\n\n# Access values\nprint(config.base_url)\nprint(config.db_url)\nprint(config.timeout)\n</code></pre>"},{"location":"reference/config/#creating-client-from-config","title":"Creating Client from Config","text":"Python<pre><code>from venomqa import Client, QAConfig\n\nconfig = load_config()\n\nclient = Client(\n    base_url=config.base_url,\n    timeout=config.timeout,\n    retry_count=config.retry_count,\n    retry_delay=config.retry_delay,\n)\n</code></pre>"},{"location":"reference/config/#validation","title":"Validation","text":"<p>VenomQA validates configuration on load:</p> Python<pre><code>from venomqa.config import load_config, ConfigValidationError\n\ntry:\n    config = load_config()\nexcept ConfigValidationError as e:\n    print(f\"Invalid configuration: {e}\")\n</code></pre> <p>Validation rules:</p> <ul> <li><code>base_url</code> must be a valid URL</li> <li><code>timeout</code> must be positive</li> <li><code>retry_count</code> must be non-negative</li> <li><code>db_url</code> must be valid connection string (if provided)</li> <li><code>report_formats</code> must contain valid format names</li> </ul>"},{"location":"reference/config/#best-practices","title":"Best Practices","text":""},{"location":"reference/config/#1-use-environment-variables-for-secrets","title":"1. Use Environment Variables for Secrets","text":"YAML<pre><code># venomqa.yaml (safe to commit)\nbase_url: \"http://localhost:8000\"\ndb_backend: \"postgresql\"\n\n# Set secrets via environment\n# export VENOMQA_DB_URL=\"postgresql://...\"\n</code></pre>"},{"location":"reference/config/#2-different-timeouts-for-different-environments","title":"2. Different Timeouts for Different Environments","text":"YAML<pre><code># Local development - fast feedback\ntimeout: 10\n\n# CI/CD - allow for network latency\ntimeout: 60\n\n# Production smoke tests - be patient\ntimeout: 120\n</code></pre>"},{"location":"reference/config/#3-enable-verbose-only-for-debugging","title":"3. Enable Verbose Only for Debugging","text":"YAML<pre><code># Development\nverbose: true\n\n# CI/CD - too noisy\nverbose: false\n</code></pre>"},{"location":"reference/config/#4-use-sequential-execution-with-database-state","title":"4. Use Sequential Execution with Database State","text":"YAML<pre><code># Safe for database checkpointing\nparallel_paths: 1\n</code></pre>"},{"location":"reference/config/#5-specify-report-formats-for-cicd","title":"5. Specify Report Formats for CI/CD","text":"YAML<pre><code># CI/CD\nreport_formats:\n  - junit    # For test results\n  - html     # For artifacts\n</code></pre>"},{"location":"reference/reporters/","title":"Reporters","text":"<p>Generate reports from VenomQA exploration results.</p>"},{"location":"reference/reporters/#overview","title":"Overview","text":"<p>Reporters capture exploration output in various formats for analysis, CI integration, and team sharing.</p> Python<pre><code>from venomqa.reporters import ConsoleReporter, HTMLTraceReporter\n\nagent = Agent(...)\n\n# Multiple reporters\nresult = agent.explore(reporter=[\n    ConsoleReporter(verbose=True),\n    HTMLTraceReporter(output_path=\"reports/trace.html\"),\n])\n</code></pre>"},{"location":"reference/reporters/#built-in-reporters","title":"Built-in Reporters","text":""},{"location":"reference/reporters/#consolereporter","title":"ConsoleReporter","text":"<p>Default reporter that outputs to terminal.</p> Python<pre><code>from venomqa.reporters import ConsoleReporter\n\nreporter = ConsoleReporter(\n    verbose=False,        # Show detailed output\n    color=True,           # Colored output\n    show_timestamps=True, # Include timestamps\n    show_progress=True,   # Progress bar\n)\n</code></pre> <p>Output:</p> Text Only<pre><code>VenomQA Exploration \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nStates visited:     25\nTransitions:        87\nInvariants checked: 261\n\n\u256d\u2500 CRITICAL VIOLATION \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Invariant: no_over_refund                      \u2502\n\u2502 Sequence: create \u2192 refund \u2192 refund             \u2502\n\u2502 Details:  Refunded $200 on $100 order          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nSummary: 25 states, 1 violation\nDuration: 4.2s\n</code></pre>"},{"location":"reference/reporters/#htmltracereporter","title":"HTMLTraceReporter","text":"<p>Generates an interactive HTML visualization.</p> Python<pre><code>from venomqa.reporters import HTMLTraceReporter\n\nreporter = HTMLTraceReporter(\n    output_path=\"reports/trace.html\",\n    include_graph=True,     # D3 force graph\n    include_timeline=True,  # Timeline view\n    theme=\"dark\",           # \"dark\" or \"light\"\n    title=\"API Exploration\",\n)\n</code></pre> <p>Features:</p> <ul> <li>Interactive state graph (D3.js)</li> <li>Path timeline</li> <li>Violation details</li> <li>Response previews</li> <li>Filterable by status, action, invariant</li> </ul>"},{"location":"reference/reporters/#jsonreporter","title":"JSONReporter","text":"<p>Exports results as JSON for programmatic processing.</p> Python<pre><code>from venomqa.reporters import JSONReporter\n\nreporter = JSONReporter(\n    output_path=\"reports/results.json\",\n    pretty_print=True,      # Human-readable\n    include_responses=True, # Full response data\n    include_context=True,   # Context snapshots\n)\n</code></pre> <p>Output Structure:</p> JSON<pre><code>{\n  \"summary\": {\n    \"states_visited\": 25,\n    \"transitions\": 87,\n    \"invariants_checked\": 261,\n    \"violations\": 1,\n    \"duration_seconds\": 4.2\n  },\n  \"violations\": [\n    {\n      \"invariant_name\": \"no_over_refund\",\n      \"severity\": \"CRITICAL\",\n      \"path\": [\"create_order\", \"refund_order\", \"refund_order\"],\n      \"message\": \"Refunded $200 on $100 order\",\n      \"context\": {...},\n      \"timestamp\": \"2024-01-15T10:30:00Z\"\n    }\n  ],\n  \"states\": [...],\n  \"transitions\": [...]\n}\n</code></pre>"},{"location":"reference/reporters/#junitreporter","title":"JUnitReporter","text":"<p>Generates JUnit XML for CI/CD integration.</p> Python<pre><code>from venomqa.reporters import JUnitReporter\n\nreporter = JUnitReporter(\n    output_path=\"reports/junit.xml\",\n    suite_name=\"VenomQA\",\n)\n</code></pre> <p>Output:</p> XML<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;testsuites&gt;\n  &lt;testsuite name=\"VenomQA\" tests=\"261\" failures=\"1\" time=\"4.2\"&gt;\n    &lt;testcase name=\"create_order\" classname=\"actions\" time=\"0.1\"/&gt;\n    &lt;testcase name=\"refund_order\" classname=\"actions\" time=\"0.08\"/&gt;\n    &lt;testcase name=\"invariant.no_over_refund\" classname=\"invariants\" time=\"0.01\"&gt;\n      &lt;failure message=\"Refunded $200 on $100 order\"&gt;\n        Path: create_order \u2192 refund_order \u2192 refund_order\n      &lt;/failure&gt;\n    &lt;/testcase&gt;\n  &lt;/testsuite&gt;\n&lt;/testsuites&gt;\n</code></pre> <p>CI Integration:</p> <ul> <li>GitHub Actions: Shows in test summary</li> <li>GitLab CI: Displays in pipeline view</li> <li>Jenkins: Parsed by JUnit plugin</li> <li>CircleCI: Test summary integration</li> </ul>"},{"location":"reference/reporters/#markdownreporter","title":"MarkdownReporter","text":"<p>Generates a markdown summary.</p> Python<pre><code>from venomqa.reporters import MarkdownReporter\n\nreporter = MarkdownReporter(\n    output_path=\"reports/summary.md\",\n    include_mermaid=True,  # Mermaid diagrams\n)\n</code></pre> <p>Output:</p> <p>Markdown<pre><code># VenomQA Exploration Report\n\n## Summary\n\n| Metric | Value |\n|--------|-------|\n| States visited | 25 |\n| Transitions | 87 |\n| Violations | 1 |\n| Duration | 4.2s |\n\n## Violations\n\n### CRITICAL: no_over_refund\n\n**Path:** `create_order \u2192 refund_order \u2192 refund_order`\n\n**Message:** Refunded $200 on $100 order\n\n## State Graph\n\n```mermaid\ngraph TD\n    A[empty] --&gt;|create| B[has_order]\n    B --&gt;|refund| C[refunded]\n</code></pre> Text Only<pre><code>---\n\n## Custom Reporters\n\nCreate custom reporters by implementing the Reporter protocol.\n\n```python\nfrom typing import List\nfrom venomqa.reporters.base import Reporter\nfrom venomqa.core import Violation, ExplorationResult\n\nclass SlackReporter(Reporter):\n    \"\"\"Post results to Slack.\"\"\"\n\n    def __init__(self, webhook_url: str, channel: str = \"#qa\"):\n        self.webhook_url = webhook_url\n        self.channel = channel\n\n    def on_violation(self, violation: Violation) -&gt; None:\n        \"\"\"Called when a violation is found.\"\"\"\n        import requests\n\n        color = {\n            \"CRITICAL\": \"#FF0000\",\n            \"HIGH\": \"#FF6600\",\n            \"MEDIUM\": \"#FFCC00\",\n            \"LOW\": \"#666666\",\n        }.get(violation.severity.name, \"#666666\")\n\n        requests.post(self.webhook_url, json={\n            \"channel\": self.channel,\n            \"attachments\": [{\n                \"color\": color,\n                \"title\": f\"VenomQA: {violation.invariant_name}\",\n                \"text\": violation.message,\n                \"fields\": [{\n                    \"title\": \"Sequence\",\n                    \"value\": \" \u2192 \".join(violation.path),\n                    \"short\": False,\n                }],\n            }],\n        })\n\n    def on_complete(self, result: ExplorationResult) -&gt; None:\n        \"\"\"Called when exploration completes.\"\"\"\n        import requests\n\n        status = \"\u2705 Passed\" if not result.violations else \"\u274c Failed\"\n\n        requests.post(self.webhook_url, json={\n            \"channel\": self.channel,\n            \"text\": f\"VenomQA complete: {status}\\n\"\n                    f\"States: {result.states_visited}, \"\n                    f\"Violations: {len(result.violations)}\",\n        })\n</code></pre></p> <p>Using Custom Reporters:</p> Python<pre><code>from reporters.slack import SlackReporter\n\nslack = SlackReporter(\n    webhook_url=\"https://hooks.slack.com/services/...\",\n    channel=\"#qa-alerts\",\n)\n\nresult = agent.explore(reporter=[slack, ConsoleReporter()])\n</code></pre>"},{"location":"reference/reporters/#reporter-protocol","title":"Reporter Protocol","text":"Python<pre><code>class Reporter(Protocol):\n    def on_start(self) -&gt; None:\n        \"\"\"Called when exploration starts.\"\"\"\n        ...\n\n    def on_action(self, action: str, result: ActionResult) -&gt; None:\n        \"\"\"Called after each action.\"\"\"\n        ...\n\n    def on_invariant(self, invariant: str, passed: bool) -&gt; None:\n        \"\"\"Called after each invariant check.\"\"\"\n        ...\n\n    def on_violation(self, violation: Violation) -&gt; None:\n        \"\"\"Called when a violation is found.\"\"\"\n        ...\n\n    def on_complete(self, result: ExplorationResult) -&gt; None:\n        \"\"\"Called when exploration completes.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/reporters/#combining-reporters","title":"Combining Reporters","text":"Python<pre><code>from venomqa.reporters import (\n    ConsoleReporter,\n    HTMLTraceReporter,\n    JSONReporter,\n    JUnitReporter,\n)\n\n# All reporters receive events\nreporters = [\n    ConsoleReporter(verbose=True),\n    HTMLTraceReporter(output_path=\"reports/trace.html\"),\n    JSONReporter(output_path=\"reports/results.json\"),\n    JUnitReporter(output_path=\"reports/junit.xml\"),\n]\n\nresult = agent.explore(reporter=reporters)\n</code></pre>"},{"location":"reference/reporters/#cli-usage","title":"CLI Usage","text":"Bash<pre><code># Single reporter\nvenomqa run qa/ --report html --output reports/\n\n# Multiple reporters\nvenomqa run qa/ \\\n  --report html \\\n  --report json \\\n  --report junit \\\n  --output reports/\n</code></pre>"},{"location":"reference/reporters/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Reference - Command-line options</li> <li>CI/CD Integration - Use in pipelines</li> <li>API Reference - Programmatic usage</li> </ul>"},{"location":"specs/","title":"Specifications","text":"<p>Technical specifications for VenomQA internals.</p>"},{"location":"specs/#overview","title":"Overview","text":"<p>These specifications define the internal architecture and contracts of VenomQA. They are intended for:</p> <ul> <li>Contributors extending VenomQA</li> <li>Users building custom adapters/reporters</li> <li>Anyone understanding the \"why\" behind design decisions</li> </ul> <ul> <li> <p> Framework Spec</p> <p>Core abstractions, extension points, and the plugin architecture.</p> <p> Read</p> </li> <li> <p> State Chain</p> <p>Checkpoint/rollback semantics, state hashing, and transaction isolation.</p> <p> Read</p> </li> <li> <p> State Explorer</p> <p>Exploration algorithms (BFS, DFS, CoverageGuided), guarantees, and tradeoffs.</p> <p> Read</p> </li> <li> <p> Publishing</p> <p>Release process, versioning strategy, and changelog management.</p> <p> Read</p> </li> </ul>"},{"location":"specs/#versioning","title":"Versioning","text":"<p>VenomQA follows Semantic Versioning:</p> <ul> <li>MAJOR: Breaking API changes</li> <li>MINOR: New features, backward compatible</li> <li>PATCH: Bug fixes, backward compatible</li> </ul>"},{"location":"specs/#stability-guarantees","title":"Stability Guarantees","text":"Component Stability <code>venomqa.Action</code> Stable <code>venomqa.Invariant</code> Stable <code>venomqa.Agent</code> Stable <code>venomqa.World</code> Stable <code>venomqa.adapters.http</code> Stable <code>venomqa.adapters.postgres</code> Stable <code>venomqa.adapters.*</code> Experimental <code>venomqa.reporters.*</code> Experimental"},{"location":"specs/framework-spec/","title":"Framework Specification","text":"<p>Technical specification of VenomQA's architecture, core abstractions, and extension points.</p>"},{"location":"specs/framework-spec/#overview","title":"Overview","text":"<p>VenomQA is a state exploration framework for testing APIs through sequences of operations. It uses database rollback to enable exhaustive exploration of state graphs.</p>"},{"location":"specs/framework-spec/#core-abstractions","title":"Core Abstractions","text":""},{"location":"specs/framework-spec/#action","title":"Action","text":"<p>An <code>Action</code> represents a single API operation.</p> Python<pre><code>@dataclass\nclass Action:\n    name: str                              # Unique identifier\n    execute: Callable[[Any, Context], Any] # (api, context) -&gt; response\n    preconditions: list[str] | None        # Required prior actions\n    max_calls: int | None                  # Max calls per state\n    requires: dict[str, str] | None        # Resource requirements\n\n    def __call__(self, api, context) -&gt; ActionResult:\n        \"\"\"Execute the action and return result.\"\"\"\n        ...\n\n    def can_execute(self, state: State) -&gt; bool:\n        \"\"\"Check if action is valid in this state.\"\"\"\n        ...\n</code></pre> <p>Semantics:</p> <ul> <li><code>execute</code> receives the API client and shared context</li> <li>Returns <code>None</code> to skip execution (precondition not met)</li> <li><code>preconditions</code> are action names that must have been executed</li> <li><code>max_calls</code> limits repetitions to prevent infinite loops</li> </ul>"},{"location":"specs/framework-spec/#invariant","title":"Invariant","text":"<p>An <code>Invariant</code> is a property that must always hold.</p> Python<pre><code>@dataclass\nclass Invariant:\n    name: str                              # Unique identifier\n    check: Callable[[World], bool | str]   # (world) -&gt; passed | error_message\n    severity: Severity                     # CRITICAL, HIGH, MEDIUM, LOW\n    timing: InvariantTiming                # PRE_ACTION, POST_ACTION, BOTH\n\n    def __call__(self, world: World) -&gt; bool | str:\n        \"\"\"Check the invariant. Return True, False, or error message.\"\"\"\n        ...\n</code></pre> <p>Severities:</p> Level Meaning CRITICAL System-breaking bugs, security issues HIGH Data corruption, business logic failures MEDIUM Minor inconsistencies, edge cases LOW Style issues, performance problems <p>Timings:</p> Timing When Checked PRE_ACTION Before action execution POST_ACTION After action + state observation BOTH Both times"},{"location":"specs/framework-spec/#world","title":"World","text":"<p>The <code>World</code> is the sandbox containing all state and systems.</p> Python<pre><code>@dataclass\nclass World:\n    api: HttpClient                        # HTTP client\n    context: Context                       # Key-value store\n    systems: dict[str, Rollbackable]       # External systems\n    resources: ResourceGraph | None        # Resource dependencies\n\n    def checkpoint(self, name: str) -&gt; Checkpoint:\n        \"\"\"Save state of all systems.\"\"\"\n        ...\n\n    def rollback(self, checkpoint: Checkpoint) -&gt; None:\n        \"\"\"Restore all systems to checkpoint state.\"\"\"\n        ...\n\n    def observe(self) -&gt; Observation:\n        \"\"\"Observe current state of all systems.\"\"\"\n        ...\n\n    def act(self, action: Action) -&gt; ActionResult:\n        \"\"\"Execute an action and observe new state.\"\"\"\n        ...\n</code></pre> <p>Construction:</p> Python<pre><code># With database adapter\nworld = World(\n    api=HttpClient(\"http://localhost:8000\"),\n    systems={\"db\": PostgresAdapter(\"postgresql://...\")},\n)\n\n# Without database (context-only state)\nworld = World(\n    api=HttpClient(\"http://localhost:8000\"),\n    state_from_context=[\"user_id\", \"order_id\"],\n)\n</code></pre>"},{"location":"specs/framework-spec/#context","title":"Context","text":"<p>The <code>Context</code> is a key-value store for passing data between actions.</p> Python<pre><code>class Context:\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Get value by key.\"\"\"\n        ...\n\n    def set(self, key: str, value: Any) -&gt; None:\n        \"\"\"Set a value.\"\"\"\n        ...\n\n    def delete(self, key: str) -&gt; None:\n        \"\"\"Delete a key.\"\"\"\n        ...\n\n    def has(self, key: str) -&gt; bool:\n        \"\"\"Check if key exists.\"\"\"\n        ...\n\n    def keys(self) -&gt; list[str]:\n        \"\"\"Get all keys.\"\"\"\n        ...\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Export as dictionary.\"\"\"\n        ...\n</code></pre> <p>Checkpoint behavior: Context is automatically checkpointed and rolled back with the World.</p>"},{"location":"specs/framework-spec/#state","title":"State","text":"<p>A <code>State</code> represents a unique point in the exploration graph.</p> Python<pre><code>@dataclass\nclass State:\n    id: str                           # Hash of observations\n    observations: list[Observation]   # System states\n    checkpoint_id: str | None         # For rollback\n    created_at: datetime              # When discovered\n</code></pre> <p>State identity: Two states are considered identical if their observations hash to the same value.</p>"},{"location":"specs/framework-spec/#observation","title":"Observation","text":"<p>An <code>Observation</code> captures a system's state at a point in time.</p> Python<pre><code>@dataclass\nclass Observation:\n    system: str              # System identifier\n    data: dict[str, Any]     # State data (counts, flags, etc.)\n    metadata: dict           # Non-hashed metadata\n</code></pre> <p>Hashing: Only <code>system</code> and <code>data</code> participate in state hashing. <code>metadata</code> is for debugging.</p>"},{"location":"specs/framework-spec/#graph","title":"Graph","text":"<p>The <code>Graph</code> stores the exploration state space.</p> Python<pre><code>class Graph:\n    states: dict[str, State]\n    transitions: list[Transition]\n    actions: dict[str, Action]\n    initial_state_id: str | None\n\n    def add_state(self, state: State) -&gt; State:\n        \"\"\"Add state, return canonical (may be deduplicated).\"\"\"\n        ...\n\n    def add_transition(self, transition: Transition) -&gt; None:\n        \"\"\"Record a state transition.\"\"\"\n        ...\n\n    def get_valid_actions(self, state: State) -&gt; list[Action]:\n        \"\"\"Get actions valid from this state.\"\"\"\n        ...\n\n    def get_unexplored(self) -&gt; list[tuple[State, Action]]:\n        \"\"\"Get unexplored (state, action) pairs.\"\"\"\n        ...\n\n    def is_explored(self, state_id: str, action_name: str) -&gt; bool:\n        \"\"\"Check if a pair has been explored.\"\"\"\n        ...\n</code></pre>"},{"location":"specs/framework-spec/#transition","title":"Transition","text":"<p>A <code>Transition</code> records moving from one state to another via an action.</p> Python<pre><code>@dataclass\nclass Transition:\n    from_state_id: str\n    action_name: str\n    to_state_id: str\n    result: ActionResult\n    timestamp: datetime\n</code></pre>"},{"location":"specs/framework-spec/#agent","title":"Agent","text":"<p>The <code>Agent</code> orchestrates exploration.</p> Python<pre><code>class Agent:\n    world: World\n    graph: Graph\n    strategy: Strategy\n    invariants: list[Invariant]\n    max_steps: int\n\n    def explore(self) -&gt; ExplorationResult:\n        \"\"\"Run exploration and return results.\"\"\"\n        ...\n</code></pre>"},{"location":"specs/framework-spec/#extension-points","title":"Extension Points","text":""},{"location":"specs/framework-spec/#custom-strategies","title":"Custom Strategies","text":"<p>Implement the <code>ExplorationStrategy</code> protocol:</p> Python<pre><code>class ExplorationStrategy(Protocol):\n    def pick(self, graph: Graph) -&gt; tuple[State, Action] | None:\n        \"\"\"Pick next (state, action) to explore, or None if done.\"\"\"\n        ...\n\n    def notify(self, state: State, actions: list[Action]) -&gt; None:\n        \"\"\"Called when new state is discovered.\"\"\"\n        ...\n</code></pre>"},{"location":"specs/framework-spec/#custom-system-adapters","title":"Custom System Adapters","text":"<p>Implement the <code>Rollbackable</code> protocol:</p> Python<pre><code>class Rollbackable(Protocol):\n    def checkpoint(self, name: str) -&gt; SystemCheckpoint:\n        \"\"\"Save current state.\"\"\"\n        ...\n\n    def rollback(self, checkpoint: SystemCheckpoint) -&gt; None:\n        \"\"\"Restore to checkpoint.\"\"\"\n        ...\n\n    def observe(self) -&gt; Observation:\n        \"\"\"Get current state for hashing.\"\"\"\n        ...\n</code></pre>"},{"location":"specs/framework-spec/#custom-reporters","title":"Custom Reporters","text":"<p>Implement a callable that accepts <code>ExplorationResult</code>:</p> Python<pre><code>def my_reporter(result: ExplorationResult) -&gt; str:\n    return f\"Found {len(result.violations)} violations\"\n</code></pre>"},{"location":"specs/framework-spec/#exploration-algorithm","title":"Exploration Algorithm","text":"Text Only<pre><code>1. Initialize\n   - Run user setup hook\n   - Observe initial state with checkpoint\n\n2. While unexplored pairs exist and max_steps not reached:\n   a. Pick (state, action) via strategy\n   b. Rollback to state\n   c. Check PRE_ACTION invariants\n   d. Execute action\n   e. Observe new state with checkpoint\n   f. Record transition\n   g. Check POST_ACTION invariants\n   h. Notify strategy of new state\n\n3. Return results\n   - All violations found\n   - Graph of explored states\n   - Coverage statistics\n</code></pre>"},{"location":"specs/framework-spec/#state-hashing","title":"State Hashing","text":"<p>States are hashed based on observations:</p> Python<pre><code>def hash_state(observations: list[Observation]) -&gt; str:\n    \"\"\"Generate deterministic hash for state identity.\"\"\"\n    data = sorted(\n        (obs.system, json.dumps(obs.data, sort_keys=True))\n        for obs in observations\n    )\n    return hashlib.sha256(json.dumps(data).encode()).hexdigest()[:16]\n</code></pre> <p>Implications:</p> <ul> <li>Identical observations = identical state ID</li> <li>State deduplication happens automatically</li> <li>Order of observations doesn't matter</li> </ul>"},{"location":"specs/framework-spec/#checkpointrollback-semantics","title":"Checkpoint/Rollback Semantics","text":""},{"location":"specs/framework-spec/#postgresql","title":"PostgreSQL","text":"SQL<pre><code>-- Checkpoint\nSAVEPOINT venom_checkpoint_N;\n\n-- Rollback\nROLLBACK TO SAVEPOINT venom_checkpoint_N;\n</code></pre> <p>Constraints:</p> <ul> <li>SAVEPOINTs are stack-based (LIFO)</li> <li>Rolling back to an earlier savepoint destroys later savepoints</li> <li>Must use DFS strategy with PostgresAdapter</li> </ul>"},{"location":"specs/framework-spec/#sqlite","title":"SQLite","text":"Python<pre><code># Checkpoint\nsnapshot = shutil.copy(db_path, temp_path)\n\n# Rollback  \nshutil.copy(temp_path, db_path)\n</code></pre>"},{"location":"specs/framework-spec/#in-memory","title":"In-Memory","text":"Python<pre><code># Checkpoint\nsnapshot = copy.deepcopy(self._state)\n\n# Rollback\nself._state = snapshot\n</code></pre>"},{"location":"specs/framework-spec/#thread-safety","title":"Thread Safety","text":"<p>VenomQA is not thread-safe by default.</p> <ul> <li>Single-threaded exploration is guaranteed safe</li> <li>Parallel exploration requires separate <code>World</code> instances</li> <li>Database connections should not be shared between agents</li> </ul>"},{"location":"specs/framework-spec/#memory-model","title":"Memory Model","text":"Component Lifetime Memory World Per exploration ~10-100MB Context Per exploration ~1-10MB Graph Per exploration ~10-500MB State Collected at end ~1KB each Transition Collected at end ~100 bytes each"},{"location":"specs/framework-spec/#error-handling","title":"Error Handling","text":""},{"location":"specs/framework-spec/#action-errors","title":"Action Errors","text":"Python<pre><code>try:\n    result = action(api, context)\nexcept Exception as e:\n    result = ActionResult(error=e)\n</code></pre> <p>Actions that raise exceptions are recorded as failed transitions.</p>"},{"location":"specs/framework-spec/#invariant-errors","title":"Invariant Errors","text":"Python<pre><code>try:\n    passed = invariant(world)\n    if not passed:\n        record_violation(invariant)\nexcept Exception as e:\n    # Invariant itself failed - treat as violation\n    record_violation(invariant, error=e)\n</code></pre>"},{"location":"specs/framework-spec/#system-errors","title":"System Errors","text":"Python<pre><code>try:\n    checkpoint = system.checkpoint(name)\nexcept Exception:\n    # Can't checkpoint - exploration may be incomplete\n    log_warning(\"Checkpoint failed, state rollback unavailable\")\n</code></pre>"},{"location":"specs/framework-spec/#configuration","title":"Configuration","text":""},{"location":"specs/framework-spec/#environment-variables","title":"Environment Variables","text":"Variable Description <code>VENOMQA_API_KEY</code> X-API-Key header <code>VENOMQA_AUTH_TOKEN</code> Bearer token <code>VENOMQA_LOG_LEVEL</code> Logging level (DEBUG, INFO, WARNING)"},{"location":"specs/framework-spec/#cli-options","title":"CLI Options","text":"Bash<pre><code>venomqa explore \\\n    --strategy dfs \\\n    --max-steps 500 \\\n    --coverage-target 0.8 \\\n    --output results.json \\\n    --format json\n</code></pre>"},{"location":"specs/framework-spec/#version-compatibility","title":"Version Compatibility","text":"Version Python Key Changes 0.6.x 3.10+ Current stable 0.5.x 3.9+ Added MCTS strategy 0.4.x 3.9+ Added SQLite adapter 0.3.x 3.8+ Initial release"},{"location":"specs/framework-spec/#deprecation-policy","title":"Deprecation Policy","text":"<ul> <li>Features deprecated for 2 minor versions before removal</li> <li>Deprecation warnings via Python <code>warnings</code> module</li> <li>Breaking changes only in major versions</li> </ul>"},{"location":"specs/publishing/","title":"Publishing Guide","text":"<p>Guide for maintainers on publishing to PyPI, versioning, and changelog management.</p>"},{"location":"specs/publishing/#overview","title":"Overview","text":"<p>This document covers the release process for VenomQA maintainers.</p>"},{"location":"specs/publishing/#versioning","title":"Versioning","text":"<p>VenomQA follows Semantic Versioning:</p> <ul> <li>MAJOR: Breaking API changes</li> <li>MINOR: New features, backward compatible</li> <li>PATCH: Bug fixes, backward compatible</li> </ul>"},{"location":"specs/publishing/#version-locations","title":"Version Locations","text":"<p>Update version in these files:</p> <ol> <li> <p><code>pyproject.toml</code>: TOML<pre><code>[project]\nversion = \"0.6.4\"\n</code></pre></p> </li> <li> <p><code>src/venomqa/__init__.py</code>: Python<pre><code>__version__ = \"0.6.4\"\n</code></pre></p> </li> </ol>"},{"location":"specs/publishing/#pre-release-versions","title":"Pre-release Versions","text":"<p>For testing before official release:</p> Bash<pre><code># Alpha\n0.7.0a1\n\n# Beta  \n0.7.0b1\n\n# Release candidate\n0.7.0rc1\n</code></pre>"},{"location":"specs/publishing/#changelog","title":"Changelog","text":"<p>Maintain a <code>CHANGELOG.md</code> following Keep a Changelog:</p> Markdown<pre><code># Changelog\n\nAll notable changes to this project will be documented in this file.\n\n## [0.7.0] - 2024-01-15\n\n### Added\n- MCTS exploration strategy for bug-focused exploration\n- MongoDB adapter with checkpoint/rollback support\n- Elasticsearch adapter for search indices\n\n### Changed\n- Improved state hashing performance by 40%\n- DFS is now the default strategy\n\n### Fixed\n- PostgreSQL savepoint cleanup on early termination\n- Context checkpoint memory leak\n\n### Deprecated\n- `Agent.run()` method (use `Agent.explore()`)\n- Old-style reporter interface (use callable)\n\n## [0.6.4] - 2024-01-01\n...\n</code></pre>"},{"location":"specs/publishing/#changelog-categories","title":"Changelog Categories","text":"Category Description Added New features Changed Changes to existing features Deprecated Features to be removed Removed Features removed this release Fixed Bug fixes Security Security improvements"},{"location":"specs/publishing/#release-process","title":"Release Process","text":""},{"location":"specs/publishing/#1-prepare-release","title":"1. Prepare Release","text":"Bash<pre><code># Ensure you're on main\ngit checkout main\ngit pull origin main\n\n# Run full test suite\npytest tests/ --ignore=tests/v1/test_postgres.py\n\n# Run linting\nruff check src/ tests/\nmypy src/\n\n# Build docs\nmkdocs build\n</code></pre>"},{"location":"specs/publishing/#2-update-version-and-changelog","title":"2. Update Version and Changelog","text":"Bash<pre><code># Update version in pyproject.toml and __init__.py\n# Update CHANGELOG.md with release date\n# Commit changes\n\ngit add pyproject.toml src/venomqa/__init__.py CHANGELOG.md\ngit commit -m \"chore: release v0.7.0\"\n</code></pre>"},{"location":"specs/publishing/#3-create-tag","title":"3. Create Tag","text":"Bash<pre><code>git tag -a v0.7.0 -m \"Release v0.7.0\"\ngit push origin main\ngit push origin v0.7.0\n</code></pre>"},{"location":"specs/publishing/#4-build-package","title":"4. Build Package","text":"Bash<pre><code># Install build tools\npip install build twine\n\n# Clean previous builds\nrm -rf dist/ build/ *.egg-info\n\n# Build source distribution and wheel\npython -m build\n</code></pre>"},{"location":"specs/publishing/#5-verify-package","title":"5. Verify Package","text":"Bash<pre><code># Check package metadata\ntwine check dist/*\n\n# Expected output:\n# Checking dist/venomqa-0.7.0-py3-none-any.whl: PASSED\n# Checking dist/venomqa-0.7.0.tar.gz: PASSED\n</code></pre>"},{"location":"specs/publishing/#6-upload-to-testpypi-optional","title":"6. Upload to TestPyPI (Optional)","text":"Bash<pre><code># Upload to TestPyPI first\ntwine upload --repository testpypi dist/*\n\n# Verify installation\npip install --index-url https://test.pypi.org/simple/ venomqa==0.7.0\n</code></pre>"},{"location":"specs/publishing/#7-upload-to-pypi","title":"7. Upload to PyPI","text":"Bash<pre><code># Upload to production PyPI\ntwine upload dist/*\n</code></pre>"},{"location":"specs/publishing/#8-verify-release","title":"8. Verify Release","text":"Bash<pre><code># Wait a few minutes for PyPI to index\npip install venomqa==0.7.0\n\n# Verify version\npython -c \"import venomqa; print(venomqa.__version__)\"\n</code></pre>"},{"location":"specs/publishing/#9-create-github-release","title":"9. Create GitHub Release","text":"<ol> <li>Go to https://github.com/namanag97/venomqa/releases/new</li> <li>Select the tag</li> <li>Title: <code>v0.7.0</code></li> <li>Description: Copy from CHANGELOG.md</li> <li>Attach built wheel and source distribution</li> </ol>"},{"location":"specs/publishing/#automated-releases-github-actions","title":"Automated Releases (GitHub Actions)","text":""},{"location":"specs/publishing/#workflow-configuration","title":"Workflow Configuration","text":"<p><code>.github/workflows/release.yml</code>:</p> YAML<pre><code>name: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build-and-publish:\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write  # For trusted publishing\n      contents: write\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n\n      - name: Install build tools\n        run: |\n          pip install build twine\n\n      - name: Build package\n        run: python -m build\n\n      - name: Check package\n        run: twine check dist/*\n\n      - name: Publish to PyPI\n        uses: pypa/gh-action-pypi-publish@release/v1\n        # Uses trusted publishing, no token needed\n\n      - name: Create GitHub Release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: dist/*\n          body_path: RELEASE_NOTES.md\n</code></pre>"},{"location":"specs/publishing/#trusted-publishing-setup","title":"Trusted Publishing Setup","text":"<ol> <li>Go to PyPI \u2192 Publishing</li> <li>Add GitHub repository as trusted publisher</li> <li>Configure workflow name: <code>release.yml</code></li> <li>No API token needed!</li> </ol>"},{"location":"specs/publishing/#branching-strategy","title":"Branching Strategy","text":"Text Only<pre><code>main\n  \u2502\n  \u251c\u2500\u2500 develop\n  \u2502     \u2502\n  \u2502     \u251c\u2500\u2500 feature/mcts-strategy\n  \u2502     \u251c\u2500\u2500 feature/mongodb-adapter\n  \u2502     \u2514\u2500\u2500 fix/postgres-cleanup\n  \u2502\n  \u2514\u2500\u2500 release/0.7.0\n</code></pre>"},{"location":"specs/publishing/#branch-types","title":"Branch Types","text":"Branch Purpose Merge To <code>main</code> Production releases - <code>develop</code> Integration branch <code>main</code> <code>feature/*</code> New features <code>develop</code> <code>fix/*</code> Bug fixes <code>develop</code> <code>release/*</code> Release preparation <code>main</code>, <code>develop</code> <code>hotfix/*</code> Production hotfixes <code>main</code>, <code>develop</code>"},{"location":"specs/publishing/#hotfix-process","title":"Hotfix Process","text":"<p>For critical production bugs:</p> Bash<pre><code># Create hotfix branch from main\ngit checkout main\ngit checkout -b hotfix/critical-bug\n\n# Fix the bug\n# Update version (e.g., 0.7.1)\n# Update CHANGELOG.md\n\n# Test\npytest\n\n# Commit and tag\ngit commit -m \"fix: critical bug in state hashing\"\ngit tag v0.7.1\n\n# Merge to main and develop\ngit checkout main\ngit merge hotfix/critical-bug\ngit checkout develop\ngit merge hotfix/critical-bug\n\n# Push and release\ngit push origin main develop v0.7.1\n</code></pre>"},{"location":"specs/publishing/#deprecation-policy","title":"Deprecation Policy","text":""},{"location":"specs/publishing/#deprecation-process","title":"Deprecation Process","text":"<ol> <li>Announce: Add deprecation warning in code</li> <li>Document: Update docs with migration guide</li> <li>Wait: 2 minor versions (e.g., 0.7.x \u2192 0.9.x)</li> <li>Remove: Delete in next major version</li> </ol>"},{"location":"specs/publishing/#adding-deprecation","title":"Adding Deprecation","text":"Python<pre><code>import warnings\n\ndef old_function():\n    warnings.warn(\n        \"old_function is deprecated. Use new_function instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return new_function()\n</code></pre>"},{"location":"specs/publishing/#deprecation-timeline","title":"Deprecation Timeline","text":"Version Status 0.7.0 Deprecated with warning 0.8.0 Still works with warning 0.9.0 Still works with warning 1.0.0 Removed"},{"location":"specs/publishing/#security-releases","title":"Security Releases","text":"<p>For security vulnerabilities:</p> <ol> <li>Do not publish details until fix is released</li> <li>Email security@venomqa.dev with details</li> <li>Create private fix branch</li> <li>Coordinate release with security advisory</li> <li>Publish to PyPI immediately after GitHub advisory</li> </ol>"},{"location":"specs/publishing/#rollback-process","title":"Rollback Process","text":"<p>If a release has critical issues:</p> Bash<pre><code># Yank the bad release from PyPI\ntwine upload --repository pypi dist/venomqa-0.7.0.tar.gz --skip-existing\n\n# Or use PyPI web interface to yank\n\n# Create and release fix\n# Version becomes 0.7.1\n</code></pre>"},{"location":"specs/publishing/#checklist","title":"Checklist","text":""},{"location":"specs/publishing/#pre-release","title":"Pre-release","text":"<ul> <li> All tests pass</li> <li> Linting passes</li> <li> Type checking passes</li> <li> Docs build successfully</li> <li> Version updated in all locations</li> <li> CHANGELOG.md updated</li> <li> Release notes prepared</li> </ul>"},{"location":"specs/publishing/#release","title":"Release","text":"<ul> <li> Tag created</li> <li> Package built</li> <li> Package verified</li> <li> Uploaded to PyPI</li> <li> GitHub release created</li> <li> Installation verified</li> </ul>"},{"location":"specs/publishing/#post-release","title":"Post-release","text":"<ul> <li> Announcement posted (Discord, Twitter)</li> <li> Docs updated with new version</li> <li> Close resolved issues</li> <li> Update milestone</li> </ul>"},{"location":"specs/publishing/#pypi-configuration","title":"PyPI Configuration","text":""},{"location":"specs/publishing/#api-token-legacy","title":"API Token (Legacy)","text":"Bash<pre><code># Create token at https://pypi.org/manage/account/token/\n# Add to ~/.pypirc:\n\n[pypi]\n  username = __token__\n  password = pypi-...\n</code></pre>"},{"location":"specs/publishing/#trusted-publishing-recommended","title":"Trusted Publishing (Recommended)","text":"<p>Configure in PyPI \u2192 Publishing \u2192 Add GitHub: - Repository: namanag97/venomqa - Workflow: release.yml - Environment: (leave empty)</p>"},{"location":"specs/publishing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"specs/publishing/#file-already-exists","title":"\"File already exists\"","text":"<p>The version was already uploaded. Bump version.</p>"},{"location":"specs/publishing/#invalid-classifier","title":"\"Invalid classifier\"","text":"<p>Check classifier syntax in <code>pyproject.toml</code>: TOML<pre><code>classifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    ...\n]\n</code></pre></p>"},{"location":"specs/publishing/#upload-failed-400","title":"\"Upload failed: 400\"","text":"<p>Check: - Version not already exists - Metadata is valid - No duplicate files in dist/</p>"},{"location":"specs/publishing/#twine-ssl-errors","title":"Twine SSL errors","text":"Bash<pre><code># Upgrade certifi\npip install --upgrade certifi twine\n</code></pre>"},{"location":"specs/state-chain/","title":"State Chain Specification","text":"<p>Specification of how state chains work, including checkpoint/rollback semantics.</p>"},{"location":"specs/state-chain/#overview","title":"Overview","text":"<p>State chains are the core mechanism enabling VenomQA's exhaustive exploration. This document specifies how checkpoints are created, managed, and rolled back during exploration.</p>"},{"location":"specs/state-chain/#definitions","title":"Definitions","text":""},{"location":"specs/state-chain/#state-chain","title":"State Chain","text":"<p>A state chain is a sequence of states connected by transitions:</p> Text Only<pre><code>S0 \u2192[a1]\u2192 S1 \u2192[a2]\u2192 S2 \u2192[a3]\u2192 S3\n</code></pre> <p>Each state has a unique ID derived from its observations, and each transition records the action that caused the state change.</p>"},{"location":"specs/state-chain/#checkpoint","title":"Checkpoint","text":"<p>A checkpoint is a snapshot of all system states at a point in time, enabling rollback to that exact state.</p> Python<pre><code>@dataclass\nclass Checkpoint:\n    id: str                          # Unique identifier\n    system_checkpoints: dict[str, Any]  # Per-system checkpoint data\n    context_snapshot: dict[str, Any]    # Context key-values\n    created_at: datetime\n</code></pre>"},{"location":"specs/state-chain/#rollback","title":"Rollback","text":"<p>A rollback restores all systems to a previous checkpoint's state.</p>"},{"location":"specs/state-chain/#checkpoint-lifecycle","title":"Checkpoint Lifecycle","text":""},{"location":"specs/state-chain/#creation","title":"Creation","text":"<p>Checkpoints are created automatically by the Agent:</p> Python<pre><code># In Agent._step()\ncheckpoint_name = f\"after_{action.name}_{step_count}\"\nto_state = world.observe_and_checkpoint(checkpoint_name)\n</code></pre> <p>The naming convention is:</p> <ul> <li>Initial: <code>\"initial\"</code></li> <li>After action: <code>\"after_{action_name}_{step_number}\"</code></li> </ul>"},{"location":"specs/state-chain/#storage","title":"Storage","text":"<p>Checkpoints are stored in-memory by the World:</p> Python<pre><code>class World:\n    _checkpoints: dict[str, Checkpoint]\n\n    def checkpoint(self, name: str) -&gt; str:\n        system_checkpoints = {}\n        for system_name, system in self.systems.items():\n            system_checkpoints[system_name] = system.checkpoint(name)\n\n        checkpoint = Checkpoint(\n            id=name,\n            system_checkpoints=system_checkpoints,\n            context_snapshot=self.context.to_dict(),\n        )\n        self._checkpoints[name] = checkpoint\n        return name\n</code></pre>"},{"location":"specs/state-chain/#cleanup","title":"Cleanup","text":"<p>Checkpoints are kept for the entire exploration. After exploration completes, all checkpoints are discarded.</p>"},{"location":"specs/state-chain/#rollback-semantics","title":"Rollback Semantics","text":""},{"location":"specs/state-chain/#basic-rollback","title":"Basic Rollback","text":"Python<pre><code>def rollback(self, checkpoint_id: str) -&gt; None:\n    checkpoint = self._checkpoints[checkpoint_id]\n\n    # Restore each system\n    for system_name, system_checkpoint in checkpoint.system_checkpoints.items():\n        self.systems[system_name].rollback(system_checkpoint)\n\n    # Restore context\n    self.context.clear()\n    for key, value in checkpoint.context_snapshot.items():\n        self.context.set(key, value)\n</code></pre>"},{"location":"specs/state-chain/#multi-system-rollback","title":"Multi-System Rollback","text":"<p>When multiple systems are registered, rollback happens atomically:</p> Python<pre><code>world = World(\n    api=api,\n    systems={\n        \"db\": PostgresAdapter(...),\n        \"cache\": RedisAdapter(...),\n        \"queue\": MockQueue(),\n    },\n)\n\n# All systems checkpoint together\ncheckpoint = world.checkpoint(\"point_a\")\n\n# All systems rollback together\nworld.rollback(checkpoint)\n</code></pre> <p>Failure handling: If any system fails to rollback, the operation fails. Some systems may be partially rolled back.</p>"},{"location":"specs/state-chain/#nested-checkpoints","title":"Nested Checkpoints","text":"<p>Checkpoints can be nested (checkpoint, then checkpoint again):</p> Text Only<pre><code>S0 \u2192 S1 (cp1) \u2192 S2 (cp2) \u2192 S3 (cp3)\n</code></pre> <p>Rollback to cp2 restores state S2, but cp3 is still valid:</p> Text Only<pre><code>S0 \u2192 S1 (cp1) \u2192 S2 (cp2) \u2192 S4 (new)\n                      \u2191\n                   rollback\n</code></pre> <p>PostgreSQL limitation</p> <p>PostgreSQL SAVEPOINTs are destroyed when you ROLLBACK TO an earlier savepoint. After rolling back from S3 to S2, checkpoint cp3 is invalid.</p>"},{"location":"specs/state-chain/#state-identity","title":"State Identity","text":""},{"location":"specs/state-chain/#hash-calculation","title":"Hash Calculation","text":"<p>State identity is determined by hashing observations:</p> Python<pre><code>def calculate_state_id(observations: list[Observation]) -&gt; str:\n    \"\"\"Calculate deterministic state ID from observations.\"\"\"\n    components = []\n    for obs in sorted(observations, key=lambda o: o.system):\n        # Only hash system + data, not metadata\n        components.append(f\"{obs.system}:{json.dumps(obs.data, sort_keys=True)}\")\n\n    combined = \"|\".join(components)\n    return hashlib.sha256(combined.encode()).hexdigest()[:16]\n</code></pre>"},{"location":"specs/state-chain/#deduplication","title":"Deduplication","text":"<p>When a new state has the same ID as an existing state:</p> Python<pre><code>def add_state(self, new_state: State) -&gt; State:\n    existing = self.states.get(new_state.id)\n    if existing:\n        # Return existing state, discard new\n        return existing\n    self.states[new_state.id] = new_state\n    return new_state\n</code></pre> <p>Implication: The same logical state reached via different paths shares the same State object.</p>"},{"location":"specs/state-chain/#context-checkpoint-behavior","title":"Context Checkpoint Behavior","text":""},{"location":"specs/state-chain/#whats-checkpointed","title":"What's Checkpointed","text":"<p>All context keys and values are checkpointed:</p> Python<pre><code>context_snapshot = {\n    \"user_id\": \"abc123\",\n    \"order_id\": \"xyz789\",\n    \"logged_in\": True,\n}\n</code></pre>"},{"location":"specs/state-chain/#whats-not-checkpointed","title":"What's Not Checkpointed","text":"<ul> <li>References to external objects</li> <li>File handles</li> <li>Database connections</li> </ul>"},{"location":"specs/state-chain/#rollback_1","title":"Rollback","text":"<p>Context is fully replaced on rollback:</p> Python<pre><code># Before rollback\ncontext.set(\"new_key\", \"value\")  # Added after checkpoint\n\n# After rollback\ncontext.get(\"new_key\")  # None - key doesn't exist\n</code></pre>"},{"location":"specs/state-chain/#database-specific-semantics","title":"Database-Specific Semantics","text":""},{"location":"specs/state-chain/#postgresql","title":"PostgreSQL","text":"SQL<pre><code>-- Checkpoint\nSAVEPOINT venom_initial;\n\n-- Later checkpoint  \nSAVEPOINT venom_after_create_order_1;\n\n-- Rollback to initial\nROLLBACK TO SAVEPOINT venom_initial;\n-- Note: venom_after_create_order_1 is now destroyed!\n</code></pre> <p>Constraint: Only DFS strategy works with PostgresAdapter because DFS only rolls back to the most recent checkpoint.</p>"},{"location":"specs/state-chain/#sqlite","title":"SQLite","text":"Python<pre><code># Checkpoint\ntemp_path = f\"{db_path}.checkpoint_{name}\"\nshutil.copy2(db_path, temp_path)\n\n# Rollback\nshutil.copy2(temp_path, db_path)\nos.remove(temp_path)\n</code></pre> <p>No ordering constraint: Any checkpoint can be restored at any time.</p>"},{"location":"specs/state-chain/#redis","title":"Redis","text":"Python<pre><code># Checkpoint\nsnapshot = {}\nfor key in scan_all_keys():\n    snapshot[key] = client.dump(key)\n    snapshot[f\"__ttl__{key}\"] = client.ttl(key)\n\n# Rollback\nclient.flushall()\nfor key, dump in snapshot.items():\n    if not key.startswith(\"__ttl__\"):\n        ttl = snapshot.get(f\"__ttl__{key}\", 0)\n        client.restore(key, ttl, dump, replace=True)\n</code></pre>"},{"location":"specs/state-chain/#replay-semantics","title":"Replay Semantics","text":"<p>When a state has no valid checkpoint (e.g., after crash), VenomQA can replay actions:</p> Python<pre><code>def replay_to_state(self, target_state: State) -&gt; None:\n    \"\"\"Replay actions to reach target state.\"\"\"\n    path = graph.get_path_to(target_state.id)\n\n    # Find last valid checkpoint in path\n    for i, transition in enumerate(path):\n        state = graph.get_state(transition.to_state_id)\n        if state.checkpoint_id:\n            last_checkpoint = state.checkpoint_id\n            replay_from = i + 1\n\n    # Rollback to last checkpoint\n    self.world.rollback(last_checkpoint)\n\n    # Replay remaining actions\n    for transition in path[replay_from:]:\n        action = graph.get_action(transition.action_name)\n        self.world.act(action)\n</code></pre>"},{"location":"specs/state-chain/#invariants-during-rollback","title":"Invariants During Rollback","text":"<p>Invariants are not checked during rollback operations. They're only checked after action execution.</p>"},{"location":"specs/state-chain/#performance-characteristics","title":"Performance Characteristics","text":"Operation PostgreSQL SQLite In-Memory Checkpoint ~1ms ~50ms ~0.1ms Rollback ~1ms ~50ms ~0.1ms Memory per checkpoint ~1KB Full DB copy ~State size"},{"location":"specs/state-chain/#error-scenarios","title":"Error Scenarios","text":""},{"location":"specs/state-chain/#checkpoint-failure","title":"Checkpoint Failure","text":"Python<pre><code>try:\n    world.checkpoint(\"point_a\")\nexcept CheckpointError as e:\n    # One or more systems failed to checkpoint\n    # Exploration can continue but rollback may fail\n    log.warning(f\"Checkpoint failed: {e}\")\n</code></pre>"},{"location":"specs/state-chain/#rollback-failure","title":"Rollback Failure","text":"Python<pre><code>try:\n    world.rollback(\"point_a\")\nexcept RollbackError as e:\n    # One or more systems failed to rollback\n    # State may be inconsistent - abort exploration\n    raise ExplorationAborted(\"Rollback failed\")\n</code></pre>"},{"location":"specs/state-chain/#invalid-checkpoint","title":"Invalid Checkpoint","text":"Python<pre><code>world.rollback(\"nonexistent_checkpoint\")\n# Raises: KeyError(\"Checkpoint not found: nonexistent_checkpoint\")\n</code></pre>"},{"location":"specs/state-chain/#guarantees","title":"Guarantees","text":"<ol> <li>Atomicity: Multi-system checkpoints are all-or-nothing</li> <li>Isolation: Each exploration has independent checkpoints</li> <li>Consistency: After rollback, all systems are at the checkpoint state</li> <li>Durability: N/A (checkpoints are in-memory only)</li> </ol>"},{"location":"specs/state-chain/#limitations","title":"Limitations","text":"<ol> <li>PostgreSQL ordering: Must use DFS strategy</li> <li>Memory usage: All checkpoints kept in memory</li> <li>External systems: Can't rollback external APIs</li> <li>File systems: Can't rollback file system changes (use MockStorage)</li> </ol>"},{"location":"specs/state-explorer/","title":"State Explorer Specification","text":"<p>Specification of the exploration algorithms (BFS, DFS, CoverageGuided, Random, MCTS), their guarantees and tradeoffs.</p>"},{"location":"specs/state-explorer/#overview","title":"Overview","text":"<p>The state explorer decides which (state, action) pairs to try next. Different strategies optimize for different goals: shortest bug reproduction, maximum coverage, or deep exploration.</p>"},{"location":"specs/state-explorer/#exploration-strategy-protocol","title":"Exploration Strategy Protocol","text":"<p>All strategies implement the <code>ExplorationStrategy</code> protocol:</p> Python<pre><code>class ExplorationStrategy(Protocol):\n    def pick(self, graph: Graph) -&gt; tuple[State, Action] | None:\n        \"\"\"Pick next (state, action) to explore.\n\n        Returns:\n            Tuple to explore, or None if exploration is complete.\n        \"\"\"\n        ...\n\n    def notify(self, state: State, actions: list[Action]) -&gt; None:\n        \"\"\"Notify strategy of a newly discovered state.\n\n        Args:\n            state: The newly discovered state.\n            actions: Actions valid from this state.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"specs/state-explorer/#built-in-strategies","title":"Built-in Strategies","text":""},{"location":"specs/state-explorer/#bfs-breadth-first-search","title":"BFS (Breadth-First Search)","text":"<p>Explores states in the order they were discovered.</p> Python<pre><code>class BFS:\n    \"\"\"Breadth-first exploration.\n\n    Guarantees shortest paths to each state.\n    Uses a queue-based frontier.\n    \"\"\"\n\n    def __init__(self):\n        self._frontier = QueueFrontier()  # FIFO queue\n</code></pre> <p>Characteristics:</p> Property Value Memory O(states \u00d7 actions) Path length Minimal to each state Best for Shortest bug reproduction PostgreSQL \u274c Incompatible <p>Algorithm:</p> Text Only<pre><code>1. Initialize queue with (initial_state, action) for all valid actions\n2. While queue not empty:\n   a. Dequeue (state, action)\n   b. If already explored, skip\n   c. Execute action, observe new state\n   d. Enqueue (new_state, action) for all valid actions\n3. Return when queue empty\n</code></pre> <p>Example trace:</p> Text Only<pre><code>Queue: [(S0, a1), (S0, a2)]\n\u2192 Execute (S0, a1) \u2192 S1\nQueue: [(S0, a2), (S1, a3), (S1, a4)]\n\u2192 Execute (S0, a2) \u2192 S2\nQueue: [(S1, a3), (S1, a4), (S2, a5)]\n</code></pre>"},{"location":"specs/state-explorer/#dfs-depth-first-search","title":"DFS (Depth-First Search)","text":"<p>Explores as deep as possible before backtracking.</p> Python<pre><code>class DFS:\n    \"\"\"Depth-first exploration.\n\n    Explores deeply before backtracking.\n    Uses less memory than BFS.\n    \"\"\"\n\n    def __init__(self):\n        self._frontier = StackFrontier()  # LIFO stack\n</code></pre> <p>Characteristics:</p> Property Value Memory O(depth \u00d7 actions) Path length May be long Best for PostgreSQL, deep bugs PostgreSQL \u2705 Compatible <p>Algorithm:</p> Text Only<pre><code>1. Initialize stack with (initial_state, action) for all valid actions\n2. While stack not empty:\n   a. Pop (state, action)\n   b. If already explored, skip\n   c. Execute action, observe new state\n   d. Push (new_state, action) for all valid actions\n3. Return when stack empty\n</code></pre> <p>Example trace:</p> Text Only<pre><code>Stack: [(S0, a1), (S0, a2)]\n\u2192 Execute (S0, a2) \u2192 S2  (LIFO: takes last added)\nStack: [(S0, a1), (S2, a5)]\n\u2192 Execute (S2, a5) \u2192 S3\nStack: [(S0, a1), (S3, a6)]\n</code></pre>"},{"location":"specs/state-explorer/#random","title":"Random","text":"<p>Picks randomly from unexplored pairs.</p> Python<pre><code>class Random:\n    \"\"\"Random exploration.\n\n    Picks uniformly from unexplored pairs.\n    Reproducible with seed.\n    \"\"\"\n\n    def __init__(self, seed: int | None = None):\n        self._rng = random.Random(seed)\n</code></pre> <p>Characteristics:</p> Property Value Memory O(1) for selection Path length Unpredictable Best for Fuzzing, surprise bugs PostgreSQL \u26a0\ufe0f Use with caution <p>Algorithm:</p> Text Only<pre><code>1. Get all unexplored (state, action) pairs\n2. Pick one uniformly at random\n3. Return None if no unexplored pairs remain\n</code></pre>"},{"location":"specs/state-explorer/#coverageguided","title":"CoverageGuided","text":"<p>Prioritizes least-explored actions.</p> Python<pre><code>class CoverageGuided:\n    \"\"\"Coverage-guided exploration.\n\n    Maximizes action diversity by prioritizing\n    actions that have been explored the fewest times.\n    \"\"\"\n\n    def __init__(self):\n        self._action_counts: Counter[str] = Counter()\n</code></pre> <p>Characteristics:</p> Property Value Memory O(actions) for counts Coverage Maximizes action diversity Best for Maximum coverage PostgreSQL \u274c Incompatible <p>Algorithm:</p> Text Only<pre><code>1. Get all unexplored (state, action) pairs\n2. Count how many times each action has been executed\n3. Sort pairs by action count (ascending)\n4. Return pair with least-executed action\n</code></pre> <p>Example:</p> Text Only<pre><code>Action counts: {a1: 5, a2: 3, a3: 1, a4: 8}\nUnexplored pairs: [(S1, a1), (S2, a2), (S3, a3)]\n\u2192 Sort by count: [(S3, a3), (S2, a2), (S1, a1)]\n\u2192 Return (S3, a3)  # a3 has count 1\n</code></pre>"},{"location":"specs/state-explorer/#weighted","title":"Weighted","text":"<p>Random selection with configurable weights.</p> Python<pre><code>class Weighted:\n    \"\"\"Weighted random exploration.\n\n    Actions with higher weights are more likely to be picked.\n    \"\"\"\n\n    def __init__(\n        self,\n        weights: dict[str, float] | None = None,\n        seed: int | None = None,\n    ):\n        self._weights = weights or {}\n        self._rng = random.Random(seed)\n</code></pre> <p>Characteristics:</p> Property Value Memory O(actions) for weights Control Manual priority Best for Focused testing PostgreSQL \u26a0\ufe0f Use with caution <p>Algorithm:</p> Text Only<pre><code>1. Get all unexplored (state, action) pairs\n2. For each pair, look up weight (default: 1.0)\n3. Weighted random selection\n4. Return selected pair\n</code></pre> <p>Example:</p> Python<pre><code>strategy = Weighted(weights={\n    \"login\": 1.0,\n    \"create_order\": 3.0,  # 3x more likely\n    \"refund\": 2.0,\n})\n</code></pre>"},{"location":"specs/state-explorer/#mcts-monte-carlo-tree-search","title":"MCTS (Monte Carlo Tree Search)","text":"<p>Uses UCB1 to balance exploration and exploitation.</p> Python<pre><code>class MCTS:\n    \"\"\"Monte Carlo Tree Search exploration.\n\n    Balances exploring new areas vs exploiting\n    paths that led to violations.\n    \"\"\"\n\n    def __init__(\n        self,\n        exploration_weight: float = math.sqrt(2),\n        violation_reward: float = 10.0,\n        new_state_reward: float = 1.0,\n        seed: int | None = None,\n    ):\n        ...\n</code></pre> <p>Characteristics:</p> Property Value Memory O(states \u00d7 actions) for tree Bug focus Learns to find bugs Best for Bug-heavy state spaces PostgreSQL \u26a0\ufe0f Use with caution <p>Algorithm:</p> Text Only<pre><code>1. Selection:\n   - Start from root\n   - Use UCB1 to pick most promising child\n   - Repeat until reaching unexplored node\n\n2. Expansion:\n   - Add unexplored children to tree\n\n3. Simulation:\n   - (Lightweight) Evaluate node's potential\n\n4. Backpropagation:\n   - Update visit counts and rewards up tree\n   - Violations give high reward\n</code></pre> <p>UCB1 Formula:</p> Text Only<pre><code>UCB1 = (reward / visits) + C \u00d7 sqrt(ln(total_visits) / visits)\n\nWhere:\n- reward: Accumulated reward for this node\n- visits: Number of times this node was visited\n- total_visits: Total visits across all nodes\n- C: exploration_weight (default: sqrt(2))\n</code></pre>"},{"location":"specs/state-explorer/#strategy-comparison","title":"Strategy Comparison","text":"Strategy Memory Coverage Bug Speed PostgreSQL BFS High Full Fast (short paths) \u274c DFS Low Full Medium \u2705 Random Low Partial Variable \u26a0\ufe0f CoverageGuided Low Maximum Medium \u274c Weighted Low Focused Variable \u26a0\ufe0f MCTS Medium Smart Fast (if bugs exist) \u26a0\ufe0f"},{"location":"specs/state-explorer/#guarantees","title":"Guarantees","text":""},{"location":"specs/state-explorer/#bfs-guarantees","title":"BFS Guarantees","text":"<ol> <li>Completeness: Explores all reachable states</li> <li>Optimality: Shortest path to each state</li> <li>Termination: Terminates if state space is finite</li> </ol>"},{"location":"specs/state-explorer/#dfs-guarantees","title":"DFS Guarantees","text":"<ol> <li>Completeness: Explores all reachable states</li> <li>PostgreSQL compatible: Safe with savepoint semantics</li> <li>Low memory: Only stores current path + siblings</li> </ol>"},{"location":"specs/state-explorer/#random-guarantees","title":"Random Guarantees","text":"<ol> <li>Coverage: Eventually covers all pairs (with enough steps)</li> <li>No bias: Uniform exploration</li> <li>Reproducibility: Same seed = same exploration</li> </ol>"},{"location":"specs/state-explorer/#coverageguided-guarantees","title":"CoverageGuided Guarantees","text":"<ol> <li>Action coverage: Prioritizes under-explored actions</li> <li>Fairness: All actions get explored eventually</li> <li>Completeness: Explores all reachable states</li> </ol>"},{"location":"specs/state-explorer/#mcts-guarantees","title":"MCTS Guarantees","text":"<ol> <li>Bug finding: Learns to find violations</li> <li>No guarantees: May miss bugs, may not terminate</li> <li>Convergence: With enough iterations, converges to optimal</li> </ol>"},{"location":"specs/state-explorer/#tradeoffs","title":"Tradeoffs","text":""},{"location":"specs/state-explorer/#bfs-vs-dfs","title":"BFS vs DFS","text":"Aspect BFS DFS Memory Higher Lower Path length Minimal May be long PostgreSQL Incompatible Compatible First bug Found quickly May take longer Deep bugs May miss Good at finding"},{"location":"specs/state-explorer/#systematic-vs-random","title":"Systematic vs Random","text":"Aspect Systematic (BFS/DFS) Random Completeness Complete Probabilistic Reproducibility Exact With seed Bug variety Structured Surprising Large spaces May not finish Samples evenly"},{"location":"specs/state-explorer/#coverage-vs-bug-focused","title":"Coverage vs Bug-Focused","text":"Aspect CoverageGuided MCTS Goal Maximize diversity Find violations Learning None Learns from violations Bug paths May miss deep bugs Focuses on bug paths No bugs Still useful May wander"},{"location":"specs/state-explorer/#postgresql-compatibility","title":"PostgreSQL Compatibility","text":"<p>Important constraint</p> <p>PostgreSQL SAVEPOINTs are stack-based. BFS, CoverageGuided, and similar strategies that rollback to arbitrary checkpoints will fail.</p> <p>Safe strategies:</p> <ul> <li>DFS (always rolls back to most recent savepoint)</li> <li>Random (with limited depth)</li> </ul> <p>Unsafe strategies:</p> <ul> <li>BFS</li> <li>CoverageGuided</li> <li>Weighted (may rollback arbitrarily)</li> </ul> <p>Workaround: Use SQLite for BFS/CoverageGuided testing:</p> Python<pre><code># Use SQLite for exhaustive BFS testing\ndb = SQLiteAdapter(\"/tmp/test.db\")\nworld = World(api=api, systems={\"db\": db})\n\nagent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n    strategy=BFS(),  # Safe with SQLite\n)\n</code></pre>"},{"location":"specs/state-explorer/#selecting-a-strategy","title":"Selecting a Strategy","text":""},{"location":"specs/state-explorer/#decision-tree","title":"Decision Tree","text":"Text Only<pre><code>Using PostgreSQL?\n\u251c\u2500\u2500 Yes \u2192 Use DFS\n\u2514\u2500\u2500 No \u2192 Need shortest bug paths?\n           \u251c\u2500\u2500 Yes \u2192 Use BFS\n           \u2514\u2500\u2500 No \u2192 Need maximum coverage?\n                      \u251c\u2500\u2500 Yes \u2192 Use CoverageGuided\n                      \u2514\u2500\u2500 No \u2192 Have known hotspots?\n                                 \u251c\u2500\u2500 Yes \u2192 Use Weighted\n                                 \u2514\u2500\u2500 No \u2192 Use Random or MCTS\n</code></pre>"},{"location":"specs/state-explorer/#by-use-case","title":"By Use Case","text":"Use Case Recommended Strategy CI/CD with PostgreSQL DFS Local development BFS Finding maximum bugs MCTS Coverage reports CoverageGuided Fuzzing Random Known risky actions Weighted"},{"location":"specs/state-explorer/#implementation-details","title":"Implementation Details","text":""},{"location":"specs/state-explorer/#frontier-abstraction","title":"Frontier Abstraction","text":"Python<pre><code>class Frontier(Protocol):\n    def add(self, state_id: str, action_name: str) -&gt; None: ...\n    def pop(self) -&gt; tuple[str, str] | None: ...\n    def is_empty(self) -&gt; bool: ...\n\nclass QueueFrontier(Frontier):\n    \"\"\"FIFO queue for BFS.\"\"\"\n    def __init__(self):\n        self._queue = deque()\n\nclass StackFrontier(Frontier):\n    \"\"\"LIFO stack for DFS.\"\"\"\n    def __init__(self):\n        self._stack = []\n</code></pre>"},{"location":"specs/state-explorer/#valid-action-filtering","title":"Valid Action Filtering","text":"<p>Strategies receive pre-filtered valid actions:</p> Python<pre><code>valid_actions = graph.get_valid_actions(state, context, used_actions)\n</code></pre> <p>Filtering includes:</p> <ol> <li>Context preconditions (<code>context.has(\"order_id\")</code>)</li> <li>Action dependencies (<code>preconditions=[\"create_order\"]</code>)</li> <li>Max call limits (<code>max_calls=2</code>)</li> <li>Resource requirements (<code>requires={\"order\": \"created\"}</code>)</li> </ol>"},{"location":"specs/state-explorer/#termination-conditions","title":"Termination Conditions","text":"<p>Exploration terminates when:</p> <ol> <li>No unexplored pairs remain</li> <li><code>max_steps</code> reached</li> <li><code>coverage_target</code> reached</li> <li>Strategy returns <code>None</code> from <code>pick()</code></li> </ol>"},{"location":"specs/state-explorer/#custom-strategies","title":"Custom Strategies","text":"<p>Implement the protocol for custom behavior:</p> Python<pre><code>class PrioritizeCriticalActions:\n    \"\"\"Strategy that prioritizes actions with critical invariants.\"\"\"\n\n    def __init__(self, critical_actions: set[str]):\n        self.critical_actions = critical_actions\n\n    def pick(self, graph: Graph) -&gt; tuple[State, Action] | None:\n        unexplored = graph.get_unexplored()\n        if not unexplored:\n            return None\n\n        # Prioritize critical actions\n        critical = [p for p in unexplored if p[1].name in self.critical_actions]\n        if critical:\n            return critical[0]\n\n        return unexplored[0]\n\n    def notify(self, state: State, actions: list[Action]) -&gt; None:\n        pass  # No internal state to update\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step guides for common testing scenarios.</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":"<ul> <li> <p> Your First Journey</p> <p>Build a complete test suite from scratch. Learn actions, invariants, and exploration.</p> <p> Start tutorial</p> </li> <li> <p> Testing Payment Flows</p> <p>Test e-commerce checkout, refunds, and payment state machines.</p> <p> Start tutorial</p> </li> <li> <p> CI/CD Integration</p> <p>Run VenomQA in GitHub Actions, GitLab CI, and Jenkins pipelines.</p> <p> Start tutorial</p> </li> </ul>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting tutorials, you should have:</p> <ul> <li>Python 3.10+ installed</li> <li>VenomQA installed: <code>pip install venomqa</code></li> <li>A test API (or use the mock server in examples)</li> </ul>"},{"location":"tutorials/#learning-path","title":"Learning Path","text":"Text Only<pre><code>1. Your First Journey\n   \u2514\u2500 Learn: Actions, Context, Invariants, Agent\n\n2. Testing Payment Flows\n   \u2514\u2500 Learn: State machines, Database rollback, Complex invariants\n\n3. CI/CD Integration\n   \u2514\u2500 Learn: Automation, Reporting, Team workflows\n</code></pre>"},{"location":"tutorials/#quick-reference","title":"Quick Reference","text":""},{"location":"tutorials/#minimal-example","title":"Minimal Example","text":"Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"id\"])\n\ndef create(api, context):\n    resp = api.post(\"/items\", json={\"name\": \"test\"})\n    context.set(\"id\", resp.json()[\"id\"])\n    return resp\n\ndef delete(api, context):\n    id = context.get(\"id\")\n    return api.delete(f\"/items/{id}\") if id else None\n\nresult = Agent(\n    world=world,\n    actions=[Action(\"create\", create), Action(\"delete\", delete)],\n    invariants=[Invariant(\"no_500s\", lambda w: True, Severity.CRITICAL)],\n    strategy=BFS(),\n    max_steps=50,\n).explore()\n\nprint(f\"States: {result.states_visited}, Violations: {result.violations}\")\n</code></pre>"},{"location":"tutorials/#cli-quick-start","title":"CLI Quick Start","text":"Bash<pre><code># Install\npip install venomqa\n\n# Run demo\nvenomqa demo\n\n# Check environment\nvenomqa doctor\n\n# Generate from OpenAPI\nvenomqa scaffold openapi spec.json\n\n# Run exploration\nvenomqa run qa/\n</code></pre>"},{"location":"tutorials/#need-help","title":"Need Help?","text":"<ul> <li>Documentation: Browse the sidebar for detailed guides</li> <li>Examples: See <code>examples/</code> in the repository</li> <li>Issues: Report bugs on GitHub</li> </ul>"},{"location":"tutorials/ci-cd/","title":"CI/CD Integration","text":"<p>Run VenomQA in your continuous integration pipeline.</p>"},{"location":"tutorials/ci-cd/#overview","title":"Overview","text":"<p>VenomQA fits naturally into CI/CD workflows:</p> YAML<pre><code># Typical CI pipeline\njobs:\n  unit-tests:      # Fast feedback\n  schema-tests:    # Schemathesis\n  sequence-tests:  # VenomQA \u2190 You are here\n  deploy:          # Only if all pass\n</code></pre>"},{"location":"tutorials/ci-cd/#github-actions","title":"GitHub Actions","text":""},{"location":"tutorials/ci-cd/#basic-setup","title":"Basic Setup","text":"<p>Create <code>.github/workflows/venomqa.yml</code>:</p> YAML<pre><code>name: VenomQA Tests\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  sequence-tests:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_PASSWORD: postgres\n          POSTGRES_DB: testdb\n        ports:\n          - 5432:5432\n        options: &gt;-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n      api:\n        image: your-api:latest\n        ports:\n          - 8000:8000\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n\n      - name: Install dependencies\n        run: |\n          pip install -e \".[dev]\"\n          pip install psycopg[binary]\n\n      - name: Run VenomQA\n        env:\n          API_URL: http://localhost:8000\n          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/testdb\n        run: |\n          venomqa run qa/ --report html\n\n      - name: Upload Report\n        uses: actions/upload-artifact@v4\n        if: always()\n        with:\n          name: venomqa-report\n          path: reports/\n</code></pre>"},{"location":"tutorials/ci-cd/#with-pr-comments","title":"With PR Comments","text":"YAML<pre><code>      - name: Comment on PR\n        if: github.event_name == 'pull_request' &amp;&amp; failure()\n        uses: actions/github-script@v7\n        with:\n          script: |\n            const fs = require('fs');\n            const report = fs.readFileSync('reports/summary.txt', 'utf8');\n            github.rest.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: context.issue.number,\n              body: `## VenomQA Results\\n\\n\\`\\`\\`\\n${report}\\n\\`\\`\\``\n            });\n</code></pre>"},{"location":"tutorials/ci-cd/#matrix-testing","title":"Matrix Testing","text":"YAML<pre><code>jobs:\n  sequence-tests:\n    strategy:\n      matrix:\n        python-version: ['3.10', '3.11', '3.12']\n        database: ['postgres:14', 'postgres:15']\n\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: ${{ matrix.database }}\n        # ...\n\n    steps:\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n      # ...\n</code></pre>"},{"location":"tutorials/ci-cd/#gitlab-ci","title":"GitLab CI","text":""},{"location":"tutorials/ci-cd/#basic-setup_1","title":"Basic Setup","text":"<p>Create <code>.gitlab-ci.yml</code>:</p> YAML<pre><code>stages:\n  - test\n  - report\n\nvenomqa:\n  stage: test\n  image: python:3.11\n\n  services:\n    - name: postgres:15\n      alias: db\n    - name: your-api:latest\n      alias: api\n\n  variables:\n    POSTGRES_PASSWORD: postgres\n    POSTGRES_DB: testdb\n    API_URL: http://api:8000\n    DATABASE_URL: postgresql://postgres:postgres@db:5432/testdb\n\n  before_script:\n    - pip install -e \".[dev]\"\n    - pip install psycopg[binary]\n\n  script:\n    - venomqa run qa/ --report html --output reports/\n\n  artifacts:\n    when: always\n    paths:\n      - reports/\n    expire_in: 1 week\n\n  coverage: '/States visited: (\\d+)/'\n</code></pre>"},{"location":"tutorials/ci-cd/#with-review-app","title":"With Review App","text":"YAML<pre><code>review:\n  stage: deploy\n  script:\n    - deploy_to_review_app\n  environment:\n    name: review/$CI_COMMIT_REF_NAME\n    url: https://review-$CI_COMMIT_REF_SLUG.example.com\n    on_stop: stop_review\n\nvenomqa-on-review:\n  stage: test\n  needs: [review]\n  script:\n    - export API_URL=$REVIEW_APP_URL\n    - venomqa run qa/\n</code></pre>"},{"location":"tutorials/ci-cd/#jenkins","title":"Jenkins","text":""},{"location":"tutorials/ci-cd/#jenkinsfile","title":"Jenkinsfile","text":"Groovy<pre><code>pipeline {\n  agent any\n\n  stages {\n    stage('Setup') {\n      steps {\n        sh 'pip install -e \".[dev]\"'\n        sh 'pip install psycopg[binary]'\n      }\n    }\n\n    stage('Start Services') {\n      steps {\n        sh 'docker-compose -f docker-compose.test.yml up -d'\n        sh 'sleep 10'  // Wait for services\n      }\n    }\n\n    stage('VenomQA') {\n      steps {\n        withCredentials([\n          string(credentialsId: 'api-token', variable: 'API_TOKEN'),\n          string(credentialsId: 'db-url', variable: 'DATABASE_URL')\n        ]) {\n          sh '''\n            export API_URL=http://localhost:8000\n            venomqa run qa/ --report html --output reports/\n          '''\n        }\n      }\n\n      post {\n        always {\n          archiveArtifacts artifacts: 'reports/**', allowEmptyArchive: true\n          publishHTML(target: [\n            allowMissing: true,\n            alwaysLinkToLastBuild: true,\n            keepAll: true,\n            reportDir: 'reports',\n            reportFiles: 'trace.html',\n            reportName: 'VenomQA Report'\n          ])\n        }\n      }\n    }\n  }\n\n  post {\n    always {\n      sh 'docker-compose -f docker-compose.test.yml down'\n    }\n  }\n}\n</code></pre>"},{"location":"tutorials/ci-cd/#circleci","title":"CircleCI","text":""},{"location":"tutorials/ci-cd/#circleciconfigyml","title":".circleci/config.yml","text":"YAML<pre><code>version: 2.1\n\njobs:\n  venomqa:\n    docker:\n      - image: python:3.11\n      - image: postgres:15\n        environment:\n          POSTGRES_PASSWORD: postgres\n          POSTGRES_DB: testdb\n      - image: your-api:latest\n\n    environment:\n      API_URL: http://localhost:8000\n      DATABASE_URL: postgresql://postgres:postgres@localhost:5432/testdb\n\n    steps:\n      - checkout\n\n      - run:\n          name: Install dependencies\n          command: |\n            pip install -e \".[dev]\"\n            pip install psycopg[binary]\n\n      - run:\n          name: Run VenomQA\n          command: venomqa run qa/ --report html\n\n      - store_artifacts:\n          path: reports/\n          destination: venomqa-report\n\n      - store_test_results:\n          path: reports/junit.xml\n\nworkflows:\n  version: 2\n  test:\n    jobs:\n      - venomqa\n</code></pre>"},{"location":"tutorials/ci-cd/#docker-compose-for-ci","title":"Docker Compose for CI","text":"<p>Create <code>docker-compose.test.yml</code>:</p> YAML<pre><code>version: '3.8'\n\nservices:\n  api:\n    build: ./app\n    ports:\n      - \"8000:8000\"\n    environment:\n      DATABASE_URL: postgresql://postgres:postgres@db:5432/testdb\n    depends_on:\n      - db\n\n  db:\n    image: postgres:15\n    environment:\n      POSTGRES_PASSWORD: postgres\n      POSTGRES_DB: testdb\n    ports:\n      - \"5432:5432\"\n\n  venomqa:\n    build:\n      context: .\n      dockerfile: Dockerfile.venomqa\n    environment:\n      API_URL: http://api:8000\n      DATABASE_URL: postgresql://postgres:postgres@db:5432/testdb\n    depends_on:\n      - api\n      - db\n    volumes:\n      - ./reports:/app/reports\n\n# Dockerfile.venomqa\nFROM python:3.11\nWORKDIR /app\nCOPY . .\nRUN pip install -e \".[dev]\" &amp;&amp; pip install psycopg[binary]\nCMD [\"venomqa\", \"run\", \"qa/\", \"--report\", \"html\", \"--output\", \"/app/reports/\"]\n</code></pre>"},{"location":"tutorials/ci-cd/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/ci-cd/#1-use-service-containers","title":"1. Use Service Containers","text":"YAML<pre><code># Good: Isolated services\nservices:\n  postgres:\n    image: postgres:15\n  api:\n    image: your-api:latest\n\n# Bad: External dependencies\n# Can't guarantee availability\n</code></pre>"},{"location":"tutorials/ci-cd/#2-upload-artifacts","title":"2. Upload Artifacts","text":"YAML<pre><code># Always upload reports, even on failure\nartifacts:\n  when: always\n  paths:\n    - reports/\n</code></pre>"},{"location":"tutorials/ci-cd/#3-set-timeouts","title":"3. Set Timeouts","text":"YAML<pre><code># Prevent hung tests\nscript:\n  - timeout 30m venomqa run qa/\n</code></pre>"},{"location":"tutorials/ci-cd/#4-fail-fast-in-prs","title":"4. Fail Fast in PRs","text":"YAML<pre><code># Quick feedback for developers\nvenomqa:\n  script:\n    - venomqa run qa/ --max-steps 100 --fail-fast\n</code></pre>"},{"location":"tutorials/ci-cd/#5-thorough-in-main","title":"5. Thorough in Main","text":"YAML<pre><code># Full exploration for main branch\nvenomqa-main:\n  if: github.ref == 'refs/heads/main'\n  script:\n    - venomqa run qa/ --max-steps 500\n</code></pre>"},{"location":"tutorials/ci-cd/#next-steps","title":"Next Steps","text":"<ul> <li>Reporting - Report formats</li> <li>Configuration - Environment setup</li> <li>Examples - Real-world setups</li> </ul>"},{"location":"tutorials/first-journey/","title":"Your First Journey","text":"<p>Build a complete VenomQA test suite from scratch.</p>"},{"location":"tutorials/first-journey/#what-youll-build","title":"What You'll Build","text":"<p>A test suite for a simple todo API that:</p> <ul> <li>Creates todos</li> <li>Updates todos</li> <li>Deletes todos</li> <li>Finds sequence bugs</li> </ul>"},{"location":"tutorials/first-journey/#prerequisites","title":"Prerequisites","text":"Bash<pre><code>pip install venomqa\n</code></pre> <p>You'll also need a todo API running. For this tutorial, use the mock server:</p> Bash<pre><code># Clone and run the example server\ngit clone https://github.com/namanag97/venomqa.git\ncd venomqa/examples/todo_app\npython app/app.py\n# Server running at http://localhost:5000\n</code></pre>"},{"location":"tutorials/first-journey/#step-1-define-your-actions","title":"Step 1: Define Your Actions","text":"<p>Create <code>qa/actions/todo.py</code>:</p> Python<pre><code>\"\"\"Actions for the todo API.\"\"\"\n\nfrom typing import Optional\nfrom venomqa.adapters.http import HttpClient\n\ndef create_todo(api: HttpClient, context) -&gt; Optional[dict]:\n    \"\"\"Create a new todo item.\"\"\"\n    resp = api.post(\"/todos\", json={\n        \"title\": \"Test Todo\",\n        \"completed\": False,\n    })\n\n    if resp.status_code == 201:\n        data = resp.json()\n        context.set(\"todo_id\", data[\"id\"])\n        context.set(\"last_status\", resp.status_code)\n        return data\n    return None\n\ndef update_todo(api: HttpClient, context) -&gt; Optional[dict]:\n    \"\"\"Update an existing todo.\"\"\"\n    todo_id = context.get(\"todo_id\")\n    if todo_id is None:\n        return None  # Skip - no todo to update\n\n    resp = api.put(f\"/todos/{todo_id}\", json={\n        \"title\": \"Updated Todo\",\n        \"completed\": True,\n    })\n\n    context.set(\"last_status\", resp.status_code)\n    return resp.json() if resp.status_code == 200 else None\n\ndef delete_todo(api: HttpClient, context) -&gt; Optional[dict]:\n    \"\"\"Delete a todo.\"\"\"\n    todo_id = context.get(\"todo_id\")\n    if todo_id is None:\n        return None  # Skip - no todo to delete\n\n    resp = api.delete(f\"/todos/{todo_id}\")\n    context.set(\"last_status\", resp.status_code)\n\n    if resp.status_code == 204:\n        context.delete(\"todo_id\")  # Clear the ID\n        return {}\n    return None\n\ndef get_todo(api: HttpClient, context) -&gt; Optional[dict]:\n    \"\"\"Get a todo by ID.\"\"\"\n    todo_id = context.get(\"todo_id\")\n    if todo_id is None:\n        return None\n\n    resp = api.get(f\"/todos/{todo_id}\")\n    context.set(\"last_status\", resp.status_code)\n    return resp.json() if resp.status_code == 200 else None\n\ndef list_todos(api: HttpClient, context) -&gt; list:\n    \"\"\"List all todos.\"\"\"\n    resp = api.get(\"/todos\")\n    context.set(\"last_status\", resp.status_code)\n    return resp.json()\n</code></pre>"},{"location":"tutorials/first-journey/#step-2-define-invariants","title":"Step 2: Define Invariants","text":"<p>Create <code>qa/invariants.py</code>:</p> Python<pre><code>\"\"\"Invariants for the todo API.\"\"\"\n\nfrom venomqa import Invariant, Severity\n\ndef no_server_errors(world) -&gt; bool:\n    \"\"\"No 5xx errors should occur.\"\"\"\n    return world.context.get(\"last_status\", 200) &lt; 500\n\ndef deleted_not_accessible(world) -&gt; bool:\n    \"\"\"Deleted todos should return 404.\"\"\"\n    # This is checked in the action itself\n    # If we got here, no violation occurred\n    return True\n\ndef completed_cannot_be_uncompleted(world) -&gt; bool:\n    \"\"\"Once completed, cannot be uncompleted (business rule).\"\"\"\n    todo = world.context.get(\"last_todo\")\n    if not todo:\n        return True\n\n    # Check if we're trying to uncomplete a completed todo\n    if todo.get(\"was_completed\") and not todo.get(\"completed\"):\n        return False\n    return True\n\n# Create invariant objects\nno_500s = Invariant(\n    name=\"no_server_errors\",\n    check=no_server_errors,\n    severity=Severity.CRITICAL,\n)\n\nconsistency = Invariant(\n    name=\"data_consistency\",\n    check=lambda w: True,  # Placeholder\n    severity=Severity.HIGH,\n)\n</code></pre>"},{"location":"tutorials/first-journey/#step-3-create-the-test-file","title":"Step 3: Create the Test File","text":"<p>Create <code>qa/test_todos.py</code>:</p> Python<pre><code>\"\"\"VenomQA test suite for todo API.\"\"\"\n\nfrom venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\nfrom actions.todo import create_todo, update_todo, delete_todo, get_todo, list_todos\nfrom invariants import no_500s\n\n# Setup\napi = HttpClient(\"http://localhost:5000\")\nworld = World(api=api, state_from_context=[\"todo_id\"])\n\n# Define actions\nactions = [\n    Action(name=\"create_todo\", execute=create_todo),\n    Action(name=\"update_todo\", execute=update_todo),\n    Action(name=\"delete_todo\", execute=delete_todo),\n    Action(name=\"get_todo\", execute=get_todo),\n    Action(name=\"list_todos\", execute=list_todos),\n]\n\n# Define invariants\ninvariants = [\n    no_500s,\n    Invariant(\n        name=\"no_negative_ids\",\n        check=lambda w: w.context.get(\"todo_id\", 0) &gt;= 0,\n        severity=Severity.MEDIUM,\n    ),\n]\n\n# Create agent and explore\nagent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n    strategy=BFS(),\n    max_steps=100,\n    max_depth=10,\n)\n\nif __name__ == \"__main__\":\n    result = agent.explore()\n\n    print(f\"\\n{'='*50}\")\n    print(f\"States visited: {result.states_visited}\")\n    print(f\"Transitions: {result.transitions}\")\n    print(f\"Invariants checked: {result.invariants_checked}\")\n    print(f\"Violations: {result.violations}\")\n\n    if result.violations:\n        print(\"\\nViolations found:\")\n        for v in result.violations:\n            print(f\"  - {v.invariant_name}: {v.message}\")\n    else:\n        print(\"\\nAll invariants passed!\")\n</code></pre>"},{"location":"tutorials/first-journey/#step-4-run-the-test","title":"Step 4: Run the Test","text":"Bash<pre><code>cd qa\npython test_todos.py\n</code></pre> <p>Expected output:</p> Text Only<pre><code>==================================================\nStates visited: 12\nTransitions: 25\nInvariants checked: 75\nViolations: 0\n\nAll invariants passed!\n</code></pre>"},{"location":"tutorials/first-journey/#step-5-find-a-bug","title":"Step 5: Find a Bug","text":"<p>Let's plant a bug in our API to see VenomQA catch it. Modify the server to allow deleting the same todo twice:</p> Python<pre><code># In your API server (intentional bug)\n@app.delete(\"/todos/&lt;int:todo_id&gt;\")\ndef delete_todo(todo_id):\n    todo = todos.get(todo_id)\n    if not todo:\n        return {\"error\": \"Not found\"}, 404  # This is correct\n\n    del todos[todo_id]\n    return \"\", 204  # Bug: should prevent double-delete\n</code></pre> <p>Now add an invariant to catch this:</p> Python<pre><code># Add to invariants.py\ndef no_double_delete(world) -&gt; bool:\n    \"\"\"Deleting the same todo twice should fail.\"\"\"\n    # Track deletions in context\n    deleted = world.context.get(\"deleted_ids\", set())\n    todo_id = world.context.get(\"last_deleted_id\")\n\n    if todo_id and todo_id in deleted:\n        return False  # Double delete!\n    return True\n\ndouble_delete_check = Invariant(\n    name=\"no_double_delete\",\n    check=no_double_delete,\n    severity=Severity.CRITICAL,\n)\n</code></pre> <p>Run again:</p> Text Only<pre><code>==================================================\nStates visited: 15\nTransitions: 32\nInvariants checked: 96\nViolations: 1\n\nViolations found:\n  - no_double_delete: Deleted todo ID 1 twice\n</code></pre>"},{"location":"tutorials/first-journey/#step-6-add-reporting","title":"Step 6: Add Reporting","text":"<p>Generate an HTML report:</p> Python<pre><code>from venomqa.reporters import HTMLTraceReporter\n\nreporter = HTMLTraceReporter(output_path=\"reports/trace.html\")\nresult = agent.explore(reporter=reporter)\n</code></pre> <p>Open <code>reports/trace.html</code> to see a visual graph of all paths explored.</p>"},{"location":"tutorials/first-journey/#what-you-learned","title":"What You Learned","text":"Concept What You Did Actions Defined create, update, delete, get, list Context Stored and retrieved <code>todo_id</code> between actions Invariants Checked for server errors and double deletes Agent Orchestrated BFS exploration Reporting Generated HTML trace"},{"location":"tutorials/first-journey/#next-steps","title":"Next Steps","text":"<ul> <li>Testing Payment Flows - More complex state machine</li> <li>CI/CD Integration - Automate in pipelines</li> <li>Concepts: Journeys - Deep dive on context</li> </ul>"},{"location":"tutorials/payment-flows/","title":"Testing Payment Flows","text":"<p>Test complex e-commerce state machines with database rollback.</p>"},{"location":"tutorials/payment-flows/#what-youll-build","title":"What You'll Build","text":"<p>A test suite for a payment API with:</p> <ul> <li>Order creation and state transitions</li> <li>Payment processing</li> <li>Refund handling</li> <li>Partial refunds</li> <li>Idempotency checks</li> </ul>"},{"location":"tutorials/payment-flows/#the-state-machine","title":"The State Machine","text":"<p>Payment flows are classic state machines:</p> Text Only<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502   [empty]   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502 create\n                           \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502   [pending] \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502\n          \u2502 cancel        \u2502 pay             \u2502 timeout\n          \u25bc               \u25bc                 \u25bc\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 [canceled]  \u2502 \u2502  [paid]     \u2502  \u2502 [expired]   \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502 refund      \u2502 capture\n                   \u25bc             \u25bc\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502 [refunded]  \u2502 \u2502 [captured]  \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                   \u2502 refund\n                                   \u25bc\n                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                            \u2502 [refunded]  \u2502\n                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tutorials/payment-flows/#setup","title":"Setup","text":"Bash<pre><code>pip install venomqa\npip install psycopg[binary]  # For PostgreSQL rollback\n</code></pre>"},{"location":"tutorials/payment-flows/#step-1-define-actions","title":"Step 1: Define Actions","text":"<p>Create <code>qa/actions/payments.py</code>:</p> Python<pre><code>\"\"\"Payment API actions.\"\"\"\n\nfrom typing import Optional\nfrom decimal import Decimal\n\ndef create_order(api, context) -&gt; Optional[dict]:\n    \"\"\"Create a new order.\"\"\"\n    resp = api.post(\"/orders\", json={\n        \"amount\": \"100.00\",\n        \"currency\": \"USD\",\n        \"customer_id\": \"cust_123\",\n    })\n\n    if resp.status_code == 201:\n        data = resp.json()\n        context.set(\"order_id\", data[\"id\"])\n        context.set(\"order_amount\", Decimal(data[\"amount\"]))\n        context.set(\"order_status\", data[\"status\"])\n        context.set(\"total_refunded\", Decimal(\"0\"))\n        return data\n    return None\n\ndef pay_order(api, context) -&gt; Optional[dict]:\n    \"\"\"Pay for a pending order.\"\"\"\n    order_id = context.get(\"order_id\")\n    if not order_id:\n        return None\n\n    status = context.get(\"order_status\")\n    if status != \"pending\":\n        return None  # Can only pay pending orders\n\n    resp = api.post(f\"/orders/{order_id}/pay\", json={\n        \"payment_method\": \"card\",\n        \"card_token\": \"tok_test\",\n    })\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"order_status\", data[\"status\"])\n        context.set(\"payment_id\", data.get(\"payment_id\"))\n        return data\n    return None\n\ndef refund_order(api, context) -&gt; Optional[dict]:\n    \"\"\"Refund a paid order (full refund).\"\"\"\n    order_id = context.get(\"order_id\")\n    if not order_id:\n        return None\n\n    status = context.get(\"order_status\")\n    if status not in (\"paid\", \"captured\"):\n        return None  # Can only refund paid/captured orders\n\n    resp = api.post(f\"/orders/{order_id}/refund\")\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"order_status\", data[\"status\"])\n        current = context.get(\"total_refunded\", Decimal(\"0\"))\n        context.set(\"total_refunded\", current + Decimal(str(data.get(\"refunded_amount\", 0))))\n        return data\n    return None\n\ndef partial_refund(api, context) -&gt; Optional[dict]:\n    \"\"\"Refund part of an order.\"\"\"\n    order_id = context.get(\"order_id\")\n    if not order_id:\n        return None\n\n    status = context.get(\"order_status\")\n    if status not in (\"paid\", \"captured\"):\n        return None\n\n    # Refund $25\n    resp = api.post(f\"/orders/{order_id}/refund\", json={\n        \"amount\": \"25.00\",\n    })\n\n    if resp.status_code == 200:\n        data = resp.json()\n        current = context.get(\"total_refunded\", Decimal(\"0\"))\n        context.set(\"total_refunded\", current + Decimal(\"25.00\"))\n        return data\n    return None\n\ndef cancel_order(api, context) -&gt; Optional[dict]:\n    \"\"\"Cancel a pending order.\"\"\"\n    order_id = context.get(\"order_id\")\n    if not order_id:\n        return None\n\n    status = context.get(\"order_status\")\n    if status != \"pending\":\n        return None  # Can only cancel pending orders\n\n    resp = api.post(f\"/orders/{order_id}/cancel\")\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"order_status\", data[\"status\"])\n        return data\n    return None\n\ndef capture_order(api, context) -&gt; Optional[dict]:\n    \"\"\"Capture an authorized payment.\"\"\"\n    order_id = context.get(\"order_id\")\n    if not order_id:\n        return None\n\n    status = context.get(\"order_status\")\n    if status != \"paid\":\n        return None  # Can only capture paid (authorized) orders\n\n    resp = api.post(f\"/orders/{order_id}/capture\")\n\n    if resp.status_code == 200:\n        data = resp.json()\n        context.set(\"order_status\", data[\"status\"])\n        return data\n    return None\n</code></pre>"},{"location":"tutorials/payment-flows/#step-2-define-invariants","title":"Step 2: Define Invariants","text":"<p>Create <code>qa/invariants_payments.py</code>:</p> Python<pre><code>\"\"\"Payment invariants.\"\"\"\n\nfrom decimal import Decimal\nfrom venomqa import Invariant, Severity\n\ndef no_over_refund(world) -&gt; bool:\n    \"\"\"Total refunds cannot exceed order amount.\"\"\"\n    total_refunded = world.context.get(\"total_refunded\", Decimal(\"0\"))\n    order_amount = world.context.get(\"order_amount\", Decimal(\"0\"))\n    return total_refunded &lt;= order_amount\n\ndef no_refund_after_cancel(world) -&gt; bool:\n    \"\"\"Cannot refund a canceled order.\"\"\"\n    status = world.context.get(\"order_status\")\n    if status == \"canceled\":\n        total_refunded = world.context.get(\"total_refunded\", Decimal(\"0\"))\n        return total_refunded == Decimal(\"0\")\n    return True\n\ndef status_consistency(world) -&gt; bool:\n    \"\"\"Order status must match API state.\"\"\"\n    order_id = world.context.get(\"order_id\")\n    if not order_id:\n        return True\n\n    resp = world.api.get(f\"/orders/{order_id}\")\n    if resp.status_code != 200:\n        return True\n\n    api_status = resp.json()[\"status\"]\n    context_status = world.context.get(\"order_status\")\n    return api_status == context_status\n\n# Create invariant objects\ninvariants = [\n    Invariant(\n        name=\"no_over_refund\",\n        check=no_over_refund,\n        severity=Severity.CRITICAL,\n        description=\"Refunds cannot exceed order total\",\n    ),\n    Invariant(\n        name=\"no_refund_after_cancel\",\n        check=no_refund_after_cancel,\n        severity=Severity.CRITICAL,\n        description=\"Cannot refund a canceled order\",\n    ),\n    Invariant(\n        name=\"status_consistency\",\n        check=status_consistency,\n        severity=Severity.HIGH,\n        description=\"API status must match context\",\n    ),\n    Invariant(\n        name=\"no_500_errors\",\n        check=lambda w: w.context.get(\"last_status\", 200) &lt; 500,\n        severity=Severity.CRITICAL,\n    ),\n]\n</code></pre>"},{"location":"tutorials/payment-flows/#step-3-add-database-rollback","title":"Step 3: Add Database Rollback","text":"<p>Create <code>qa/conftest.py</code>:</p> Python<pre><code>\"\"\"Configuration and fixtures.\"\"\"\n\nimport os\nfrom venomqa import World\nfrom venomqa.adapters.http import HttpClient\nfrom venomqa.adapters.postgres import PostgresAdapter\n\ndef get_world():\n    \"\"\"Create a world with PostgreSQL rollback.\"\"\"\n    api = HttpClient(\n        base_url=os.getenv(\"API_URL\", \"http://localhost:8000\"),\n        timeout=30.0,\n    )\n\n    # PostgreSQL adapter for rollback\n    db = PostgresAdapter(\n        os.getenv(\"DATABASE_URL\", \"postgresql://localhost/payments_test\")\n    )\n\n    return World(\n        api=api,\n        systems={\"db\": db},\n        state_from_context=[\"order_id\", \"order_status\"],\n    )\n</code></pre>"},{"location":"tutorials/payment-flows/#step-4-run-the-test","title":"Step 4: Run the Test","text":"<p>Create <code>qa/test_payments.py</code>:</p> Python<pre><code>\"\"\"Payment flow tests.\"\"\"\n\nfrom venomqa import Action, Agent, BFS\nfrom conftest import get_world\nfrom actions.payments import (\n    create_order, pay_order, refund_order, \n    partial_refund, cancel_order, capture_order\n)\nfrom invariants_payments import invariants\n\nworld = get_world()\n\nactions = [\n    Action(\"create_order\", create_order),\n    Action(\"pay_order\", pay_order),\n    Action(\"refund_order\", refund_order),\n    Action(\"partial_refund\", partial_refund),\n    Action(\"cancel_order\", cancel_order),\n    Action(\"capture_order\", capture_order),\n]\n\nagent = Agent(\n    world=world,\n    actions=actions,\n    invariants=invariants,\n    strategy=BFS(),\n    max_steps=200,\n    max_depth=15,\n)\n\nif __name__ == \"__main__\":\n    result = agent.explore()\n\n    print(f\"\\n{'='*60}\")\n    print(f\"PAYMENT FLOW EXPLORATION RESULTS\")\n    print(f\"{'='*60}\")\n    print(f\"States visited:     {result.states_visited}\")\n    print(f\"Transitions:        {result.transitions}\")\n    print(f\"Invariants checked: {result.invariants_checked}\")\n    print(f\"Violations:         {result.violations}\")\n\n    if result.violations:\n        print(f\"\\n{'\u2500'*60}\")\n        print(\"VIOLATIONS FOUND:\")\n        for v in result.violations:\n            print(f\"\\n  [{v.severity}] {v.invariant_name}\")\n            print(f\"    Path: {' \u2192 '.join(v.path)}\")\n            print(f\"    {v.message}\")\n    else:\n        print(f\"\\n{'\u2500'*60}\")\n        print(\"\u2713 All invariants passed!\")\n</code></pre> <p>Run:</p> Bash<pre><code>python qa/test_payments.py\n</code></pre>"},{"location":"tutorials/payment-flows/#common-bugs-this-catches","title":"Common Bugs This Catches","text":""},{"location":"tutorials/payment-flows/#1-double-refund","title":"1. Double Refund","text":"Python<pre><code># Bug: API allows refunding more than order total\ncreate \u2192 pay \u2192 refund \u2192 refund \u2192 refund\n# Expected: Second+ refund fails\n# Bug: All refunds succeed, total &gt; order amount\n</code></pre>"},{"location":"tutorials/payment-flows/#2-refund-after-cancel","title":"2. Refund After Cancel","text":"Python<pre><code># Bug: Can refund a canceled order\ncreate \u2192 cancel \u2192 refund\n# Expected: Refund fails (order canceled)\n# Bug: Refund succeeds\n</code></pre>"},{"location":"tutorials/payment-flows/#3-state-transitions","title":"3. State Transitions","text":"Python<pre><code># Bug: Can capture a refunded order\ncreate \u2192 pay \u2192 refund \u2192 capture\n# Expected: Capture fails (already refunded)\n# Bug: Capture succeeds, corrupts state\n</code></pre>"},{"location":"tutorials/payment-flows/#4-partial-refund-overflow","title":"4. Partial Refund Overflow","text":"Python<pre><code># Bug: Can partially refund more than total\ncreate \u2192 pay \u2192 partial_refund \u2192 partial_refund \u2192 partial_refund \u2192 partial_refund \u2192 partial_refund\n# Expected: Total capped at order amount\n# Bug: No limit on partial refunds\n</code></pre>"},{"location":"tutorials/payment-flows/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/payment-flows/#1-track-state-in-context","title":"1. Track State in Context","text":"Python<pre><code># Always update context when state changes\ncontext.set(\"order_status\", data[\"status\"])\ncontext.set(\"total_refunded\", current + amount)\n</code></pre>"},{"location":"tutorials/payment-flows/#2-check-preconditions","title":"2. Check Preconditions","text":"Python<pre><code># Skip actions that don't apply\nif context.get(\"order_status\") != \"pending\":\n    return None  # Skip\n</code></pre>"},{"location":"tutorials/payment-flows/#3-use-decimal-for-money","title":"3. Use Decimal for Money","text":"Python<pre><code># Never use float for money\namount = Decimal(\"100.00\")  # Correct\namount = 100.00             # Wrong - floating point errors\n</code></pre>"},{"location":"tutorials/payment-flows/#4-verify-database-state","title":"4. Verify Database State","text":"Python<pre><code>def db_api_consistency(world):\n    api_amount = world.api.get(\"/orders/123\").json()[\"refunded\"]\n    db_amount = world.systems[\"db\"].query(\"SELECT refunded FROM orders WHERE id = 123\")\n    return api_amount == db_amount\n</code></pre>"},{"location":"tutorials/payment-flows/#next-steps","title":"Next Steps","text":"<ul> <li>CI/CD Integration - Automate these tests</li> <li>Invariants Guide - Write better invariants</li> <li>Examples - More patterns</li> </ul>"}]}