{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#venomqa","title":"VenomQA","text":"<p>Stateful Journey Testing for Modern APIs</p> <p>Test complex user flows with automatic state exploration and branch testing</p>  [Get Started](getting-started/quickstart.md){ .md-button .md-button--primary } [View on GitHub](https://github.com/venomqa/venomqa){ .md-button .md-button--secondary }"},{"location":"#why-venomqa","title":"Why VenomQA?","text":"<p>Traditional API testing tools treat each test in isolation. But real users don't work that way---they follow complex journeys through your application, and bugs often emerge from specific state combinations.</p> <p>VenomQA is different.</p> Traditional Testing VenomQA Tests are independent Tests are stateful journeys Each test starts fresh Checkpoint and restore database state One path per test Branch to explore multiple paths from one checkpoint Manual test data setup Automatic state isolation between branches Fragile, dependent tests Deterministic, repeatable test flows"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#state-branching","title":"State Branching","text":"<p>Save a database checkpoint, then fork execution to test multiple scenarios from the exact same starting state. No more flaky tests from inconsistent data.</p>"},{"location":"#path-exploration","title":"Path Exploration","text":"<p>Automatically explore every branch of your user flows. Test the happy path, error paths, and edge cases---all from one journey definition.</p>"},{"location":"#ports-adapters","title":"Ports &amp; Adapters","text":"<p>Clean architecture with swappable backends. Swap Redis for Memcached, PostgreSQL for MySQL, or use mocks---all without changing your tests.</p>"},{"location":"#rich-reporting","title":"Rich Reporting","text":"<p>Get detailed reports with request/response logs, stack traces, and fix suggestions when things fail. Export to Markdown, JSON, JUnit XML, or HTML.</p>"},{"location":"#infrastructure-as-code","title":"Infrastructure as Code","text":"<p>Docker Compose integration spins up isolated test environments. Every test run starts with a clean slate.</p>"},{"location":"#cicd-ready","title":"CI/CD Ready","text":"<p>Native support for GitHub Actions, GitLab CI, Jenkins, and more. JUnit XML reports integrate seamlessly with your pipeline.</p>"},{"location":"#quick-example","title":"Quick Example","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\ndef login(client, context):\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\"\n    })\n    context[\"token\"] = response.json()[\"token\"]\n    return response\n\ndef create_order(client, context):\n    return client.post(\"/api/orders\", json={\n        \"item_id\": 1,\n        \"quantity\": 2\n    })\n\ndef pay_with_card(client, context):\n    return client.post(\"/api/payments\", json={\n        \"method\": \"credit_card\",\n        \"card_token\": \"tok_visa\"\n    })\n\ndef pay_with_wallet(client, context):\n    return client.post(\"/api/payments\", json={\n        \"method\": \"wallet\"\n    })\n\njourney = Journey(\n    name=\"checkout_flow\",\n    description=\"Test checkout with multiple payment methods\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Checkpoint(name=\"authenticated\"),\n        Step(name=\"create_order\", action=create_order),\n        Checkpoint(name=\"order_created\"),\n        Branch(\n            checkpoint_name=\"order_created\",\n            paths=[\n                Path(name=\"card_payment\", steps=[\n                    Step(name=\"pay_card\", action=pay_with_card),\n                ]),\n                Path(name=\"wallet_payment\", steps=[\n                    Step(name=\"pay_wallet\", action=pay_with_wallet),\n                ]),\n            ]\n        ),\n    ],\n)\n</code></pre> <p>Run it:</p> Bash<pre><code>venomqa run checkout_flow\n</code></pre>"},{"location":"#who-is-venomqa-for","title":"Who is VenomQA for?","text":"QA EngineersBackend DevelopersPlatform EngineersTeams with Complex Logic <p>You're tired of maintaining flaky end-to-end tests. You want tests that are reliable, repeatable, and actually catch bugs. VenomQA's state checkpointing ensures every test starts from a known state.</p> <p>You need to test complex API flows---authentication, authorization, multi-step transactions---but setting up test data for each scenario is painful. Define the journey once, branch at checkpoints, test all paths.</p> <p>You want API tests that integrate with your CI/CD pipeline. VenomQA outputs JUnit XML, has a clean CLI, and manages its own infrastructure with Docker Compose.</p> <p>Your application has lots of \"if this, then that\" logic. Testing all paths manually is impossible. VenomQA lets you define branches and automatically explores all of them.</p>"},{"location":"#installation","title":"Installation","text":"Bash<pre><code>pip install venomqa\n</code></pre> <p>With optional dependencies:</p> Bash<pre><code>pip install \"venomqa[postgres]\"   # PostgreSQL state management\npip install \"venomqa[redis]\"      # Redis cache/queue adapters\npip install \"venomqa[all]\"        # Everything\n</code></pre> <p>Requirements: Python 3.10+</p>"},{"location":"#whats-next","title":"What's Next?","text":"<p>Built with care by Naman Agarwal and contributors</p> <p>GitHub | PyPI | Discord</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Get up and running in 5 minutes with your first journey.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>Understand Journeys, Checkpoints, Branches, and State Management.</p>"},{"location":"#tutorials","title":"Tutorials","text":"<p>Step-by-step guides for common testing scenarios.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>Complete API documentation for all public classes and functions.</p>"},{"location":"advanced/","title":"Advanced Usage","text":"<p>This guide covers advanced features and patterns in VenomQA.</p> <p>Prerequisites: Familiarity with Journeys and Configuration.</p>"},{"location":"advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Caching</li> <li>Parallel Execution</li> <li>Custom Reporters</li> <li>Custom State Backends</li> <li>Hooks and Extensions</li> <li>Performance Optimization</li> <li>Error Handling Strategies</li> <li>Testing Patterns</li> </ul>"},{"location":"advanced/#related-documentation","title":"Related Documentation","text":"Topic Document API Reference api.md Adapters adapters.md Examples examples.md FAQ FAQ.md"},{"location":"advanced/#caching","title":"Caching","text":""},{"location":"advanced/#response-caching","title":"Response Caching","text":"<p>Cache responses to speed up repeated requests:</p> Python<pre><code>from functools import lru_cache\nfrom venomqa import Client\n\nclass CachedClient(Client):\n    \"\"\"HTTP client with response caching for GET requests.\"\"\"\n\n    def __init__(self, *args, cache_size: int = 100, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._cache_size = cache_size\n        self._get_cached = lru_cache(maxsize=cache_size)(self._get_uncached)\n\n    def _get_uncached(self, path: str, cache_key: str) -&gt; dict:\n        \"\"\"Uncached GET implementation.\"\"\"\n        return super().get(path)\n\n    def get(self, path: str, **kwargs) -&gt; dict:\n        # Create cache key from path and params\n        import json\n        cache_key = json.dumps({\"path\": path, \"kwargs\": kwargs}, sort_keys=True)\n        return self._get_cached(path, cache_key)\n\n    def clear_cache(self):\n        \"\"\"Clear the response cache.\"\"\"\n        self._get_cached.cache_clear()\n</code></pre>"},{"location":"advanced/#authentication-token-caching","title":"Authentication Token Caching","text":"<p>Cache auth tokens across steps:</p> Python<pre><code>from venomqa.core.context import ExecutionContext\n\ndef login_with_cache(client, context: ExecutionContext):\n    \"\"\"Login with token caching to avoid repeated auth.\"\"\"\n    cached_token = context.get(\"_cached_auth_token\")\n\n    if cached_token:\n        client.set_auth_token(cached_token)\n        # Verify token still works\n        response = client.get(\"/api/auth/verify\")\n        if response.status_code == 200:\n            return response\n\n    # Perform fresh login\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n\n    if response.status_code == 200:\n        token = response.json()[\"token\"]\n        context[\"_cached_auth_token\"] = token\n        client.set_auth_token(token)\n\n    return response\n</code></pre>"},{"location":"advanced/#fixture-data-caching","title":"Fixture Data Caching","text":"<p>Cache expensive setup operations:</p> Python<pre><code>import hashlib\nimport pickle\nfrom pathlib import Path\n\nclass FixtureCache:\n    \"\"\"Cache fixture data to disk.\"\"\"\n\n    def __init__(self, cache_dir: str = \".venomqa_cache\"):\n        self.cache_dir = Path(cache_dir)\n        self.cache_dir.mkdir(exist_ok=True)\n\n    def _cache_key(self, data: dict) -&gt; str:\n        return hashlib.md5(pickle.dumps(data)).hexdigest()\n\n    def get(self, key: str) -&gt; dict | None:\n        cache_file = self.cache_dir / f\"{key}.pkl\"\n        if cache_file.exists():\n            return pickle.loads(cache_file.read_bytes())\n        return None\n\n    def set(self, key: str, data: dict) -&gt; None:\n        cache_file = self.cache_dir / f\"{key}.pkl\"\n        cache_file.write_bytes(pickle.dumps(data))\n\n    def cached_setup(self, setup_func, *args, **kwargs):\n        \"\"\"Run setup function with caching.\"\"\"\n        cache_key = self._cache_key({\"func\": setup_func.__name__, \"args\": args, \"kwargs\": kwargs})\n\n        cached = self.get(cache_key)\n        if cached is not None:\n            return cached\n\n        result = setup_func(*args, **kwargs)\n        self.set(cache_key, result)\n        return result\n</code></pre>"},{"location":"advanced/#parallel-execution","title":"Parallel Execution","text":""},{"location":"advanced/#enabling-parallel-paths","title":"Enabling Parallel Paths","text":"<p>Run branch paths in parallel:</p> Python<pre><code>from venomqa import JourneyRunner\n\nrunner = JourneyRunner(\n    client=client,\n    state_manager=state_manager,\n    parallel_paths=4,  # Run up to 4 paths concurrently\n)\n\nresult = runner.run(journey)\n</code></pre>"},{"location":"advanced/#configuration","title":"Configuration","text":"YAML<pre><code># venomqa.yaml\nparallel_paths: 4\n</code></pre>"},{"location":"advanced/#considerations-for-parallel-execution","title":"Considerations for Parallel Execution","text":"<ol> <li>State Isolation: Each parallel path needs isolated state</li> <li>Resource Limits: Don't exceed database connection limits</li> <li>Rate Limiting: APIs may have rate limits</li> </ol>"},{"location":"advanced/#isolating-state-for-parallel-paths","title":"Isolating State for Parallel Paths","text":"<p>When running in parallel, each path needs its own context:</p> Python<pre><code># The runner automatically handles this by:\n# 1. Creating a context snapshot before the branch\n# 2. Restoring the snapshot for each path\n# 3. Each path gets its own isolated context\n\n# For database state, ensure:\n# 1. Each path uses different record IDs\n# 2. Or use database-level transactions with SAVEPOINT\n</code></pre>"},{"location":"advanced/#parallel-journey-execution","title":"Parallel Journey Execution","text":"<p>Run multiple journeys in parallel:</p> Python<pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed\nfrom venomqa import JourneyRunner, Client\n\ndef run_journey(journey, config):\n    client = Client(base_url=config.base_url)\n    runner = JourneyRunner(client=client)\n    return runner.run(journey)\n\ndef run_all_parallel(journeys, config, max_workers=4):\n    results = []\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(run_journey, j, config): j\n            for j in journeys\n        }\n\n        for future in as_completed(futures):\n            journey = futures[future]\n            try:\n                result = future.result()\n                results.append(result)\n            except Exception as e:\n                print(f\"Journey {journey.name} failed: {e}\")\n\n    return results\n</code></pre>"},{"location":"advanced/#custom-reporters","title":"Custom Reporters","text":""},{"location":"advanced/#creating-a-custom-reporter","title":"Creating a Custom Reporter","text":"Python<pre><code>from pathlib import Path\nfrom typing import Any\nfrom venomqa.reporters.base import BaseReporter\nfrom venomqa.core.models import JourneyResult\n\nclass CSVReporter(BaseReporter):\n    \"\"\"Generate CSV reports for spreadsheet analysis.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".csv\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        lines = [\n            \"journey_name,success,duration_ms,total_steps,passed_steps,issue_count\"\n        ]\n\n        for result in results:\n            lines.append(\n                f\"{result.journey_name},\"\n                f\"{result.success},\"\n                f\"{result.duration_ms:.0f},\"\n                f\"{result.total_steps},\"\n                f\"{result.passed_steps},\"\n                f\"{len(result.issues)}\"\n            )\n\n        return \"\\n\".join(lines)\n\n\nclass SlackReporter(BaseReporter):\n    \"\"\"Send test results to Slack.\"\"\"\n\n    def __init__(self, webhook_url: str, output_path: str | Path | None = None):\n        super().__init__(output_path)\n        self.webhook_url = webhook_url\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".json\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; dict[str, Any]:\n        passed = sum(1 for r in results if r.success)\n        failed = len(results) - passed\n\n        color = \"good\" if failed == 0 else \"danger\"\n        status = \"All tests passed!\" if failed == 0 else f\"{failed} test(s) failed\"\n\n        return {\n            \"attachments\": [{\n                \"color\": color,\n                \"title\": \"VenomQA Test Results\",\n                \"text\": status,\n                \"fields\": [\n                    {\"title\": \"Passed\", \"value\": str(passed), \"short\": True},\n                    {\"title\": \"Failed\", \"value\": str(failed), \"short\": True},\n                ],\n            }]\n        }\n\n    def send_to_slack(self, results: list[JourneyResult]) -&gt; None:\n        import httpx\n\n        payload = self.generate(results)\n        httpx.post(self.webhook_url, json=payload)\n\n\nclass HTMLDashboardReporter(BaseReporter):\n    \"\"\"Generate interactive HTML dashboard.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".html\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        return f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;VenomQA Dashboard&lt;/title&gt;\n    &lt;style&gt;\n        body {{ font-family: system-ui, sans-serif; margin: 40px; }}\n        .card {{ border: 1px solid #e5e5e5; border-radius: 8px; padding: 16px; margin: 16px 0; }}\n        .passed {{ border-left: 4px solid #22c55e; }}\n        .failed {{ border-left: 4px solid #ef4444; }}\n        .metrics {{ display: flex; gap: 24px; }}\n        .metric {{ text-align: center; }}\n        .metric-value {{ font-size: 2em; font-weight: bold; }}\n        .metric-label {{ color: #666; }}\n        table {{ width: 100%; border-collapse: collapse; }}\n        th, td {{ padding: 8px; text-align: left; border-bottom: 1px solid #e5e5e5; }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;VenomQA Dashboard&lt;/h1&gt;\n\n    &lt;div class=\"card\"&gt;\n        &lt;div class=\"metrics\"&gt;\n            {self._generate_metrics(results)}\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"card\"&gt;\n        &lt;h2&gt;Journey Results&lt;/h2&gt;\n        &lt;table&gt;\n            &lt;tr&gt;\n                &lt;th&gt;Journey&lt;/th&gt;\n                &lt;th&gt;Status&lt;/th&gt;\n                &lt;th&gt;Duration&lt;/th&gt;\n                &lt;th&gt;Steps&lt;/th&gt;\n                &lt;th&gt;Issues&lt;/th&gt;\n            &lt;/tr&gt;\n            {self._generate_rows(results)}\n        &lt;/table&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n\n    def _generate_metrics(self, results: list[JourneyResult]) -&gt; str:\n        passed = sum(1 for r in results if r.success)\n        failed = len(results) - passed\n        total_duration = sum(r.duration_ms for r in results)\n\n        return f\"\"\"\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\" style=\"color: #22c55e;\"&gt;{passed}&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Passed&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\" style=\"color: #ef4444;\"&gt;{failed}&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Failed&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\"&gt;{total_duration/1000:.1f}s&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Duration&lt;/div&gt;\n            &lt;/div&gt;\n        \"\"\"\n\n    def _generate_rows(self, results: list[JourneyResult]) -&gt; str:\n        rows = []\n        for r in results:\n            status_class = \"passed\" if r.success else \"failed\"\n            status_icon = \"\u2713\" if r.success else \"\u2717\"\n            rows.append(f\"\"\"\n                &lt;tr class=\"{status_class}\"&gt;\n                    &lt;td&gt;{r.journey_name}&lt;/td&gt;\n                    &lt;td&gt;{status_icon}&lt;/td&gt;\n                    &lt;td&gt;{r.duration_ms:.0f}ms&lt;/td&gt;\n                    &lt;td&gt;{r.passed_steps}/{r.total_steps}&lt;/td&gt;\n                    &lt;td&gt;{len(r.issues)}&lt;/td&gt;\n                &lt;/tr&gt;\n            \"\"\")\n        return \"\\n\".join(rows)\n</code></pre>"},{"location":"advanced/#using-custom-reporters","title":"Using Custom Reporters","text":"Python<pre><code>from venomqa.reporters import MarkdownReporter\n\n# Use built-in reporter\nreporter = MarkdownReporter(output_path=\"reports/test.md\")\nreporter.save([result1, result2])\n\n# Use custom reporter\ncsv_reporter = CSVReporter(output_path=\"reports/results.csv\")\ncsv_reporter.save([result1, result2])\n\nslack_reporter = SlackReporter(webhook_url=\"https://hooks.slack.com/...\")\nslack_reporter.send_to_slack([result1, result2])\n</code></pre>"},{"location":"advanced/#custom-state-backends","title":"Custom State Backends","text":"<p>See Database Backends for implementing custom state backends.</p>"},{"location":"advanced/#hooks-and-extensions","title":"Hooks and Extensions","text":""},{"location":"advanced/#prepost-step-hooks","title":"Pre/Post Step Hooks","text":"Python<pre><code>from venomqa import JourneyRunner, Step\nfrom venomqa.core.models import StepResult\nfrom typing import Callable\n\nclass HookedJourneyRunner(JourneyRunner):\n    \"\"\"Runner with pre/post step hooks.\"\"\"\n\n    def __init__(self, *args, \n                 pre_step_hook: Callable | None = None,\n                 post_step_hook: Callable | None = None,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        self.pre_step_hook = pre_step_hook\n        self.post_step_hook = post_step_hook\n\n    def _run_step(self, step: Step, journey_name: str, path_name: str, context) -&gt; StepResult:\n        # Pre-step hook\n        if self.pre_step_hook:\n            self.pre_step_hook(step=step, journey=journey_name, path=path_name, context=context)\n\n        # Run the step\n        result = super()._run_step(step, journey_name, path_name, context)\n\n        # Post-step hook\n        if self.post_step_hook:\n            self.post_step_hook(step=step, result=result, context=context)\n\n        return result\n\n\n# Usage\ndef log_step(step, journey, path, context):\n    print(f\"Running: {journey}/{path}/{step.name}\")\n\ndef capture_screenshot_on_failure(step, result, context):\n    if not result.success:\n        # Take screenshot, save logs, etc.\n        print(f\"Step {step.name} failed, capturing diagnostics...\")\n\nrunner = HookedJourneyRunner(\n    client=client,\n    pre_step_hook=log_step,\n    post_step_hook=capture_screenshot_on_failure,\n)\n</code></pre>"},{"location":"advanced/#journey-lifecycle-hooks","title":"Journey Lifecycle Hooks","text":"Python<pre><code>class LifecycleRunner(JourneyRunner):\n    \"\"\"Runner with full lifecycle hooks.\"\"\"\n\n    def __init__(self, *args,\n                 on_journey_start: Callable | None = None,\n                 on_journey_end: Callable | None = None,\n                 on_branch_start: Callable | None = None,\n                 on_branch_end: Callable | None = None,\n                 on_path_start: Callable | None = None,\n                 on_path_end: Callable | None = None,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        self.on_journey_start = on_journey_start\n        self.on_journey_end = on_journey_end\n        self.on_branch_start = on_branch_start\n        self.on_branch_end = on_branch_end\n        self.on_path_start = on_path_start\n        self.on_path_end = on_path_end\n\n    def run(self, journey):\n        if self.on_journey_start:\n            self.on_journey_start(journey=journey)\n\n        result = super().run(journey)\n\n        if self.on_journey_end:\n            self.on_journey_end(journey=journey, result=result)\n\n        return result\n</code></pre>"},{"location":"advanced/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/#reduce-request-overhead","title":"Reduce Request Overhead","text":"Python<pre><code># Reuse client across journeys\nclient = Client(base_url=\"http://localhost:8000\")\nclient.connect()  # Keep connection open\n\nfor journey in journeys:\n    runner = JourneyRunner(client=client)\n    result = runner.run(journey)\n\nclient.disconnect()\n</code></pre>"},{"location":"advanced/#batch-operations","title":"Batch Operations","text":"Python<pre><code>def create_items_batch(client, context):\n    \"\"\"Create multiple items in one request.\"\"\"\n    items = [{\"name\": f\"Item {i}\"} for i in range(10)]\n    return client.post(\"/api/items/batch\", json={\"items\": items})\n</code></pre>"},{"location":"advanced/#skip-unnecessary-steps","title":"Skip Unnecessary Steps","text":"Python<pre><code>def conditional_step(client, context):\n    # Skip if already done\n    if context.get(\"setup_complete\"):\n        return {\"status\": \"skipped\"}\n\n    # Do expensive setup\n    result = client.post(\"/api/setup\", json={...})\n    context[\"setup_complete\"] = True\n    return result\n</code></pre>"},{"location":"advanced/#parallel-data-setup","title":"Parallel Data Setup","text":"Python<pre><code>from concurrent.futures import ThreadPoolExecutor\n\ndef setup_test_data_parallel(client, context):\n    \"\"\"Setup test data in parallel.\"\"\"\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        futures = [\n            executor.submit(client.post, \"/api/users\", json={\"name\": f\"User {i}\"})\n            for i in range(10)\n        ]\n        results = [f.result() for f in futures]\n\n    context[\"user_ids\"] = [r.json()[\"id\"] for r in results]\n    return results\n</code></pre>"},{"location":"advanced/#error-handling-strategies","title":"Error Handling Strategies","text":""},{"location":"advanced/#graceful-degradation","title":"Graceful Degradation","text":"Python<pre><code>def resilient_step(client, context):\n    \"\"\"Step that degrades gracefully on failure.\"\"\"\n    try:\n        response = client.get(\"/api/features\")\n        context[\"features\"] = response.json()\n    except Exception:\n        # Use defaults if features API is down\n        context[\"features\"] = {\"default_feature\": True}\n\n    return response\n</code></pre>"},{"location":"advanced/#retry-with-exponential-backoff","title":"Retry with Exponential Backoff","text":"Python<pre><code>import time\nimport random\n\ndef retry_with_backoff(func, max_retries=3, base_delay=1.0):\n    \"\"\"Execute function with exponential backoff retry.\"\"\"\n    for attempt in range(max_retries):\n        try:\n            return func()\n        except Exception as e:\n            if attempt == max_retries - 1:\n                raise\n\n            delay = base_delay * (2 ** attempt) + random.uniform(0, 1)\n            time.sleep(delay)\n\ndef flaky_api_call(client, context):\n    return retry_with_backoff(\n        lambda: client.get(\"/api/flaky-endpoint\"),\n        max_retries=5,\n        base_delay=0.5,\n    )\n</code></pre>"},{"location":"advanced/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"Python<pre><code>from datetime import datetime, timedelta\nfrom enum import Enum\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"\n    OPEN = \"open\"\n    HALF_OPEN = \"half_open\"\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker for unreliable services.\"\"\"\n\n    def __init__(self, failure_threshold: int = 3, recovery_timeout: float = 30.0):\n        self.failure_threshold = failure_threshold\n        self.recovery_timeout = recovery_timeout\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n        self.last_failure_time: datetime | None = None\n\n    def execute(self, func):\n        if self.state == CircuitState.OPEN:\n            if self._should_try_recovery():\n                self.state = CircuitState.HALF_OPEN\n            else:\n                raise Exception(\"Circuit breaker is open\")\n\n        try:\n            result = func()\n            self._on_success()\n            return result\n        except Exception as e:\n            self._on_failure()\n            raise e\n\n    def _should_try_recovery(self) -&gt; bool:\n        if self.last_failure_time is None:\n            return True\n        return datetime.now() - self.last_failure_time &gt; timedelta(seconds=self.recovery_timeout)\n\n    def _on_success(self):\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n\n    def _on_failure(self):\n        self.failures += 1\n        self.last_failure_time = datetime.now()\n        if self.failures &gt;= self.failure_threshold:\n            self.state = CircuitState.OPEN\n\n# Usage\ncircuit = CircuitBreaker(failure_threshold=3, recovery_timeout=30)\n\ndef protected_api_call(client, context):\n    return circuit.execute(lambda: client.get(\"/api/unreliable\"))\n</code></pre>"},{"location":"advanced/#known-limitations","title":"Known Limitations","text":""},{"location":"advanced/#parallel-path-execution-with-state-management","title":"Parallel Path Execution with State Management","text":"<p>When using <code>parallel_paths &gt; 1</code> (parallel branch execution), database state isolation is not guaranteed. Each path should start from the checkpoint state, but with parallel execution:</p> <ul> <li>All threads share the same database connection</li> <li>Rollback doesn't happen between parallel paths</li> <li>Paths may interfere with each other's database state</li> </ul> <p>Recommendation: Use <code>parallel_paths=1</code> (sequential execution) when: - Your journeys use database checkpoints and rollback - Your paths modify database state - State isolation between paths is important</p> <p>Parallel execution is safe when: - You're only testing read operations - Paths are independent and don't rely on specific database state - You're using the MockStateManager (in-memory)</p>"},{"location":"advanced/#testing-patterns","title":"Testing Patterns","text":""},{"location":"advanced/#data-driven-testing","title":"Data-Driven Testing","text":"Python<pre><code>from venomqa import Journey, Step\n\n# Test with multiple data sets\ntest_cases = [\n    {\"name\": \"valid_user\", \"email\": \"test@example.com\", \"expect_success\": True},\n    {\"name\": \"invalid_email\", \"email\": \"invalid\", \"expect_success\": False},\n    {\"name\": \"missing_email\", \"email\": None, \"expect_success\": False},\n]\n\njourneys = []\nfor case in test_cases:\n    def register_test(client, context, case=case):\n        return client.post(\"/api/register\", json={\"email\": case[\"email\"]})\n\n    journey = Journey(\n        name=f\"register_{case['name']}\",\n        steps=[\n            Step(\n                name=\"register\",\n                action=register_test,\n                expect_failure=not case[\"expect_success\"],\n            ),\n        ],\n    )\n    journeys.append(journey)\n</code></pre>"},{"location":"advanced/#smoke-tests","title":"Smoke Tests","text":"Python<pre><code>smoke_journey = Journey(\n    name=\"smoke_test\",\n    description=\"Quick health check of critical endpoints\",\n    timeout=30.0,\n    steps=[\n        Step(name=\"health\", action=lambda c, ctx: c.get(\"/health\")),\n        Step(name=\"api_status\", action=lambda c, ctx: c.get(\"/api/status\")),\n        Step(name=\"db_ping\", action=lambda c, ctx: c.get(\"/api/ping/db\")),\n    ],\n)\n</code></pre>"},{"location":"advanced/#regression-tests","title":"Regression Tests","text":"Python<pre><code># Capture expected responses for regression testing\nexpected_responses = {\n    \"get_user\": {\"id\": 1, \"name\": \"Test User\"},\n}\n\ndef regression_test_step(client, context):\n    response = client.get(\"/api/users/1\")\n    actual = response.json()\n    expected = expected_responses[\"get_user\"]\n\n    if actual != expected:\n        context[\"regression_diff\"] = {\n            \"expected\": expected,\n            \"actual\": actual,\n        }\n        raise AssertionError(\"Response differs from expected\")\n\n    return response\n</code></pre>"},{"location":"advanced/#chaos-testing","title":"Chaos Testing","text":"Python<pre><code>import random\n\ndef chaos_step(client, context):\n    \"\"\"Introduce random failures for resilience testing.\"\"\"\n    # Randomly fail 10% of the time\n    if random.random() &lt; 0.1:\n        raise Exception(\"Chaos monkey strike!\")\n\n    return client.get(\"/api/data\")\n\ndef slow_network_step(client, context):\n    \"\"\"Simulate slow network conditions.\"\"\"\n    import time\n    time.sleep(random.uniform(0.5, 2.0))  # Random delay\n    return client.get(\"/api/data\")\n</code></pre>"},{"location":"advanced/#ports-adapters","title":"Ports &amp; Adapters","text":"<p>The Ports and Adapters architecture enables clean separation between test logic and external dependencies.</p>"},{"location":"advanced/#dependency-injection-pattern","title":"Dependency Injection Pattern","text":"<p>Inject adapters through constructor or fixtures:</p> Python<pre><code>import pytest\nfrom venomqa.ports import CachePort, MailPort\nfrom venomqa.adapters import RedisCacheAdapter, MailhogAdapter\n\nclass TestUserRegistration:\n    def __init__(self, cache: CachePort, mail: MailPort):\n        self.cache = cache\n        self.mail = mail\n\n    def test_registration_sends_email(self):\n        # Register user\n        self.register_user(\"test@example.com\")\n\n        # Verify email was sent\n        email = self.mail.wait_for_email(\n            to=\"test@example.com\",\n            subject=\"Welcome\",\n            timeout=30.0,\n        )\n        assert email is not None\n\n        # Verify cache was updated\n        assert self.cache.exists(\"user:test@example.com\")\n\n# Using with pytest fixtures\n@pytest.fixture\ndef cache():\n    return RedisCacheAdapter(host=\"localhost\")\n\n@pytest.fixture\ndef mail():\n    return MailhogAdapter(host=\"localhost\")\n\ndef test_with_adapters(cache, mail):\n    tester = TestUserRegistration(cache, mail)\n    tester.test_registration_sends_email()\n</code></pre>"},{"location":"advanced/#swapping-adapters-for-testing","title":"Swapping Adapters for Testing","text":"<p>Use different adapters for different test environments:</p> Python<pre><code>from venomqa.ports import CachePort\nfrom venomqa.adapters import RedisCacheAdapter, LocalStorageAdapter\n\ndef get_cache_adapter(env: str) -&gt; CachePort:\n    if env == \"production\":\n        return RedisCacheAdapter(\n            host=\"redis.production.internal\",\n            password=os.environ[\"REDIS_PASSWORD\"],\n        )\n    elif env == \"staging\":\n        return RedisCacheAdapter(host=\"localhost\")\n    else:\n        # In-memory adapter for unit tests\n        return LocalStorageAdapter(base_path=\"/tmp/test-cache\")\n</code></pre>"},{"location":"advanced/#time-travel-testing","title":"Time Travel Testing","text":"<p>Test time-dependent logic without waiting:</p> Python<pre><code>from datetime import timedelta\nfrom venomqa.adapters import ControllableTimeAdapter\n\ndef test_token_expiration():\n    time = ControllableTimeAdapter()\n    time.freeze()\n\n    # Create token that expires in 1 hour\n    token = create_token(expires_in=3600)\n    assert token.is_valid()\n\n    # Fast forward 59 minutes\n    time.advance(timedelta(minutes=59))\n    assert token.is_valid()\n\n    # Fast forward 1 more minute - token should expire\n    time.advance(timedelta(minutes=1))\n    assert not token.is_valid()\n\ndef test_scheduled_task():\n    time = ControllableTimeAdapter()\n    results = []\n\n    def callback():\n        results.append(\"executed\")\n\n    # Schedule task for 5 seconds\n    time.schedule_after(5.0, callback)\n\n    # Time hasn't advanced yet\n    assert len(results) == 0\n\n    # Advance past scheduled time\n    time.advance(timedelta(seconds=5))\n    assert len(results) == 1\n</code></pre>"},{"location":"advanced/#mock-server-integration","title":"Mock Server Integration","text":"<p>Use WireMock for API stubbing in tests:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import WireMockAdapter\nfrom venomqa import Client\n\n@pytest.fixture\ndef mock_server():\n    mock = WireMockAdapter(port=8080)\n    yield mock\n    mock.reset()\n\ndef test_api_with_mock(mock_server):\n    # Stub API response\n    mock_server.stub(\n        \"GET\",\n        \"/api/users/1\",\n        body={\"id\": 1, \"name\": \"John Doe\"},\n        status_code=200,\n    )\n\n    # Stub error response\n    mock_server.stub(\n        \"GET\",\n        \"/api/users/999\",\n        body={\"error\": \"Not found\"},\n        status_code=404,\n    )\n\n    # Use mocked API\n    client = Client(base_url=mock_server.get_base_url())\n\n    response = client.get(\"/api/users/1\")\n    assert response.status_code == 200\n    assert response.json()[\"name\"] == \"John Doe\"\n\n    # Verify request was made\n    assert mock_server.verify(\"GET\", \"/api/users/1\", count=1)\n\ndef test_sequential_responses(mock_server):\n    # Return different responses on each call\n    mock_server.stub_sequence(\"POST\", \"/api/orders\", responses=[\n        MockResponse(status_code=201, body={\"id\": 1}),\n        MockResponse(status_code=201, body={\"id\": 2}),\n        MockResponse(status_code=429, body={\"error\": \"Rate limited\"}),\n    ])\n\n    client = Client(base_url=mock_server.get_base_url())\n\n    # First call\n    r1 = client.post(\"/api/orders\")\n    assert r1.status_code == 201\n\n    # Second call\n    r2 = client.post(\"/api/orders\")\n    assert r2.status_code == 201\n\n    # Third call - rate limited\n    r3 = client.post(\"/api/orders\")\n    assert r3.status_code == 429\n</code></pre>"},{"location":"advanced/#parallel-task-execution","title":"Parallel Task Execution","text":"<p>Test concurrent operations:</p> Python<pre><code>from venomqa.adapters import ThreadingConcurrencyAdapter\n\ndef test_concurrent_requests():\n    concurrency = ThreadingConcurrencyAdapter(max_workers=10)\n\n    def make_request(user_id):\n        # Simulate API call\n        return client.get(f\"/api/users/{user_id}\")\n\n    # Spawn 100 concurrent tasks\n    task_ids = concurrency.map_async(make_request, range(100))\n\n    # Wait for all to complete\n    results = concurrency.join_all(task_ids, timeout=30.0)\n\n    # Verify all succeeded\n    successful = [r for r in results if r.success]\n    assert len(successful) == 100\n</code></pre>"},{"location":"advanced/#email-testing-workflow","title":"Email Testing Workflow","text":"<p>Complete email testing with cleanup:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import MailhogAdapter\n\n@pytest.fixture\ndef mail():\n    adapter = MailhogAdapter(host=\"localhost\")\n    adapter.delete_all_emails()  # Clean slate\n    yield adapter\n    adapter.delete_all_emails()  # Cleanup\n\ndef test_password_reset_email(mail):\n    # Request password reset\n    response = client.post(\"/api/auth/forgot-password\", json={\n        \"email\": \"user@example.com\",\n    })\n    assert response.status_code == 200\n\n    # Wait for and verify email\n    email = mail.wait_for_email(\n        to=\"user@example.com\",\n        subject=\"Password Reset\",\n        timeout=30.0,\n    )\n\n    assert email is not None\n    assert \"reset\" in email.body.lower()\n\n    # Extract reset link from email\n    import re\n    match = re.search(r'https://\\S+/reset/\\S+', email.body)\n    assert match\n    reset_link = match.group(0)\n\n    # Use reset link\n    response = client.post(reset_link, json={\"password\": \"newpass123\"})\n    assert response.status_code == 200\n</code></pre>"},{"location":"advanced/#cache-testing-patterns","title":"Cache Testing Patterns","text":"<p>Test cache behavior:</p> Python<pre><code>from venomqa.adapters import RedisCacheAdapter\n\ndef test_cache_expiration():\n    cache = RedisCacheAdapter()\n\n    # Set with TTL\n    cache.set(\"session:abc123\", {\"user_id\": 1}, ttl=60)\n\n    # Verify exists\n    assert cache.exists(\"session:abc123\")\n\n    # Check TTL\n    ttl = cache.get_ttl(\"session:abc123\")\n    assert 0 &lt; ttl &lt;= 60\n\n    # Get stats\n    stats = cache.get_stats()\n    print(f\"Hit rate: {stats.hit_rate}%\")\n\ndef test_cache_invalidation():\n    cache = RedisCacheAdapter()\n\n    # Cache user data\n    cache.set(\"user:1\", {\"name\": \"John\", \"role\": \"user\"})\n\n    # Update user\n    update_user(1, role=\"admin\")\n\n    # Invalidate cache\n    cache.delete(\"user:1\")\n\n    # Next read will fetch fresh data\n    user = cache.get(\"user:1\")\n    assert user is None\n</code></pre>"},{"location":"advanced/#queue-testing-patterns","title":"Queue Testing Patterns","text":"<p>Test async job processing:</p> Python<pre><code>from venomqa.adapters import RedisQueueAdapter\n\ndef test_job_queue():\n    queue = RedisQueueAdapter(host=\"localhost\")\n\n    # Clear queue\n    queue.clear_queue(\"test\")\n\n    # Enqueue job\n    job_id = queue.enqueue(\n        \"myapp.tasks.send_notification\",\n        user_id=123,\n        message=\"Hello!\",\n        queue=\"test\",\n    )\n\n    # Check job status\n    job = queue.get_job(job_id)\n    assert job.status == \"pending\"\n\n    # Wait for completion (requires worker running)\n    result = queue.get_job_result(job_id, timeout=60.0)\n\n    if result:\n        assert result.success\n        print(f\"Job result: {result.result}\")\n\n    # Check for failed jobs\n    failed = queue.get_failed_jobs(queue=\"test\")\n    assert len(failed) == 0\n</code></pre>"},{"location":"advanced/#creating-test-fixtures-with-ports","title":"Creating Test Fixtures with Ports","text":"<p>Create reusable test fixtures:</p> Python<pre><code>import pytest\nfrom typing import TypeVar, Protocol\nfrom venomqa.ports import CachePort, MailPort, QueuePort\n\nT = TypeVar('T')\n\nclass TestFixtures:\n    \"\"\"Collection of test fixtures using ports.\"\"\"\n\n    def __init__(\n        self,\n        cache: CachePort,\n        mail: MailPort,\n        queue: QueuePort,\n    ):\n        self.cache = cache\n        self.mail = mail\n        self.queue = queue\n\n    def reset(self):\n        \"\"\"Reset all fixtures to clean state.\"\"\"\n        self.cache.clear()\n        self.mail.delete_all_emails()\n        self.queue.clear_queue()\n\n    def cached_user(self, user_id: int) -&gt; dict:\n        \"\"\"Get or create cached user.\"\"\"\n        key = f\"test:user:{user_id}\"\n        user = self.cache.get(key)\n        if user is None:\n            user = {\"id\": user_id, \"name\": f\"User {user_id}\"}\n            self.cache.set(key, user, ttl=300)\n        return user\n\n@pytest.fixture\ndef fixtures():\n    from venomqa.adapters import (\n        RedisCacheAdapter,\n        MailhogAdapter,\n        RedisQueueAdapter,\n    )\n\n    fx = TestFixtures(\n        cache=RedisCacheAdapter(),\n        mail=MailhogAdapter(),\n        queue=RedisQueueAdapter(),\n    )\n    fx.reset()\n    yield fx\n    fx.reset()\n</code></pre>"},{"location":"advanced/#health-check-pattern","title":"Health Check Pattern","text":"<p>Verify external services before tests:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import (\n    RedisCacheAdapter,\n    MailhogAdapter,\n    ElasticsearchAdapter,\n)\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef verify_services():\n    \"\"\"Verify all required services are healthy.\"\"\"\n    services = [\n        (\"Redis\", RedisCacheAdapter()),\n        (\"MailHog\", MailhogAdapter()),\n        (\"Elasticsearch\", ElasticsearchAdapter()),\n    ]\n\n    unhealthy = []\n    for name, adapter in services:\n        if not adapter.health_check():\n            unhealthy.append(name)\n\n    if unhealthy:\n        pytest.skip(f\"Services not available: {', '.join(unhealthy)}\")\n</code></pre>"},{"location":"advanced/#multi-environment-configuration","title":"Multi-Environment Configuration","text":"<p>Configure adapters for different environments:</p> Python<pre><code>from dataclasses import dataclass\nfrom venomqa.ports import CachePort, MailPort\nfrom venomqa.adapters import RedisCacheAdapter, MailhogAdapter, MailpitAdapter\n\n@dataclass\nclass Environment:\n    name: str\n    cache: CachePort\n    mail: MailPort\n\ndef get_environment() -&gt; Environment:\n    env_name = os.environ.get(\"ENV\", \"local\")\n\n    if env_name == \"production\":\n        return Environment(\n            name=\"production\",\n            cache=RedisCacheAdapter(\n                host=\"redis.prod.internal\",\n                password=os.environ[\"REDIS_PASSWORD\"],\n            ),\n            mail=MailpitAdapter(\n                host=\"mail.prod.internal\",\n                use_tls=True,\n            ),\n        )\n    elif env_name == \"staging\":\n        return Environment(\n            name=\"staging\",\n            cache=RedisCacheAdapter(host=\"localhost\"),\n            mail=MailhogAdapter(host=\"localhost\"),\n        )\n    else:\n        return Environment(\n            name=\"local\",\n            cache=RedisCacheAdapter(host=\"localhost\"),\n            mail=MailhogAdapter(host=\"localhost\"),\n        )\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to VenomQA will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>MkDocs documentation site with Material theme</li> <li>Comprehensive API documentation</li> <li>Tutorial guides for common scenarios</li> <li>Advanced usage documentation</li> </ul>"},{"location":"changelog/#020-2024-01-15","title":"[0.2.0] - 2024-01-15","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Ports and Adapters architecture</li> <li>Multiple cache adapters (Redis, Memory)</li> <li>Email testing adapters (Mailhog, Mailpit)</li> <li>Queue adapters (Redis Queue, Celery)</li> <li>Time control adapter for testing</li> <li>Mock server adapter (WireMock)</li> <li>SARIF report format</li> <li>Slack and Discord reporters</li> <li>Performance optimizations (connection pooling, caching)</li> <li>Security features (input validation, secrets management)</li> <li>File handling utilities</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improved error messages with fix suggestions</li> <li>Enhanced CLI output formatting</li> <li>Better parallel execution support</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Checkpoint rollback in nested branches</li> <li>Context restoration edge cases</li> <li>Connection handling in long-running journeys</li> </ul>"},{"location":"changelog/#010-2024-01-01","title":"[0.1.0] - 2024-01-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Initial release</li> <li>Core journey DSL (Journey, Step, Checkpoint, Branch, Path)</li> <li>PostgreSQL state management</li> <li>HTTP client with retry logic</li> <li>Basic reporters (Markdown, JSON, JUnit)</li> <li>Docker Compose integration</li> <li>CLI tool (venomqa run, venomqa list, venomqa report)</li> </ul>"},{"location":"changelog/#version-history","title":"Version History","text":"Version Date Highlights 0.2.0 2024-01-15 Ports &amp; Adapters, Performance 0.1.0 2024-01-01 Initial release"},{"location":"changelog/#upgrade-guide","title":"Upgrade Guide","text":""},{"location":"changelog/#01x-to-02x","title":"0.1.x to 0.2.x","text":"<p>No breaking changes. New features are additive.</p> <p>To use new adapters:</p> Bash<pre><code>pip install \"venomqa[redis,s3]\"  # Install adapter dependencies\n</code></pre>"},{"location":"changelog/#roadmap","title":"Roadmap","text":""},{"location":"changelog/#v030-enhanced-reporting","title":"v0.3.0 - Enhanced Reporting","text":"<ul> <li>Interactive HTML reports with charts</li> <li>Slack/Teams webhook notifications</li> <li>Test trend analysis</li> <li>Flaky test detection</li> </ul>"},{"location":"changelog/#v040-parallel-execution","title":"v0.4.0 - Parallel Execution","text":"<ul> <li>Distributed journey execution</li> <li>Shared state cache for checkpoints</li> <li>Resource-aware scheduling</li> </ul>"},{"location":"changelog/#v050-ai-powered-features","title":"v0.5.0 - AI-Powered Features","text":"<ul> <li>Journey generation from OpenAPI specs</li> <li>Intelligent failure analysis</li> <li>Anomaly detection</li> </ul> <p>See GitHub Projects for detailed tracking.</p>"},{"location":"ci-cd/","title":"VenomQA CI/CD Integration Guide","text":"<p>This guide covers how to integrate VenomQA into your CI/CD pipelines for automated journey testing.</p>"},{"location":"ci-cd/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Exit Codes</li> <li>GitHub Actions</li> <li>GitLab CI</li> <li>Docker-based Runner</li> <li>Other CI Systems</li> <li>Best Practices</li> <li>Handling Secrets</li> <li>Parallelization Strategies</li> <li>Troubleshooting</li> </ul>"},{"location":"ci-cd/#overview","title":"Overview","text":"<p>VenomQA is designed for CI/CD environments with proper exit codes, report generation, and configurable timeouts. The CLI returns meaningful exit codes that CI systems can use to determine build success or failure.</p>"},{"location":"ci-cd/#key-features-for-cicd","title":"Key Features for CI/CD","text":"<ul> <li>Proper Exit Codes: Clear indication of success, failure, or configuration errors</li> <li>Multiple Report Formats: JUnit XML, HTML, JSON, and Markdown</li> <li>Docker Support: Pre-built runner image for consistent environments</li> <li>Parallel Execution: Run journey groups in parallel for faster feedback</li> <li>Service Orchestration: Integration with Docker Compose for test dependencies</li> </ul>"},{"location":"ci-cd/#exit-codes","title":"Exit Codes","text":"<p>VenomQA uses standard exit codes for CI/CD integration:</p> Exit Code Meaning CI Action <code>0</code> All journeys passed Build succeeds <code>1</code> Some journeys failed Build fails <code>2</code> Configuration error Build fails (setup issue) <p>Example usage in shell scripts:</p> Bash<pre><code>venomqa run --config qa/venomqa.yaml\nEXIT_CODE=$?\n\ncase $EXIT_CODE in\n    0)\n        echo \"All journeys passed!\"\n        ;;\n    1)\n        echo \"Some journeys failed - check reports\"\n        exit 1\n        ;;\n    2)\n        echo \"Configuration error - check venomqa.yaml\"\n        exit 2\n        ;;\nesac\n</code></pre>"},{"location":"ci-cd/#github-actions","title":"GitHub Actions","text":""},{"location":"ci-cd/#basic-setup","title":"Basic Setup","text":"<p>Create <code>.github/workflows/venomqa.yml</code>:</p> YAML<pre><code>name: VenomQA Tests\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:15-alpine\n        env:\n          POSTGRES_USER: qa\n          POSTGRES_PASSWORD: ${{ secrets.QA_DB_PASSWORD }}\n          POSTGRES_DB: venomqa_qa\n        ports:\n          - 5432:5432\n        options: &gt;-\n          --health-cmd \"pg_isready -U qa\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.12'\n          cache: 'pip'\n\n      - name: Install VenomQA\n        run: pip install venomqa[all]\n\n      - name: Start application\n        run: docker compose up -d --wait\n\n      - name: Run journeys\n        run: |\n          venomqa run --config qa/venomqa.yaml\n\n      - name: Generate reports\n        if: always()\n        run: |\n          mkdir -p reports\n          venomqa report --format junit --output reports/junit.xml\n          venomqa report --format html --output reports/report.html\n\n      - name: Upload reports\n        uses: actions/upload-artifact@v4\n        if: always()\n        with:\n          name: venomqa-reports\n          path: reports/\n</code></pre>"},{"location":"ci-cd/#parallel-journey-groups","title":"Parallel Journey Groups","text":"<p>For larger test suites, run journey groups in parallel:</p> YAML<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        group: [auth, checkout, api, content]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Run ${{ matrix.group }} journeys\n        run: |\n          venomqa run ${{ matrix.group }}_* --config qa/venomqa.yaml\n</code></pre>"},{"location":"ci-cd/#full-example","title":"Full Example","text":"<p>See <code>.github/workflows/venomqa.yml.example</code> for a complete workflow with: - Configuration validation - Parallel test execution - Artifact collection - JUnit report publishing - Conditional deployment</p>"},{"location":"ci-cd/#gitlab-ci","title":"GitLab CI","text":""},{"location":"ci-cd/#basic-setup_1","title":"Basic Setup","text":"<p>Create <code>.gitlab-ci.yml</code>:</p> YAML<pre><code>stages:\n  - test\n  - deploy\n\nvariables:\n  POSTGRES_USER: qa\n  POSTGRES_PASSWORD: $QA_DB_PASSWORD\n  POSTGRES_DB: venomqa_qa\n\ntest:\n  stage: test\n  image: python:3.12\n  services:\n    - postgres:15-alpine\n    - redis:7-alpine\n  script:\n    - pip install venomqa[all]\n    - venomqa run --config qa/venomqa.yaml\n    - venomqa report --format junit --output reports/junit.xml\n  artifacts:\n    when: always\n    paths:\n      - reports/\n    reports:\n      junit: reports/junit.xml\n</code></pre>"},{"location":"ci-cd/#parallel-groups-with-gitlab","title":"Parallel Groups with GitLab","text":"YAML<pre><code>.test-template:\n  stage: test\n  image: python:3.12\n  services:\n    - postgres:15-alpine\n  before_script:\n    - pip install venomqa[all]\n  artifacts:\n    when: always\n    reports:\n      junit: reports/junit-*.xml\n\ntest-auth:\n  extends: .test-template\n  script:\n    - venomqa run auth_* --config qa/venomqa.yaml\n    - venomqa report --format junit --output reports/junit-auth.xml\n\ntest-checkout:\n  extends: .test-template\n  script:\n    - venomqa run checkout_* --config qa/venomqa.yaml\n    - venomqa report --format junit --output reports/junit-checkout.xml\n</code></pre>"},{"location":"ci-cd/#full-example_1","title":"Full Example","text":"<p>See <code>.gitlab-ci.yml.example</code> for a complete pipeline with: - Multi-stage workflow - Parallel job execution - GitLab Pages for reports - Environment-based deployment</p>"},{"location":"ci-cd/#docker-based-runner","title":"Docker-based Runner","text":"<p>VenomQA provides a Docker image that can run in any CI system.</p>"},{"location":"ci-cd/#building-the-runner-image","title":"Building the Runner Image","text":"Bash<pre><code># Build the runner image\ndocker build -f docker/Dockerfile.runner -t venomqa-runner:latest .\n\n# Or use multi-stage for smaller image\ndocker build -f docker/Dockerfile.runner --target production -t venomqa-runner:prod .\n</code></pre>"},{"location":"ci-cd/#using-the-runner","title":"Using the Runner","text":"Bash<pre><code># Run journeys with mounted volumes\ndocker run --rm \\\n  -e API_BASE_URL=http://host.docker.internal:8000 \\\n  -v $(pwd)/qa:/app/qa:ro \\\n  -v $(pwd)/reports:/app/reports \\\n  venomqa-runner:latest \\\n  run --config qa/venomqa.yaml\n</code></pre>"},{"location":"ci-cd/#docker-compose-integration","title":"Docker Compose Integration","text":"YAML<pre><code>version: \"3.8\"\n\nservices:\n  api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      - postgres\n\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_USER: qa\n      POSTGRES_PASSWORD: qapass\n      POSTGRES_DB: qa\n\n  venomqa:\n    image: venomqa-runner:latest\n    environment:\n      - API_BASE_URL=http://api:8000\n      - WAIT_FOR_POSTGRES=postgres:5432\n      - WAIT_FOR_HTTP=http://api:8000/health\n    volumes:\n      - ./qa:/app/qa:ro\n      - ./reports:/app/reports\n    depends_on:\n      - api\n    command: [\"run\", \"--config\", \"qa/venomqa.yaml\"]\n</code></pre>"},{"location":"ci-cd/#helper-scripts","title":"Helper Scripts","text":"<p>The runner image includes helper scripts:</p> <p>wait-for-services.sh: Wait for dependencies before running tests</p> Bash<pre><code>docker run --rm venomqa-runner:latest \\\n  /usr/local/bin/wait-for-services.sh \\\n    --postgres db:5432 \\\n    --redis cache:6379 \\\n    --http http://api:8000/health \\\n    -- venomqa run\n</code></pre> <p>run-journeys.sh: Comprehensive test runner with reports</p> Bash<pre><code>docker run --rm \\\n  -e WAIT_FOR_POSTGRES=db:5432 \\\n  -e VENOMQA_CONFIG=qa/venomqa.yaml \\\n  -v ./qa:/app/qa:ro \\\n  -v ./reports:/app/reports \\\n  venomqa-runner:latest \\\n  /usr/local/bin/run-journeys.sh\n</code></pre>"},{"location":"ci-cd/#other-ci-systems","title":"Other CI Systems","text":""},{"location":"ci-cd/#jenkins","title":"Jenkins","text":"Groovy<pre><code>pipeline {\n    agent {\n        docker {\n            image 'venomqa-runner:latest'\n        }\n    }\n\n    environment {\n        API_BASE_URL = 'http://localhost:8000'\n    }\n\n    stages {\n        stage('Test') {\n            steps {\n                sh 'venomqa run --config qa/venomqa.yaml'\n            }\n            post {\n                always {\n                    sh 'venomqa report --format junit --output reports/junit.xml'\n                    junit 'reports/junit.xml'\n                    archiveArtifacts artifacts: 'reports/**'\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"ci-cd/#circleci","title":"CircleCI","text":"YAML<pre><code>version: 2.1\n\njobs:\n  test:\n    docker:\n      - image: python:3.12\n      - image: postgres:15-alpine\n        environment:\n          POSTGRES_USER: qa\n          POSTGRES_PASSWORD: qapass\n          POSTGRES_DB: qa\n    steps:\n      - checkout\n      - run:\n          name: Install VenomQA\n          command: pip install venomqa[all]\n      - run:\n          name: Run journeys\n          command: venomqa run --config qa/venomqa.yaml\n      - run:\n          name: Generate reports\n          command: venomqa report --format junit --output reports/junit.xml\n          when: always\n      - store_test_results:\n          path: reports\n      - store_artifacts:\n          path: reports\n\nworkflows:\n  test:\n    jobs:\n      - test\n</code></pre>"},{"location":"ci-cd/#azure-devops","title":"Azure DevOps","text":"YAML<pre><code>trigger:\n  - main\n\npool:\n  vmImage: 'ubuntu-latest'\n\nservices:\n  postgres:\n    image: postgres:15-alpine\n    ports:\n      - 5432:5432\n\nsteps:\n  - task: UsePythonVersion@0\n    inputs:\n      versionSpec: '3.12'\n\n  - script: pip install venomqa[all]\n    displayName: Install VenomQA\n\n  - script: venomqa run --config qa/venomqa.yaml\n    displayName: Run Journeys\n\n  - script: |\n      venomqa report --format junit --output $(Build.ArtifactStagingDirectory)/junit.xml\n    displayName: Generate Reports\n    condition: always()\n\n  - task: PublishTestResults@2\n    inputs:\n      testResultsFormat: 'JUnit'\n      testResultsFiles: '$(Build.ArtifactStagingDirectory)/junit.xml'\n    condition: always()\n</code></pre>"},{"location":"ci-cd/#buildkite","title":"Buildkite","text":"YAML<pre><code>steps:\n  - label: \":snake: VenomQA Tests\"\n    command:\n      - pip install venomqa[all]\n      - venomqa run --config qa/venomqa.yaml\n      - venomqa report --format junit --output reports/junit.xml\n    plugins:\n      - docker-compose#v4.0.0:\n          services:\n            - postgres\n            - redis\n    artifact_paths:\n      - \"reports/**\"\n</code></pre>"},{"location":"ci-cd/#best-practices","title":"Best Practices","text":""},{"location":"ci-cd/#1-fail-fast-in-development-full-run-in-ci","title":"1. Fail Fast in Development, Full Run in CI","text":"YAML<pre><code># Development - stop on first failure for quick feedback\nvenomqa run --fail-fast --config qa/venomqa.yaml\n\n# CI - run all tests for complete picture\nvenomqa run --config qa/venomqa.yaml\n</code></pre>"},{"location":"ci-cd/#2-use-journey-groups-for-parallelization","title":"2. Use Journey Groups for Parallelization","text":"<p>Organize journeys by domain: Text Only<pre><code>qa/journeys/\n  auth_login.py\n  auth_registration.py\n  checkout_basic.py\n  checkout_with_coupon.py\n  api_crud.py\n  api_versioning.py\n</code></pre></p> <p>Then run groups in parallel: YAML<pre><code>matrix:\n  group: [auth, checkout, api]\n</code></pre></p>"},{"location":"ci-cd/#3-generate-multiple-report-formats","title":"3. Generate Multiple Report Formats","text":"Bash<pre><code># JUnit for CI integration\nvenomqa report --format junit --output reports/junit.xml\n\n# HTML for human review\nvenomqa report --format html --output reports/report.html\n\n# JSON for custom processing\nvenomqa report --format json --output reports/results.json\n</code></pre>"},{"location":"ci-cd/#4-set-appropriate-timeouts","title":"4. Set Appropriate Timeouts","text":"YAML<pre><code># venomqa.yaml\ntimeout: 30  # Default request timeout\n\n# For specific slow operations, override in journey\nsteps:\n  - name: process_large_file\n    action: upload.process\n    timeout: 120  # 2 minutes for this step\n</code></pre>"},{"location":"ci-cd/#5-use-health-checks","title":"5. Use Health Checks","text":"<p>Always wait for services before running tests:</p> YAML<pre><code>services:\n  api:\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n</code></pre>"},{"location":"ci-cd/#6-capture-logs-on-failure","title":"6. Capture Logs on Failure","text":"YAML<pre><code>- name: Collect logs on failure\n  if: failure()\n  run: |\n    docker compose logs &gt; reports/docker.log\n    docker ps -a &gt; reports/containers.txt\n</code></pre>"},{"location":"ci-cd/#handling-secrets","title":"Handling Secrets","text":""},{"location":"ci-cd/#environment-variables","title":"Environment Variables","text":"<p>Never commit secrets to code. Use CI/CD secret management:</p> <p>GitHub Actions: YAML<pre><code>env:\n  DATABASE_URL: ${{ secrets.DATABASE_URL }}\n  API_KEY: ${{ secrets.API_KEY }}\n</code></pre></p> <p>GitLab CI: YAML<pre><code>variables:\n  DATABASE_URL: $DB_URL  # CI/CD variable\n</code></pre></p>"},{"location":"ci-cd/#secret-files","title":"Secret Files","text":"<p>For complex secrets (certificates, key files):</p> YAML<pre><code># GitHub Actions\n- name: Setup credentials\n  run: |\n    echo \"${{ secrets.SERVICE_ACCOUNT_KEY }}\" &gt; /tmp/sa-key.json\n    export GOOGLE_APPLICATION_CREDENTIALS=/tmp/sa-key.json\n</code></pre>"},{"location":"ci-cd/#venomqa-configuration","title":"VenomQA Configuration","text":"<p>Reference secrets via environment variables in <code>venomqa.yaml</code>:</p> YAML<pre><code># venomqa.yaml\nbase_url: ${API_BASE_URL:-http://localhost:8000}\n\nports:\n  - name: database\n    adapter_type: postgres\n    config:\n      host: ${POSTGRES_HOST:-localhost}\n      port: ${POSTGRES_PORT:-5432}\n      user: ${POSTGRES_USER}\n      password: ${POSTGRES_PASSWORD}  # From environment\n      database: ${POSTGRES_DB}\n</code></pre>"},{"location":"ci-cd/#secret-masking","title":"Secret Masking","text":"<p>VenomQA automatically masks common secret patterns in logs: - API keys - Passwords - Tokens - Authorization headers</p>"},{"location":"ci-cd/#parallelization-strategies","title":"Parallelization Strategies","text":""},{"location":"ci-cd/#1-journey-group-parallelization","title":"1. Journey Group Parallelization","text":"<p>Split journeys by domain/feature:</p> YAML<pre><code># GitHub Actions\nstrategy:\n  matrix:\n    group: [auth, checkout, api, content, realtime]\n</code></pre>"},{"location":"ci-cd/#2-test-environment-parallelization","title":"2. Test Environment Parallelization","text":"<p>Run against multiple environments:</p> YAML<pre><code>strategy:\n  matrix:\n    environment: [staging, qa, preview]\n    include:\n      - environment: staging\n        base_url: https://staging.example.com\n      - environment: qa\n        base_url: https://qa.example.com\n</code></pre>"},{"location":"ci-cd/#3-database-sharding","title":"3. Database Sharding","text":"<p>For database-heavy tests, use separate databases:</p> YAML<pre><code>strategy:\n  matrix:\n    shard: [1, 2, 3, 4]\n\nservices:\n  postgres:\n    image: postgres:15-alpine\n    env:\n      POSTGRES_DB: qa_shard_${{ matrix.shard }}\n</code></pre>"},{"location":"ci-cd/#4-time-based-parallelization","title":"4. Time-based Parallelization","text":"<p>Run different test suites at different times:</p> YAML<pre><code># Fast tests on every push\non:\n  push:\n    branches: [main, develop]\n\n# Full test suite nightly\non:\n  schedule:\n    - cron: '0 2 * * *'  # 2 AM daily\n</code></pre>"},{"location":"ci-cd/#troubleshooting","title":"Troubleshooting","text":""},{"location":"ci-cd/#common-issues","title":"Common Issues","text":"<p>1. Services not ready</p> Text Only<pre><code>Error: Connection refused to localhost:5432\n</code></pre> <p>Solution: Use health checks and wait scripts: Bash<pre><code>wait-for-services.sh --postgres localhost:5432 -- venomqa run\n</code></pre></p> <p>2. Timeout errors</p> Text Only<pre><code>Error: Request timeout after 30s\n</code></pre> <p>Solution: Increase timeout in config: YAML<pre><code>timeout: 60  # Increase default timeout\n</code></pre></p> <p>3. Permission errors in Docker</p> Text Only<pre><code>Error: Permission denied: /app/reports\n</code></pre> <p>Solution: Match user IDs: Bash<pre><code>docker run --user $(id -u):$(id -g) ...\n</code></pre></p> <p>4. Exit code not propagated</p> <p>Ensure your shell script properly captures exit codes: Bash<pre><code>set +e  # Don't exit on error\nvenomqa run\nEXIT_CODE=$?\nset -e  # Re-enable exit on error\n# ... generate reports ...\nexit $EXIT_CODE  # Propagate original exit code\n</code></pre></p>"},{"location":"ci-cd/#debugging-ci-failures","title":"Debugging CI Failures","text":"<p>1. Enable verbose output: Bash<pre><code>venomqa run --verbose --config qa/venomqa.yaml\n</code></pre></p> <p>2. Add debugging steps: YAML<pre><code>- name: Debug environment\n  if: failure()\n  run: |\n    env | sort\n    docker ps -a\n    docker compose logs\n    cat qa/venomqa.yaml\n</code></pre></p> <p>3. SSH into failed runner (GitHub Actions): YAML<pre><code>- name: Debug with tmate\n  if: failure()\n  uses: mxschmitt/action-tmate@v3\n  with:\n    limit-access-to-actor: true\n</code></pre></p>"},{"location":"ci-cd/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: https://venomqa.dev/docs</li> <li>Issues: https://github.com/namanagarwal/venomqa/issues</li> <li>Discussions: https://github.com/namanagarwal/venomqa/discussions</li> </ul> <p>For complete working examples, see: - <code>.github/workflows/venomqa.yml.example</code> - GitHub Actions - <code>.gitlab-ci.yml.example</code> - GitLab CI - <code>docker/Dockerfile.runner</code> - Docker runner image</p>"},{"location":"cli-output/","title":"VenomQA CLI Output Features","text":"<p>VenomQA includes professional, live progress indicators and beautiful visualizations for your test journeys using the Rich library.</p>"},{"location":"cli-output/#features","title":"Features","text":""},{"location":"cli-output/#1-live-progress-bar","title":"1. Live Progress Bar","text":"<p>Real-time progress tracking with: - Spinner animation - Shows activity while tests are running - Progress bar - Visual representation: <code>[=====&gt;    ] 50%</code> - Step counter - Current and total steps: <code>5/10</code> - Elapsed time - How long the journey has been running - Estimated time remaining (ETA) - Predicted completion time</p> <p>Example output: Text Only<pre><code>\u280b \u2192 Step 5/10: process_payment \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 5/10 \u2022 0:00:02 \u2022 0:00:02\n</code></pre></p>"},{"location":"cli-output/#2-current-step-indicator","title":"2. Current Step Indicator","text":"<p>Each step is displayed with: - Spinner - Animated spinner (\u280b \u2819 \u2839 \u2838 \u283c \u2834 \u2826 \u2827 \u2807 \u280f) - Step number - Current position in journey - Step name - Descriptive name of the action - Status updates - Updates in real-time without spamming the terminal</p>"},{"location":"cli-output/#3-timing-information","title":"3. Timing Information","text":"<p>Comprehensive timing data: - Per-step duration - Time taken for each step (shown after completion) - Elapsed time - Total time since journey started - ETA calculation - Smart prediction based on average step time - Summary timing - Complete breakdown in the final summary</p> <p>Example: Text Only<pre><code>Step Timings:\n  login            270ms\n  browse_products  290ms\n  add_to_cart      310ms\n  ...\n</code></pre></p>"},{"location":"cli-output/#4-branch-visualization","title":"4. Branch Visualization","text":"<p>Tree-like visualization for branches and paths:</p> Text Only<pre><code>\u251c\u2500 Branch: before_payment (3 paths)\n  \u2502 \u251c\u2500 Path: credit_card_payment\n  \u2502 \u2514\u2500 \u2713 credit_card_payment (3 steps)\n  \u2502 \u251c\u2500 Path: paypal_payment\n  \u2502 \u2514\u2500 \u2713 paypal_payment (2 steps)\n  \u2502 \u251c\u2500 Path: crypto_payment\n  \u2502 \u2514\u2500 \u2717 crypto_payment (2 steps)\n</code></pre> <p>Features: - Tree characters - Visual hierarchy (\u251c\u2500, \u2514\u2500, \u2502) - Branch indicators - Shows checkpoint name and path count - Path status - Success (\u2713) or failure (\u2717) with step counts - Color coding - Green for success, red for failure</p>"},{"location":"cli-output/#5-checkpoint-rollback-indicators","title":"5. Checkpoint &amp; Rollback Indicators","text":"<p>Visual markers for state management:</p> Text Only<pre><code>\u25c9 Checkpoint: before_payment\n\u21a9 Rollback to: before_payment\n</code></pre> <ul> <li>Checkpoints - Shown in yellow with \u25c9 symbol</li> <li>Rollbacks - Shown in cyan with \u21a9 symbol</li> <li>Integration - Seamlessly displayed during live progress</li> </ul>"},{"location":"cli-output/#6-summary-panel","title":"6. Summary Panel","text":"<p>Beautiful summary boxes at journey completion:</p> Text Only<pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 JOURNEY COMPLETE: checkout_flow \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                \u2502\n\u2502  Status:            \u2713 PASSED                                                   \u2502\n\u2502  Duration:          3.50s                                                      \u2502\n\u2502  Steps:             10/10 passed                                               \u2502\n\u2502  Paths:             3/3 passed                                                 \u2502\n\u2502                                                                                \u2502\n\u2502  Step Timings:                                                                 \u2502\n\u2502    login            270ms                                                      \u2502\n\u2502    browse_products  290ms                                                      \u2502\n\u2502    add_to_cart      310ms                                                      \u2502\n\u2502    ...                                                                         \u2502\n\u2502                                                                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Includes: - Status indicator - Pass/fail with colored symbols - Duration - Total execution time - Step statistics - Passed vs total steps - Path statistics - Passed vs total paths (if applicable) - Timing breakdown - Top 10 slowest steps - Border styling - Green for success, red for failure</p>"},{"location":"cli-output/#7-overall-summary","title":"7. Overall Summary","text":"<p>Multi-journey summary with aggregate statistics:</p> Text Only<pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2713 SUMMARY: ALL JOURNEYS PASSED \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                \u2502\n\u2502  Total:     5                                                                  \u2502\n\u2502  Passed:    5                                                                  \u2502\n\u2502  Failed:    0                                                                  \u2502\n\u2502  Duration:  15.00s                                                             \u2502\n\u2502                                                                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli-output/#8-issue-reporting","title":"8. Issue Reporting","text":"<p>Failed steps are clearly highlighted:</p> Text Only<pre><code>\u2717 Issues:\n  \u2717 apply_discount: Discount code expired\n  \u2717 payment_gateway: Connection timeout\n</code></pre>"},{"location":"cli-output/#configuration","title":"Configuration","text":"<p>Control output features via <code>ProgressConfig</code>:</p> Python<pre><code>from venomqa.cli.output import CLIOutput, ProgressConfig\n\nconfig = ProgressConfig(\n    show_progress=True,      # Enable progress bars\n    show_checkpoints=True,   # Show checkpoint markers\n    show_paths=True,         # Show branch paths\n    show_timing=True,        # Show timing information\n    use_colors=True,         # Enable colored output\n    use_unicode=True,        # Use Unicode symbols (vs ASCII)\n)\n\noutput = CLIOutput(config)\n</code></pre>"},{"location":"cli-output/#terminal-compatibility","title":"Terminal Compatibility","text":""},{"location":"cli-output/#unicode-support","title":"Unicode Support","text":"<p>The CLI automatically detects terminal capabilities:</p> <p>Unicode terminals (default): - Beautiful symbols: \u2713 \u2717 \u2699 \u25c9 \u21a9 \u2192 \u251c\u2500 \u2514\u2500 \u2502 - Smooth spinners: \u280b \u2819 \u2839 \u2838 \u283c \u2834 \u2826 \u2827</p> <p>ASCII-only terminals: - ASCII fallbacks: [OK][FAIL] [*] &lt;- -&gt; |-- `-- | - Text-based indicators</p>"},{"location":"cli-output/#color-support","title":"Color Support","text":"<ul> <li>Color terminals: Rich colors with ANSI codes</li> <li>No-color terminals: Plain text output</li> <li>Auto-detection: Automatically detects TTY capabilities</li> </ul>"},{"location":"cli-output/#usage-examples","title":"Usage Examples","text":""},{"location":"cli-output/#basic-journey","title":"Basic Journey","text":"Python<pre><code>from venomqa import Journey, Step\nfrom venomqa.cli.output import CLIOutput, ProgressConfig\n\noutput = CLIOutput()\n\n# Start journey\noutput.journey_start(\n    name=\"user_registration\",\n    description=\"Complete user registration flow\",\n    total_steps=5\n)\n\n# Run steps (integrated with runner)\n# Output automatically updates during execution\n\n# Show summary\noutput.journey_summary(\n    name=\"user_registration\",\n    success=True,\n    step_count=5,\n    passed_steps=5,\n    duration_ms=1200\n)\n</code></pre>"},{"location":"cli-output/#with-branches","title":"With Branches","text":"Python<pre><code># Branch starts automatically\noutput.branch_start(\"after_signup\", 3)\n\n# Paths run automatically\noutput.path_start(\"email_verification\")\noutput.path_result(\"email_verification\", True, 3)\n\noutput.path_start(\"phone_verification\")\noutput.path_result(\"phone_verification\", True, 2)\n</code></pre>"},{"location":"cli-output/#integration","title":"Integration","text":"<p>The CLI output is automatically integrated with: - JourneyRunner - Automatic progress updates during execution - Commands - Built into <code>venomqa run</code> command - Reporters - Works alongside all reporter formats</p>"},{"location":"cli-output/#performance","title":"Performance","text":"<ul> <li>Non-blocking - Progress updates don't slow down tests</li> <li>Efficient rendering - Updates at 10 FPS (configurable)</li> <li>Memory conscious - Minimal overhead</li> <li>Live updates - In-place rendering without terminal spam</li> </ul>"},{"location":"cli-output/#best-practices","title":"Best Practices","text":"<ol> <li>Always provide total_steps for accurate progress bars</li> <li>Use descriptive step names for clarity</li> <li>Enable timing to identify slow steps</li> <li>Color support improves readability in CI logs</li> <li>Unicode symbols provide better visual hierarchy</li> </ol>"},{"location":"cli-output/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli-output/#progress-bar-not-showing","title":"Progress bar not showing","text":"<ul> <li>Ensure <code>total_steps &gt; 0</code> in <code>journey_start()</code></li> <li>Check <code>show_progress=True</code> in config</li> </ul>"},{"location":"cli-output/#symbols-displaying-incorrectly","title":"Symbols displaying incorrectly","text":"<ul> <li>Terminal may not support Unicode</li> <li>Set <code>use_unicode=False</code> for ASCII fallback</li> </ul>"},{"location":"cli-output/#colors-not-working","title":"Colors not working","text":"<ul> <li>Verify terminal supports ANSI colors</li> <li>Check TTY detection with <code>output._supports_color()</code></li> </ul>"},{"location":"cli-output/#future-enhancements","title":"Future Enhancements","text":"<p>Planned features: - Real-time request/response preview - Interactive mode for step debugging - Performance graphs and charts - Export progress to file/stream - WebSocket streaming for remote monitoring</p>"},{"location":"cli-output/#see-also","title":"See Also","text":"<ul> <li>CLI Commands - Command-line interface</li> <li>Journeys - Journey structure</li> <li>Reporters - Report formats</li> </ul>"},{"location":"comparison/","title":"Comparison: VenomQA vs Other Tools","text":"<p>This document provides a detailed comparison of VenomQA with other popular testing tools to help you choose the right tool for your needs.</p>"},{"location":"comparison/#quick-comparison","title":"Quick Comparison","text":"Feature VenomQA Postman Playwright pytest Karate Primary Focus API Journey Testing API Testing E2E/UI Testing Unit/Integration API/UI Testing State Branching \u2705 \u274c \u274c \u274c \u274c DB Savepoints \u2705 \u274c \u274c \u274c \u274c Journey DSL \u2705 Collections Code Code Gherkin-like HTTP Client \u2705 Built-in \u2705 \u2705 Plugin \u2705 Docker Integration \u2705 \u274c \u274c Plugin \u274c Issue Capture \u2705 Full Partial Partial Plugin Partial Auto-Suggestions \u2705 \u274c \u274c \u274c \u274c Language Python JS/GUI JS/Python/Java Python Java/Gherkin Learning Curve Medium Low Medium Low Medium CI/CD Ready \u2705 \u2705 \u2705 \u2705 \u2705"},{"location":"comparison/#detailed-comparisons","title":"Detailed Comparisons","text":""},{"location":"comparison/#venomqa-vs-postman","title":"VenomQA vs Postman","text":""},{"location":"comparison/#overview","title":"Overview","text":"Aspect VenomQA Postman Type Code-based framework GUI + CLI tool Primary Use Complex API journeys API development &amp; testing Scripting Python JavaScript"},{"location":"comparison/#when-to-choose-venomqa","title":"When to Choose VenomQA","text":"<ul> <li>You need state branching to test multiple paths from same state</li> <li>You want tests in version control as code</li> <li>You need database rollback between test scenarios</li> <li>Your tests are complex user journeys</li> <li>You prefer Python over JavaScript</li> <li>You need programmatic control over test execution</li> </ul>"},{"location":"comparison/#when-to-choose-postman","title":"When to Choose Postman","text":"<ul> <li>You want a GUI for API exploration</li> <li>Your team is non-technical or prefers visual tools</li> <li>You need quick ad-hoc API testing</li> <li>You want API documentation generation</li> <li>You need mock server for development</li> <li>Your tests are simple request-response sequences</li> </ul>"},{"location":"comparison/#feature-comparison","title":"Feature Comparison","text":"Text Only<pre><code>Feature                      VenomQA    Postman\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nRequest Collections             \u2705          \u2705\nEnvironment Variables           \u2705          \u2705\nPre/Post Scripts               \u2705          \u2705\nData-Driven Tests              \u2705          \u2705\nCI/CD Integration              \u2705          \u2705\nVisual Interface               \u274c          \u2705\nAPI Documentation              \u274c          \u2705\nMock Server                    \u274c          \u2705\nState Branching                \u2705          \u274c\nDB Savepoints                  \u2705          \u274c\nDocker Management              \u2705          \u274c\nFull Issue Context             \u2705       Partial\nAuto Fix Suggestions           \u2705          \u274c\nParallel Execution             \u2705       Paid Only\n</code></pre>"},{"location":"comparison/#code-comparison","title":"Code Comparison","text":"<p>Postman (Pre-request Script): JavaScript<pre><code>// Login and set token\npm.sendRequest({\n    url: pm.environment.get(\"base_url\") + \"/auth/login\",\n    method: \"POST\",\n    header: {\"Content-Type\": \"application/json\"},\n    body: {\n        mode: \"raw\",\n        raw: JSON.stringify({email: \"test@example.com\", password: \"secret\"})\n    }\n}, function(err, res) {\n    pm.environment.set(\"token\", res.json().token);\n});\n</code></pre></p> <p>VenomQA: Python<pre><code>def login(client, context):\n    response = client.post(\"/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n    context[\"token\"] = response.json()[\"token\"]\n    client.set_auth_token(context[\"token\"])\n    return response\n</code></pre></p>"},{"location":"comparison/#venomqa-vs-playwright","title":"VenomQA vs Playwright","text":""},{"location":"comparison/#overview_1","title":"Overview","text":"Aspect VenomQA Playwright Type API testing framework Browser automation Primary Use API/backend testing E2E/UI testing Focus Stateful journeys Browser interactions"},{"location":"comparison/#when-to-choose-venomqa_1","title":"When to Choose VenomQA","text":"<ul> <li>You're testing REST APIs or microservices</li> <li>You need fast test execution (no browser overhead)</li> <li>You want database state control</li> <li>Your tests focus on backend logic</li> <li>You need to test multiple paths efficiently</li> </ul>"},{"location":"comparison/#when-to-choose-playwright","title":"When to Choose Playwright","text":"<ul> <li>You need browser automation and UI testing</li> <li>You want to test JavaScript behavior</li> <li>You need visual regression testing</li> <li>You're testing single-page applications</li> <li>You want screenshots/videos on failure</li> </ul>"},{"location":"comparison/#feature-comparison_1","title":"Feature Comparison","text":"Text Only<pre><code>Feature                      VenomQA   Playwright\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAPI Testing                     \u2705         \u2705\nBrowser Automation              \u274c         \u2705\nCross-Browser                   \u274c         \u2705\nScreenshots                     \u274c         \u2705\nVideo Recording                 \u274c         \u2705\nVisual Regression               \u274c         \u2705\nState Branching                 \u2705         \u274c\nDB Savepoints                   \u2705         \u274c\nFast Execution                  \u2705       Slower\nHeadless Mode                   N/A        \u2705\nMobile Emulation                \u274c         \u2705\nNetwork Interception            \u274c         \u2705\n</code></pre>"},{"location":"comparison/#code-comparison_1","title":"Code Comparison","text":"<p>Playwright (API Testing): Python<pre><code>from playwright.sync_api import sync_playwright\n\ndef test_create_user():\n    with sync_playwright() as p:\n        request = p.request.new_context(base_url=\"http://localhost:8000\")\n        response = request.post(\"/api/users\", data={\n            \"name\": \"John\",\n            \"email\": \"john@example.com\",\n        })\n        assert response.ok\n        user_id = response.json()[\"id\"]\n\n        # Get user\n        response = request.get(f\"/api/users/{user_id}\")\n        assert response.ok\n</code></pre></p> <p>VenomQA: Python<pre><code>from venomqa import Journey, Step\n\ndef create_user(client, context):\n    response = client.post(\"/api/users\", json={\n        \"name\": \"John\",\n        \"email\": \"john@example.com\",\n    })\n    context[\"user_id\"] = response.json()[\"id\"]\n    return response\n\ndef get_user(client, context):\n    return client.get(f\"/api/users/{context['user_id']}\")\n\njourney = Journey(\n    name=\"user_crud\",\n    steps=[\n        Step(name=\"create\", action=create_user),\n        Step(name=\"read\", action=get_user),\n    ],\n)\n</code></pre></p>"},{"location":"comparison/#can-they-work-together","title":"Can They Work Together?","text":"<p>Yes! Use them together for comprehensive testing:</p> YAML<pre><code># CI Pipeline\nstages:\n  - api_tests     # VenomQA - fast feedback\n  - e2e_tests     # Playwright - UI verification\n</code></pre>"},{"location":"comparison/#venomqa-vs-pytest","title":"VenomQA vs pytest","text":""},{"location":"comparison/#overview_2","title":"Overview","text":"Aspect VenomQA pytest Type Specialized framework General-purpose framework Primary Use Journey/API testing All testing types Philosophy Declarative journeys Imperative tests"},{"location":"comparison/#when-to-choose-venomqa_2","title":"When to Choose VenomQA","text":"<ul> <li>You want structured journey testing</li> <li>You need state branching from checkpoints</li> <li>You want built-in HTTP client with history</li> <li>You need automatic issue capture</li> <li>You prefer declarative test definitions</li> </ul>"},{"location":"comparison/#when-to-choose-pytest","title":"When to Choose pytest","text":"<ul> <li>You need unit tests for functions</li> <li>You want maximum flexibility</li> <li>You need parameterized tests</li> <li>You have existing pytest ecosystem</li> <li>You want simple test functions</li> </ul>"},{"location":"comparison/#feature-comparison_2","title":"Feature Comparison","text":"Text Only<pre><code>Feature                      VenomQA      pytest\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nUnit Testing                    \u2705          \u2705\nIntegration Testing             \u2705          \u2705\nAPI Testing                     \u2705      Plugin\nFixtures                       \u2705          \u2705\nParametrization                \u2705          \u2705\nPlugins                        \u274c       Many\nState Branching                \u2705          \u274c\nDB Savepoints                  \u2705      Plugin\nBuilt-in HTTP Client           \u2705      Plugin\nIssue Capture                  \u2705          \u274c\nAuto-Suggestions               \u2705          \u274c\nJourney DSL                    \u2705          \u274c\n</code></pre>"},{"location":"comparison/#code-comparison_2","title":"Code Comparison","text":"<p>pytest: Python<pre><code>import pytest\nimport httpx\n\n@pytest.fixture\ndef client():\n    with httpx.Client(base_url=\"http://localhost:8000\") as client:\n        yield client\n\ndef test_user_flow(client):\n    # Create user\n    response = client.post(\"/api/users\", json={\"name\": \"John\"})\n    assert response.status_code == 201\n    user_id = response.json()[\"id\"]\n\n    # Get user\n    response = client.get(f\"/api/users/{user_id}\")\n    assert response.status_code == 200\n\n    # Delete user\n    response = client.delete(f\"/api/users/{user_id}\")\n    assert response.status_code == 204\n\ndef test_payment_with_card(client):\n    # Need to recreate state...\n    pass\n\ndef test_payment_with_paypal(client):\n    # Need to recreate state again...\n    pass\n</code></pre></p> <p>VenomQA (with state branching): Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\njourney = Journey(\n    name=\"checkout_flow\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"add_to_cart\", action=add_to_cart),\n        Checkpoint(name=\"ready_for_payment\"),  # State saved once!\n\n        Branch(\n            checkpoint_name=\"ready_for_payment\",\n            paths=[\n                Path(name=\"card\", steps=[\n                    Step(name=\"pay_card\", action=pay_with_card),\n                ]),\n                Path(name=\"paypal\", steps=[\n                    Step(name=\"pay_paypal\", action=pay_with_paypal),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre></p>"},{"location":"comparison/#can-they-work-together_1","title":"Can They Work Together?","text":"<p>Absolutely! VenomQA journeys can be run within pytest:</p> Python<pre><code>import pytest\nfrom venomqa import JourneyRunner, Client\n\n@pytest.fixture\ndef runner():\n    client = Client(base_url=\"http://localhost:8000\")\n    return JourneyRunner(client=client)\n\ndef test_checkout_flow(runner):\n    result = runner.run(checkout_journey)\n    assert result.success, f\"Failed: {result.issues}\"\n</code></pre>"},{"location":"comparison/#venomqa-vs-karate","title":"VenomQA vs Karate","text":""},{"location":"comparison/#overview_3","title":"Overview","text":"Aspect VenomQA Karate Type Python framework Java/Gherkin framework Primary Use API journey testing API + UI testing Language Python Gherkin-like DSL"},{"location":"comparison/#when-to-choose-venomqa_3","title":"When to Choose VenomQA","text":"<ul> <li>You prefer Python ecosystem</li> <li>You need state branching capabilities</li> <li>You want clean Python code over DSL</li> <li>You need database state management</li> <li>You want auto-suggestions for failures</li> </ul>"},{"location":"comparison/#when-to-choose-karate","title":"When to Choose Karate","text":"<ul> <li>You prefer Gherkin/BDD style</li> <li>Your team uses Java/JVM</li> <li>You need UI testing in same framework</li> <li>You want embedded assertions</li> <li>You need cross-platform compatibility</li> </ul>"},{"location":"comparison/#feature-comparison_3","title":"Feature Comparison","text":"Text Only<pre><code>Feature                      VenomQA    Karate\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nAPI Testing                     \u2705         \u2705\nUI Testing                      \u274c         \u2705\nBDD/Gherkin Style               \u274c         \u2705\nNative Code                     \u2705      Mixed\nState Branching                 \u2705         \u274c\nDB Savepoints                   \u2705         \u274c\nParallel Execution              \u2705         \u2705\nAssertions                     Code    Embedded\nData-Driven Tests              \u2705         \u2705\nMock Server                    \u274c         \u2705\n</code></pre>"},{"location":"comparison/#code-comparison_3","title":"Code Comparison","text":"<p>Karate: Gherkin<pre><code>Feature: User Management\n\nScenario: Create and retrieve user\n  Given url baseurl\n  And path 'users'\n  And request { name: 'John', email: 'john@example.com' }\n  When method post\n  Then status 201\n  And match response.id == '#present'\n  * def userId = response.id\n\n  Given path 'users', userId\n  When method get\n  Then status 200\n  And match response.name == 'John'\n</code></pre></p> <p>VenomQA: Python<pre><code>from venomqa import Journey, Step\n\ndef create_user(client, context):\n    response = client.post(\"/api/users\", json={\n        \"name\": \"John\",\n        \"email\": \"john@example.com\",\n    })\n    context[\"user_id\"] = response.json()[\"id\"]\n    return response\n\ndef get_user(client, context):\n    return client.get(f\"/api/users/{context['user_id']}\")\n\njourney = Journey(\n    name=\"user_management\",\n    steps=[\n        Step(name=\"create\", action=create_user),\n        Step(name=\"get\", action=get_user),\n    ],\n)\n</code></pre></p>"},{"location":"comparison/#decision-matrix","title":"Decision Matrix","text":""},{"location":"comparison/#choose-venomqa-if","title":"Choose VenomQA If:","text":"Scenario Why Testing complex user journeys State branching saves time Backend API testing Built-in HTTP client, history Need database rollback Native SAVEPOINT support Testing multiple paths Branch from same state Python project Native Python, no DSL overhead CI/CD pipelines CLI-first design"},{"location":"comparison/#choose-postman-if","title":"Choose Postman If:","text":"Scenario Why Non-technical team GUI is more accessible Quick API exploration Visual interface API documentation Built-in docs generation Mock server needed Built-in mocking Simple request tests Easier for beginners"},{"location":"comparison/#choose-playwright-if","title":"Choose Playwright If:","text":"Scenario Why UI testing Browser automation Visual regression Screenshot comparison Cross-browser testing Multi-browser support SPA testing JavaScript execution Accessibility testing aXe integration"},{"location":"comparison/#choose-pytest-if","title":"Choose pytest If:","text":"Scenario Why Unit testing Best-in-class fixtures Maximum flexibility Plugin ecosystem Existing pytest code Compatibility Simple assertions assert statement Parameterized tests @pytest.mark.parametrize"},{"location":"comparison/#choose-karate-if","title":"Choose Karate If:","text":"Scenario Why BDD preference Gherkin syntax Java ecosystem JVM compatibility Combined API + UI Single framework Non-programmers DSL is simpler"},{"location":"comparison/#combining-tools","title":"Combining Tools","text":"<p>You don't have to choose just one! Here's a recommended testing stack:</p> Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Testing Pyramid                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                          \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u2502\n\u2502                    \u2502 Playwright\u2502  \u2190 E2E / UI Tests      \u2502\n\u2502                    \u2502   (UI)   \u2502    (Critical paths)     \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2502\n\u2502                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                      \u2502\n\u2502                  \u2502   VenomQA     \u2502  \u2190 Journey Tests     \u2502\n\u2502                  \u2502 (Integration) \u2502    (User flows)      \u2502\n\u2502                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                      \u2502\n\u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u2502\n\u2502              \u2502        pytest         \u2502  \u2190 Unit Tests    \u2502\n\u2502              \u2502      (Isolated)       \u2502    (Fast)        \u2502\n\u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n\u2502                                                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"comparison/#example-ci-pipeline","title":"Example CI Pipeline","text":"YAML<pre><code>name: Test Suite\n\non: [push, pull_request]\n\njobs:\n  unit-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - run: pytest tests/unit/\n\n  api-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - run: venomqa run --format junit\n      - uses: actions/upload-artifact@v4\n        with:\n          name: api-reports\n          path: reports/\n\n  e2e-tests:\n    runs-on: ubuntu-latest\n    needs: [unit-tests, api-tests]\n    steps:\n      - uses: actions/checkout@v4\n      - run: npx playwright test\n</code></pre>"},{"location":"comparison/#summary","title":"Summary","text":"Tool Best For VenomQA Complex API journeys with state branching Postman API development, documentation, simple tests Playwright Browser automation, E2E testing pytest Unit tests, maximum flexibility Karate BDD-style API/UI testing <p>Choose the tool that best fits your use case, or combine multiple tools for comprehensive test coverage!</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We love contributions! Here's how to get started with VenomQA development.</p>"},{"location":"contributing/#quick-start","title":"Quick Start","text":"Bash<pre><code># Clone the repository\ngit clone https://github.com/venomqa/venomqa.git\ncd venomqa\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install with development dependencies\npip install -e \".[dev,docs]\"\n\n# Install pre-commit hooks\npre-commit install\n\n# Run tests\npytest\n\n# Run linting\nruff check .\nmypy venomqa\n</code></pre>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Found a bug? Open an issue with:</p> <ul> <li>VenomQA version</li> <li>Python version</li> <li>Minimal reproduction steps</li> <li>Expected vs actual behavior</li> </ul>"},{"location":"contributing/#suggest-features","title":"Suggest Features","text":"<p>Have an idea? Start a discussion to:</p> <ul> <li>Describe the use case</li> <li>Explain the proposed solution</li> <li>Discuss alternatives</li> </ul>"},{"location":"contributing/#improve-documentation","title":"Improve Documentation","text":"<p>Documentation improvements are always welcome:</p> <ul> <li>Fix typos</li> <li>Add examples</li> <li>Clarify explanations</li> <li>Translate documentation</li> </ul>"},{"location":"contributing/#submit-code","title":"Submit Code","text":"<p>Ready to code? Look for issues labeled <code>good first issue</code>.</p>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"Bash<pre><code># Fork on GitHub, then clone\ngit clone https://github.com/YOUR_USERNAME/venomqa.git\ncd venomqa\ngit remote add upstream https://github.com/venomqa/venomqa.git\n</code></pre>"},{"location":"contributing/#2-create-branch","title":"2. Create Branch","text":"Bash<pre><code>git checkout -b feature/my-feature\n# or\ngit checkout -b fix/my-fix\n</code></pre>"},{"location":"contributing/#3-make-changes","title":"3. Make Changes","text":"<ul> <li>Write code</li> <li>Add tests</li> <li>Update documentation</li> </ul>"},{"location":"contributing/#4-test-changes","title":"4. Test Changes","text":"Bash<pre><code># Run all tests\npytest\n\n# Run specific tests\npytest tests/test_models.py\n\n# Run with coverage\npytest --cov=venomqa\n\n# Run linting\nruff check .\nruff format --check .\n\n# Run type checking\nmypy venomqa\n</code></pre>"},{"location":"contributing/#5-commit-changes","title":"5. Commit Changes","text":"<p>Follow Conventional Commits:</p> Bash<pre><code>git commit -m \"feat: add support for MySQL backend\"\ngit commit -m \"fix: resolve checkpoint naming conflict\"\ngit commit -m \"docs: add MySQL configuration example\"\ngit commit -m \"test: add tests for branch rollback\"\n</code></pre>"},{"location":"contributing/#6-push-and-create-pr","title":"6. Push and Create PR","text":"Bash<pre><code>git push origin feature/my-feature\n</code></pre> <p>Then create a Pull Request on GitHub.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":""},{"location":"contributing/#python-style","title":"Python Style","text":"<p>We use:</p> <ul> <li>Ruff for linting and formatting</li> <li>mypy for type checking</li> <li>Line length: 100 characters</li> </ul> Bash<pre><code># Format code\nruff format .\n\n# Check linting\nruff check .\n\n# Fix linting issues\nruff check --fix .\n</code></pre>"},{"location":"contributing/#type-hints","title":"Type Hints","text":"<p>Use type hints for all public APIs:</p> Python<pre><code>def create_journey(\n    name: str,\n    steps: list[Step],\n    description: str = \"\",\n    tags: list[str] | None = None,\n) -&gt; Journey:\n    \"\"\"Create a new journey.\n\n    Args:\n        name: Unique journey identifier\n        steps: List of steps to execute\n        description: Human-readable description\n        tags: Optional tags for filtering\n\n    Returns:\n        A new Journey instance\n    \"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings:</p> Python<pre><code>def process_result(\n    result: StepResult,\n    context: ExecutionContext,\n) -&gt; dict[str, Any]:\n    \"\"\"Process a step result and update context.\n\n    Args:\n        result: The step execution result\n        context: The execution context to update\n\n    Returns:\n        A dictionary containing processed result data\n\n    Raises:\n        ValueError: If result is invalid\n        StateError: If context cannot be updated\n    \"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#test-structure","title":"Test Structure","text":"Text Only<pre><code>tests/\n\u251c\u2500\u2500 test_models.py          # Core model tests\n\u251c\u2500\u2500 test_runner.py          # Runner tests\n\u251c\u2500\u2500 test_client.py          # HTTP client tests\n\u251c\u2500\u2500 test_state.py           # State manager tests\n\u251c\u2500\u2500 test_reporters.py       # Reporter tests\n\u2514\u2500\u2500 conftest.py             # Shared fixtures\n</code></pre>"},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"Python<pre><code>import pytest\nfrom venomqa import Journey, Step, Client\n\n\nclass TestJourney:\n    def test_journey_creation(self):\n        \"\"\"Test basic journey creation.\"\"\"\n        journey = Journey(\n            name=\"test\",\n            steps=[\n                Step(name=\"step1\", action=lambda c, ctx: c.get(\"/\"))\n            ],\n        )\n        assert journey.name == \"test\"\n        assert len(journey.steps) == 1\n\n    def test_journey_validation(self):\n        \"\"\"Test journey validates checkpoint references.\"\"\"\n        with pytest.raises(ValueError):\n            Journey(\n                name=\"test\",\n                steps=[\n                    Branch(checkpoint_name=\"nonexistent\", paths=[])\n                ],\n            )\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client.\"\"\"\n    return Client(base_url=\"http://localhost:8000\")\n\n\n@pytest.fixture\ndef mock_response(respx_mock):\n    \"\"\"Mock HTTP responses.\"\"\"\n    respx_mock.get(\"/health\").respond(200, json={\"status\": \"ok\"})\n    return respx_mock\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"Bash<pre><code># All tests\npytest\n\n# With coverage\npytest --cov=venomqa --cov-report=html\n\n# Specific file\npytest tests/test_models.py\n\n# Specific test\npytest tests/test_models.py::TestJourney::test_journey_creation\n\n# Verbose output\npytest -v\n\n# Stop on first failure\npytest -x\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#building-docs","title":"Building Docs","text":"Bash<pre><code># Install docs dependencies\npip install -e \".[docs]\"\n\n# Serve locally\nmkdocs serve\n\n# Build\nmkdocs build\n</code></pre>"},{"location":"contributing/#documentation-structure","title":"Documentation Structure","text":"Text Only<pre><code>docs/\n\u251c\u2500\u2500 index.md                  # Home page\n\u251c\u2500\u2500 getting-started/          # Getting started guides\n\u251c\u2500\u2500 concepts/                 # Core concepts\n\u251c\u2500\u2500 tutorials/                # Step-by-step tutorials\n\u251c\u2500\u2500 reference/                # API reference\n\u251c\u2500\u2500 examples/                 # Code examples\n\u2514\u2500\u2500 advanced/                 # Advanced topics\n</code></pre>"},{"location":"contributing/#release-process","title":"Release Process","text":"<ol> <li>Update version in <code>venomqa/__init__.py</code> and <code>pyproject.toml</code></li> <li>Update CHANGELOG.md</li> <li>Create release PR</li> <li>After merge, tag release: <code>git tag v0.x.0</code></li> <li>Push tag: <code>git push --tags</code></li> <li>GitHub Actions builds and publishes to PyPI</li> </ol>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please read our Code of Conduct before contributing.</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>GitHub Discussions</li> <li>Discord</li> </ul>"},{"location":"examples/","title":"Real-World Examples","text":"<p>This page provides practical, real-world examples of using VenomQA.</p> <p>Looking for basics? See the Getting Started Guide for introductory examples.</p>"},{"location":"examples/#table-of-contents","title":"Table of Contents","text":"<ul> <li>E-Commerce Checkout Flow</li> <li>User Registration with Email Verification</li> <li>API Rate Limiting Tests</li> <li>Multi-Tenant Application Testing</li> <li>Payment Gateway Integration</li> <li>File Upload and Processing</li> <li>WebSocket and Real-Time Features</li> <li>Third-Party API Mocking</li> </ul>"},{"location":"examples/#related-documentation","title":"Related Documentation","text":"Topic Document Journey DSL journeys.md Adapters adapters.md Ports ports.md Advanced Patterns advanced.md"},{"location":"examples/#e-commerce-checkout-flow","title":"E-Commerce Checkout Flow","text":"<p>Complete checkout journey testing multiple payment methods.</p>"},{"location":"examples/#actions-file","title":"Actions File","text":"Python<pre><code># actions/shop.py\n\ndef add_to_cart(client, context, product_id=None, quantity=1):\n    \"\"\"Add product to shopping cart.\"\"\"\n    product_id = product_id or context.get(\"product_id\")\n    response = client.post(\"/api/cart/items\", json={\n        \"product_id\": product_id,\n        \"quantity\": quantity,\n    })\n    if response.status_code == 200:\n        context[\"cart_id\"] = response.json()[\"cart_id\"]\n    return response\n\ndef get_cart(client, context):\n    \"\"\"Get current cart contents.\"\"\"\n    cart_id = context.get(\"cart_id\")\n    if cart_id:\n        return client.get(f\"/api/cart/{cart_id}\")\n    return client.get(\"/api/cart\")\n\ndef apply_coupon(client, context, code=\"DISCOUNT10\"):\n    \"\"\"Apply discount coupon to cart.\"\"\"\n    cart_id = context.get_required(\"cart_id\")\n    return client.post(f\"/api/cart/{cart_id}/coupon\", json={\"code\": code})\n\ndef start_checkout(client, context):\n    \"\"\"Begin checkout process.\"\"\"\n    cart_id = context.get_required(\"cart_id\")\n    response = client.post(f\"/api/cart/{cart_id}/checkout\")\n    if response.status_code == 200:\n        context[\"order_id\"] = response.json()[\"order_id\"]\n    return response\n\ndef add_shipping_address(client, context):\n    \"\"\"Add shipping address to order.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/shipping\", json={\n        \"name\": \"John Doe\",\n        \"address\": \"123 Main St\",\n        \"city\": \"New York\",\n        \"state\": \"NY\",\n        \"zip\": \"10001\",\n        \"country\": \"USA\",\n    })\n\ndef pay_with_credit_card(client, context):\n    \"\"\"Process credit card payment.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/payment\", json={\n        \"method\": \"credit_card\",\n        \"card_number\": \"4242424242424242\",\n        \"exp_month\": 12,\n        \"exp_year\": 2025,\n        \"cvv\": \"123\",\n    })\n\ndef pay_with_paypal(client, context):\n    \"\"\"Process PayPal payment.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/payment\", json={\n        \"method\": \"paypal\",\n        \"return_url\": \"https://example.com/return\",\n    })\n\ndef pay_with_crypto(client, context):\n    \"\"\"Process cryptocurrency payment.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/payment\", json={\n        \"method\": \"crypto\",\n        \"currency\": \"BTC\",\n    })\n\ndef confirm_order(client, context):\n    \"\"\"Confirm and finalize order.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    response = client.post(f\"/api/orders/{order_id}/confirm\")\n    if response.status_code == 200:\n        context[\"confirmation_number\"] = response.json()[\"confirmation_number\"]\n    return response\n</code></pre>"},{"location":"examples/#journey-definition","title":"Journey Definition","text":"Python<pre><code># journeys/ecommerce_checkout.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.shop import (\n    add_to_cart, get_cart, apply_coupon, start_checkout,\n    add_shipping_address, pay_with_credit_card, pay_with_paypal,\n    pay_with_crypto, confirm_order,\n)\n\ncheckout_journey = Journey(\n    name=\"ecommerce_checkout\",\n    description=\"Complete e-commerce checkout flow with multiple payment methods\",\n    tags=[\"e-commerce\", \"checkout\", \"payment\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"add_item\", action=lambda c, ctx: add_to_cart(c, ctx, product_id=123)),\n        Step(name=\"verify_cart\", action=get_cart),\n        Step(name=\"apply_discount\", action=apply_coupon),\n        Checkpoint(name=\"cart_ready\"),\n        Step(name=\"start_checkout\", action=start_checkout),\n        Step(name=\"add_shipping\", action=add_shipping_address),\n        Checkpoint(name=\"ready_for_payment\"),\n        Branch(\n            checkpoint_name=\"ready_for_payment\",\n            paths=[\n                Path(name=\"credit_card\", steps=[\n                    Step(name=\"pay_card\", action=pay_with_credit_card),\n                    Step(name=\"confirm_card\", action=confirm_order),\n                ]),\n                Path(name=\"paypal\", steps=[\n                    Step(name=\"pay_paypal\", action=pay_with_paypal),\n                    Step(name=\"confirm_paypal\", action=confirm_order),\n                ]),\n                Path(name=\"crypto\", steps=[\n                    Step(name=\"pay_crypto\", action=pay_with_crypto),\n                    Step(name=\"confirm_crypto\", action=confirm_order),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#user-registration-with-email-verification","title":"User Registration with Email Verification","text":"<p>Test complete registration flow including email verification.</p>"},{"location":"examples/#actions","title":"Actions","text":"Python<pre><code># actions/user_registration.py\nimport time\n\ndef register_user(client, context, email=None, password=None):\n    \"\"\"Register a new user account.\"\"\"\n    email = email or context.get(\"email\", f\"test_{int(time.time())}@example.com\")\n    password = password or context.get(\"password\", \"SecurePass123!\")\n\n    response = client.post(\"/api/auth/register\", json={\n        \"email\": email,\n        \"password\": password,\n        \"name\": \"Test User\",\n    })\n\n    if response.status_code == 201:\n        context[\"user_email\"] = email\n        context[\"user_password\"] = password\n        context[\"user_id\"] = response.json()[\"user\"][\"id\"]\n\n    return response\n\ndef get_verification_token(client, context):\n    \"\"\"Get email verification token (simulating email retrieval).\"\"\"\n    # In real tests, this might query a test email service\n    user_id = context.get_required(\"user_id\")\n    response = client.get(f\"/api/test/verification-token/{user_id}\")\n\n    if response.status_code == 200:\n        context[\"verification_token\"] = response.json()[\"token\"]\n\n    return response\n\ndef verify_email(client, context):\n    \"\"\"Verify email with token.\"\"\"\n    token = context.get_required(\"verification_token\")\n    return client.post(\"/api/auth/verify-email\", json={\"token\": token})\n\ndef login_and_verify(client, context):\n    \"\"\"Login and verify account is active.\"\"\"\n    email = context.get_required(\"user_email\")\n    password = context.get_required(\"user_password\")\n\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": email,\n        \"password\": password,\n    })\n\n    if response.status_code == 200:\n        context[\"auth_token\"] = response.json()[\"token\"]\n        client.set_auth_token(context[\"auth_token\"])\n\n    return response\n\ndef check_account_status(client, context):\n    \"\"\"Verify account is verified and active.\"\"\"\n    return client.get(\"/api/auth/me\")\n</code></pre>"},{"location":"examples/#journey","title":"Journey","text":"Python<pre><code># journeys/user_registration.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.user_registration import (\n    register_user, get_verification_token, verify_email,\n    login_and_verify, check_account_status,\n)\n\nregistration_journey = Journey(\n    name=\"user_registration\",\n    description=\"Complete user registration with email verification\",\n    tags=[\"auth\", \"registration\", \"email\"],\n    steps=[\n        Step(name=\"register\", action=register_user),\n        Checkpoint(name=\"user_created\"),\n        Step(name=\"get_token\", action=get_verification_token),\n        Checkpoint(name=\"token_retrieved\"),\n        Branch(\n            checkpoint_name=\"token_retrieved\",\n            paths=[\n                Path(name=\"valid_verification\", steps=[\n                    Step(name=\"verify_email\", action=verify_email),\n                    Step(name=\"login\", action=login_and_verify),\n                    Step(name=\"check_status\", action=check_account_status),\n                ]),\n                Path(name=\"invalid_token\", steps=[\n                    Step(\n                        name=\"verify_with_invalid\",\n                        action=lambda c, ctx: c.post(\"/api/auth/verify-email\", json={\"token\": \"invalid\"}),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"expired_token\", steps=[\n                    Step(\n                        name=\"verify_with_expired\",\n                        action=lambda c, ctx: c.post(\"/api/auth/verify-email\", json={\"token\": \"expired_token_123\"}),\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#api-rate-limiting-tests","title":"API Rate Limiting Tests","text":"<p>Test rate limiting behavior and error handling.</p>"},{"location":"examples/#actions_1","title":"Actions","text":"Python<pre><code># actions/rate_limit.py\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef make_request(client, context, endpoint=\"/api/data\"):\n    \"\"\"Make a single API request.\"\"\"\n    return client.get(endpoint)\n\ndef burst_requests(client, context, count=10, endpoint=\"/api/data\"):\n    \"\"\"Make multiple rapid requests.\"\"\"\n    results = []\n    for _ in range(count):\n        results.append(client.get(endpoint))\n    context[\"burst_results\"] = results\n    return results[-1]\n\ndef parallel_requests(client, context, count=10, endpoint=\"/api/data\"):\n    \"\"\"Make parallel requests to trigger rate limiting.\"\"\"\n    def make_request():\n        return client.get(endpoint)\n\n    with ThreadPoolExecutor(max_workers=count) as executor:\n        futures = [executor.submit(make_request) for _ in range(count)]\n        results = [f.result() for f in futures]\n\n    context[\"parallel_results\"] = results\n    return results[-1]\n\ndef wait_and_retry(client, context):\n    \"\"\"Wait for rate limit to reset and retry.\"\"\"\n    time.sleep(60)  # Wait for rate limit window\n    return client.get(\"/api/data\")\n\ndef check_rate_limit_headers(client, context):\n    \"\"\"Check rate limit headers in response.\"\"\"\n    response = client.get(\"/api/data\")\n\n    headers = response.headers\n    context[\"rate_limit\"] = {\n        \"limit\": headers.get(\"X-RateLimit-Limit\"),\n        \"remaining\": headers.get(\"X-RateLimit-Remaining\"),\n        \"reset\": headers.get(\"X-RateLimit-Reset\"),\n    }\n\n    return response\n</code></pre>"},{"location":"examples/#journey_1","title":"Journey","text":"Python<pre><code># journeys/rate_limiting.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.rate_limit import (\n    make_request, burst_requests, parallel_requests,\n    wait_and_retry, check_rate_limit_headers,\n)\n\nrate_limit_journey = Journey(\n    name=\"rate_limiting\",\n    description=\"Test API rate limiting behavior\",\n    tags=[\"rate-limit\", \"api\", \"reliability\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"check_headers\", action=check_rate_limit_headers),\n        Checkpoint(name=\"initial_state\"),\n        Branch(\n            checkpoint_name=\"initial_state\",\n            paths=[\n                Path(name=\"sequential_burst\", steps=[\n                    Step(name=\"burst_10\", action=lambda c, ctx: burst_requests(c, ctx, count=10)),\n                    Step(\n                        name=\"expect_rate_limited\",\n                        action=lambda c, ctx: make_request(c, ctx),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"parallel_burst\", steps=[\n                    Step(name=\"parallel_20\", action=lambda c, ctx: parallel_requests(c, ctx, count=20)),\n                    Step(\n                        name=\"expect_blocked\",\n                        action=lambda c, ctx: make_request(c, ctx),\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#multi-tenant-application-testing","title":"Multi-Tenant Application Testing","text":"<p>Test behavior across different tenants with data isolation.</p>"},{"location":"examples/#actions_2","title":"Actions","text":"Python<pre><code># actions/multi_tenant.py\n\ndef switch_tenant(client, context, tenant_id=None):\n    \"\"\"Switch to a specific tenant context.\"\"\"\n    tenant_id = tenant_id or context.get(\"tenant_id\")\n    client.clear_auth()\n\n    # Get tenant-specific auth\n    response = client.post(\"/api/auth/tenant-login\", json={\n        \"tenant_id\": tenant_id,\n        \"api_key\": f\"key_{tenant_id}\",\n    })\n\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n        context[\"current_tenant\"] = tenant_id\n\n    return response\n\ndef create_tenant_resource(client, context, name=None):\n    \"\"\"Create a resource in current tenant.\"\"\"\n    tenant = context.get(\"current_tenant\")\n    name = name or f\"Resource for {tenant}\"\n\n    response = client.post(\"/api/resources\", json={\n        \"name\": name,\n        \"tenant_id\": tenant,\n    })\n\n    if response.status_code == 201:\n        context[f\"resource_{tenant}\"] = response.json()[\"id\"]\n\n    return response\n\ndef list_tenant_resources(client, context):\n    \"\"\"List resources for current tenant.\"\"\"\n    return client.get(\"/api/resources\")\n\ndef try_cross_tenant_access(client, context, target_tenant=None, resource_id=None):\n    \"\"\"Attempt to access another tenant's resource.\"\"\"\n    target = target_tenant or context.get(\"other_tenant\")\n    resource = resource_id or context.get(f\"resource_{target}\")\n\n    return client.get(f\"/api/resources/{resource}\")\n</code></pre>"},{"location":"examples/#journey_2","title":"Journey","text":"Python<pre><code># journeys/multi_tenant.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.multi_tenant import (\n    switch_tenant, create_tenant_resource, list_tenant_resources,\n    try_cross_tenant_access,\n)\n\nmulti_tenant_journey = Journey(\n    name=\"multi_tenant_isolation\",\n    description=\"Test multi-tenant data isolation\",\n    tags=[\"multi-tenant\", \"security\", \"isolation\"],\n    steps=[\n        # Setup tenant A\n        Step(name=\"switch_tenant_a\", action=lambda c, ctx: switch_tenant(c, ctx, tenant_id=\"tenant_a\")),\n        Step(name=\"create_resource_a\", action=create_tenant_resource),\n        Checkpoint(name=\"tenant_a_setup\"),\n\n        # Setup tenant B\n        Step(name=\"switch_tenant_b\", action=lambda c, ctx: switch_tenant(c, ctx, tenant_id=\"tenant_b\")),\n        Step(name=\"create_resource_b\", action=create_tenant_resource),\n        context[\"other_tenant\"] = \"tenant_a\",\n        Checkpoint(name=\"tenant_b_setup\"),\n\n        # Test isolation\n        Branch(\n            checkpoint_name=\"tenant_b_setup\",\n            paths=[\n                Path(name=\"isolation_test\", steps=[\n                    # Tenant B tries to access Tenant A's resource\n                    Step(\n                        name=\"cross_tenant_access\",\n                        action=try_cross_tenant_access,\n                        expect_failure=True,  # Should fail\n                    ),\n                ]),\n                Path(name=\"list_own_resources\", steps=[\n                    Step(name=\"list_b_resources\", action=list_tenant_resources),\n                ]),\n            ],\n        ),\n\n        # Switch back to A and verify\n        Step(name=\"back_to_tenant_a\", action=lambda c, ctx: switch_tenant(c, ctx, tenant_id=\"tenant_a\")),\n        Step(name=\"verify_a_resources\", action=list_tenant_resources),\n    ],\n)\n</code></pre>"},{"location":"examples/#payment-gateway-integration","title":"Payment Gateway Integration","text":"<p>Test payment processing with various scenarios.</p>"},{"location":"examples/#actions_3","title":"Actions","text":"Python<pre><code># actions/payment.py\n\ndef create_payment_intent(client, context, amount=1000, currency=\"usd\"):\n    \"\"\"Create a payment intent.\"\"\"\n    response = client.post(\"/api/payments/intents\", json={\n        \"amount\": amount,\n        \"currency\": currency,\n    })\n\n    if response.status_code == 201:\n        context[\"payment_intent_id\"] = response.json()[\"id\"]\n        context[\"payment_amount\"] = amount\n\n    return response\n\ndef confirm_payment(client, context, payment_method=\"card_success\"):\n    \"\"\"Confirm a payment with specified method.\"\"\"\n    intent_id = context.get_required(\"payment_intent_id\")\n\n    response = client.post(f\"/api/payments/intents/{intent_id}/confirm\", json={\n        \"payment_method\": payment_method,\n    })\n\n    if response.status_code == 200:\n        context[\"payment_status\"] = response.json()[\"status\"]\n\n    return response\n\ndef refund_payment(client, context, amount=None):\n    \"\"\"Refund a payment.\"\"\"\n    intent_id = context.get_required(\"payment_intent_id\")\n    amount = amount or context.get(\"payment_amount\")\n\n    return client.post(f\"/api/payments/intents/{intent_id}/refund\", json={\n        \"amount\": amount,\n    })\n\ndef get_payment_status(client, context):\n    \"\"\"Get current payment status.\"\"\"\n    intent_id = context.get_required(\"payment_intent_id\")\n    return client.get(f\"/api/payments/intents/{intent_id}\")\n</code></pre>"},{"location":"examples/#journey_3","title":"Journey","text":"Python<pre><code># journeys/payment_gateway.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.payment import (\n    create_payment_intent, confirm_payment, refund_payment, get_payment_status,\n)\n\npayment_journey = Journey(\n    name=\"payment_gateway\",\n    description=\"Test payment gateway integration\",\n    tags=[\"payment\", \"integration\", \"critical\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"create_intent\", action=create_payment_intent),\n        Checkpoint(name=\"intent_created\"),\n        Branch(\n            checkpoint_name=\"intent_created\",\n            paths=[\n                Path(name=\"successful_payment\", steps=[\n                    Step(name=\"confirm_success\", action=lambda c, ctx: confirm_payment(c, ctx, \"card_success\")),\n                    Step(name=\"verify_success\", action=get_payment_status),\n                ]),\n                Path(name=\"declined_payment\", steps=[\n                    Step(\n                        name=\"confirm_declined\",\n                        action=lambda c, ctx: confirm_payment(c, ctx, \"card_declined\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"insufficient_funds\", steps=[\n                    Step(\n                        name=\"confirm_insufficient\",\n                        action=lambda c, ctx: confirm_payment(c, ctx, \"card_insufficient\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"payment_then_refund\", steps=[\n                    Step(name=\"confirm_for_refund\", action=lambda c, ctx: confirm_payment(c, ctx, \"card_success\")),\n                    Step(name=\"refund_full\", action=refund_payment),\n                    Step(name=\"verify_refunded\", action=get_payment_status),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#file-upload-and-processing","title":"File Upload and Processing","text":"<p>Test file upload and async processing.</p>"},{"location":"examples/#actions_4","title":"Actions","text":"Python<pre><code># actions/file_upload.py\nimport io\nimport time\n\ndef upload_file(client, context, filename=\"test.csv\", content=None):\n    \"\"\"Upload a file for processing.\"\"\"\n    content = content or b\"id,name\\n1,Test\\n2,Example\"\n\n    files = {\n        \"file\": (filename, io.BytesIO(content), \"text/csv\"),\n    }\n\n    response = client.post(\"/api/uploads\", files=files)\n\n    if response.status_code == 201:\n        context[\"upload_id\"] = response.json()[\"upload_id\"]\n\n    return response\n\ndef get_upload_status(client, context):\n    \"\"\"Get upload processing status.\"\"\"\n    upload_id = context.get_required(\"upload_id\")\n    return client.get(f\"/api/uploads/{upload_id}\")\n\ndef wait_for_processing(client, context, timeout=60):\n    \"\"\"Wait for upload to finish processing.\"\"\"\n    upload_id = context.get_required(\"upload_id\")\n    start = time.time()\n\n    while time.time() - start &lt; timeout:\n        response = client.get(f\"/api/uploads/{upload_id}\")\n        status = response.json()[\"status\"]\n\n        if status in [\"completed\", \"failed\"]:\n            context[\"processing_status\"] = status\n            return response\n\n        time.sleep(1)\n\n    raise TimeoutError(\"Processing timed out\")\n\ndef get_upload_results(client, context):\n    \"\"\"Get results of processed upload.\"\"\"\n    upload_id = context.get_required(\"upload_id\")\n    return client.get(f\"/api/uploads/{upload_id}/results\")\n\ndef upload_large_file(client, context, size_mb=10):\n    \"\"\"Upload a large file.\"\"\"\n    content = b\"x\" * (size_mb * 1024 * 1024)\n    return upload_file(client, context, filename=\"large.bin\", content=content)\n</code></pre>"},{"location":"examples/#journey_4","title":"Journey","text":"Python<pre><code># journeys/file_upload.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.file_upload import (\n    upload_file, get_upload_status, wait_for_processing,\n    get_upload_results, upload_large_file,\n)\n\nfile_upload_journey = Journey(\n    name=\"file_upload\",\n    description=\"Test file upload and processing\",\n    tags=[\"upload\", \"async\", \"processing\"],\n    timeout=120.0,\n    steps=[\n        Step(name=\"login\", action=login),\n        Checkpoint(name=\"authenticated\"),\n        Branch(\n            checkpoint_name=\"authenticated\",\n            paths=[\n                Path(name=\"small_csv\", steps=[\n                    Step(name=\"upload_csv\", action=upload_file),\n                    Step(name=\"wait_process\", action=wait_for_processing),\n                    Step(name=\"get_results\", action=get_upload_results),\n                ]),\n                Path(name=\"invalid_format\", steps=[\n                    Step(\n                        name=\"upload_invalid\",\n                        action=lambda c, ctx: upload_file(c, ctx, filename=\"test.exe\", content=b\"invalid\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"large_file\", steps=[\n                    Step(name=\"upload_large\", action=lambda c, ctx: upload_large_file(c, ctx, size_mb=50)),\n                    Step(name=\"wait_large\", action=wait_for_processing),\n                ], description=\"Test large file handling\"),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#websocket-and-real-time-features","title":"WebSocket and Real-Time Features","text":"<p>Test WebSocket connections and real-time updates.</p>"},{"location":"examples/#actions_5","title":"Actions","text":"Python<pre><code># actions/websocket.py\nimport json\nimport time\n\ndef subscribe_to_channel(client, context, channel=\"updates\"):\n    \"\"\"Subscribe to a real-time channel via REST.\"\"\"\n    response = client.post(\"/api/realtime/subscribe\", json={\n        \"channel\": channel,\n    })\n\n    if response.status_code == 200:\n        context[\"channel\"] = channel\n        context[\"subscription_id\"] = response.json()[\"subscription_id\"]\n\n    return response\n\ndef trigger_event(client, context, event_type=\"test_event\", data=None):\n    \"\"\"Trigger a real-time event.\"\"\"\n    channel = context.get(\"channel\", \"updates\")\n\n    return client.post(\"/api/realtime/events\", json={\n        \"channel\": channel,\n        \"event\": event_type,\n        \"data\": data or {\"message\": \"test\"},\n    })\n\ndef poll_for_events(client, context, timeout=10):\n    \"\"\"Poll for events (simulating WebSocket).\"\"\"\n    subscription_id = context.get_required(\"subscription_id\")\n    events = []\n    start = time.time()\n\n    while time.time() - start &lt; timeout:\n        response = client.get(f\"/api/realtime/events/{subscription_id}\")\n        if response.status_code == 200:\n            new_events = response.json().get(\"events\", [])\n            events.extend(new_events)\n\n            if events:\n                context[\"received_events\"] = events\n                return response\n\n        time.sleep(0.5)\n\n    context[\"received_events\"] = events\n    return response\n\ndef unsubscribe(client, context):\n    \"\"\"Unsubscribe from channel.\"\"\"\n    subscription_id = context.get_required(\"subscription_id\")\n    return client.delete(f\"/api/realtime/subscriptions/{subscription_id}\")\n</code></pre>"},{"location":"examples/#journey_5","title":"Journey","text":"Python<pre><code># journeys/realtime.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.websocket import (\n    subscribe_to_channel, trigger_event, poll_for_events, unsubscribe,\n)\n\nrealtime_journey = Journey(\n    name=\"realtime_features\",\n    description=\"Test real-time WebSocket features\",\n    tags=[\"websocket\", \"realtime\", \"events\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"subscribe\", action=subscribe_to_channel),\n        Checkpoint(name=\"subscribed\"),\n        Branch(\n            checkpoint_name=\"subscribed\",\n            paths=[\n                Path(name=\"single_event\", steps=[\n                    Step(name=\"trigger\", action=trigger_event),\n                    Step(name=\"poll\", action=poll_for_events),\n                ]),\n                Path(name=\"multiple_events\", steps=[\n                    Step(name=\"trigger_1\", action=lambda c, ctx: trigger_event(c, ctx, \"event_1\")),\n                    Step(name=\"trigger_2\", action=lambda c, ctx: trigger_event(c, ctx, \"event_2\")),\n                    Step(name=\"trigger_3\", action=lambda c, ctx: trigger_event(c, ctx, \"event_3\")),\n                    Step(name=\"poll_multiple\", action=lambda c, ctx: poll_for_events(c, ctx, timeout=15)),\n                ]),\n            ],\n        ),\n        Step(name=\"unsubscribe\", action=unsubscribe),\n    ],\n)\n</code></pre>"},{"location":"examples/#third-party-api-mocking","title":"Third-Party API Mocking","text":"<p>Test with mocked third-party services.</p>"},{"location":"examples/#actions_6","title":"Actions","text":"Python<pre><code># actions/integrations.py\n\ndef configure_stripe_mock(client, context, scenario=\"success\"):\n    \"\"\"Configure Stripe mock for testing.\"\"\"\n    return client.post(\"/api/test/mock/stripe\", json={\n        \"scenario\": scenario,\n    })\n\ndef configure_sendgrid_mock(client, context, scenario=\"success\"):\n    \"\"\"Configure SendGrid mock for testing.\"\"\"\n    return client.post(\"/api/test/mock/sendgrid\", json={\n        \"scenario\": scenario,\n    })\n\ndef verify_email_sent(client, context):\n    \"\"\"Verify email was sent via mock.\"\"\"\n    response = client.get(\"/api/test/mock/sendgrid/emails\")\n\n    if response.status_code == 200:\n        emails = response.json().get(\"emails\", [])\n        if emails:\n            context[\"last_email\"] = emails[-1]\n\n    return response\n\ndef verify_stripe_charge(client, context):\n    \"\"\"Verify Stripe charge was created.\"\"\"\n    response = client.get(\"/api/test/mock/stripe/charges\")\n\n    if response.status_code == 200:\n        charges = response.json().get(\"charges\", [])\n        if charges:\n            context[\"last_charge\"] = charges[-1]\n\n    return response\n</code></pre>"},{"location":"examples/#journey_6","title":"Journey","text":"Python<pre><code># journeys/third_party_mocks.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.integrations import (\n    configure_stripe_mock, configure_sendgrid_mock,\n    verify_email_sent, verify_stripe_charge,\n)\nfrom actions.payment import create_payment_intent, confirm_payment\nfrom actions.user_registration import register_user\n\nmocked_integration_journey = Journey(\n    name=\"third_party_mocks\",\n    description=\"Test with mocked third-party services\",\n    tags=[\"mocking\", \"integration\", \"testing\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Checkpoint(name=\"authenticated\"),\n\n        Branch(\n            checkpoint_name=\"authenticated\",\n            paths=[\n                Path(name=\"stripe_success\", steps=[\n                    Step(name=\"mock_stripe_ok\", action=lambda c, ctx: configure_stripe_mock(c, ctx, \"success\")),\n                    Step(name=\"create_payment\", action=create_payment_intent),\n                    Step(name=\"confirm_payment\", action=lambda c, ctx: confirm_payment(c, ctx, \"card_success\")),\n                    Step(name=\"verify_charge\", action=verify_stripe_charge),\n                ]),\n                Path(name=\"stripe_failure\", steps=[\n                    Step(name=\"mock_stripe_fail\", action=lambda c, ctx: configure_stripe_mock(c, ctx, \"card_declined\")),\n                    Step(name=\"create_payment_fail\", action=create_payment_intent),\n                    Step(\n                        name=\"confirm_fail\",\n                        action=lambda c, ctx: confirm_payment(c, ctx, \"card_declined\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"email_success\", steps=[\n                    Step(name=\"mock_sendgrid_ok\", action=lambda c, ctx: configure_sendgrid_mock(c, ctx, \"success\")),\n                    Step(name=\"register_user\", action=register_user),\n                    Step(name=\"verify_email\", action=verify_email_sent),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"faq/","title":"FAQ","text":"<p>Common questions about VenomQA.</p>"},{"location":"faq/#general","title":"General","text":"<p>Q: What is VenomQA?</p> <p>A: VenomQA is a state-based API testing framework that helps you test your entire application through state exploration.</p>"},{"location":"plugins/","title":"VenomQA Plugin System","text":"<p>VenomQA provides a comprehensive plugin architecture that enables you to extend the framework's functionality. Plugins can add custom reporters, service adapters, data generators, reusable actions, and lifecycle hooks.</p>"},{"location":"plugins/#overview","title":"Overview","text":"<p>The plugin system supports five main extension points:</p> <ol> <li>Reporters - Custom output formats (Slack, DataDog, custom formats)</li> <li>Adapters - Service integrations (databases, caches, queues)</li> <li>Generators - Data generation (domain-specific test data)</li> <li>Actions - Reusable action sets (common test patterns)</li> <li>Hooks - Lifecycle callbacks (notifications, metrics, logging)</li> </ol>"},{"location":"plugins/#creating-a-plugin","title":"Creating a Plugin","text":""},{"location":"plugins/#basic-plugin-structure","title":"Basic Plugin Structure","text":"<p>All plugins inherit from <code>VenomQAPlugin</code>:</p> Python<pre><code>from venomqa.plugins import VenomQAPlugin, PluginType, HookPriority\n\nclass MyPlugin(VenomQAPlugin):\n    # Required: Plugin identifier\n    name = \"my-plugin\"\n    version = \"1.0.0\"\n\n    # Optional: Plugin type (default: HOOK)\n    plugin_type = PluginType.HOOK\n    description = \"My custom plugin\"\n    author = \"Your Name\"\n    priority = HookPriority.NORMAL\n\n    def on_load(self, config: dict) -&gt; None:\n        \"\"\"Called when plugin is loaded.\"\"\"\n        super().on_load(config)\n        self.api_key = config.get(\"api_key\")\n\n    def on_journey_start(self, context):\n        \"\"\"Called before each journey.\"\"\"\n        print(f\"Starting: {context.journey.name}\")\n\n    def on_failure(self, context):\n        \"\"\"Called when a test fails.\"\"\"\n        self.send_alert(context.error)\n</code></pre>"},{"location":"plugins/#plugin-types","title":"Plugin Types","text":""},{"location":"plugins/#hook-plugin","title":"Hook Plugin","text":"<p>For plugins that only need lifecycle callbacks:</p> Python<pre><code>from venomqa.plugins import HookPlugin, HookPriority\n\nclass NotifierPlugin(HookPlugin):\n    name = \"notifier\"\n    version = \"1.0.0\"\n    priority = HookPriority.LOW  # Run after other plugins\n\n    def on_failure(self, context):\n        self.send_notification(context)\n</code></pre>"},{"location":"plugins/#reporter-plugin","title":"Reporter Plugin","text":"<p>For plugins that provide custom report formats:</p> Python<pre><code>from venomqa.plugins import ReporterPlugin\nfrom venomqa.reporters.base import BaseReporter\n\nclass MyReporter(BaseReporter):\n    @property\n    def file_extension(self) -&gt; str:\n        return \".html\"\n\n    def generate(self, results):\n        return \"&lt;html&gt;...&lt;/html&gt;\"\n\nclass MyReporterPlugin(ReporterPlugin):\n    name = \"my-reporter\"\n    version = \"1.0.0\"\n\n    def get_reporter(self) -&gt; BaseReporter:\n        return MyReporter()\n</code></pre>"},{"location":"plugins/#adapter-plugin","title":"Adapter Plugin","text":"<p>For plugins that provide service adapters:</p> Python<pre><code>from venomqa.plugins import AdapterPlugin\n\nclass MongoDBPlugin(AdapterPlugin):\n    name = \"mongodb\"\n    version = \"1.0.0\"\n    provides_adapters = [\"database\"]\n\n    def get_adapter(self, port_type: str):\n        if port_type == \"database\":\n            return MongoDBAdapter(self.config)\n        return None\n</code></pre>"},{"location":"plugins/#action-plugin","title":"Action Plugin","text":"<p>For plugins that provide reusable actions:</p> Python<pre><code>from venomqa.plugins import ActionPlugin\n\nclass AuthActionsPlugin(ActionPlugin):\n    name = \"auth-actions\"\n    version = \"1.0.0\"\n\n    def get_actions(self) -&gt; dict:\n        return {\n            \"auth.login\": self._login,\n            \"auth.logout\": self._logout,\n            \"auth.refresh\": self._refresh_token,\n        }\n\n    def _login(self, client, ctx, **kwargs):\n        return client.post(\"/auth/login\", json=kwargs)\n</code></pre>"},{"location":"plugins/#available-hooks","title":"Available Hooks","text":""},{"location":"plugins/#plugin-lifecycle","title":"Plugin Lifecycle","text":"Hook Method Called When <code>ON_LOAD</code> <code>on_load(config)</code> Plugin is loaded <code>ON_UNLOAD</code> <code>on_unload()</code> Plugin is unloaded"},{"location":"plugins/#journey-lifecycle","title":"Journey Lifecycle","text":"Hook Method Called When <code>BEFORE_JOURNEY</code> <code>on_journey_start(context)</code> Before journey execution <code>AFTER_JOURNEY</code> <code>on_journey_complete(journey, result, context)</code> After journey completes <code>ON_JOURNEY_ERROR</code> <code>on_journey_error(journey, error, context)</code> Journey fails with exception"},{"location":"plugins/#step-lifecycle","title":"Step Lifecycle","text":"Hook Method Called When <code>BEFORE_STEP</code> <code>on_step_start(step, context)</code> Before step execution <code>AFTER_STEP</code> <code>on_step_complete(step, result, context)</code> After step completes <code>ON_STEP_ERROR</code> <code>on_step_error(step, error, context)</code> Step fails with exception"},{"location":"plugins/#branch-lifecycle","title":"Branch Lifecycle","text":"Hook Method Called When <code>BEFORE_BRANCH</code> <code>on_branch_start(branch, context)</code> Before branch exploration <code>AFTER_BRANCH</code> <code>on_branch_complete(branch, result, context)</code> After all paths complete <code>BEFORE_PATH</code> <code>on_path_start(path, context)</code> Before path execution <code>AFTER_PATH</code> <code>on_path_complete(path, result, context)</code> After path completes"},{"location":"plugins/#state-lifecycle","title":"State Lifecycle","text":"Hook Method Called When <code>ON_CHECKPOINT</code> <code>on_checkpoint(checkpoint_name, context)</code> Checkpoint created <code>ON_ROLLBACK</code> <code>on_rollback(checkpoint_name, context)</code> Rolling back to checkpoint"},{"location":"plugins/#error-handling","title":"Error Handling","text":"Hook Method Called When <code>ON_FAILURE</code> <code>on_failure(context)</code> Test failure captured <code>ON_RETRY</code> <code>on_retry(step, attempt, max_attempts, error, context)</code> Step being retried <code>ON_TIMEOUT</code> <code>on_timeout(step, timeout, context)</code> Step times out"},{"location":"plugins/#plugin-configuration","title":"Plugin Configuration","text":""},{"location":"plugins/#yaml-configuration","title":"YAML Configuration","text":"<p>Configure plugins in <code>venomqa.yaml</code>:</p> YAML<pre><code>plugins:\n  # Auto-discover plugins from entry points\n  auto_discover: true\n\n  # Local plugins directory\n  local_plugins_path: qa/plugins\n\n  # Plugin configurations\n  plugins:\n    # Reference by entry point name\n    - name: venomqa-slack\n      enabled: true\n      priority: low\n      config:\n        webhook_url: https://hooks.slack.com/services/...\n        channel: \"#qa-alerts\"\n\n    # Reference by module path\n    - name: venomqa.plugins.examples.timing_analyzer\n      config:\n        threshold_warning_ms: 1000\n\n    # Reference local file\n    - name: ./qa/plugins/custom.py\n      enabled: true\n</code></pre>"},{"location":"plugins/#programmatic-configuration","title":"Programmatic Configuration","text":"Python<pre><code>from venomqa.plugins import (\n    PluginManager,\n    PluginsConfig,\n    PluginConfig,\n    HookPriority,\n)\n\nconfig = PluginsConfig(\n    auto_discover=True,\n    local_plugins_path=\"qa/plugins\",\n    plugins=[\n        PluginConfig(\n            name=\"my-plugin\",\n            enabled=True,\n            priority=HookPriority.HIGH,\n            config={\"api_key\": \"xxx\"},\n        ),\n    ],\n)\n\nmanager = PluginManager()\nmanager.load_plugins_from_config(config)\n</code></pre>"},{"location":"plugins/#plugin-discovery","title":"Plugin Discovery","text":"<p>Plugins are discovered from multiple sources:</p>"},{"location":"plugins/#1-entry-points-recommended","title":"1. Entry Points (Recommended)","text":"<p>Register plugins in <code>pyproject.toml</code>:</p> TOML<pre><code>[project.entry-points.\"venomqa.plugins\"]\nmy-plugin = \"my_package.plugin:MyPlugin\"\n</code></pre> <p>Install the package and VenomQA will auto-discover it.</p>"},{"location":"plugins/#2-local-directory","title":"2. Local Directory","text":"<p>Place Python files in <code>qa/plugins/</code>:</p> Python<pre><code># qa/plugins/custom.py\nfrom venomqa.plugins import VenomQAPlugin\n\nclass CustomPlugin(VenomQAPlugin):\n    name = \"custom\"\n    version = \"1.0.0\"\n    ...\n\n# Either export directly:\nplugin = CustomPlugin()\n\n# Or use 'Plugin' class name:\nPlugin = CustomPlugin\n</code></pre>"},{"location":"plugins/#3-module-import","title":"3. Module Import","text":"<p>Load by module path:</p> Python<pre><code>manager.load_plugin(\"my_package.plugins.custom\")\n</code></pre>"},{"location":"plugins/#built-in-example-plugins","title":"Built-in Example Plugins","text":"<p>VenomQA includes several example plugins:</p>"},{"location":"plugins/#console-logger","title":"Console Logger","text":"<p>Rich console output during test execution:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.console_logger\n    config:\n      level: debug\n      color: true\n      show_timestamps: true\n</code></pre>"},{"location":"plugins/#timing-analyzer","title":"Timing Analyzer","text":"<p>Analyze step execution times:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.timing_analyzer\n    config:\n      threshold_warning_ms: 1000\n      threshold_critical_ms: 5000\n      track_percentiles: [50, 90, 95, 99]\n</code></pre>"},{"location":"plugins/#slack-notifier","title":"Slack Notifier","text":"<p>Send Slack notifications:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.slack_notifier\n    config:\n      webhook_url: ${SLACK_WEBHOOK_URL}\n      channel: \"#qa-alerts\"\n      notify_on_failure: true\n      mention_on_failure: \"@qa-team\"\n</code></pre>"},{"location":"plugins/#datadog-metrics","title":"DataDog Metrics","text":"<p>Report metrics to DataDog:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.datadog_metrics\n    config:\n      api_key: ${DATADOG_API_KEY}\n      prefix: venomqa\n      tags:\n        - env:production\n        - team:qa\n</code></pre>"},{"location":"plugins/#custom-assertions","title":"Custom Assertions","text":"<p>Additional assertion helpers:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.custom_assertions\n    config:\n      strict_mode: false\n</code></pre> <p>Use in steps:</p> Python<pre><code>from venomqa.plugins import get_plugin_manager\n\nmanager = get_plugin_manager()\nassertions = manager.get_assertion(\"assert_json_path\")\n\ndef my_step(client, ctx):\n    response = client.get(\"/api/users\")\n    assertions[\"assert_json_path\"](response, \"data.users.0.name\", \"John\")\n</code></pre>"},{"location":"plugins/#hook-priority","title":"Hook Priority","text":"<p>Control hook execution order with priorities:</p> Python<pre><code>from venomqa.plugins import HookPriority\n\nclass EarlyPlugin(VenomQAPlugin):\n    priority = HookPriority.HIGHEST  # Run first (0)\n\nclass LatePlugin(VenomQAPlugin):\n    priority = HookPriority.LOWEST   # Run last (100)\n</code></pre> <p>Priority levels: - <code>HIGHEST</code> (0) - <code>HIGH</code> (25) - <code>NORMAL</code> (50) - default - <code>LOW</code> (75) - <code>LOWEST</code> (100)</p>"},{"location":"plugins/#error-handling_1","title":"Error Handling","text":"<p>Plugin errors are isolated by default:</p> Python<pre><code># In PluginManager\nmanager = PluginManager(fail_on_plugin_error=False)  # Default\n\n# If True, plugin errors propagate and abort test execution\nmanager = PluginManager(fail_on_plugin_error=True)\n</code></pre>"},{"location":"plugins/#context-objects","title":"Context Objects","text":""},{"location":"plugins/#journeycontext","title":"JourneyContext","text":"Python<pre><code>@dataclass\nclass JourneyContext:\n    journey: Journey          # The Journey object\n    client: Client           # HTTP client\n    state_manager: Any       # State manager (optional)\n    context: ExecutionContext  # Shared state\n</code></pre>"},{"location":"plugins/#stepcontext","title":"StepContext","text":"Python<pre><code>@dataclass\nclass StepContext:\n    journey_name: str\n    path_name: str\n    step_name: str\n    step_number: int\n    step: Step\n    context: ExecutionContext\n</code></pre>"},{"location":"plugins/#failurecontext","title":"FailureContext","text":"Python<pre><code>@dataclass\nclass FailureContext:\n    journey_name: str\n    path_name: str\n    step_name: str\n    error: Exception | str\n    request: dict | None\n    response: dict | None\n    traceback: str | None\n</code></pre>"},{"location":"plugins/#best-practices","title":"Best Practices","text":"<ol> <li>Keep plugins focused - Each plugin should do one thing well</li> <li>Use appropriate priority - Logging plugins should run early, notifications late</li> <li>Handle errors gracefully - Don't let plugin failures break tests</li> <li>Document configuration - Clearly document required and optional config</li> <li>Version your plugins - Follow semantic versioning</li> <li>Test your plugins - Write unit tests for plugin logic</li> </ol>"},{"location":"roadmap/","title":"VenomQA Development Roadmap","text":""},{"location":"roadmap/#current-sprint-comprehensive-enhancement","title":"Current Sprint: Comprehensive Enhancement","text":"<p>Status: 22 parallel workstreams in progress</p>"},{"location":"roadmap/#workstreams","title":"Workstreams","text":""},{"location":"roadmap/#core-framework-improvements","title":"Core Framework Improvements","text":"# Task Status Description 1 Performance Optimization \ud83d\udd04 In Progress Connection pooling, parallel execution fix, caching, benchmarking 2 Retry and Timeout \ud83d\udd04 In Progress Configurable retries, timeouts, circuit breakers 3 Error Messages \ud83d\udd04 In Progress Better errors, debug mode, step-through mode"},{"location":"roadmap/#real-world-validation","title":"Real-World Validation","text":"# Task Status Description 4 Medusa Setup \ud83d\udd04 In Progress Clone, Docker setup, API exploration 5 Medusa Integration \ud83d\udd04 In Progress Full test suite with actions, fixtures, journeys 6 Test Scenarios \ud83d\udd04 In Progress Deep branching, concurrent users, failure recovery"},{"location":"roadmap/#developer-experience","title":"Developer Experience","text":"# Task Status Description 7 Watch Mode \ud83d\udd04 In Progress File watching, auto-rerun on changes 8 OpenAPI Import \ud83d\udd04 In Progress Auto-generate actions from API specs 9 Data Generation \ud83d\udd04 In Progress Faker integration, reproducible test data 10 Data Seeding \ud83d\udd04 In Progress Seed files, auto cleanup, isolation"},{"location":"roadmap/#reporting-and-output","title":"Reporting and Output","text":"# Task Status Description 11 CLI Output \ud83d\udd04 In Progress Real-time progress, better formatting 12 Result Persistence \ud83d\udd04 In Progress Save to database, history command 13 Run Comparison \ud83d\udd04 In Progress Diff between runs, baseline snapshots 14 Notifications \ud83d\udd04 In Progress Slack, email, PagerDuty alerts"},{"location":"roadmap/#testing-capabilities","title":"Testing Capabilities","text":"# Task Status Description 15 Load Testing \ud83d\udd04 In Progress Concurrent users, metrics, assertions 16 Security Testing \ud83d\udd04 In Progress OWASP checks, injection testing 17 Service Mocking \ud83d\udd04 In Progress Mock Stripe, SendGrid, etc. 18 GraphQL Support \ud83d\udd04 In Progress Enhanced queries, subscriptions"},{"location":"roadmap/#infrastructure","title":"Infrastructure","text":"# Task Status Description 19 CI/CD Examples \ud83d\udd04 In Progress GitHub Actions, GitLab CI, Docker 20 Environment Mgmt \ud83d\udd04 In Progress Multi-env configs, secrets 21 Plugin System \ud83d\udd04 In Progress Extensible architecture 22 Documentation \ud83d\udd04 In Progress MkDocs site, tutorials"},{"location":"roadmap/#previously-completed","title":"Previously Completed","text":"Task Status Fix CLI init bootstrap \u2705 Complete Fix optional imports \u2705 Complete Fix verbose flag \u2705 Complete Create examples README \u2705 Complete Document parallel limitation \u2705 Complete"},{"location":"roadmap/#success-metrics","title":"Success Metrics","text":""},{"location":"roadmap/#for-10-release","title":"For 1.0 Release","text":"<ul> <li> VenomQA runs successfully against Medusa e-commerce</li> <li> All 22 workstreams completed and tested</li> <li> Documentation site live</li> <li> PyPI package published</li> <li> At least 3 real-world examples working</li> <li> Test suite &gt;90% passing</li> <li> Performance: 100+ steps/second</li> </ul>"},{"location":"roadmap/#quality-gates","title":"Quality Gates","text":"<ul> <li>All new code has tests</li> <li>No regressions in existing tests</li> <li>Documentation updated</li> <li>Examples verified working</li> </ul>"},{"location":"roadmap/#timeline","title":"Timeline","text":"<ul> <li>Week 1-2: Core improvements, real-world validation</li> <li>Week 3-4: Developer experience, reporting</li> <li>Week 5-6: Testing capabilities, infrastructure</li> <li>Week 7-8: Polish, documentation, release</li> </ul>"},{"location":"roadmap/#architecture-goals","title":"Architecture Goals","text":"<ol> <li>Language Agnostic: Test any API (REST, GraphQL, gRPC)</li> <li>State Management: Database checkpoints and rollback</li> <li>Branching: Explore multiple paths from same state</li> <li>Extensible: Plugin system for customization</li> <li>Observable: Rich reporting and persistence</li> <li>Performant: Fast execution, parallel support</li> </ol>"},{"location":"advanced/","title":"Advanced Usage","text":"<p>Advanced features and patterns for power users.</p>"},{"location":"advanced/#custom-reporters","title":"Custom Reporters","text":"<p>Create custom reporters for your specific needs.</p>"},{"location":"advanced/#custom-backends","title":"Custom Backends","text":"<p>Implement custom state management backends.</p>"},{"location":"advanced/#performance","title":"Performance","text":"<p>Optimize test execution and reduce runtime.</p>"},{"location":"advanced/#testing-patterns","title":"Testing Patterns","text":"<p>Advanced testing patterns and strategies.</p>"},{"location":"advanced/#topics-covered","title":"Topics Covered","text":"Topic Description Custom Reporters Create CSV, Slack, custom format reporters Custom Backends MySQL, Redis, custom state backends Performance Parallel execution, caching, optimization Testing Patterns Data-driven, chaos, regression testing"},{"location":"advanced/#quick-examples","title":"Quick Examples","text":""},{"location":"advanced/#custom-reporter","title":"Custom Reporter","text":"Python<pre><code>from venomqa.reporters.base import BaseReporter\n\nclass CSVReporter(BaseReporter):\n    @property\n    def file_extension(self) -&gt; str:\n        return \".csv\"\n\n    def generate(self, results):\n        # Generate CSV content\n        return \"name,status\\n\" + \"\\n\".join(\n            f\"{r.journey_name},{r.success}\" for r in results\n        )\n</code></pre>"},{"location":"advanced/#custom-state-backend","title":"Custom State Backend","text":"Python<pre><code>from venomqa.state.base import BaseStateManager\n\nclass RedisStateManager(BaseStateManager):\n    def checkpoint(self, name: str) -&gt; None:\n        # Save state to Redis\n        pass\n\n    def rollback(self, name: str) -&gt; None:\n        # Restore state from Redis\n        pass\n</code></pre>"},{"location":"advanced/#parallel-execution","title":"Parallel Execution","text":"YAML<pre><code># venomqa.yaml\nparallel_paths: 4  # Run 4 paths concurrently\n</code></pre>"},{"location":"advanced/#data-driven-testing","title":"Data-Driven Testing","text":"Python<pre><code>test_cases = [\n    {\"email\": \"valid@example.com\", \"expect_success\": True},\n    {\"email\": \"invalid\", \"expect_success\": False},\n]\n\njourneys = [\n    Journey(\n        name=f\"test_{case['email']}\",\n        steps=[\n            Step(\n                name=\"register\",\n                action=lambda c, ctx: c.post(\"/register\", json={\"email\": case[\"email\"]}),\n                expect_failure=not case[\"expect_success\"],\n            ),\n        ],\n    )\n    for case in test_cases\n]\n</code></pre>"},{"location":"advanced/custom-backends/","title":"Custom Backends","text":"<p>Implement custom state management backends for different databases or storage systems.</p>"},{"location":"advanced/custom-backends/#statemanager-protocol","title":"StateManager Protocol","text":"<p>All state backends must implement this protocol:</p> Python<pre><code>from typing import Protocol\n\n\nclass StateManager(Protocol):\n    def connect(self) -&gt; None:\n        \"\"\"Establish connection to the database/service.\"\"\"\n        ...\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Close connection to the database/service.\"\"\"\n        ...\n\n    def checkpoint(self, name: str) -&gt; None:\n        \"\"\"Create a savepoint with the given name.\"\"\"\n        ...\n\n    def rollback(self, name: str) -&gt; None:\n        \"\"\"Rollback to a previously created checkpoint.\"\"\"\n        ...\n\n    def release(self, name: str) -&gt; None:\n        \"\"\"Release a checkpoint (free resources).\"\"\"\n        ...\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset database to clean state (truncate tables).\"\"\"\n        ...\n\n    def is_connected(self) -&gt; bool:\n        \"\"\"Check if connection is active.\"\"\"\n        ...\n</code></pre>"},{"location":"advanced/custom-backends/#basestatemanager-class","title":"BaseStateManager Class","text":"<p>Use <code>BaseStateManager</code> as a starting point:</p> Python<pre><code>from venomqa.state.base import BaseStateManager\n\n\nclass MyStateManager(BaseStateManager):\n    def __init__(self, connection_url: str, **kwargs):\n        super().__init__(connection_url)\n        self._conn = None\n\n    def connect(self) -&gt; None:\n        self._conn = my_db.connect(self.connection_url)\n        self._connected = True\n\n    def disconnect(self) -&gt; None:\n        if self._conn:\n            self._conn.close()\n            self._conn = None\n        self._connected = False\n\n    def checkpoint(self, name: str) -&gt; None:\n        self._ensure_connected()\n        # Implementation\n        self._checkpoints.append(name)\n\n    def rollback(self, name: str) -&gt; None:\n        self._ensure_connected()\n        # Implementation\n\n    def release(self, name: str) -&gt; None:\n        self._ensure_connected()\n        # Implementation\n        if name in self._checkpoints:\n            self._checkpoints.remove(name)\n\n    def reset(self) -&gt; None:\n        self._ensure_connected()\n        # Implementation\n        self._checkpoints.clear()\n</code></pre>"},{"location":"advanced/custom-backends/#example-mysql-backend","title":"Example: MySQL Backend","text":"Python<pre><code>import mysql.connector\nfrom venomqa.state.base import BaseStateManager\n\n\nclass MySQLStateManager(BaseStateManager):\n    \"\"\"MySQL state manager using SAVEPOINT.\"\"\"\n\n    def __init__(\n        self,\n        connection_url: str,\n        tables_to_reset: list[str] | None = None,\n        exclude_tables: list[str] | None = None,\n    ):\n        super().__init__(connection_url)\n        self.tables_to_reset = tables_to_reset or []\n        self.exclude_tables = exclude_tables or []\n        self._conn = None\n\n    def connect(self) -&gt; None:\n        # Parse connection URL\n        # mysql://user:pass@host:port/database\n        from urllib.parse import urlparse\n        parsed = urlparse(self.connection_url)\n\n        self._conn = mysql.connector.connect(\n            host=parsed.hostname,\n            port=parsed.port or 3306,\n            user=parsed.username,\n            password=parsed.password,\n            database=parsed.path.lstrip('/'),\n            autocommit=False,\n        )\n        self._connected = True\n\n    def disconnect(self) -&gt; None:\n        if self._conn:\n            self._conn.close()\n            self._conn = None\n        self._connected = False\n\n    def checkpoint(self, name: str) -&gt; None:\n        self._ensure_connected()\n        cursor = self._conn.cursor()\n        cursor.execute(f\"SAVEPOINT {name}\")\n        self._checkpoints.append(name)\n\n    def rollback(self, name: str) -&gt; None:\n        self._ensure_connected()\n        if name not in self._checkpoints:\n            raise ValueError(f\"Checkpoint '{name}' not found\")\n        cursor = self._conn.cursor()\n        cursor.execute(f\"ROLLBACK TO SAVEPOINT {name}\")\n\n    def release(self, name: str) -&gt; None:\n        self._ensure_connected()\n        cursor = self._conn.cursor()\n        cursor.execute(f\"RELEASE SAVEPOINT {name}\")\n        if name in self._checkpoints:\n            self._checkpoints.remove(name)\n\n    def reset(self) -&gt; None:\n        self._ensure_connected()\n        cursor = self._conn.cursor()\n\n        # Get tables to reset\n        tables = self.tables_to_reset\n        if not tables:\n            cursor.execute(\"SHOW TABLES\")\n            tables = [row[0] for row in cursor.fetchall()]\n            tables = [t for t in tables if t not in self.exclude_tables]\n\n        # Disable foreign key checks temporarily\n        cursor.execute(\"SET FOREIGN_KEY_CHECKS = 0\")\n\n        for table in tables:\n            cursor.execute(f\"TRUNCATE TABLE {table}\")\n\n        cursor.execute(\"SET FOREIGN_KEY_CHECKS = 1\")\n        self._conn.commit()\n        self._checkpoints.clear()\n\n    def commit(self) -&gt; None:\n        self._ensure_connected()\n        self._conn.commit()\n</code></pre>"},{"location":"advanced/custom-backends/#example-redis-backend","title":"Example: Redis Backend","text":"<p>For applications using Redis as primary storage:</p> Python<pre><code>import redis\nimport json\nfrom venomqa.state.base import BaseStateManager\n\n\nclass RedisStateManager(BaseStateManager):\n    \"\"\"Redis state manager using key snapshots.\"\"\"\n\n    def __init__(\n        self,\n        redis_url: str,\n        key_prefix: str = \"qa:\",\n        snapshot_prefix: str = \"_snapshot:\",\n    ):\n        super().__init__(redis_url)\n        self.key_prefix = key_prefix\n        self.snapshot_prefix = snapshot_prefix\n        self._redis = None\n        self._snapshots: dict[str, dict] = {}\n\n    def connect(self) -&gt; None:\n        self._redis = redis.from_url(self.connection_url)\n        self._connected = True\n\n    def disconnect(self) -&gt; None:\n        if self._redis:\n            self._redis.close()\n            self._redis = None\n        self._connected = False\n\n    def checkpoint(self, name: str) -&gt; None:\n        self._ensure_connected()\n\n        # Get all keys matching prefix\n        keys = self._redis.keys(f\"{self.key_prefix}*\")\n        snapshot = {}\n\n        for key in keys:\n            key_str = key.decode() if isinstance(key, bytes) else key\n            value = self._redis.get(key)\n            ttl = self._redis.ttl(key)\n            snapshot[key_str] = {\n                \"value\": value.decode() if isinstance(value, bytes) else value,\n                \"ttl\": ttl if ttl &gt; 0 else None,\n            }\n\n        self._snapshots[name] = snapshot\n        self._checkpoints.append(name)\n\n    def rollback(self, name: str) -&gt; None:\n        self._ensure_connected()\n\n        if name not in self._snapshots:\n            raise ValueError(f\"Checkpoint '{name}' not found\")\n\n        snapshot = self._snapshots[name]\n\n        # Clear current keys\n        keys = self._redis.keys(f\"{self.key_prefix}*\")\n        if keys:\n            self._redis.delete(*keys)\n\n        # Restore snapshot\n        for key, data in snapshot.items():\n            if data[\"ttl\"]:\n                self._redis.setex(key, data[\"ttl\"], data[\"value\"])\n            else:\n                self._redis.set(key, data[\"value\"])\n\n    def release(self, name: str) -&gt; None:\n        if name in self._snapshots:\n            del self._snapshots[name]\n        if name in self._checkpoints:\n            self._checkpoints.remove(name)\n\n    def reset(self) -&gt; None:\n        self._ensure_connected()\n\n        # Delete all keys matching prefix\n        keys = self._redis.keys(f\"{self.key_prefix}*\")\n        if keys:\n            self._redis.delete(*keys)\n\n        self._snapshots.clear()\n        self._checkpoints.clear()\n</code></pre>"},{"location":"advanced/custom-backends/#example-mongodb-backend","title":"Example: MongoDB Backend","text":"Python<pre><code>from pymongo import MongoClient\nfrom bson import json_util\nimport json\nfrom venomqa.state.base import BaseStateManager\n\n\nclass MongoDBStateManager(BaseStateManager):\n    \"\"\"MongoDB state manager using collection snapshots.\"\"\"\n\n    def __init__(\n        self,\n        connection_url: str,\n        database: str,\n        collections_to_reset: list[str] | None = None,\n    ):\n        super().__init__(connection_url)\n        self.database_name = database\n        self.collections_to_reset = collections_to_reset or []\n        self._client = None\n        self._db = None\n        self._snapshots: dict[str, dict] = {}\n\n    def connect(self) -&gt; None:\n        self._client = MongoClient(self.connection_url)\n        self._db = self._client[self.database_name]\n        self._connected = True\n\n    def disconnect(self) -&gt; None:\n        if self._client:\n            self._client.close()\n            self._client = None\n            self._db = None\n        self._connected = False\n\n    def checkpoint(self, name: str) -&gt; None:\n        self._ensure_connected()\n\n        collections = self.collections_to_reset or self._db.list_collection_names()\n        snapshot = {}\n\n        for coll_name in collections:\n            coll = self._db[coll_name]\n            docs = list(coll.find({}))\n            snapshot[coll_name] = json.loads(json_util.dumps(docs))\n\n        self._snapshots[name] = snapshot\n        self._checkpoints.append(name)\n\n    def rollback(self, name: str) -&gt; None:\n        self._ensure_connected()\n\n        if name not in self._snapshots:\n            raise ValueError(f\"Checkpoint '{name}' not found\")\n\n        snapshot = self._snapshots[name]\n\n        for coll_name, docs in snapshot.items():\n            coll = self._db[coll_name]\n            coll.delete_many({})\n            if docs:\n                restored_docs = json.loads(json_util.dumps(docs))\n                coll.insert_many(restored_docs)\n\n    def release(self, name: str) -&gt; None:\n        if name in self._snapshots:\n            del self._snapshots[name]\n        if name in self._checkpoints:\n            self._checkpoints.remove(name)\n\n    def reset(self) -&gt; None:\n        self._ensure_connected()\n\n        collections = self.collections_to_reset or self._db.list_collection_names()\n\n        for coll_name in collections:\n            self._db[coll_name].delete_many({})\n\n        self._snapshots.clear()\n        self._checkpoints.clear()\n</code></pre>"},{"location":"advanced/custom-backends/#registering-custom-backends","title":"Registering Custom Backends","text":""},{"location":"advanced/custom-backends/#using-entry-points","title":"Using Entry Points","text":"<p>Add to <code>pyproject.toml</code>:</p> TOML<pre><code>[project.entry-points.\"venomqa.state_backends\"]\nmysql = \"my_package.state:MySQLStateManager\"\nredis = \"my_package.state:RedisStateManager\"\nmongodb = \"my_package.state:MongoDBStateManager\"\n</code></pre>"},{"location":"advanced/custom-backends/#using-configuration","title":"Using Configuration","text":"YAML<pre><code># venomqa.yaml\ndb_backend: \"mysql\"  # Uses registered backend\ndb_url: \"mysql://user:pass@localhost:3306/qa_test\"\n</code></pre>"},{"location":"advanced/custom-backends/#using-custom-backends","title":"Using Custom Backends","text":"Python<pre><code>from my_state import MySQLStateManager\nfrom venomqa import JourneyRunner, Client\n\n# Create state manager\nstate_manager = MySQLStateManager(\n    connection_url=\"mysql://qa:secret@localhost:3306/qa_test\",\n    tables_to_reset=[\"users\", \"orders\"],\n)\n\n# Create runner with state manager\nrunner = JourneyRunner(\n    client=Client(base_url=\"http://localhost:8000\"),\n    state_manager=state_manager,\n)\n\n# Run journey\nresult = runner.run(journey)\n</code></pre>"},{"location":"advanced/custom-backends/#best-practices","title":"Best Practices","text":""},{"location":"advanced/custom-backends/#1-handle-connection-errors","title":"1. Handle Connection Errors","text":"Python<pre><code>def connect(self) -&gt; None:\n    try:\n        self._conn = db.connect(self.connection_url)\n        self._connected = True\n    except Exception as e:\n        self._connected = False\n        raise ConnectionError(f\"Failed to connect: {e}\")\n</code></pre>"},{"location":"advanced/custom-backends/#2-use-context-managers","title":"2. Use Context Managers","text":"Python<pre><code>class MyStateManager(BaseStateManager):\n    def __enter__(self):\n        self.connect()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.disconnect()\n        return False\n\n# Usage\nwith MyStateManager(url) as state_manager:\n    state_manager.checkpoint(\"start\")\n    # ...\n</code></pre>"},{"location":"advanced/custom-backends/#3-implement-health-checks","title":"3. Implement Health Checks","text":"Python<pre><code>def health_check(self) -&gt; bool:\n    \"\"\"Check if the database is healthy.\"\"\"\n    try:\n        if not self._connected:\n            return False\n        self._conn.execute(\"SELECT 1\")\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"advanced/custom-backends/#4-support-async-operations","title":"4. Support Async Operations","text":"Python<pre><code>import asyncio\n\n\nclass AsyncStateManager(BaseStateManager):\n    async def connect_async(self) -&gt; None:\n        self._conn = await async_db.connect(self.connection_url)\n        self._connected = True\n\n    async def checkpoint_async(self, name: str) -&gt; None:\n        self._ensure_connected()\n        await self._conn.execute(f\"SAVEPOINT {name}\")\n        self._checkpoints.append(name)\n</code></pre>"},{"location":"advanced/custom-backends/#5-log-operations","title":"5. Log Operations","text":"Python<pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass LoggingStateManager(BaseStateManager):\n    def checkpoint(self, name: str) -&gt; None:\n        logger.debug(f\"Creating checkpoint: {name}\")\n        super().checkpoint(name)\n        logger.info(f\"Checkpoint created: {name}\")\n\n    def rollback(self, name: str) -&gt; None:\n        logger.debug(f\"Rolling back to: {name}\")\n        super().rollback(name)\n        logger.info(f\"Rolled back to: {name}\")\n</code></pre>"},{"location":"advanced/custom-reporters/","title":"Custom Reporters","text":"<p>Create custom reporters to output test results in any format.</p>"},{"location":"advanced/custom-reporters/#creating-a-custom-reporter","title":"Creating a Custom Reporter","text":"<p>Extend <code>BaseReporter</code> and implement the required methods:</p> Python<pre><code>from pathlib import Path\nfrom venomqa.reporters.base import BaseReporter\nfrom venomqa.core.models import JourneyResult\n\n\nclass CSVReporter(BaseReporter):\n    \"\"\"Generate CSV reports for spreadsheet analysis.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".csv\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        lines = [\n            \"journey_name,success,duration_ms,total_steps,passed_steps,issues\"\n        ]\n\n        for result in results:\n            lines.append(\n                f\"{result.journey_name},\"\n                f\"{result.success},\"\n                f\"{result.duration_ms:.0f},\"\n                f\"{result.total_steps},\"\n                f\"{result.passed_steps},\"\n                f\"{len(result.issues)}\"\n            )\n\n        return \"\\n\".join(lines)\n\n\n# Usage\nreporter = CSVReporter(output_path=\"reports/results.csv\")\nreporter.save([journey_result])\n</code></pre>"},{"location":"advanced/custom-reporters/#basereporter-interface","title":"BaseReporter Interface","text":"Python<pre><code>from abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import Any\n\n\nclass BaseReporter(ABC):\n    \"\"\"Base class for all reporters.\"\"\"\n\n    def __init__(self, output_path: str | Path | None = None):\n        self.output_path = Path(output_path) if output_path else None\n\n    @property\n    @abstractmethod\n    def file_extension(self) -&gt; str:\n        \"\"\"Return the file extension (e.g., '.csv').\"\"\"\n        ...\n\n    @abstractmethod\n    def generate(self, results: list[JourneyResult]) -&gt; str | dict | bytes:\n        \"\"\"Generate report content from results.\"\"\"\n        ...\n\n    def save(self, results: list[JourneyResult], path: Path | None = None) -&gt; Path:\n        \"\"\"Save report to file.\"\"\"\n        output_path = path or self.output_path\n        if output_path is None:\n            output_path = Path(f\"report{self.file_extension}\")\n\n        content = self.generate(results)\n\n        if isinstance(content, bytes):\n            output_path.write_bytes(content)\n        elif isinstance(content, dict):\n            import json\n            output_path.write_text(json.dumps(content, indent=2))\n        else:\n            output_path.write_text(content)\n\n        return output_path\n</code></pre>"},{"location":"advanced/custom-reporters/#example-slack-reporter","title":"Example: Slack Reporter","text":"Python<pre><code>import httpx\nfrom venomqa.reporters.base import BaseReporter\nfrom venomqa.core.models import JourneyResult\n\n\nclass SlackReporter(BaseReporter):\n    \"\"\"Send test results to Slack.\"\"\"\n\n    def __init__(\n        self,\n        webhook_url: str,\n        channel: str | None = None,\n        mention_on_failure: str | None = None,\n        output_path: str | None = None,\n    ):\n        super().__init__(output_path)\n        self.webhook_url = webhook_url\n        self.channel = channel\n        self.mention_on_failure = mention_on_failure\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".json\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; dict:\n        passed = sum(1 for r in results if r.success)\n        failed = len(results) - passed\n        total_duration = sum(r.duration_ms for r in results) / 1000\n\n        color = \"good\" if failed == 0 else \"danger\"\n        status = \"All tests passed!\" if failed == 0 else f\"{failed} test(s) failed\"\n\n        mention = \"\"\n        if failed &gt; 0 and self.mention_on_failure:\n            mention = f\"{self.mention_on_failure} \"\n\n        return {\n            \"channel\": self.channel,\n            \"attachments\": [{\n                \"color\": color,\n                \"title\": \"VenomQA Test Results\",\n                \"text\": f\"{mention}{status}\",\n                \"fields\": [\n                    {\"title\": \"Passed\", \"value\": str(passed), \"short\": True},\n                    {\"title\": \"Failed\", \"value\": str(failed), \"short\": True},\n                    {\"title\": \"Duration\", \"value\": f\"{total_duration:.1f}s\", \"short\": True},\n                ],\n                \"footer\": \"VenomQA\",\n            }]\n        }\n\n    def send(self, results: list[JourneyResult]) -&gt; None:\n        \"\"\"Send results to Slack.\"\"\"\n        payload = self.generate(results)\n        httpx.post(self.webhook_url, json=payload)\n\n\n# Usage\nreporter = SlackReporter(\n    webhook_url=\"https://hooks.slack.com/services/...\",\n    channel=\"#qa-results\",\n    mention_on_failure=\"@channel\",\n)\nreporter.send([journey_result])\n</code></pre>"},{"location":"advanced/custom-reporters/#example-html-dashboard-reporter","title":"Example: HTML Dashboard Reporter","text":"Python<pre><code>from venomqa.reporters.base import BaseReporter\nfrom venomqa.core.models import JourneyResult\n\n\nclass HTMLDashboardReporter(BaseReporter):\n    \"\"\"Generate interactive HTML dashboard.\"\"\"\n\n    def __init__(self, output_path: str | None = None, title: str = \"QA Dashboard\"):\n        super().__init__(output_path)\n        self.title = title\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".html\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        passed = sum(1 for r in results if r.success)\n        failed = len(results) - passed\n        total_duration = sum(r.duration_ms for r in results)\n\n        rows = \"\\n\".join(\n            f\"\"\"&lt;tr class=\"{'passed' if r.success else 'failed'}\"&gt;\n                &lt;td&gt;{r.journey_name}&lt;/td&gt;\n                &lt;td&gt;{'PASS' if r.success else 'FAIL'}&lt;/td&gt;\n                &lt;td&gt;{r.duration_ms:.0f}ms&lt;/td&gt;\n                &lt;td&gt;{r.passed_steps}/{r.total_steps}&lt;/td&gt;\n                &lt;td&gt;{len(r.issues)}&lt;/td&gt;\n            &lt;/tr&gt;\"\"\"\n            for r in results\n        )\n\n        return f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{self.title}&lt;/title&gt;\n    &lt;style&gt;\n        body {{ font-family: system-ui; margin: 40px; }}\n        .summary {{ display: flex; gap: 20px; margin-bottom: 30px; }}\n        .metric {{ text-align: center; padding: 20px; background: #f5f5f5; border-radius: 8px; }}\n        .metric-value {{ font-size: 2em; font-weight: bold; }}\n        .passed {{ color: #22c55e; }}\n        .failed {{ color: #ef4444; }}\n        table {{ width: 100%; border-collapse: collapse; }}\n        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}\n        tr.passed td:nth-child(2) {{ color: #22c55e; }}\n        tr.failed td:nth-child(2) {{ color: #ef4444; }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;{self.title}&lt;/h1&gt;\n\n    &lt;div class=\"summary\"&gt;\n        &lt;div class=\"metric\"&gt;\n            &lt;div class=\"metric-value passed\"&gt;{passed}&lt;/div&gt;\n            &lt;div&gt;Passed&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"metric\"&gt;\n            &lt;div class=\"metric-value failed\"&gt;{failed}&lt;/div&gt;\n            &lt;div&gt;Failed&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"metric\"&gt;\n            &lt;div class=\"metric-value\"&gt;{total_duration/1000:.1f}s&lt;/div&gt;\n            &lt;div&gt;Duration&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;table&gt;\n        &lt;tr&gt;\n            &lt;th&gt;Journey&lt;/th&gt;\n            &lt;th&gt;Status&lt;/th&gt;\n            &lt;th&gt;Duration&lt;/th&gt;\n            &lt;th&gt;Steps&lt;/th&gt;\n            &lt;th&gt;Issues&lt;/th&gt;\n        &lt;/tr&gt;\n        {rows}\n    &lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"advanced/custom-reporters/#example-xml-reporter","title":"Example: XML Reporter","text":"Python<pre><code>import xml.etree.ElementTree as ET\nfrom venomqa.reporters.base import BaseReporter\n\n\nclass XMLReporter(BaseReporter):\n    \"\"\"Generate XML reports.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".xml\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        root = ET.Element(\"testResults\")\n        root.set(\"total\", str(len(results)))\n        root.set(\"passed\", str(sum(1 for r in results if r.success)))\n\n        for result in results:\n            journey = ET.SubElement(root, \"journey\")\n            journey.set(\"name\", result.journey_name)\n            journey.set(\"success\", str(result.success).lower())\n            journey.set(\"duration\", str(result.duration_ms))\n\n            for step_result in result.step_results:\n                step = ET.SubElement(journey, \"step\")\n                step.set(\"name\", step_result.step_name)\n                step.set(\"success\", str(step_result.success).lower())\n\n        return ET.tostring(root, encoding=\"unicode\")\n</code></pre>"},{"location":"advanced/custom-reporters/#registering-custom-reporters","title":"Registering Custom Reporters","text":""},{"location":"advanced/custom-reporters/#using-decorator","title":"Using Decorator","text":"Python<pre><code>from venomqa.reporters import register_reporter\n\n@register_reporter(\"csv\")\nclass CSVReporter(BaseReporter):\n    ...\n</code></pre>"},{"location":"advanced/custom-reporters/#using-function","title":"Using Function","text":"Python<pre><code>from venomqa.reporters import register_reporter_class\n\nregister_reporter_class(\"csv\", CSVReporter)\n</code></pre>"},{"location":"advanced/custom-reporters/#using-entry-points","title":"Using Entry Points","text":"<p>Add to <code>pyproject.toml</code>:</p> TOML<pre><code>[project.entry-points.\"venomqa.reporters\"]\ncsv = \"my_package.reporters:CSVReporter\"\nslack = \"my_package.reporters:SlackReporter\"\n</code></pre>"},{"location":"advanced/custom-reporters/#using-custom-reporters","title":"Using Custom Reporters","text":""},{"location":"advanced/custom-reporters/#cli","title":"CLI","text":"<p>After registering:</p> Bash<pre><code>venomqa report --format csv --output results.csv\n</code></pre>"},{"location":"advanced/custom-reporters/#programmatic","title":"Programmatic","text":"Python<pre><code>from my_reporters import CSVReporter, SlackReporter\n\n# Generate CSV\ncsv_reporter = CSVReporter(output_path=\"results.csv\")\ncsv_reporter.save(results)\n\n# Send to Slack\nslack_reporter = SlackReporter(webhook_url=\"...\")\nslack_reporter.send(results)\n</code></pre>"},{"location":"advanced/custom-reporters/#best-practices","title":"Best Practices","text":""},{"location":"advanced/custom-reporters/#1-handle-missing-data","title":"1. Handle Missing Data","text":"Python<pre><code>def generate(self, results):\n    for result in results:\n        name = result.journey_name or \"unknown\"\n        duration = result.duration_ms or 0\n        # ...\n</code></pre>"},{"location":"advanced/custom-reporters/#2-include-timestamps","title":"2. Include Timestamps","text":"Python<pre><code>from datetime import datetime\n\ndef generate(self, results):\n    return {\n        \"generated_at\": datetime.utcnow().isoformat(),\n        \"results\": [...]\n    }\n</code></pre>"},{"location":"advanced/custom-reporters/#3-support-filtering","title":"3. Support Filtering","text":"Python<pre><code>class FilterableReporter(BaseReporter):\n    def __init__(self, output_path=None, include_passed=True, include_failed=True):\n        super().__init__(output_path)\n        self.include_passed = include_passed\n        self.include_failed = include_failed\n\n    def generate(self, results):\n        filtered = [\n            r for r in results\n            if (r.success and self.include_passed) or\n               (not r.success and self.include_failed)\n        ]\n        # Generate from filtered results\n</code></pre>"},{"location":"advanced/custom-reporters/#4-add-configuration-options","title":"4. Add Configuration Options","text":"Python<pre><code>class ConfigurableReporter(BaseReporter):\n    def __init__(\n        self,\n        output_path=None,\n        include_request_details=False,\n        include_timing=True,\n        verbose=False,\n    ):\n        super().__init__(output_path)\n        self.include_request_details = include_request_details\n        self.include_timing = include_timing\n        self.verbose = verbose\n</code></pre>"},{"location":"advanced/performance/","title":"Advanced Usage","text":"<p>This guide covers advanced features and patterns in VenomQA.</p> <p>Prerequisites: Familiarity with Journeys and Configuration.</p>"},{"location":"advanced/performance/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Caching</li> <li>Parallel Execution</li> <li>Custom Reporters</li> <li>Custom State Backends</li> <li>Hooks and Extensions</li> <li>Performance Optimization</li> <li>Error Handling Strategies</li> <li>Testing Patterns</li> </ul>"},{"location":"advanced/performance/#related-documentation","title":"Related Documentation","text":"Topic Document API Reference api.md Adapters adapters.md Examples examples.md FAQ FAQ.md"},{"location":"advanced/performance/#caching","title":"Caching","text":""},{"location":"advanced/performance/#response-caching","title":"Response Caching","text":"<p>Cache responses to speed up repeated requests:</p> Python<pre><code>from functools import lru_cache\nfrom venomqa import Client\n\nclass CachedClient(Client):\n    \"\"\"HTTP client with response caching for GET requests.\"\"\"\n\n    def __init__(self, *args, cache_size: int = 100, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._cache_size = cache_size\n        self._get_cached = lru_cache(maxsize=cache_size)(self._get_uncached)\n\n    def _get_uncached(self, path: str, cache_key: str) -&gt; dict:\n        \"\"\"Uncached GET implementation.\"\"\"\n        return super().get(path)\n\n    def get(self, path: str, **kwargs) -&gt; dict:\n        # Create cache key from path and params\n        import json\n        cache_key = json.dumps({\"path\": path, \"kwargs\": kwargs}, sort_keys=True)\n        return self._get_cached(path, cache_key)\n\n    def clear_cache(self):\n        \"\"\"Clear the response cache.\"\"\"\n        self._get_cached.cache_clear()\n</code></pre>"},{"location":"advanced/performance/#authentication-token-caching","title":"Authentication Token Caching","text":"<p>Cache auth tokens across steps:</p> Python<pre><code>from venomqa.core.context import ExecutionContext\n\ndef login_with_cache(client, context: ExecutionContext):\n    \"\"\"Login with token caching to avoid repeated auth.\"\"\"\n    cached_token = context.get(\"_cached_auth_token\")\n\n    if cached_token:\n        client.set_auth_token(cached_token)\n        # Verify token still works\n        response = client.get(\"/api/auth/verify\")\n        if response.status_code == 200:\n            return response\n\n    # Perform fresh login\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n\n    if response.status_code == 200:\n        token = response.json()[\"token\"]\n        context[\"_cached_auth_token\"] = token\n        client.set_auth_token(token)\n\n    return response\n</code></pre>"},{"location":"advanced/performance/#fixture-data-caching","title":"Fixture Data Caching","text":"<p>Cache expensive setup operations:</p> Python<pre><code>import hashlib\nimport pickle\nfrom pathlib import Path\n\nclass FixtureCache:\n    \"\"\"Cache fixture data to disk.\"\"\"\n\n    def __init__(self, cache_dir: str = \".venomqa_cache\"):\n        self.cache_dir = Path(cache_dir)\n        self.cache_dir.mkdir(exist_ok=True)\n\n    def _cache_key(self, data: dict) -&gt; str:\n        return hashlib.md5(pickle.dumps(data)).hexdigest()\n\n    def get(self, key: str) -&gt; dict | None:\n        cache_file = self.cache_dir / f\"{key}.pkl\"\n        if cache_file.exists():\n            return pickle.loads(cache_file.read_bytes())\n        return None\n\n    def set(self, key: str, data: dict) -&gt; None:\n        cache_file = self.cache_dir / f\"{key}.pkl\"\n        cache_file.write_bytes(pickle.dumps(data))\n\n    def cached_setup(self, setup_func, *args, **kwargs):\n        \"\"\"Run setup function with caching.\"\"\"\n        cache_key = self._cache_key({\"func\": setup_func.__name__, \"args\": args, \"kwargs\": kwargs})\n\n        cached = self.get(cache_key)\n        if cached is not None:\n            return cached\n\n        result = setup_func(*args, **kwargs)\n        self.set(cache_key, result)\n        return result\n</code></pre>"},{"location":"advanced/performance/#parallel-execution","title":"Parallel Execution","text":""},{"location":"advanced/performance/#enabling-parallel-paths","title":"Enabling Parallel Paths","text":"<p>Run branch paths in parallel:</p> Python<pre><code>from venomqa import JourneyRunner\n\nrunner = JourneyRunner(\n    client=client,\n    state_manager=state_manager,\n    parallel_paths=4,  # Run up to 4 paths concurrently\n)\n\nresult = runner.run(journey)\n</code></pre>"},{"location":"advanced/performance/#configuration","title":"Configuration","text":"YAML<pre><code># venomqa.yaml\nparallel_paths: 4\n</code></pre>"},{"location":"advanced/performance/#considerations-for-parallel-execution","title":"Considerations for Parallel Execution","text":"<ol> <li>State Isolation: Each parallel path needs isolated state</li> <li>Resource Limits: Don't exceed database connection limits</li> <li>Rate Limiting: APIs may have rate limits</li> </ol>"},{"location":"advanced/performance/#isolating-state-for-parallel-paths","title":"Isolating State for Parallel Paths","text":"<p>When running in parallel, each path needs its own context:</p> Python<pre><code># The runner automatically handles this by:\n# 1. Creating a context snapshot before the branch\n# 2. Restoring the snapshot for each path\n# 3. Each path gets its own isolated context\n\n# For database state, ensure:\n# 1. Each path uses different record IDs\n# 2. Or use database-level transactions with SAVEPOINT\n</code></pre>"},{"location":"advanced/performance/#parallel-journey-execution","title":"Parallel Journey Execution","text":"<p>Run multiple journeys in parallel:</p> Python<pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed\nfrom venomqa import JourneyRunner, Client\n\ndef run_journey(journey, config):\n    client = Client(base_url=config.base_url)\n    runner = JourneyRunner(client=client)\n    return runner.run(journey)\n\ndef run_all_parallel(journeys, config, max_workers=4):\n    results = []\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(run_journey, j, config): j\n            for j in journeys\n        }\n\n        for future in as_completed(futures):\n            journey = futures[future]\n            try:\n                result = future.result()\n                results.append(result)\n            except Exception as e:\n                print(f\"Journey {journey.name} failed: {e}\")\n\n    return results\n</code></pre>"},{"location":"advanced/performance/#custom-reporters","title":"Custom Reporters","text":""},{"location":"advanced/performance/#creating-a-custom-reporter","title":"Creating a Custom Reporter","text":"Python<pre><code>from pathlib import Path\nfrom typing import Any\nfrom venomqa.reporters.base import BaseReporter\nfrom venomqa.core.models import JourneyResult\n\nclass CSVReporter(BaseReporter):\n    \"\"\"Generate CSV reports for spreadsheet analysis.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".csv\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        lines = [\n            \"journey_name,success,duration_ms,total_steps,passed_steps,issue_count\"\n        ]\n\n        for result in results:\n            lines.append(\n                f\"{result.journey_name},\"\n                f\"{result.success},\"\n                f\"{result.duration_ms:.0f},\"\n                f\"{result.total_steps},\"\n                f\"{result.passed_steps},\"\n                f\"{len(result.issues)}\"\n            )\n\n        return \"\\n\".join(lines)\n\n\nclass SlackReporter(BaseReporter):\n    \"\"\"Send test results to Slack.\"\"\"\n\n    def __init__(self, webhook_url: str, output_path: str | Path | None = None):\n        super().__init__(output_path)\n        self.webhook_url = webhook_url\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".json\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; dict[str, Any]:\n        passed = sum(1 for r in results if r.success)\n        failed = len(results) - passed\n\n        color = \"good\" if failed == 0 else \"danger\"\n        status = \"All tests passed!\" if failed == 0 else f\"{failed} test(s) failed\"\n\n        return {\n            \"attachments\": [{\n                \"color\": color,\n                \"title\": \"VenomQA Test Results\",\n                \"text\": status,\n                \"fields\": [\n                    {\"title\": \"Passed\", \"value\": str(passed), \"short\": True},\n                    {\"title\": \"Failed\", \"value\": str(failed), \"short\": True},\n                ],\n            }]\n        }\n\n    def send_to_slack(self, results: list[JourneyResult]) -&gt; None:\n        import httpx\n\n        payload = self.generate(results)\n        httpx.post(self.webhook_url, json=payload)\n\n\nclass HTMLDashboardReporter(BaseReporter):\n    \"\"\"Generate interactive HTML dashboard.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".html\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        return f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;VenomQA Dashboard&lt;/title&gt;\n    &lt;style&gt;\n        body {{ font-family: system-ui, sans-serif; margin: 40px; }}\n        .card {{ border: 1px solid #e5e5e5; border-radius: 8px; padding: 16px; margin: 16px 0; }}\n        .passed {{ border-left: 4px solid #22c55e; }}\n        .failed {{ border-left: 4px solid #ef4444; }}\n        .metrics {{ display: flex; gap: 24px; }}\n        .metric {{ text-align: center; }}\n        .metric-value {{ font-size: 2em; font-weight: bold; }}\n        .metric-label {{ color: #666; }}\n        table {{ width: 100%; border-collapse: collapse; }}\n        th, td {{ padding: 8px; text-align: left; border-bottom: 1px solid #e5e5e5; }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;VenomQA Dashboard&lt;/h1&gt;\n\n    &lt;div class=\"card\"&gt;\n        &lt;div class=\"metrics\"&gt;\n            {self._generate_metrics(results)}\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"card\"&gt;\n        &lt;h2&gt;Journey Results&lt;/h2&gt;\n        &lt;table&gt;\n            &lt;tr&gt;\n                &lt;th&gt;Journey&lt;/th&gt;\n                &lt;th&gt;Status&lt;/th&gt;\n                &lt;th&gt;Duration&lt;/th&gt;\n                &lt;th&gt;Steps&lt;/th&gt;\n                &lt;th&gt;Issues&lt;/th&gt;\n            &lt;/tr&gt;\n            {self._generate_rows(results)}\n        &lt;/table&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n\n    def _generate_metrics(self, results: list[JourneyResult]) -&gt; str:\n        passed = sum(1 for r in results if r.success)\n        failed = len(results) - passed\n        total_duration = sum(r.duration_ms for r in results)\n\n        return f\"\"\"\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\" style=\"color: #22c55e;\"&gt;{passed}&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Passed&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\" style=\"color: #ef4444;\"&gt;{failed}&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Failed&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\"&gt;{total_duration/1000:.1f}s&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Duration&lt;/div&gt;\n            &lt;/div&gt;\n        \"\"\"\n\n    def _generate_rows(self, results: list[JourneyResult]) -&gt; str:\n        rows = []\n        for r in results:\n            status_class = \"passed\" if r.success else \"failed\"\n            status_icon = \"\u2713\" if r.success else \"\u2717\"\n            rows.append(f\"\"\"\n                &lt;tr class=\"{status_class}\"&gt;\n                    &lt;td&gt;{r.journey_name}&lt;/td&gt;\n                    &lt;td&gt;{status_icon}&lt;/td&gt;\n                    &lt;td&gt;{r.duration_ms:.0f}ms&lt;/td&gt;\n                    &lt;td&gt;{r.passed_steps}/{r.total_steps}&lt;/td&gt;\n                    &lt;td&gt;{len(r.issues)}&lt;/td&gt;\n                &lt;/tr&gt;\n            \"\"\")\n        return \"\\n\".join(rows)\n</code></pre>"},{"location":"advanced/performance/#using-custom-reporters","title":"Using Custom Reporters","text":"Python<pre><code>from venomqa.reporters import MarkdownReporter\n\n# Use built-in reporter\nreporter = MarkdownReporter(output_path=\"reports/test.md\")\nreporter.save([result1, result2])\n\n# Use custom reporter\ncsv_reporter = CSVReporter(output_path=\"reports/results.csv\")\ncsv_reporter.save([result1, result2])\n\nslack_reporter = SlackReporter(webhook_url=\"https://hooks.slack.com/...\")\nslack_reporter.send_to_slack([result1, result2])\n</code></pre>"},{"location":"advanced/performance/#custom-state-backends","title":"Custom State Backends","text":"<p>See Database Backends for implementing custom state backends.</p>"},{"location":"advanced/performance/#hooks-and-extensions","title":"Hooks and Extensions","text":""},{"location":"advanced/performance/#prepost-step-hooks","title":"Pre/Post Step Hooks","text":"Python<pre><code>from venomqa import JourneyRunner, Step\nfrom venomqa.core.models import StepResult\nfrom typing import Callable\n\nclass HookedJourneyRunner(JourneyRunner):\n    \"\"\"Runner with pre/post step hooks.\"\"\"\n\n    def __init__(self, *args, \n                 pre_step_hook: Callable | None = None,\n                 post_step_hook: Callable | None = None,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        self.pre_step_hook = pre_step_hook\n        self.post_step_hook = post_step_hook\n\n    def _run_step(self, step: Step, journey_name: str, path_name: str, context) -&gt; StepResult:\n        # Pre-step hook\n        if self.pre_step_hook:\n            self.pre_step_hook(step=step, journey=journey_name, path=path_name, context=context)\n\n        # Run the step\n        result = super()._run_step(step, journey_name, path_name, context)\n\n        # Post-step hook\n        if self.post_step_hook:\n            self.post_step_hook(step=step, result=result, context=context)\n\n        return result\n\n\n# Usage\ndef log_step(step, journey, path, context):\n    print(f\"Running: {journey}/{path}/{step.name}\")\n\ndef capture_screenshot_on_failure(step, result, context):\n    if not result.success:\n        # Take screenshot, save logs, etc.\n        print(f\"Step {step.name} failed, capturing diagnostics...\")\n\nrunner = HookedJourneyRunner(\n    client=client,\n    pre_step_hook=log_step,\n    post_step_hook=capture_screenshot_on_failure,\n)\n</code></pre>"},{"location":"advanced/performance/#journey-lifecycle-hooks","title":"Journey Lifecycle Hooks","text":"Python<pre><code>class LifecycleRunner(JourneyRunner):\n    \"\"\"Runner with full lifecycle hooks.\"\"\"\n\n    def __init__(self, *args,\n                 on_journey_start: Callable | None = None,\n                 on_journey_end: Callable | None = None,\n                 on_branch_start: Callable | None = None,\n                 on_branch_end: Callable | None = None,\n                 on_path_start: Callable | None = None,\n                 on_path_end: Callable | None = None,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        self.on_journey_start = on_journey_start\n        self.on_journey_end = on_journey_end\n        self.on_branch_start = on_branch_start\n        self.on_branch_end = on_branch_end\n        self.on_path_start = on_path_start\n        self.on_path_end = on_path_end\n\n    def run(self, journey):\n        if self.on_journey_start:\n            self.on_journey_start(journey=journey)\n\n        result = super().run(journey)\n\n        if self.on_journey_end:\n            self.on_journey_end(journey=journey, result=result)\n\n        return result\n</code></pre>"},{"location":"advanced/performance/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/performance/#reduce-request-overhead","title":"Reduce Request Overhead","text":"Python<pre><code># Reuse client across journeys\nclient = Client(base_url=\"http://localhost:8000\")\nclient.connect()  # Keep connection open\n\nfor journey in journeys:\n    runner = JourneyRunner(client=client)\n    result = runner.run(journey)\n\nclient.disconnect()\n</code></pre>"},{"location":"advanced/performance/#batch-operations","title":"Batch Operations","text":"Python<pre><code>def create_items_batch(client, context):\n    \"\"\"Create multiple items in one request.\"\"\"\n    items = [{\"name\": f\"Item {i}\"} for i in range(10)]\n    return client.post(\"/api/items/batch\", json={\"items\": items})\n</code></pre>"},{"location":"advanced/performance/#skip-unnecessary-steps","title":"Skip Unnecessary Steps","text":"Python<pre><code>def conditional_step(client, context):\n    # Skip if already done\n    if context.get(\"setup_complete\"):\n        return {\"status\": \"skipped\"}\n\n    # Do expensive setup\n    result = client.post(\"/api/setup\", json={...})\n    context[\"setup_complete\"] = True\n    return result\n</code></pre>"},{"location":"advanced/performance/#parallel-data-setup","title":"Parallel Data Setup","text":"Python<pre><code>from concurrent.futures import ThreadPoolExecutor\n\ndef setup_test_data_parallel(client, context):\n    \"\"\"Setup test data in parallel.\"\"\"\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        futures = [\n            executor.submit(client.post, \"/api/users\", json={\"name\": f\"User {i}\"})\n            for i in range(10)\n        ]\n        results = [f.result() for f in futures]\n\n    context[\"user_ids\"] = [r.json()[\"id\"] for r in results]\n    return results\n</code></pre>"},{"location":"advanced/performance/#error-handling-strategies","title":"Error Handling Strategies","text":""},{"location":"advanced/performance/#graceful-degradation","title":"Graceful Degradation","text":"Python<pre><code>def resilient_step(client, context):\n    \"\"\"Step that degrades gracefully on failure.\"\"\"\n    try:\n        response = client.get(\"/api/features\")\n        context[\"features\"] = response.json()\n    except Exception:\n        # Use defaults if features API is down\n        context[\"features\"] = {\"default_feature\": True}\n\n    return response\n</code></pre>"},{"location":"advanced/performance/#retry-with-exponential-backoff","title":"Retry with Exponential Backoff","text":"Python<pre><code>import time\nimport random\n\ndef retry_with_backoff(func, max_retries=3, base_delay=1.0):\n    \"\"\"Execute function with exponential backoff retry.\"\"\"\n    for attempt in range(max_retries):\n        try:\n            return func()\n        except Exception as e:\n            if attempt == max_retries - 1:\n                raise\n\n            delay = base_delay * (2 ** attempt) + random.uniform(0, 1)\n            time.sleep(delay)\n\ndef flaky_api_call(client, context):\n    return retry_with_backoff(\n        lambda: client.get(\"/api/flaky-endpoint\"),\n        max_retries=5,\n        base_delay=0.5,\n    )\n</code></pre>"},{"location":"advanced/performance/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"Python<pre><code>from datetime import datetime, timedelta\nfrom enum import Enum\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"\n    OPEN = \"open\"\n    HALF_OPEN = \"half_open\"\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker for unreliable services.\"\"\"\n\n    def __init__(self, failure_threshold: int = 3, recovery_timeout: float = 30.0):\n        self.failure_threshold = failure_threshold\n        self.recovery_timeout = recovery_timeout\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n        self.last_failure_time: datetime | None = None\n\n    def execute(self, func):\n        if self.state == CircuitState.OPEN:\n            if self._should_try_recovery():\n                self.state = CircuitState.HALF_OPEN\n            else:\n                raise Exception(\"Circuit breaker is open\")\n\n        try:\n            result = func()\n            self._on_success()\n            return result\n        except Exception as e:\n            self._on_failure()\n            raise e\n\n    def _should_try_recovery(self) -&gt; bool:\n        if self.last_failure_time is None:\n            return True\n        return datetime.now() - self.last_failure_time &gt; timedelta(seconds=self.recovery_timeout)\n\n    def _on_success(self):\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n\n    def _on_failure(self):\n        self.failures += 1\n        self.last_failure_time = datetime.now()\n        if self.failures &gt;= self.failure_threshold:\n            self.state = CircuitState.OPEN\n\n# Usage\ncircuit = CircuitBreaker(failure_threshold=3, recovery_timeout=30)\n\ndef protected_api_call(client, context):\n    return circuit.execute(lambda: client.get(\"/api/unreliable\"))\n</code></pre>"},{"location":"advanced/performance/#known-limitations","title":"Known Limitations","text":""},{"location":"advanced/performance/#parallel-path-execution-with-state-management","title":"Parallel Path Execution with State Management","text":"<p>When using <code>parallel_paths &gt; 1</code> (parallel branch execution), database state isolation is not guaranteed. Each path should start from the checkpoint state, but with parallel execution:</p> <ul> <li>All threads share the same database connection</li> <li>Rollback doesn't happen between parallel paths</li> <li>Paths may interfere with each other's database state</li> </ul> <p>Recommendation: Use <code>parallel_paths=1</code> (sequential execution) when: - Your journeys use database checkpoints and rollback - Your paths modify database state - State isolation between paths is important</p> <p>Parallel execution is safe when: - You're only testing read operations - Paths are independent and don't rely on specific database state - You're using the MockStateManager (in-memory)</p>"},{"location":"advanced/performance/#testing-patterns","title":"Testing Patterns","text":""},{"location":"advanced/performance/#data-driven-testing","title":"Data-Driven Testing","text":"Python<pre><code>from venomqa import Journey, Step\n\n# Test with multiple data sets\ntest_cases = [\n    {\"name\": \"valid_user\", \"email\": \"test@example.com\", \"expect_success\": True},\n    {\"name\": \"invalid_email\", \"email\": \"invalid\", \"expect_success\": False},\n    {\"name\": \"missing_email\", \"email\": None, \"expect_success\": False},\n]\n\njourneys = []\nfor case in test_cases:\n    def register_test(client, context, case=case):\n        return client.post(\"/api/register\", json={\"email\": case[\"email\"]})\n\n    journey = Journey(\n        name=f\"register_{case['name']}\",\n        steps=[\n            Step(\n                name=\"register\",\n                action=register_test,\n                expect_failure=not case[\"expect_success\"],\n            ),\n        ],\n    )\n    journeys.append(journey)\n</code></pre>"},{"location":"advanced/performance/#smoke-tests","title":"Smoke Tests","text":"Python<pre><code>smoke_journey = Journey(\n    name=\"smoke_test\",\n    description=\"Quick health check of critical endpoints\",\n    timeout=30.0,\n    steps=[\n        Step(name=\"health\", action=lambda c, ctx: c.get(\"/health\")),\n        Step(name=\"api_status\", action=lambda c, ctx: c.get(\"/api/status\")),\n        Step(name=\"db_ping\", action=lambda c, ctx: c.get(\"/api/ping/db\")),\n    ],\n)\n</code></pre>"},{"location":"advanced/performance/#regression-tests","title":"Regression Tests","text":"Python<pre><code># Capture expected responses for regression testing\nexpected_responses = {\n    \"get_user\": {\"id\": 1, \"name\": \"Test User\"},\n}\n\ndef regression_test_step(client, context):\n    response = client.get(\"/api/users/1\")\n    actual = response.json()\n    expected = expected_responses[\"get_user\"]\n\n    if actual != expected:\n        context[\"regression_diff\"] = {\n            \"expected\": expected,\n            \"actual\": actual,\n        }\n        raise AssertionError(\"Response differs from expected\")\n\n    return response\n</code></pre>"},{"location":"advanced/performance/#chaos-testing","title":"Chaos Testing","text":"Python<pre><code>import random\n\ndef chaos_step(client, context):\n    \"\"\"Introduce random failures for resilience testing.\"\"\"\n    # Randomly fail 10% of the time\n    if random.random() &lt; 0.1:\n        raise Exception(\"Chaos monkey strike!\")\n\n    return client.get(\"/api/data\")\n\ndef slow_network_step(client, context):\n    \"\"\"Simulate slow network conditions.\"\"\"\n    import time\n    time.sleep(random.uniform(0.5, 2.0))  # Random delay\n    return client.get(\"/api/data\")\n</code></pre>"},{"location":"advanced/performance/#ports-adapters","title":"Ports &amp; Adapters","text":"<p>The Ports and Adapters architecture enables clean separation between test logic and external dependencies.</p>"},{"location":"advanced/performance/#dependency-injection-pattern","title":"Dependency Injection Pattern","text":"<p>Inject adapters through constructor or fixtures:</p> Python<pre><code>import pytest\nfrom venomqa.ports import CachePort, MailPort\nfrom venomqa.adapters import RedisCacheAdapter, MailhogAdapter\n\nclass TestUserRegistration:\n    def __init__(self, cache: CachePort, mail: MailPort):\n        self.cache = cache\n        self.mail = mail\n\n    def test_registration_sends_email(self):\n        # Register user\n        self.register_user(\"test@example.com\")\n\n        # Verify email was sent\n        email = self.mail.wait_for_email(\n            to=\"test@example.com\",\n            subject=\"Welcome\",\n            timeout=30.0,\n        )\n        assert email is not None\n\n        # Verify cache was updated\n        assert self.cache.exists(\"user:test@example.com\")\n\n# Using with pytest fixtures\n@pytest.fixture\ndef cache():\n    return RedisCacheAdapter(host=\"localhost\")\n\n@pytest.fixture\ndef mail():\n    return MailhogAdapter(host=\"localhost\")\n\ndef test_with_adapters(cache, mail):\n    tester = TestUserRegistration(cache, mail)\n    tester.test_registration_sends_email()\n</code></pre>"},{"location":"advanced/performance/#swapping-adapters-for-testing","title":"Swapping Adapters for Testing","text":"<p>Use different adapters for different test environments:</p> Python<pre><code>from venomqa.ports import CachePort\nfrom venomqa.adapters import RedisCacheAdapter, LocalStorageAdapter\n\ndef get_cache_adapter(env: str) -&gt; CachePort:\n    if env == \"production\":\n        return RedisCacheAdapter(\n            host=\"redis.production.internal\",\n            password=os.environ[\"REDIS_PASSWORD\"],\n        )\n    elif env == \"staging\":\n        return RedisCacheAdapter(host=\"localhost\")\n    else:\n        # In-memory adapter for unit tests\n        return LocalStorageAdapter(base_path=\"/tmp/test-cache\")\n</code></pre>"},{"location":"advanced/performance/#time-travel-testing","title":"Time Travel Testing","text":"<p>Test time-dependent logic without waiting:</p> Python<pre><code>from datetime import timedelta\nfrom venomqa.adapters import ControllableTimeAdapter\n\ndef test_token_expiration():\n    time = ControllableTimeAdapter()\n    time.freeze()\n\n    # Create token that expires in 1 hour\n    token = create_token(expires_in=3600)\n    assert token.is_valid()\n\n    # Fast forward 59 minutes\n    time.advance(timedelta(minutes=59))\n    assert token.is_valid()\n\n    # Fast forward 1 more minute - token should expire\n    time.advance(timedelta(minutes=1))\n    assert not token.is_valid()\n\ndef test_scheduled_task():\n    time = ControllableTimeAdapter()\n    results = []\n\n    def callback():\n        results.append(\"executed\")\n\n    # Schedule task for 5 seconds\n    time.schedule_after(5.0, callback)\n\n    # Time hasn't advanced yet\n    assert len(results) == 0\n\n    # Advance past scheduled time\n    time.advance(timedelta(seconds=5))\n    assert len(results) == 1\n</code></pre>"},{"location":"advanced/performance/#mock-server-integration","title":"Mock Server Integration","text":"<p>Use WireMock for API stubbing in tests:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import WireMockAdapter\nfrom venomqa import Client\n\n@pytest.fixture\ndef mock_server():\n    mock = WireMockAdapter(port=8080)\n    yield mock\n    mock.reset()\n\ndef test_api_with_mock(mock_server):\n    # Stub API response\n    mock_server.stub(\n        \"GET\",\n        \"/api/users/1\",\n        body={\"id\": 1, \"name\": \"John Doe\"},\n        status_code=200,\n    )\n\n    # Stub error response\n    mock_server.stub(\n        \"GET\",\n        \"/api/users/999\",\n        body={\"error\": \"Not found\"},\n        status_code=404,\n    )\n\n    # Use mocked API\n    client = Client(base_url=mock_server.get_base_url())\n\n    response = client.get(\"/api/users/1\")\n    assert response.status_code == 200\n    assert response.json()[\"name\"] == \"John Doe\"\n\n    # Verify request was made\n    assert mock_server.verify(\"GET\", \"/api/users/1\", count=1)\n\ndef test_sequential_responses(mock_server):\n    # Return different responses on each call\n    mock_server.stub_sequence(\"POST\", \"/api/orders\", responses=[\n        MockResponse(status_code=201, body={\"id\": 1}),\n        MockResponse(status_code=201, body={\"id\": 2}),\n        MockResponse(status_code=429, body={\"error\": \"Rate limited\"}),\n    ])\n\n    client = Client(base_url=mock_server.get_base_url())\n\n    # First call\n    r1 = client.post(\"/api/orders\")\n    assert r1.status_code == 201\n\n    # Second call\n    r2 = client.post(\"/api/orders\")\n    assert r2.status_code == 201\n\n    # Third call - rate limited\n    r3 = client.post(\"/api/orders\")\n    assert r3.status_code == 429\n</code></pre>"},{"location":"advanced/performance/#parallel-task-execution","title":"Parallel Task Execution","text":"<p>Test concurrent operations:</p> Python<pre><code>from venomqa.adapters import ThreadingConcurrencyAdapter\n\ndef test_concurrent_requests():\n    concurrency = ThreadingConcurrencyAdapter(max_workers=10)\n\n    def make_request(user_id):\n        # Simulate API call\n        return client.get(f\"/api/users/{user_id}\")\n\n    # Spawn 100 concurrent tasks\n    task_ids = concurrency.map_async(make_request, range(100))\n\n    # Wait for all to complete\n    results = concurrency.join_all(task_ids, timeout=30.0)\n\n    # Verify all succeeded\n    successful = [r for r in results if r.success]\n    assert len(successful) == 100\n</code></pre>"},{"location":"advanced/performance/#email-testing-workflow","title":"Email Testing Workflow","text":"<p>Complete email testing with cleanup:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import MailhogAdapter\n\n@pytest.fixture\ndef mail():\n    adapter = MailhogAdapter(host=\"localhost\")\n    adapter.delete_all_emails()  # Clean slate\n    yield adapter\n    adapter.delete_all_emails()  # Cleanup\n\ndef test_password_reset_email(mail):\n    # Request password reset\n    response = client.post(\"/api/auth/forgot-password\", json={\n        \"email\": \"user@example.com\",\n    })\n    assert response.status_code == 200\n\n    # Wait for and verify email\n    email = mail.wait_for_email(\n        to=\"user@example.com\",\n        subject=\"Password Reset\",\n        timeout=30.0,\n    )\n\n    assert email is not None\n    assert \"reset\" in email.body.lower()\n\n    # Extract reset link from email\n    import re\n    match = re.search(r'https://\\S+/reset/\\S+', email.body)\n    assert match\n    reset_link = match.group(0)\n\n    # Use reset link\n    response = client.post(reset_link, json={\"password\": \"newpass123\"})\n    assert response.status_code == 200\n</code></pre>"},{"location":"advanced/performance/#cache-testing-patterns","title":"Cache Testing Patterns","text":"<p>Test cache behavior:</p> Python<pre><code>from venomqa.adapters import RedisCacheAdapter\n\ndef test_cache_expiration():\n    cache = RedisCacheAdapter()\n\n    # Set with TTL\n    cache.set(\"session:abc123\", {\"user_id\": 1}, ttl=60)\n\n    # Verify exists\n    assert cache.exists(\"session:abc123\")\n\n    # Check TTL\n    ttl = cache.get_ttl(\"session:abc123\")\n    assert 0 &lt; ttl &lt;= 60\n\n    # Get stats\n    stats = cache.get_stats()\n    print(f\"Hit rate: {stats.hit_rate}%\")\n\ndef test_cache_invalidation():\n    cache = RedisCacheAdapter()\n\n    # Cache user data\n    cache.set(\"user:1\", {\"name\": \"John\", \"role\": \"user\"})\n\n    # Update user\n    update_user(1, role=\"admin\")\n\n    # Invalidate cache\n    cache.delete(\"user:1\")\n\n    # Next read will fetch fresh data\n    user = cache.get(\"user:1\")\n    assert user is None\n</code></pre>"},{"location":"advanced/performance/#queue-testing-patterns","title":"Queue Testing Patterns","text":"<p>Test async job processing:</p> Python<pre><code>from venomqa.adapters import RedisQueueAdapter\n\ndef test_job_queue():\n    queue = RedisQueueAdapter(host=\"localhost\")\n\n    # Clear queue\n    queue.clear_queue(\"test\")\n\n    # Enqueue job\n    job_id = queue.enqueue(\n        \"myapp.tasks.send_notification\",\n        user_id=123,\n        message=\"Hello!\",\n        queue=\"test\",\n    )\n\n    # Check job status\n    job = queue.get_job(job_id)\n    assert job.status == \"pending\"\n\n    # Wait for completion (requires worker running)\n    result = queue.get_job_result(job_id, timeout=60.0)\n\n    if result:\n        assert result.success\n        print(f\"Job result: {result.result}\")\n\n    # Check for failed jobs\n    failed = queue.get_failed_jobs(queue=\"test\")\n    assert len(failed) == 0\n</code></pre>"},{"location":"advanced/performance/#creating-test-fixtures-with-ports","title":"Creating Test Fixtures with Ports","text":"<p>Create reusable test fixtures:</p> Python<pre><code>import pytest\nfrom typing import TypeVar, Protocol\nfrom venomqa.ports import CachePort, MailPort, QueuePort\n\nT = TypeVar('T')\n\nclass TestFixtures:\n    \"\"\"Collection of test fixtures using ports.\"\"\"\n\n    def __init__(\n        self,\n        cache: CachePort,\n        mail: MailPort,\n        queue: QueuePort,\n    ):\n        self.cache = cache\n        self.mail = mail\n        self.queue = queue\n\n    def reset(self):\n        \"\"\"Reset all fixtures to clean state.\"\"\"\n        self.cache.clear()\n        self.mail.delete_all_emails()\n        self.queue.clear_queue()\n\n    def cached_user(self, user_id: int) -&gt; dict:\n        \"\"\"Get or create cached user.\"\"\"\n        key = f\"test:user:{user_id}\"\n        user = self.cache.get(key)\n        if user is None:\n            user = {\"id\": user_id, \"name\": f\"User {user_id}\"}\n            self.cache.set(key, user, ttl=300)\n        return user\n\n@pytest.fixture\ndef fixtures():\n    from venomqa.adapters import (\n        RedisCacheAdapter,\n        MailhogAdapter,\n        RedisQueueAdapter,\n    )\n\n    fx = TestFixtures(\n        cache=RedisCacheAdapter(),\n        mail=MailhogAdapter(),\n        queue=RedisQueueAdapter(),\n    )\n    fx.reset()\n    yield fx\n    fx.reset()\n</code></pre>"},{"location":"advanced/performance/#health-check-pattern","title":"Health Check Pattern","text":"<p>Verify external services before tests:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import (\n    RedisCacheAdapter,\n    MailhogAdapter,\n    ElasticsearchAdapter,\n)\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef verify_services():\n    \"\"\"Verify all required services are healthy.\"\"\"\n    services = [\n        (\"Redis\", RedisCacheAdapter()),\n        (\"MailHog\", MailhogAdapter()),\n        (\"Elasticsearch\", ElasticsearchAdapter()),\n    ]\n\n    unhealthy = []\n    for name, adapter in services:\n        if not adapter.health_check():\n            unhealthy.append(name)\n\n    if unhealthy:\n        pytest.skip(f\"Services not available: {', '.join(unhealthy)}\")\n</code></pre>"},{"location":"advanced/performance/#multi-environment-configuration","title":"Multi-Environment Configuration","text":"<p>Configure adapters for different environments:</p> Python<pre><code>from dataclasses import dataclass\nfrom venomqa.ports import CachePort, MailPort\nfrom venomqa.adapters import RedisCacheAdapter, MailhogAdapter, MailpitAdapter\n\n@dataclass\nclass Environment:\n    name: str\n    cache: CachePort\n    mail: MailPort\n\ndef get_environment() -&gt; Environment:\n    env_name = os.environ.get(\"ENV\", \"local\")\n\n    if env_name == \"production\":\n        return Environment(\n            name=\"production\",\n            cache=RedisCacheAdapter(\n                host=\"redis.prod.internal\",\n                password=os.environ[\"REDIS_PASSWORD\"],\n            ),\n            mail=MailpitAdapter(\n                host=\"mail.prod.internal\",\n                use_tls=True,\n            ),\n        )\n    elif env_name == \"staging\":\n        return Environment(\n            name=\"staging\",\n            cache=RedisCacheAdapter(host=\"localhost\"),\n            mail=MailhogAdapter(host=\"localhost\"),\n        )\n    else:\n        return Environment(\n            name=\"local\",\n            cache=RedisCacheAdapter(host=\"localhost\"),\n            mail=MailhogAdapter(host=\"localhost\"),\n        )\n</code></pre>"},{"location":"advanced/testing-patterns/","title":"Testing Patterns","text":"<p>Advanced testing patterns and strategies for VenomQA.</p>"},{"location":"advanced/testing-patterns/#data-driven-testing","title":"Data-Driven Testing","text":""},{"location":"advanced/testing-patterns/#parameterized-journeys","title":"Parameterized Journeys","text":"Python<pre><code>from venomqa import Journey, Step\n\ntest_cases = [\n    {\"email\": \"valid@example.com\", \"password\": \"ValidPass123!\", \"expect_success\": True},\n    {\"email\": \"invalid-email\", \"password\": \"ValidPass123!\", \"expect_success\": False},\n    {\"email\": \"valid@example.com\", \"password\": \"short\", \"expect_success\": False},\n    {\"email\": \"\", \"password\": \"ValidPass123!\", \"expect_success\": False},\n]\n\ndef make_register_action(case):\n    def register(client, context):\n        return client.post(\"/api/auth/register\", json={\n            \"email\": case[\"email\"],\n            \"password\": case[\"password\"],\n        })\n    return register\n\njourneys = []\nfor case in test_cases:\n    journey = Journey(\n        name=f\"register_{case['email'].replace('@', '_at_').replace('.', '_')}\",\n        description=f\"Test registration with email={case['email']}\",\n        tags=[\"registration\", \"data-driven\"],\n        steps=[\n            Step(\n                name=\"register\",\n                action=make_register_action(case),\n                expect_failure=not case[\"expect_success\"],\n            ),\n        ],\n    )\n    journeys.append(journey)\n</code></pre>"},{"location":"advanced/testing-patterns/#csv-based-test-data","title":"CSV-Based Test Data","text":"Python<pre><code>import csv\nfrom venomqa import Journey, Step\n\n\ndef load_test_cases(csv_path: str) -&gt; list[dict]:\n    \"\"\"Load test cases from CSV file.\"\"\"\n    with open(csv_path) as f:\n        reader = csv.DictReader(f)\n        return list(reader)\n\n\ntest_cases = load_test_cases(\"test_data/users.csv\")\n\njourneys = [\n    Journey(\n        name=f\"user_test_{i}\",\n        steps=[\n            Step(\n                name=\"create_user\",\n                action=lambda c, ctx, tc=tc: c.post(\"/api/users\", json=tc),\n                expect_failure=tc.get(\"expect_failure\", \"false\").lower() == \"true\",\n            ),\n        ],\n    )\n    for i, tc in enumerate(test_cases)\n]\n</code></pre>"},{"location":"advanced/testing-patterns/#contract-testing","title":"Contract Testing","text":""},{"location":"advanced/testing-patterns/#schema-validation","title":"Schema Validation","text":"Python<pre><code>from venomqa import Journey, Step\nimport jsonschema\n\n\nUSER_SCHEMA = {\n    \"type\": \"object\",\n    \"required\": [\"id\", \"email\", \"name\"],\n    \"properties\": {\n        \"id\": {\"type\": \"integer\"},\n        \"email\": {\"type\": \"string\", \"format\": \"email\"},\n        \"name\": {\"type\": \"string\", \"minLength\": 1},\n        \"created_at\": {\"type\": \"string\", \"format\": \"date-time\"},\n    },\n}\n\n\ndef create_user(client, context):\n    response = client.post(\"/api/users\", json={\n        \"email\": \"test@example.com\",\n        \"name\": \"Test User\",\n    })\n\n    if response.status_code in [200, 201]:\n        # Validate response schema\n        try:\n            jsonschema.validate(response.json(), USER_SCHEMA)\n            context[\"schema_valid\"] = True\n        except jsonschema.ValidationError as e:\n            context[\"schema_error\"] = str(e)\n            raise AssertionError(f\"Schema validation failed: {e}\")\n\n    return response\n\n\ndef get_user(client, context):\n    response = client.get(f\"/api/users/{context['user_id']}\")\n\n    if response.status_code == 200:\n        jsonschema.validate(response.json(), USER_SCHEMA)\n\n    return response\n\n\njourney = Journey(\n    name=\"user_contract_test\",\n    description=\"Test user API contract\",\n    tags=[\"contract\", \"schema\"],\n    steps=[\n        Step(name=\"create\", action=create_user),\n        Step(name=\"read\", action=get_user),\n    ],\n)\n</code></pre>"},{"location":"advanced/testing-patterns/#smoke-testing","title":"Smoke Testing","text":""},{"location":"advanced/testing-patterns/#quick-health-checks","title":"Quick Health Checks","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef health_check(client, context):\n    return client.get(\"/health\")\n\n\ndef api_status(client, context):\n    return client.get(\"/api/status\")\n\n\ndef db_ping(client, context):\n    return client.get(\"/api/health/db\")\n\n\ndef cache_ping(client, context):\n    return client.get(\"/api/health/cache\")\n\n\ndef queue_ping(client, context):\n    return client.get(\"/api/health/queue\")\n\n\nsmoke_journey = Journey(\n    name=\"smoke_test\",\n    description=\"Quick health check of all services\",\n    tags=[\"smoke\", \"health\"],\n    timeout=30.0,\n    steps=[\n        Step(name=\"health\", action=health_check, timeout=5.0),\n        Step(name=\"api\", action=api_status, timeout=5.0),\n        Step(name=\"db\", action=db_ping, timeout=5.0),\n        Step(name=\"cache\", action=cache_ping, timeout=5.0),\n        Step(name=\"queue\", action=queue_ping, timeout=5.0),\n    ],\n)\n</code></pre>"},{"location":"advanced/testing-patterns/#regression-testing","title":"Regression Testing","text":""},{"location":"advanced/testing-patterns/#baseline-comparison","title":"Baseline Comparison","text":"Python<pre><code>import json\nfrom pathlib import Path\nfrom venomqa import Journey, Step\n\n\nBASELINE_PATH = Path(\"baselines\")\n\n\ndef load_baseline(name: str) -&gt; dict | None:\n    \"\"\"Load baseline response.\"\"\"\n    path = BASELINE_PATH / f\"{name}.json\"\n    if path.exists():\n        return json.loads(path.read_text())\n    return None\n\n\ndef save_baseline(name: str, data: dict) -&gt; None:\n    \"\"\"Save baseline response.\"\"\"\n    BASELINE_PATH.mkdir(exist_ok=True)\n    path = BASELINE_PATH / f\"{name}.json\"\n    path.write_text(json.dumps(data, indent=2))\n\n\ndef compare_response(name: str, actual: dict, context) -&gt; None:\n    \"\"\"Compare response with baseline.\"\"\"\n    expected = load_baseline(name)\n\n    if expected is None:\n        # First run - save baseline\n        save_baseline(name, actual)\n        context[f\"{name}_baseline_created\"] = True\n        return\n\n    # Compare (ignoring timestamps, ids, etc.)\n    def normalize(obj):\n        if isinstance(obj, dict):\n            return {k: normalize(v) for k, v in obj.items()\n                    if k not in [\"id\", \"created_at\", \"updated_at\"]}\n        elif isinstance(obj, list):\n            return [normalize(item) for item in obj]\n        return obj\n\n    if normalize(actual) != normalize(expected):\n        context[f\"{name}_regression_diff\"] = {\n            \"expected\": expected,\n            \"actual\": actual,\n        }\n        raise AssertionError(f\"Regression detected in {name}\")\n\n\ndef get_users_regression(client, context):\n    response = client.get(\"/api/users\")\n    if response.status_code == 200:\n        compare_response(\"get_users\", response.json(), context)\n    return response\n\n\njourney = Journey(\n    name=\"regression_test\",\n    description=\"Compare API responses with baselines\",\n    tags=[\"regression\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"get_users\", action=get_users_regression),\n    ],\n)\n</code></pre>"},{"location":"advanced/testing-patterns/#chaos-testing","title":"Chaos Testing","text":""},{"location":"advanced/testing-patterns/#random-failure-injection","title":"Random Failure Injection","text":"Python<pre><code>import random\nfrom venomqa import Journey, Step\n\n\nclass ChaosConfig:\n    failure_rate: float = 0.1  # 10% failure rate\n    slow_rate: float = 0.2     # 20% slow rate\n    slow_min: float = 0.5      # Min slow delay\n    slow_max: float = 2.0      # Max slow delay\n\n\ndef chaos_wrapper(action, config: ChaosConfig = ChaosConfig()):\n    \"\"\"Wrap action with chaos injection.\"\"\"\n    def wrapped(client, context):\n        # Random failure\n        if random.random() &lt; config.failure_rate:\n            raise Exception(\"Chaos monkey strike!\")\n\n        # Random slowdown\n        if random.random() &lt; config.slow_rate:\n            import time\n            delay = random.uniform(config.slow_min, config.slow_max)\n            time.sleep(delay)\n\n        return action(client, context)\n\n    return wrapped\n\n\ndef normal_action(client, context):\n    return client.get(\"/api/data\")\n\n\njourney = Journey(\n    name=\"chaos_test\",\n    description=\"Test resilience with random failures\",\n    tags=[\"chaos\", \"resilience\"],\n    steps=[\n        Step(name=\"action_1\", action=chaos_wrapper(normal_action)),\n        Step(name=\"action_2\", action=chaos_wrapper(normal_action)),\n        Step(name=\"action_3\", action=chaos_wrapper(normal_action)),\n    ],\n)\n</code></pre>"},{"location":"advanced/testing-patterns/#load-testing-patterns","title":"Load Testing Patterns","text":""},{"location":"advanced/testing-patterns/#concurrent-users","title":"Concurrent Users","text":"Python<pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed\nfrom venomqa import Journey, Step, Client, JourneyRunner\n\n\ndef run_journey_for_user(user_id: int, journey: Journey, config) -&gt; dict:\n    \"\"\"Run journey for a single simulated user.\"\"\"\n    client = Client(base_url=config.base_url)\n    runner = JourneyRunner(client=client)\n\n    # Set user-specific context\n    result = runner.run(journey)\n\n    return {\n        \"user_id\": user_id,\n        \"success\": result.success,\n        \"duration_ms\": result.duration_ms,\n    }\n\n\ndef load_test(journey: Journey, config, num_users: int = 10, max_workers: int = 5):\n    \"\"\"Run journey concurrently for multiple users.\"\"\"\n    results = []\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(run_journey_for_user, i, journey, config): i\n            for i in range(num_users)\n        }\n\n        for future in as_completed(futures):\n            user_id = futures[future]\n            try:\n                result = future.result()\n                results.append(result)\n            except Exception as e:\n                results.append({\n                    \"user_id\": user_id,\n                    \"success\": False,\n                    \"error\": str(e),\n                })\n\n    # Analyze results\n    successful = sum(1 for r in results if r.get(\"success\"))\n    avg_duration = sum(r.get(\"duration_ms\", 0) for r in results) / len(results)\n\n    return {\n        \"total_users\": num_users,\n        \"successful\": successful,\n        \"failed\": num_users - successful,\n        \"avg_duration_ms\": avg_duration,\n        \"results\": results,\n    }\n</code></pre>"},{"location":"advanced/testing-patterns/#boundary-testing","title":"Boundary Testing","text":""},{"location":"advanced/testing-patterns/#edge-cases","title":"Edge Cases","text":"Python<pre><code>from venomqa import Journey, Step, Branch, Path, Checkpoint\n\n\ndef create_item_min_name(client, context):\n    \"\"\"Create item with minimum name length.\"\"\"\n    return client.post(\"/api/items\", json={\n        \"name\": \"A\",  # Minimum 1 character\n        \"price\": 0.01,  # Minimum price\n    })\n\n\ndef create_item_max_name(client, context):\n    \"\"\"Create item with maximum name length.\"\"\"\n    return client.post(\"/api/items\", json={\n        \"name\": \"A\" * 255,  # Maximum characters\n        \"price\": 999999.99,  # Maximum price\n    })\n\n\ndef create_item_boundary_exceeded(client, context):\n    \"\"\"Create item exceeding boundaries.\"\"\"\n    return client.post(\"/api/items\", json={\n        \"name\": \"A\" * 256,  # Exceeds maximum\n        \"price\": 0,  # Below minimum\n    })\n\n\njourney = Journey(\n    name=\"boundary_test\",\n    description=\"Test boundary conditions\",\n    tags=[\"boundary\", \"edge-case\"],\n    steps=[\n        Checkpoint(name=\"start\"),\n        Branch(\n            checkpoint_name=\"start\",\n            paths=[\n                Path(name=\"minimum_values\", steps=[\n                    Step(name=\"create\", action=create_item_min_name),\n                ]),\n                Path(name=\"maximum_values\", steps=[\n                    Step(name=\"create\", action=create_item_max_name),\n                ]),\n                Path(name=\"exceeded_boundaries\", steps=[\n                    Step(\n                        name=\"create\",\n                        action=create_item_boundary_exceeded,\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"advanced/testing-patterns/#idempotency-testing","title":"Idempotency Testing","text":""},{"location":"advanced/testing-patterns/#verify-idempotent-operations","title":"Verify Idempotent Operations","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef create_order(client, context):\n    \"\"\"Create order with idempotency key.\"\"\"\n    idempotency_key = \"test-order-12345\"\n    context[\"idempotency_key\"] = idempotency_key\n\n    response = client.post(\"/api/orders\", json={\n        \"items\": [{\"product_id\": 1, \"quantity\": 1}],\n    }, headers={\n        \"Idempotency-Key\": idempotency_key,\n    })\n\n    if response.status_code in [200, 201]:\n        context[\"order_id\"] = response.json()[\"id\"]\n\n    return response\n\n\ndef retry_create_order(client, context):\n    \"\"\"Retry same order - should return same result.\"\"\"\n    response = client.post(\"/api/orders\", json={\n        \"items\": [{\"product_id\": 1, \"quantity\": 1}],\n    }, headers={\n        \"Idempotency-Key\": context[\"idempotency_key\"],\n    })\n\n    # Should return same order ID, not create new one\n    if response.status_code in [200, 201]:\n        if response.json()[\"id\"] != context[\"order_id\"]:\n            raise AssertionError(\"Idempotency failed - new order created\")\n\n    return response\n\n\njourney = Journey(\n    name=\"idempotency_test\",\n    description=\"Test idempotent operations\",\n    tags=[\"idempotency\"],\n    steps=[\n        Step(name=\"create_order\", action=create_order),\n        Step(name=\"retry_order\", action=retry_create_order),\n        Step(name=\"retry_again\", action=retry_create_order),\n    ],\n)\n</code></pre>"},{"location":"advanced/testing-patterns/#cleanup-patterns","title":"Cleanup Patterns","text":""},{"location":"advanced/testing-patterns/#with-cleanup-steps","title":"With Cleanup Steps","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint\n\n\ndef setup_test_data(client, context):\n    \"\"\"Create test data.\"\"\"\n    response = client.post(\"/api/items\", json={\"name\": \"Test\"})\n    context[\"item_id\"] = response.json()[\"id\"]\n    return response\n\n\ndef run_tests(client, context):\n    \"\"\"Run actual tests.\"\"\"\n    return client.get(f\"/api/items/{context['item_id']}\")\n\n\ndef cleanup(client, context):\n    \"\"\"Clean up test data.\"\"\"\n    item_id = context.get(\"item_id\")\n    if item_id:\n        return client.delete(f\"/api/items/{item_id}\")\n    return {\"status\": \"nothing to clean\"}\n\n\njourney = Journey(\n    name=\"with_cleanup\",\n    description=\"Test with cleanup\",\n    steps=[\n        Step(name=\"setup\", action=setup_test_data),\n        Checkpoint(name=\"after_setup\"),\n        Step(name=\"test\", action=run_tests),\n        Step(name=\"cleanup\", action=cleanup),  # Always runs\n    ],\n)\n</code></pre>"},{"location":"advanced/testing-patterns/#using-context-manager","title":"Using Context Manager","text":"Python<pre><code>class TestDataManager:\n    \"\"\"Manage test data with automatic cleanup.\"\"\"\n\n    def __init__(self, client):\n        self.client = client\n        self.created_items = []\n\n    def create_item(self, data: dict) -&gt; dict:\n        response = self.client.post(\"/api/items\", json=data)\n        if response.status_code in [200, 201]:\n            self.created_items.append(response.json()[\"id\"])\n        return response.json()\n\n    def cleanup(self):\n        for item_id in self.created_items:\n            self.client.delete(f\"/api/items/{item_id}\")\n        self.created_items.clear()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.cleanup()\n        return False\n\n\n# Usage in journey\ndef test_with_manager(client, context):\n    with TestDataManager(client) as manager:\n        item = manager.create_item({\"name\": \"Test\"})\n        # ... run tests ...\n        # Cleanup happens automatically\n</code></pre>"},{"location":"concepts/","title":"Core Concepts","text":"<p>Understanding VenomQA's core concepts will help you write effective, maintainable tests.</p>"},{"location":"concepts/#overview","title":"Overview","text":"<p>VenomQA is built around four key concepts:</p> <pre><code>graph LR\n    A[Journey] --&gt; B[Steps]\n    B --&gt; C[Checkpoints]\n    C --&gt; D[Branches]\n    D --&gt; E[Paths]</code></pre>"},{"location":"concepts/#journeys","title":"Journeys","text":"<p>A complete user scenario from start to finish. Contains Steps, Checkpoints, and Branches.</p>"},{"location":"concepts/#checkpoints-branching","title":"Checkpoints &amp; Branching","text":"<p>Save database state and fork execution to test multiple scenarios.</p>"},{"location":"concepts/#state-management","title":"State Management","text":"<p>How VenomQA manages database state for checkpointing and rollback.</p>"},{"location":"concepts/#ports-adapters","title":"Ports &amp; Adapters","text":"<p>Clean architecture for swapping external dependencies.</p>"},{"location":"concepts/#quick-reference","title":"Quick Reference","text":""},{"location":"concepts/#journey","title":"Journey","text":"<p>A journey represents a complete user scenario:</p> Python<pre><code>from venomqa import Journey, Step\n\njourney = Journey(\n    name=\"user_registration\",\n    description=\"Test user registration flow\",\n    tags=[\"auth\", \"critical\"],\n    steps=[\n        Step(name=\"register\", action=register_user),\n        Step(name=\"verify_email\", action=verify_email),\n        Step(name=\"login\", action=login_user),\n    ],\n)\n</code></pre>"},{"location":"concepts/#step","title":"Step","text":"<p>A single action in a journey:</p> Python<pre><code>from venomqa import Step\n\nStep(\n    name=\"create_order\",\n    action=create_order,\n    description=\"Create a new order\",\n    timeout=10.0,\n    retries=3,\n    expect_failure=False,\n)\n</code></pre>"},{"location":"concepts/#checkpoint","title":"Checkpoint","text":"<p>A savepoint for database state:</p> Python<pre><code>from venomqa import Checkpoint\n\nCheckpoint(name=\"order_created\")\n</code></pre>"},{"location":"concepts/#branch","title":"Branch","text":"<p>Fork execution to test multiple paths:</p> Python<pre><code>from venomqa import Branch, Path, Step\n\nBranch(\n    checkpoint_name=\"order_created\",\n    paths=[\n        Path(name=\"card_payment\", steps=[\n            Step(name=\"pay_card\", action=pay_with_card),\n        ]),\n        Path(name=\"wallet_payment\", steps=[\n            Step(name=\"pay_wallet\", action=pay_with_wallet),\n        ]),\n    ],\n)\n</code></pre>"},{"location":"concepts/#context","title":"Context","text":"<p>Share data between steps:</p> Python<pre><code>def login(client, context):\n    response = client.post(\"/auth/login\", json={...})\n    context[\"token\"] = response.json()[\"token\"]  # Store\n    return response\n\ndef get_orders(client, context):\n    token = context[\"token\"]  # Retrieve\n    return client.get(\"/orders\", headers={\"Authorization\": f\"Bearer {token}\"})\n</code></pre>"},{"location":"concepts/#how-it-all-fits-together","title":"How It All Fits Together","text":"<p>Here's a complete example showing all concepts:</p> Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\ndef login(client, context):\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n    if response.status_code == 200:\n        context[\"token\"] = response.json()[\"token\"]\n        client.set_auth_token(context[\"token\"])\n    return response\n\ndef add_to_cart(client, context):\n    response = client.post(\"/api/cart/items\", json={\n        \"product_id\": 1,\n        \"quantity\": 2,\n    })\n    context[\"cart_total\"] = response.json()[\"total\"]\n    return response\n\ndef pay_with_card(client, context):\n    return client.post(\"/api/checkout/pay\", json={\n        \"method\": \"credit_card\",\n        \"amount\": context[\"cart_total\"],\n    })\n\ndef pay_with_wallet(client, context):\n    return client.post(\"/api/checkout/pay\", json={\n        \"method\": \"wallet\",\n        \"amount\": context[\"cart_total\"],\n    })\n\ndef pay_with_invalid_card(client, context):\n    return client.post(\"/api/checkout/pay\", json={\n        \"method\": \"credit_card\",\n        \"card_token\": \"tok_declined\",\n    })\n\njourney = Journey(\n    name=\"checkout_flow\",\n    description=\"Test checkout with multiple payment methods\",\n    tags=[\"e-commerce\", \"critical\"],\n    steps=[\n        # Setup phase\n        Step(name=\"login\", action=login),\n        Step(name=\"add_to_cart\", action=add_to_cart),\n\n        # Checkpoint - save state here\n        Checkpoint(name=\"cart_ready\"),\n\n        # Branch - test multiple paths from saved state\n        Branch(\n            checkpoint_name=\"cart_ready\",\n            paths=[\n                # Happy path: credit card\n                Path(name=\"credit_card\", steps=[\n                    Step(name=\"pay_card\", action=pay_with_card),\n                ]),\n\n                # Happy path: wallet\n                Path(name=\"wallet\", steps=[\n                    Step(name=\"pay_wallet\", action=pay_with_wallet),\n                ]),\n\n                # Error path: declined card\n                Path(name=\"declined\", steps=[\n                    Step(\n                        name=\"pay_declined\",\n                        action=pay_with_invalid_card,\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre> <p>When you run this journey:</p> <ol> <li><code>login</code> and <code>add_to_cart</code> execute once</li> <li>At <code>Checkpoint(\"cart_ready\")</code>, the database state is saved</li> <li>For each <code>Path</code>:</li> <li>Database is restored to the checkpoint</li> <li>Context is restored to the checkpoint state</li> <li>Path steps execute</li> <li>After all paths complete, results are aggregated</li> </ol>"},{"location":"concepts/#mental-model","title":"Mental Model","text":"<p>Think of VenomQA like version control for your test state:</p> Git Concept VenomQA Concept Repository Journey Commit Checkpoint Branch Branch Working tree Execution Context <p>Just as Git lets you branch from a commit and explore different changes, VenomQA lets you branch from a database checkpoint and explore different execution paths.</p>"},{"location":"concepts/#next-steps","title":"Next Steps","text":"<p>Dive deeper into each concept:</p> <ul> <li>Journeys - The foundation of VenomQA testing</li> <li>Checkpoints &amp; Branching - State management and path exploration</li> <li>State Management - How checkpoints work under the hood</li> <li>Ports &amp; Adapters - Clean architecture for external dependencies</li> </ul>"},{"location":"concepts/branching/","title":"Checkpoints &amp; Branching","text":"<p>Checkpoints and branching are VenomQA's most powerful features. They let you save database state and test multiple scenarios from the same starting point.</p>"},{"location":"concepts/branching/#the-problem","title":"The Problem","text":"<p>Without state management, testing multiple scenarios requires:</p> <ol> <li>Running the same setup steps repeatedly</li> <li>Cleaning up data between tests</li> <li>Dealing with flaky tests from inconsistent state</li> </ol> Text Only<pre><code>Traditional Testing:\nTest 1: Login \u2192 Add to Cart \u2192 Pay with Card\nTest 2: Login \u2192 Add to Cart \u2192 Pay with Wallet (repeat setup!)\nTest 3: Login \u2192 Add to Cart \u2192 Pay with PayPal (repeat again!)\n</code></pre>"},{"location":"concepts/branching/#the-solution-checkpoints","title":"The Solution: Checkpoints","text":"<p>VenomQA lets you save state at a checkpoint and branch from there:</p> Text Only<pre><code>VenomQA Testing:\nLogin \u2192 Add to Cart \u2192 [CHECKPOINT: cart_ready]\n                            \u2502\n                            \u251c\u2500\u2500 Pay with Card\n                            \u251c\u2500\u2500 Pay with Wallet\n                            \u2514\u2500\u2500 Pay with PayPal\n</code></pre> <p>Each branch starts from the exact same state - no repeated setup, no flaky tests.</p>"},{"location":"concepts/branching/#checkpoints","title":"Checkpoints","text":""},{"location":"concepts/branching/#creating-a-checkpoint","title":"Creating a Checkpoint","text":"<p>A checkpoint saves the database state at a specific point:</p> Python<pre><code>from venomqa import Journey, Step, Checkpoint\n\njourney = Journey(\n    name=\"order_testing\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"create_order\", action=create_order),\n        Checkpoint(name=\"order_created\"),  # Save state here\n        Step(name=\"process_order\", action=process_order),\n    ],\n)\n</code></pre>"},{"location":"concepts/branching/#when-to-use-checkpoints","title":"When to Use Checkpoints","text":"<p>Place checkpoints before operations where you want to test multiple scenarios:</p> Python<pre><code>Journey(\n    name=\"payment_flows\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"add_to_cart\", action=add_to_cart),\n        Checkpoint(name=\"cart_ready\"),      # Before payment\n        Step(name=\"checkout\", action=checkout),\n        Checkpoint(name=\"order_pending\"),   # Before payment processing\n        # Branch here to test different payment methods\n    ],\n)\n</code></pre>"},{"location":"concepts/branching/#how-checkpoints-work","title":"How Checkpoints Work","text":"<p>Under the hood, VenomQA uses database transactions:</p> SQL<pre><code>-- Creating a checkpoint\nSAVEPOINT chk_order_created;\n\n-- Rolling back to checkpoint\nROLLBACK TO SAVEPOINT chk_order_created;\n\n-- Releasing checkpoint (cleanup)\nRELEASE SAVEPOINT chk_order_created;\n</code></pre>"},{"location":"concepts/branching/#branches","title":"Branches","text":""},{"location":"concepts/branching/#basic-branching","title":"Basic Branching","text":"<p>A Branch tests multiple paths from a checkpoint:</p> Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\njourney = Journey(\n    name=\"checkout_flows\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"add_items\", action=add_items),\n        Checkpoint(name=\"items_added\"),\n        Branch(\n            checkpoint_name=\"items_added\",\n            paths=[\n                Path(name=\"standard_checkout\", steps=[\n                    Step(name=\"checkout_standard\", action=checkout_standard),\n                ]),\n                Path(name=\"express_checkout\", steps=[\n                    Step(name=\"checkout_express\", action=checkout_express),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"concepts/branching/#branch-parameters","title":"Branch Parameters","text":"Parameter Type Description <code>checkpoint_name</code> <code>str</code> Name of the checkpoint to rollback to <code>paths</code> <code>list[Path]</code> List of paths to explore"},{"location":"concepts/branching/#path-parameters","title":"Path Parameters","text":"Parameter Type Default Description <code>name</code> <code>str</code> Required Unique identifier for the path <code>steps</code> <code>list</code> Required Steps to execute in this path <code>description</code> <code>str</code> <code>\"\"</code> Human-readable description"},{"location":"concepts/branching/#real-world-example-payment-testing","title":"Real-World Example: Payment Testing","text":"Python<pre><code>def pay_with_card(client, context):\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"credit_card\",\n        \"card_number\": \"4242424242424242\",\n    })\n\ndef pay_with_paypal(client, context):\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"paypal\",\n    })\n\ndef pay_with_wallet(client, context):\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"wallet\",\n    })\n\ndef pay_insufficient_funds(client, context):\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"credit_card\",\n        \"card_number\": \"4000000000000002\",  # Test card that declines\n    })\n\njourney = Journey(\n    name=\"payment_methods\",\n    steps=[\n        Step(name=\"setup_order\", action=setup_order),\n        Checkpoint(name=\"order_ready\"),\n        Branch(\n            checkpoint_name=\"order_ready\",\n            paths=[\n                Path(name=\"credit_card\", steps=[\n                    Step(name=\"pay_card\", action=pay_with_card),\n                ]),\n                Path(name=\"paypal\", steps=[\n                    Step(name=\"pay_paypal\", action=pay_with_paypal),\n                ]),\n                Path(name=\"wallet\", steps=[\n                    Step(name=\"pay_wallet\", action=pay_with_wallet),\n                ]),\n                Path(name=\"declined\", steps=[\n                    Step(\n                        name=\"pay_declined\",\n                        action=pay_insufficient_funds,\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"concepts/branching/#how-rollback-works","title":"How Rollback Works","text":"<p>When a Branch is encountered:</p> <pre><code>graph TB\n    A[Start Journey] --&gt; B[Execute Steps]\n    B --&gt; C[Checkpoint: order_ready]\n    C --&gt; D[Save DB State]\n    D --&gt; E[Branch]\n\n    E --&gt; F[Path: credit_card]\n    F --&gt; G[Execute Steps]\n    G --&gt; H[Rollback to order_ready]\n\n    H --&gt; I[Path: paypal]\n    I --&gt; J[Execute Steps]\n    J --&gt; K[Rollback to order_ready]\n\n    K --&gt; L[Path: wallet]\n    L --&gt; M[Execute Steps]\n    M --&gt; N[Continue Journey]</code></pre> <ol> <li>Save Context: Snapshot the execution context (variables, tokens, etc.)</li> <li>Execute Path: Run all steps in the path</li> <li>Rollback Database: Restore database to checkpoint state</li> <li>Restore Context: Reset context to snapshot</li> <li>Next Path: Repeat for each path</li> </ol>"},{"location":"concepts/branching/#nested-checkpoints","title":"Nested Checkpoints","text":"<p>You can create checkpoints inside branch paths:</p> Python<pre><code>journey = Journey(\n    name=\"complex_flows\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Checkpoint(name=\"authenticated\"),\n        Step(name=\"create_order\", action=create_order),\n        Checkpoint(name=\"order_created\"),\n        Branch(\n            checkpoint_name=\"order_created\",\n            paths=[\n                Path(name=\"full_payment\", steps=[\n                    Step(name=\"process_payment\", action=process_payment),\n                    Checkpoint(name=\"payment_done\"),  # Nested checkpoint\n                    Step(name=\"ship_order\", action=ship_order),\n                ]),\n                Path(name=\"partial_payment\", steps=[\n                    Step(name=\"pay_deposit\", action=pay_deposit),\n                    Checkpoint(name=\"deposit_paid\"),  # Another nested checkpoint\n                    Step(name=\"pay_remainder\", action=pay_remainder),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"concepts/branching/#context-behavior-in-branches","title":"Context Behavior in Branches","text":""},{"location":"concepts/branching/#what-gets-restored","title":"What Gets Restored","text":"<p>When rolling back to a checkpoint:</p> <ul> <li>Database state: Fully restored via SAVEPOINT</li> <li>Context variables: Restored to snapshot at checkpoint time</li> <li>Auth tokens: Preserved from context</li> </ul>"},{"location":"concepts/branching/#what-persists","title":"What Persists","text":"<p>Across paths in a branch:</p> <ul> <li>Client connection: Same HTTP client</li> <li>Auth headers: Unless explicitly cleared</li> </ul>"},{"location":"concepts/branching/#example","title":"Example","text":"Python<pre><code>def setup_user(client, context):\n    # This runs once before checkpoint\n    context[\"user_id\"] = create_user()\n    context[\"token\"] = login()\n    return response\n\ndef path_a_action(client, context):\n    # Can access context[\"user_id\"] and context[\"token\"]\n    # Modifications here are reset for next path\n    context[\"path_a_data\"] = \"data\"\n    return client.get(\"/api/something\")\n\ndef path_b_action(client, context):\n    # context[\"path_a_data\"] does NOT exist here\n    # We're starting fresh from the checkpoint\n    return client.get(\"/api/other\")\n</code></pre>"},{"location":"concepts/branching/#best-practices","title":"Best Practices","text":""},{"location":"concepts/branching/#1-use-meaningful-checkpoint-names","title":"1. Use Meaningful Checkpoint Names","text":"Python<pre><code># Good\nCheckpoint(name=\"user_authenticated\")\nCheckpoint(name=\"order_created\")\nCheckpoint(name=\"payment_completed\")\n\n# Bad\nCheckpoint(name=\"cp1\")\nCheckpoint(name=\"save_here\")\n</code></pre>"},{"location":"concepts/branching/#2-place-checkpoints-strategically","title":"2. Place Checkpoints Strategically","text":"<p>Checkpoint before operations where you want to test multiple outcomes:</p> Python<pre><code># Good: Checkpoint before the fork point\nStep(name=\"create_order\", action=create_order),\nCheckpoint(name=\"order_ready\"),  # Multiple payment methods from here\nBranch(checkpoint_name=\"order_ready\", ...)\n\n# Bad: Checkpoint too early\nCheckpoint(name=\"start\"),  # Too much to repeat\nStep(name=\"login\", action=login),\nStep(name=\"add_items\", action=add_items),\nStep(name=\"create_order\", action=create_order),\nBranch(checkpoint_name=\"start\", ...)\n</code></pre>"},{"location":"concepts/branching/#3-keep-paths-focused","title":"3. Keep Paths Focused","text":"<p>Each path should test one specific scenario:</p> Python<pre><code># Good: Focused paths\nBranch(\n    checkpoint_name=\"order_ready\",\n    paths=[\n        Path(name=\"card_success\", steps=[\n            Step(name=\"pay_card\", action=pay_with_valid_card),\n        ]),\n        Path(name=\"card_declined\", steps=[\n            Step(name=\"pay_card\", action=pay_with_declined_card, expect_failure=True),\n        ]),\n        Path(name=\"card_expired\", steps=[\n            Step(name=\"pay_card\", action=pay_with_expired_card, expect_failure=True),\n        ]),\n    ],\n)\n</code></pre>"},{"location":"concepts/branching/#4-test-both-success-and-failure-paths","title":"4. Test Both Success and Failure Paths","text":"Python<pre><code>Branch(\n    checkpoint_name=\"checkout_ready\",\n    paths=[\n        # Happy paths\n        Path(name=\"success_card\", steps=[...]),\n        Path(name=\"success_wallet\", steps=[...]),\n\n        # Error paths\n        Path(name=\"error_insufficient_funds\", steps=[\n            Step(name=\"pay\", action=pay_insufficient, expect_failure=True),\n        ]),\n        Path(name=\"error_invalid_card\", steps=[\n            Step(name=\"pay\", action=pay_invalid_card, expect_failure=True),\n        ]),\n    ],\n)\n</code></pre>"},{"location":"concepts/branching/#5-document-path-purpose","title":"5. Document Path Purpose","text":"Python<pre><code>Path(\n    name=\"international_shipping\",\n    description=\"Test checkout with international shipping address and customs handling\",\n    steps=[...],\n)\n</code></pre>"},{"location":"concepts/branching/#limitations","title":"Limitations","text":""},{"location":"concepts/branching/#database-backend-required","title":"Database Backend Required","text":"<p>Full checkpoint/rollback requires a database that supports transactions:</p> <ul> <li>PostgreSQL: Fully supported</li> <li>MySQL: Supported (with InnoDB)</li> <li>SQLite: Limited support</li> </ul> <p>Without a database backend, checkpoints only save context state, not database changes.</p>"},{"location":"concepts/branching/#parallel-path-execution","title":"Parallel Path Execution","text":"<p>When running paths in parallel (<code>parallel_paths &gt; 1</code>), be aware:</p> <ul> <li>Each path may need its own database connection</li> <li>Paths may interfere with each other if not properly isolated</li> <li>Use <code>parallel_paths=1</code> when state isolation is critical</li> </ul>"},{"location":"concepts/branching/#transaction-scope","title":"Transaction Scope","text":"<p>Checkpoints work within a single transaction. If your application uses multiple databases or external services, only the primary database is rolled back.</p>"},{"location":"concepts/branching/#debugging-tips","title":"Debugging Tips","text":""},{"location":"concepts/branching/#enable-verbose-logging","title":"Enable Verbose Logging","text":"Bash<pre><code>venomqa run my_journey -v\n</code></pre> <p>Look for checkpoint operations:</p> Text Only<pre><code>DEBUG - Created checkpoint: chk_order_created\nDEBUG - Rolled back to checkpoint: chk_order_created\n</code></pre>"},{"location":"concepts/branching/#verify-checkpoint-order","title":"Verify Checkpoint Order","text":"<p>Ensure checkpoints are created before branches reference them:</p> Python<pre><code># Correct\nCheckpoint(name=\"order_created\"),\nBranch(checkpoint_name=\"order_created\", ...)\n\n# Wrong - will fail\nBranch(checkpoint_name=\"order_created\", ...)\nCheckpoint(name=\"order_created\"),  # Too late!\n</code></pre>"},{"location":"concepts/branching/#next-steps","title":"Next Steps","text":"<ul> <li>State Management - Deep dive into how state management works</li> <li>Database Backends - Configure different database backends</li> <li>Tutorials - Step-by-step guides for common scenarios</li> </ul>"},{"location":"concepts/journeys/","title":"Journeys","text":"<p>A Journey is the fundamental unit of testing in VenomQA. It represents a complete user scenario from start to finish.</p>"},{"location":"concepts/journeys/#what-is-a-journey","title":"What is a Journey?","text":"<p>Unlike traditional unit tests that test isolated functions, a Journey tests how your system behaves when users perform real-world workflows. Each journey consists of:</p> <ul> <li>Steps: Individual actions that make API calls</li> <li>Checkpoints: Savepoints for database state</li> <li>Branches: Multiple paths to explore from checkpoints</li> </ul> Text Only<pre><code>User Journey: Online Shopping\n\u251c\u2500\u2500 Login\n\u251c\u2500\u2500 Browse Products\n\u251c\u2500\u2500 Add to Cart\n\u251c\u2500\u2500 Checkout\n\u2502   \u251c\u2500\u2500 Credit Card Payment\n\u2502   \u251c\u2500\u2500 PayPal Payment\n\u2502   \u2514\u2500\u2500 Gift Card Payment\n\u2514\u2500\u2500 Confirmation\n</code></pre>"},{"location":"concepts/journeys/#creating-a-journey","title":"Creating a Journey","text":""},{"location":"concepts/journeys/#basic-journey","title":"Basic Journey","text":"<p>The simplest journey is a linear sequence of steps:</p> Python<pre><code>from venomqa import Journey, Step\n\ndef login(client, context):\n    return client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n\ndef get_profile(client, context):\n    return client.get(\"/api/users/me\")\n\ndef update_profile(client, context):\n    return client.patch(\"/api/users/me\", json={\n        \"name\": \"Updated Name\",\n    })\n\njourney = Journey(\n    name=\"profile_update\",\n    description=\"Test profile update flow\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"get_profile\", action=get_profile),\n        Step(name=\"update_profile\", action=update_profile),\n    ],\n)\n</code></pre>"},{"location":"concepts/journeys/#journey-with-metadata","title":"Journey with Metadata","text":"<p>Add tags, descriptions, and timeouts for organization:</p> Python<pre><code>journey = Journey(\n    name=\"checkout_flow\",\n    description=\"Complete checkout with payment processing\",\n    tags=[\"e-commerce\", \"critical\", \"payment\"],\n    timeout=120.0,  # 2 minute total timeout\n    steps=[...],\n)\n</code></pre>"},{"location":"concepts/journeys/#journey-parameters","title":"Journey Parameters","text":"Parameter Type Default Description <code>name</code> <code>str</code> Required Unique identifier for the journey <code>steps</code> <code>list</code> Required Sequence of Steps, Checkpoints, and Branches <code>description</code> <code>str</code> <code>\"\"</code> Human-readable description <code>tags</code> <code>list[str]</code> <code>[]</code> Tags for filtering/categorization <code>timeout</code> <code>float</code> <code>None</code> Maximum execution time in seconds"},{"location":"concepts/journeys/#steps","title":"Steps","text":""},{"location":"concepts/journeys/#action-function-signature","title":"Action Function Signature","text":"<p>Every step action receives two parameters:</p> Python<pre><code>def action(client: Client, context: ExecutionContext) -&gt; Any:\n    \"\"\"\n    Args:\n        client: HTTP client for making API requests\n        context: Shared state between steps\n\n    Returns:\n        Typically an httpx.Response object\n    \"\"\"\n    pass\n</code></pre>"},{"location":"concepts/journeys/#http-operations","title":"HTTP Operations","text":"Python<pre><code># GET request\ndef list_users(client, context):\n    return client.get(\"/api/users\", params={\"page\": 1, \"limit\": 10})\n\n# POST with JSON body\ndef create_user(client, context):\n    return client.post(\"/api/users\", json={\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\",\n    })\n\n# PUT for full updates\ndef replace_user(client, context):\n    user_id = context[\"user_id\"]\n    return client.put(f\"/api/users/{user_id}\", json={\n        \"name\": \"Jane Doe\",\n        \"email\": \"jane@example.com\",\n    })\n\n# PATCH for partial updates\ndef update_email(client, context):\n    user_id = context[\"user_id\"]\n    return client.patch(f\"/api/users/{user_id}\", json={\n        \"email\": \"newemail@example.com\",\n    })\n\n# DELETE\ndef delete_user(client, context):\n    user_id = context[\"user_id\"]\n    return client.delete(f\"/api/users/{user_id}\")\n</code></pre>"},{"location":"concepts/journeys/#step-options","title":"Step Options","text":"Python<pre><code>Step(\n    name=\"create_order\",\n    action=create_order,\n    description=\"Create a new order\",     # Optional description\n    timeout=10.0,                         # Override timeout\n    retries=3,                            # Retry on failure\n    expect_failure=False,                 # Expect this to fail\n)\n</code></pre> Parameter Type Default Description <code>name</code> <code>str</code> Required Unique identifier for the step <code>action</code> <code>Callable</code> Required Function to execute <code>description</code> <code>str</code> <code>\"\"</code> Human-readable description <code>timeout</code> <code>float</code> <code>None</code> Max execution time in seconds <code>retries</code> <code>int</code> <code>0</code> Number of retry attempts <code>expect_failure</code> <code>bool</code> <code>False</code> If True, step passes when action fails"},{"location":"concepts/journeys/#using-lambda-functions","title":"Using Lambda Functions","text":"<p>For simple actions, use lambda functions:</p> Python<pre><code>journey = Journey(\n    name=\"quick_test\",\n    steps=[\n        Step(\n            name=\"health_check\",\n            action=lambda c, ctx: c.get(\"/health\"),\n        ),\n        Step(\n            name=\"create_item\",\n            action=lambda c, ctx: c.post(\"/items\", json={\"name\": \"test\"}),\n        ),\n    ],\n)\n</code></pre>"},{"location":"concepts/journeys/#context-and-state-sharing","title":"Context and State Sharing","text":""},{"location":"concepts/journeys/#storing-values","title":"Storing Values","text":"<p>Use the context to pass data between steps:</p> Python<pre><code>def login(client, context):\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n    data = response.json()\n\n    # Store values for later steps\n    context[\"token\"] = data[\"token\"]\n    context[\"user_id\"] = data[\"user\"][\"id\"]\n\n    # Set auth token for subsequent requests\n    client.set_auth_token(data[\"token\"])\n\n    return response\n\ndef get_orders(client, context):\n    # Access stored values\n    user_id = context[\"user_id\"]\n    return client.get(f\"/api/users/{user_id}/orders\")\n</code></pre>"},{"location":"concepts/journeys/#context-methods","title":"Context Methods","text":"Python<pre><code># Store a value\ncontext[\"key\"] = value\ncontext.set(\"key\", value)\n\n# Get a value (returns None if not found)\nvalue = context.get(\"key\")\nvalue = context.get(\"key\", default=\"fallback\")\n\n# Get required value (raises KeyError if missing)\nvalue = context.get_required(\"key\")\n\n# Check if key exists\nif \"key\" in context:\n    # ...\n\n# Store step result explicitly\ncontext.store_step_result(\"login\", response.json())\n\n# Get previous step result\nlogin_data = context.get_step_result(\"login\")\n\n# Create snapshot for restoration\nsnapshot = context.snapshot()\ncontext.restore(snapshot)\n</code></pre>"},{"location":"concepts/journeys/#expected-failures","title":"Expected Failures","text":"<p>Use <code>expect_failure=True</code> when testing that your API correctly rejects invalid requests:</p> Python<pre><code># Test unauthorized access\nStep(\n    name=\"access_admin_without_auth\",\n    action=lambda c, ctx: c.get(\"/api/admin/users\"),\n    expect_failure=True,\n)\n\n# Test invalid input\nStep(\n    name=\"create_invalid_user\",\n    action=lambda c, ctx: c.post(\"/api/users\", json={\"email\": \"invalid\"}),\n    expect_failure=True,\n)\n\n# Test rate limiting\nStep(\n    name=\"exceed_rate_limit\",\n    action=spam_requests,\n    expect_failure=True,\n)\n</code></pre> <p>When <code>expect_failure=True</code>:</p> <ul> <li>Step passes if the action fails (HTTP 4xx/5xx, exception)</li> <li>Step fails if the action succeeds</li> </ul>"},{"location":"concepts/journeys/#reusable-actions","title":"Reusable Actions","text":""},{"location":"concepts/journeys/#creating-action-modules","title":"Creating Action Modules","text":"<p>Organize actions in separate files for reuse:</p> Python<pre><code># actions/auth.py\ndef login(client, context, email=\"test@example.com\", password=\"secret\"):\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": email,\n        \"password\": password,\n    })\n    if response.status_code == 200:\n        context[\"token\"] = response.json()[\"token\"]\n        client.set_auth_token(context[\"token\"])\n    return response\n\ndef logout(client, context):\n    return client.post(\"/api/auth/logout\")\n</code></pre> Python<pre><code># actions/items.py\ndef create_item(client, context, name=None, price=None):\n    response = client.post(\"/api/items\", json={\n        \"name\": name or context.get(\"item_name\", \"Default Item\"),\n        \"price\": price or context.get(\"item_price\", 0.0),\n    })\n    if response.status_code in [200, 201]:\n        context[\"item_id\"] = response.json()[\"id\"]\n    return response\n\ndef get_item(client, context, item_id=None):\n    item_id = item_id or context.get(\"item_id\")\n    return client.get(f\"/api/items/{item_id}\")\n</code></pre>"},{"location":"concepts/journeys/#using-actions-in-journeys","title":"Using Actions in Journeys","text":"Python<pre><code># journeys/item_crud.py\nfrom venomqa import Journey, Step, Checkpoint\nfrom actions.auth import login\nfrom actions.items import create_item, get_item, delete_item\n\njourney = Journey(\n    name=\"item_crud\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"create\", action=create_item),\n        Checkpoint(name=\"item_created\"),\n        Step(name=\"read\", action=get_item),\n        Step(name=\"delete\", action=delete_item),\n    ],\n)\n</code></pre>"},{"location":"concepts/journeys/#best-practices","title":"Best Practices","text":""},{"location":"concepts/journeys/#1-name-steps-clearly","title":"1. Name Steps Clearly","text":"Python<pre><code># Good\nStep(name=\"create_order\", action=create_order)\nStep(name=\"process_payment\", action=process_payment)\nStep(name=\"send_confirmation_email\", action=send_email)\n\n# Bad\nStep(name=\"step1\", action=create_order)\nStep(name=\"do_it\", action=process_payment)\n</code></pre>"},{"location":"concepts/journeys/#2-use-descriptive-journey-names","title":"2. Use Descriptive Journey Names","text":"Python<pre><code># Good\nJourney(name=\"user_registration_email_verification\")\nJourney(name=\"checkout_with_credit_card\")\n\n# Bad\nJourney(name=\"test1\")\nJourney(name=\"my_journey\")\n</code></pre>"},{"location":"concepts/journeys/#3-add-tags-for-organization","title":"3. Add Tags for Organization","text":"Python<pre><code>Journey(\n    name=\"payment_processing\",\n    tags=[\"critical\", \"payment\", \"integration\"],\n    steps=[...],\n)\n</code></pre>"},{"location":"concepts/journeys/#4-keep-actions-focused","title":"4. Keep Actions Focused","text":"Python<pre><code># Good - single responsibility\ndef create_order(client, context):\n    return client.post(\"/api/orders\", json={\"item_id\": context[\"item_id\"]})\n\ndef add_shipping(client, context):\n    return client.post(f\"/api/orders/{context['order_id']}/shipping\", json={...})\n\n# Bad - doing too much\ndef create_order_with_shipping(client, context):\n    order = client.post(\"/api/orders\", json={...})\n    shipping = client.post(f\"/api/orders/{order.json()['id']}/shipping\", json={...})\n    return shipping\n</code></pre>"},{"location":"concepts/journeys/#5-set-timeouts-appropriately","title":"5. Set Timeouts Appropriately","text":"Python<pre><code># Quick operations\nStep(name=\"health_check\", action=health_check, timeout=5.0)\n\n# Normal operations\nStep(name=\"create_order\", action=create_order, timeout=30.0)\n\n# Long-running operations\nStep(name=\"generate_report\", action=generate_report, timeout=120.0)\n</code></pre>"},{"location":"concepts/journeys/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/journeys/#crud-operations","title":"CRUD Operations","text":"Python<pre><code>journey = Journey(\n    name=\"user_crud\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"create_user\", action=create_user),\n        Checkpoint(name=\"user_created\"),\n        Step(name=\"read_user\", action=read_user),\n        Step(name=\"update_user\", action=update_user),\n        Step(name=\"delete_user\", action=delete_user),\n    ],\n)\n</code></pre>"},{"location":"concepts/journeys/#authentication-flow","title":"Authentication Flow","text":"Python<pre><code>journey = Journey(\n    name=\"auth_flow\",\n    steps=[\n        Step(name=\"register\", action=register),\n        Step(name=\"login\", action=login),\n        Step(name=\"access_protected\", action=access_protected),\n        Step(name=\"refresh_token\", action=refresh_token),\n        Step(name=\"logout\", action=logout),\n    ],\n)\n</code></pre>"},{"location":"concepts/journeys/#multi-user-interaction","title":"Multi-User Interaction","text":"Python<pre><code>def login_as_buyer(client, context):\n    return login(client, context, email=\"buyer@example.com\")\n\ndef login_as_seller(client, context):\n    return login(client, context, email=\"seller@example.com\")\n\njourney = Journey(\n    name=\"marketplace_transaction\",\n    steps=[\n        Step(name=\"seller_lists_item\", action=login_as_seller),\n        Step(name=\"create_listing\", action=create_listing),\n        Checkpoint(name=\"item_listed\"),\n        Step(name=\"buyer_browses\", action=login_as_buyer),\n        Step(name=\"add_to_cart\", action=add_to_cart),\n        Step(name=\"checkout\", action=checkout),\n    ],\n)\n</code></pre>"},{"location":"concepts/journeys/#next-steps","title":"Next Steps","text":"<ul> <li>Checkpoints &amp; Branching - Learn about state management and path exploration</li> <li>State Management - Understand how checkpoints work</li> <li>Tutorials - Step-by-step guides for specific scenarios</li> </ul>"},{"location":"concepts/ports-adapters/","title":"Ports &amp; Adapters","text":"<p>VenomQA uses the Ports and Adapters (Hexagonal) architecture pattern for clean separation between test logic and external dependencies.</p>"},{"location":"concepts/ports-adapters/#overview","title":"Overview","text":"<p>The architecture has two key components:</p> <ul> <li>Ports: Abstract interfaces defining what operations your tests need</li> <li>Adapters: Concrete implementations for real services</li> </ul> <pre><code>graph LR\n    subgraph \"Test Logic\"\n        T[Tests]\n    end\n\n    subgraph \"Ports (Interfaces)\"\n        CP[CachePort]\n        MP[MailPort]\n        QP[QueuePort]\n    end\n\n    subgraph \"Adapters (Implementations)\"\n        RA[RedisCacheAdapter]\n        MA[MailhogAdapter]\n        QA[RedisQueueAdapter]\n    end\n\n    T --&gt; CP\n    T --&gt; MP\n    T --&gt; QP\n\n    CP --&gt; RA\n    MP --&gt; MA\n    QP --&gt; QA</code></pre>"},{"location":"concepts/ports-adapters/#why-ports-adapters","title":"Why Ports &amp; Adapters?","text":""},{"location":"concepts/ports-adapters/#benefits","title":"Benefits","text":"<ol> <li>Testability: Swap real services for mocks in unit tests</li> <li>Flexibility: Change infrastructure without modifying test code</li> <li>Clarity: Clear contracts between test logic and external systems</li> <li>Portability: Same tests work across different environments</li> </ol>"},{"location":"concepts/ports-adapters/#example","title":"Example","text":"Python<pre><code># Your test logic uses the abstract port\nfrom venomqa.ports import CachePort\n\ndef test_user_caching(cache: CachePort):\n    cache.set(\"user:1\", {\"name\": \"John\"})\n    user = cache.get(\"user:1\")\n    assert user[\"name\"] == \"John\"\n\n# In production tests, use Redis\nfrom venomqa.adapters import RedisCacheAdapter\ncache = RedisCacheAdapter(host=\"redis.prod.internal\")\ntest_user_caching(cache)\n\n# In unit tests, use a mock\nfrom unittest.mock import Mock\ncache = Mock(spec=CachePort)\ncache.get.return_value = {\"name\": \"John\"}\ntest_user_caching(cache)\n</code></pre>"},{"location":"concepts/ports-adapters/#available-ports","title":"Available Ports","text":"<p>VenomQA provides ports for common external dependencies:</p> Port Purpose <code>CachePort</code> Key-value caching (Redis, Memcached) <code>MailPort</code> Email sending and verification <code>QueuePort</code> Job/task queues (Celery, RQ) <code>SearchPort</code> Full-text search (Elasticsearch) <code>StoragePort</code> File/blob storage (S3, local) <code>TimePort</code> Time control for testing <code>MockPort</code> HTTP mocking (WireMock) <code>WebSocketPort</code> WebSocket connections <code>DatabasePort</code> Database operations <code>NotificationPort</code> Push notifications, SMS"},{"location":"concepts/ports-adapters/#available-adapters","title":"Available Adapters","text":"Category Adapters Email <code>MailhogAdapter</code>, <code>MailpitAdapter</code>, <code>SMTPMockAdapter</code> Cache <code>RedisCacheAdapter</code> Queue <code>RedisQueueAdapter</code>, <code>CeleryQueueAdapter</code> Search <code>ElasticsearchAdapter</code> Storage <code>S3StorageAdapter</code>, <code>LocalStorageAdapter</code> Mock <code>WireMockAdapter</code> Time <code>ControllableTimeAdapter</code>, <code>RealTimeAdapter</code> Concurrency <code>ThreadingConcurrencyAdapter</code>, <code>AsyncConcurrencyAdapter</code>"},{"location":"concepts/ports-adapters/#using-ports-in-tests","title":"Using Ports in Tests","text":""},{"location":"concepts/ports-adapters/#email-testing","title":"Email Testing","text":"Python<pre><code>from venomqa.ports import MailPort\nfrom venomqa.adapters import MailhogAdapter\n\ndef test_password_reset_email(mail: MailPort):\n    # Trigger password reset\n    client.post(\"/api/auth/forgot-password\", json={\n        \"email\": \"user@example.com\"\n    })\n\n    # Wait for email to arrive\n    email = mail.wait_for_email(\n        to=\"user@example.com\",\n        subject=\"Password Reset\",\n        timeout=30.0,\n    )\n\n    assert email is not None\n    assert \"reset\" in email.body.lower()\n\n# Create adapter and run test\nmail = MailhogAdapter(host=\"localhost\", port=8025)\ntest_password_reset_email(mail)\n</code></pre>"},{"location":"concepts/ports-adapters/#cache-testing","title":"Cache Testing","text":"Python<pre><code>from venomqa.ports import CachePort\nfrom venomqa.adapters import RedisCacheAdapter\n\ndef test_session_caching(cache: CachePort):\n    # Set session with TTL\n    cache.set(\"session:abc123\", {\"user_id\": 1}, ttl=3600)\n\n    # Verify it exists\n    assert cache.exists(\"session:abc123\")\n\n    # Get the value\n    session = cache.get(\"session:abc123\")\n    assert session[\"user_id\"] == 1\n\n    # Check TTL\n    ttl = cache.get_ttl(\"session:abc123\")\n    assert 0 &lt; ttl &lt;= 3600\n\ncache = RedisCacheAdapter(host=\"localhost\", port=6379)\ntest_session_caching(cache)\n</code></pre>"},{"location":"concepts/ports-adapters/#queue-testing","title":"Queue Testing","text":"Python<pre><code>from venomqa.ports import QueuePort\nfrom venomqa.adapters import RedisQueueAdapter\n\ndef test_job_processing(queue: QueuePort):\n    # Clear the queue\n    queue.clear_queue(\"notifications\")\n\n    # Enqueue a job\n    job_id = queue.enqueue(\n        \"myapp.tasks.send_notification\",\n        user_id=123,\n        message=\"Hello!\",\n        queue=\"notifications\",\n    )\n\n    # Check job was queued\n    job = queue.get_job(job_id)\n    assert job.status in [\"pending\", \"queued\"]\n\n    # Wait for completion (requires worker)\n    result = queue.get_job_result(job_id, timeout=60.0)\n    assert result.success\n\nqueue = RedisQueueAdapter(host=\"localhost\")\ntest_job_processing(queue)\n</code></pre>"},{"location":"concepts/ports-adapters/#time-control","title":"Time Control","text":"Python<pre><code>from datetime import timedelta\nfrom venomqa.adapters import ControllableTimeAdapter\n\ndef test_token_expiration():\n    time = ControllableTimeAdapter()\n    time.freeze()\n\n    # Create token that expires in 1 hour\n    token = create_token(expires_in=3600)\n    assert token.is_valid()\n\n    # Fast forward 59 minutes - still valid\n    time.advance(timedelta(minutes=59))\n    assert token.is_valid()\n\n    # Fast forward 1 more minute - expired\n    time.advance(timedelta(minutes=1))\n    assert not token.is_valid()\n</code></pre>"},{"location":"concepts/ports-adapters/#mock-server","title":"Mock Server","text":"Python<pre><code>from venomqa.adapters import WireMockAdapter\nfrom venomqa import Client\n\ndef test_with_mock_api():\n    mock = WireMockAdapter(port=8080)\n\n    # Stub an endpoint\n    mock.stub(\n        \"GET\",\n        \"/api/external/users/1\",\n        body={\"id\": 1, \"name\": \"John Doe\"},\n        status_code=200,\n    )\n\n    # Use mocked API\n    client = Client(base_url=mock.get_base_url())\n    response = client.get(\"/api/external/users/1\")\n\n    assert response.status_code == 200\n    assert response.json()[\"name\"] == \"John Doe\"\n\n    # Verify request was made\n    assert mock.verify(\"GET\", \"/api/external/users/1\", count=1)\n\n    mock.reset()\n</code></pre>"},{"location":"concepts/ports-adapters/#dependency-injection","title":"Dependency Injection","text":""},{"location":"concepts/ports-adapters/#using-pytest-fixtures","title":"Using pytest Fixtures","text":"Python<pre><code>import pytest\nfrom venomqa.ports import CachePort, MailPort\nfrom venomqa.adapters import RedisCacheAdapter, MailhogAdapter\n\n@pytest.fixture\ndef cache() -&gt; CachePort:\n    adapter = RedisCacheAdapter(host=\"localhost\")\n    yield adapter\n    adapter.clear()\n\n@pytest.fixture\ndef mail() -&gt; MailPort:\n    adapter = MailhogAdapter(host=\"localhost\")\n    adapter.delete_all_emails()  # Clean start\n    yield adapter\n    adapter.delete_all_emails()  # Clean up\n\ndef test_user_registration(cache: CachePort, mail: MailPort):\n    # Test using injected adapters\n    pass\n</code></pre>"},{"location":"concepts/ports-adapters/#using-in-journeys","title":"Using in Journeys","text":"Python<pre><code>from venomqa import Journey, Step\nfrom venomqa.adapters import MailhogAdapter\n\nmail = MailhogAdapter(host=\"localhost\")\n\ndef verify_welcome_email(client, context):\n    email = mail.wait_for_email(\n        to=context[\"user_email\"],\n        subject=\"Welcome\",\n        timeout=30.0,\n    )\n    if email is None:\n        raise AssertionError(\"Welcome email not received\")\n    return {\"email_received\": True}\n\njourney = Journey(\n    name=\"registration_flow\",\n    steps=[\n        Step(name=\"register\", action=register_user),\n        Step(name=\"verify_email\", action=verify_welcome_email),\n    ],\n)\n</code></pre>"},{"location":"concepts/ports-adapters/#creating-custom-adapters","title":"Creating Custom Adapters","text":"<p>Implement a port interface to create custom adapters:</p> Python<pre><code>from venomqa.ports import CachePort, CacheEntry\nfrom typing import Any\n\nclass MemoryCacheAdapter(CachePort):\n    \"\"\"In-memory cache for testing.\"\"\"\n\n    def __init__(self):\n        self._data: dict[str, CacheEntry] = {}\n\n    def get(self, key: str) -&gt; Any | None:\n        entry = self._data.get(key)\n        if entry is None:\n            return None\n        if entry.is_expired():\n            del self._data[key]\n            return None\n        return entry.value\n\n    def set(self, key: str, value: Any, ttl: int | None = None) -&gt; bool:\n        self._data[key] = CacheEntry(\n            key=key,\n            value=value,\n            ttl=ttl,\n        )\n        return True\n\n    def delete(self, key: str) -&gt; bool:\n        if key in self._data:\n            del self._data[key]\n            return True\n        return False\n\n    def exists(self, key: str) -&gt; bool:\n        return self.get(key) is not None\n\n    def clear(self) -&gt; bool:\n        self._data.clear()\n        return True\n\n    # ... implement other required methods\n</code></pre>"},{"location":"concepts/ports-adapters/#adapter-registration","title":"Adapter Registration","text":"<p>Register custom adapters for discovery:</p> Python<pre><code>from venomqa.adapters import register_adapter\n\n@register_adapter(\"memory_cache\")\nclass MemoryCacheAdapter(CachePort):\n    pass\n\n# Or register directly\nfrom venomqa.adapters import register_adapter_class\nregister_adapter_class(\"memory_cache\", MemoryCacheAdapter)\n\n# Retrieve registered adapters\nfrom venomqa.adapters import get_adapter, list_adapters\n\nadapter_class = get_adapter(\"memory_cache\")\nall_adapters = list_adapters()\n</code></pre>"},{"location":"concepts/ports-adapters/#environment-based-adapters","title":"Environment-Based Adapters","text":"<p>Switch adapters based on environment:</p> Python<pre><code>import os\nfrom venomqa.ports import CachePort\nfrom venomqa.adapters import RedisCacheAdapter\n\ndef get_cache_adapter() -&gt; CachePort:\n    env = os.environ.get(\"ENV\", \"local\")\n\n    if env == \"production\":\n        return RedisCacheAdapter(\n            host=\"redis.prod.internal\",\n            password=os.environ[\"REDIS_PASSWORD\"],\n        )\n    elif env == \"staging\":\n        return RedisCacheAdapter(host=\"redis.staging.internal\")\n    else:\n        return RedisCacheAdapter(host=\"localhost\")\n</code></pre>"},{"location":"concepts/ports-adapters/#best-practices","title":"Best Practices","text":""},{"location":"concepts/ports-adapters/#1-program-to-interfaces","title":"1. Program to Interfaces","text":"Python<pre><code># Good - depends on abstract port\ndef test_feature(cache: CachePort):\n    cache.set(\"key\", \"value\")\n\n# Bad - depends on concrete implementation\ndef test_feature(cache: RedisCacheAdapter):\n    cache.set(\"key\", \"value\")\n</code></pre>"},{"location":"concepts/ports-adapters/#2-clean-up-after-tests","title":"2. Clean Up After Tests","text":"Python<pre><code>@pytest.fixture\ndef mail():\n    adapter = MailhogAdapter()\n    adapter.delete_all_emails()  # Before\n    yield adapter\n    adapter.delete_all_emails()  # After\n</code></pre>"},{"location":"concepts/ports-adapters/#3-use-type-hints","title":"3. Use Type Hints","text":"Python<pre><code>from venomqa.ports import CachePort, MailPort\n\ndef test_feature(\n    cache: CachePort,\n    mail: MailPort,\n) -&gt; None:\n    # Type checker knows the interface\n    pass\n</code></pre>"},{"location":"concepts/ports-adapters/#4-health-check-services","title":"4. Health Check Services","text":"Python<pre><code>@pytest.fixture(scope=\"session\", autouse=True)\ndef verify_services():\n    services = [\n        (\"Redis\", RedisCacheAdapter()),\n        (\"MailHog\", MailhogAdapter()),\n    ]\n\n    unhealthy = []\n    for name, adapter in services:\n        if not adapter.health_check():\n            unhealthy.append(name)\n\n    if unhealthy:\n        pytest.skip(f\"Services not available: {', '.join(unhealthy)}\")\n</code></pre>"},{"location":"concepts/ports-adapters/#next-steps","title":"Next Steps","text":"<ul> <li>Adapters Reference - All available adapters</li> <li>Custom Backends - Implement custom adapters</li> <li>API Reference - Complete port interfaces</li> </ul>"},{"location":"concepts/state/","title":"State Management","text":"<p>State management is what makes VenomQA unique. It enables checkpointing and rollback for testing multiple scenarios from the same database state.</p>"},{"location":"concepts/state/#overview","title":"Overview","text":"<p>VenomQA manages two types of state:</p> <ol> <li>Execution Context: In-memory variables shared between steps</li> <li>Database State: Actual database records (requires a state backend)</li> </ol>"},{"location":"concepts/state/#execution-context","title":"Execution Context","text":"<p>The execution context is an in-memory dictionary that persists across steps:</p> Python<pre><code>def step_one(client, context):\n    # Store data\n    context[\"user_id\"] = 123\n    context[\"token\"] = \"abc123\"\n    return response\n\ndef step_two(client, context):\n    # Access data from previous step\n    user_id = context[\"user_id\"]\n    return client.get(f\"/api/users/{user_id}\")\n</code></pre>"},{"location":"concepts/state/#context-api","title":"Context API","text":"Python<pre><code># Store values\ncontext[\"key\"] = value\ncontext.set(\"key\", value)\n\n# Retrieve values\nvalue = context.get(\"key\")                    # Returns None if missing\nvalue = context.get(\"key\", default=\"fallback\")  # Custom default\nvalue = context.get_required(\"key\")           # Raises KeyError if missing\n\n# Check existence\nif \"key\" in context:\n    pass\n\n# Store/retrieve step results\ncontext.store_step_result(\"step_name\", result)\nresult = context.get_step_result(\"step_name\")\n\n# Snapshot/restore\nsnapshot = context.snapshot()\ncontext.restore(snapshot)\n\n# Export\ndata = context.to_dict()\n</code></pre>"},{"location":"concepts/state/#database-state","title":"Database State","text":"<p>For database state management, VenomQA uses the State Manager pattern.</p>"},{"location":"concepts/state/#how-it-works","title":"How It Works","text":"<pre><code>sequenceDiagram\n    participant Journey\n    participant StateManager\n    participant Database\n\n    Journey-&gt;&gt;StateManager: checkpoint(\"order_created\")\n    StateManager-&gt;&gt;Database: SAVEPOINT order_created\n    Database--&gt;&gt;StateManager: OK\n\n    Journey-&gt;&gt;Journey: Execute path steps\n\n    Journey-&gt;&gt;StateManager: rollback(\"order_created\")\n    StateManager-&gt;&gt;Database: ROLLBACK TO SAVEPOINT order_created\n    Database--&gt;&gt;StateManager: OK</code></pre>"},{"location":"concepts/state/#statemanager-protocol","title":"StateManager Protocol","text":"<p>All state backends implement this protocol:</p> Python<pre><code>from typing import Protocol\n\nclass StateManager(Protocol):\n    def connect(self) -&gt; None:\n        \"\"\"Establish connection to the database.\"\"\"\n        ...\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Close connection to the database.\"\"\"\n        ...\n\n    def checkpoint(self, name: str) -&gt; None:\n        \"\"\"Create a savepoint with the given name.\"\"\"\n        ...\n\n    def rollback(self, name: str) -&gt; None:\n        \"\"\"Rollback to a previously created checkpoint.\"\"\"\n        ...\n\n    def release(self, name: str) -&gt; None:\n        \"\"\"Release a checkpoint (free resources).\"\"\"\n        ...\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset database to clean state (truncate tables).\"\"\"\n        ...\n\n    def is_connected(self) -&gt; bool:\n        \"\"\"Check if connection is active.\"\"\"\n        ...\n</code></pre>"},{"location":"concepts/state/#postgresql-backend","title":"PostgreSQL Backend","text":"<p>PostgreSQL is the recommended backend for state management.</p>"},{"location":"concepts/state/#installation","title":"Installation","text":"Bash<pre><code>pip install \"venomqa[postgres]\"\n</code></pre>"},{"location":"concepts/state/#configuration","title":"Configuration","text":"YAML<pre><code># venomqa.yaml\ndb_url: \"postgresql://qa:secret@localhost:5432/qa_test\"\ndb_backend: \"postgresql\"\n</code></pre>"},{"location":"concepts/state/#usage","title":"Usage","text":"Python<pre><code>from venomqa import JourneyRunner, Client\nfrom venomqa.state import PostgreSQLStateManager\n\n# Create state manager\nstate_manager = PostgreSQLStateManager(\n    connection_url=\"postgresql://qa:secret@localhost:5432/qa_test\",\n    tables_to_reset=[\"users\", \"orders\", \"items\"],  # Tables to truncate on reset\n    exclude_tables=[\"migrations\"],                  # Never truncate these\n)\n\n# Create runner with state manager\nrunner = JourneyRunner(\n    client=Client(base_url=\"http://localhost:8000\"),\n    state_manager=state_manager,\n)\n\n# Run journey - checkpoints handled automatically\nresult = runner.run(journey)\n</code></pre>"},{"location":"concepts/state/#how-postgresql-checkpoints-work","title":"How PostgreSQL Checkpoints Work","text":"<p>VenomQA uses SQL <code>SAVEPOINT</code> for checkpoints:</p> SQL<pre><code>-- Creating a checkpoint\nSAVEPOINT chk_order_created;\n\n-- Rolling back to checkpoint\nROLLBACK TO SAVEPOINT chk_order_created;\n\n-- Releasing checkpoint (optional cleanup)\nRELEASE SAVEPOINT chk_order_created;\n</code></pre> <p>This is why:</p> <ul> <li>Checkpoints are lightweight (just markers in the transaction log)</li> <li>Rollback is instant (no data copying)</li> <li>Multiple nested checkpoints are supported</li> </ul>"},{"location":"concepts/state/#table-reset-options","title":"Table Reset Options","text":"<p>Control which tables are affected:</p> Python<pre><code># Only reset specific tables\nstate_manager = PostgreSQLStateManager(\n    connection_url=\"...\",\n    tables_to_reset=[\"users\", \"orders\", \"items\"],\n)\n\n# Reset all tables except some\nstate_manager = PostgreSQLStateManager(\n    connection_url=\"...\",\n    exclude_tables=[\"migrations\", \"audit_log\", \"schema_versions\"],\n)\n\n# Reset all public schema tables (default)\nstate_manager = PostgreSQLStateManager(connection_url=\"...\")\n</code></pre>"},{"location":"concepts/state/#context-vs-database-state","title":"Context vs Database State","text":"<p>Understanding the difference is crucial:</p> Aspect Context State Database State Storage In-memory Database Persistence Per journey run Persists until rollback Checkpoint Always saved Requires StateManager Rollback Always restored Requires StateManager Performance Instant Transaction overhead"},{"location":"concepts/state/#example","title":"Example","text":"Python<pre><code>def create_user(client, context):\n    # Database state: new row in users table\n    response = client.post(\"/api/users\", json={\"name\": \"John\"})\n\n    # Context state: in-memory reference\n    context[\"user_id\"] = response.json()[\"id\"]\n\n    return response\n\n# At checkpoint:\n# - Context: {\"user_id\": 123} is snapshotted\n# - Database: SAVEPOINT marks the transaction\n\n# After rollback:\n# - Context: {\"user_id\": 123} is restored\n# - Database: User row is removed (ROLLBACK TO SAVEPOINT)\n</code></pre>"},{"location":"concepts/state/#running-without-state-backend","title":"Running Without State Backend","text":"<p>VenomQA works without a database backend, but with limitations:</p> Python<pre><code># No state manager - context only\nrunner = JourneyRunner(\n    client=Client(base_url=\"http://localhost:8000\"),\n    # state_manager=None (default)\n)\n</code></pre> <p>What works:</p> <ul> <li>Context checkpointing and restoration</li> <li>Branch execution (context is isolated)</li> <li>All step execution features</li> </ul> <p>What doesn't work:</p> <ul> <li>Database rollback (changes persist)</li> <li>True state isolation between paths</li> <li>Deterministic test data</li> </ul>"},{"location":"concepts/state/#best-practices","title":"Best Practices","text":""},{"location":"concepts/state/#1-use-separate-test-database","title":"1. Use Separate Test Database","text":"<p>Never test against production or development databases:</p> YAML<pre><code># Good - dedicated test database\ndb_url: \"postgresql://qa:secret@localhost:5432/qa_test\"\n\n# Bad - development database\ndb_url: \"postgresql://dev:dev@localhost:5432/dev_db\"\n</code></pre>"},{"location":"concepts/state/#2-reset-state-between-journey-runs","title":"2. Reset State Between Journey Runs","text":"<p>Start each journey with a clean state:</p> Python<pre><code># In your test setup\nstate_manager.reset()  # Truncate tables\nstate_manager.checkpoint(\"clean_state\")\n</code></pre>"},{"location":"concepts/state/#3-use-fast-storage-for-tests","title":"3. Use Fast Storage for Tests","text":"<p>Use tmpfs for faster database operations:</p> YAML<pre><code># docker-compose.qa.yml\nservices:\n  db:\n    image: postgres:15\n    tmpfs:\n      - /var/lib/postgresql/data  # RAM-based storage\n</code></pre>"},{"location":"concepts/state/#4-exclude-migration-tables","title":"4. Exclude Migration Tables","text":"<p>Never truncate schema migration tables:</p> Python<pre><code>state_manager = PostgreSQLStateManager(\n    connection_url=\"...\",\n    exclude_tables=[\n        \"alembic_version\",      # Alembic\n        \"django_migrations\",    # Django\n        \"schema_migrations\",    # Rails/custom\n        \"_prisma_migrations\",   # Prisma\n    ],\n)\n</code></pre>"},{"location":"concepts/state/#5-handle-connection-pooling","title":"5. Handle Connection Pooling","text":"<p>For parallel execution, consider connection limits:</p> Python<pre><code># PostgreSQL connection string with pool settings\ndb_url = \"postgresql://qa:secret@localhost:5432/qa_test?pool_size=10\"\n</code></pre>"},{"location":"concepts/state/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/state/#connection-refused","title":"Connection Refused","text":"Text Only<pre><code>Error: Connection refused to postgresql://localhost:5432\n</code></pre> <p>Solutions:</p> <ol> <li>Ensure PostgreSQL is running</li> <li>Check port is correct</li> <li>Verify credentials</li> </ol> Bash<pre><code># Test connection\npsql \"postgresql://qa:secret@localhost:5432/qa_test\" -c \"SELECT 1\"\n</code></pre>"},{"location":"concepts/state/#checkpoint-not-found","title":"Checkpoint Not Found","text":"Text Only<pre><code>ValueError: Checkpoint 'order_created' not found\n</code></pre> <p>Causes:</p> <ol> <li>Checkpoint never created</li> <li>Typo in checkpoint name</li> <li>Connection was reset</li> </ol> <p>Solution: Ensure checkpoint is created before branch:</p> Python<pre><code>Checkpoint(name=\"order_created\"),  # Create first\nBranch(checkpoint_name=\"order_created\", ...)  # Then reference\n</code></pre>"},{"location":"concepts/state/#transaction-issues","title":"Transaction Issues","text":"Text Only<pre><code>Error: SAVEPOINT can only be used in transaction blocks\n</code></pre> <p>Solution: Ensure autocommit is disabled:</p> Python<pre><code># This is handled automatically by PostgreSQLStateManager\n# but if using custom backend, ensure:\nconnection.autocommit = False\n</code></pre>"},{"location":"concepts/state/#slow-reset-operations","title":"Slow Reset Operations","text":"<p>If <code>reset()</code> is slow:</p> Python<pre><code># Specify only needed tables\nstate_manager = PostgreSQLStateManager(\n    connection_url=\"...\",\n    tables_to_reset=[\"users\", \"orders\", \"items\"],  # Only these\n)\n</code></pre>"},{"location":"concepts/state/#custom-state-backends","title":"Custom State Backends","text":"<p>Implement the StateManager protocol for custom backends:</p> Python<pre><code>from venomqa.state.base import BaseStateManager\n\nclass MyCustomStateManager(BaseStateManager):\n    def connect(self) -&gt; None:\n        self._conn = my_database.connect()\n        self._connected = True\n\n    def disconnect(self) -&gt; None:\n        self._conn.close()\n        self._connected = False\n\n    def checkpoint(self, name: str) -&gt; None:\n        self._ensure_connected()\n        self._conn.execute(f\"SAVEPOINT {name}\")\n        self._checkpoints.append(name)\n\n    def rollback(self, name: str) -&gt; None:\n        self._ensure_connected()\n        self._conn.execute(f\"ROLLBACK TO SAVEPOINT {name}\")\n\n    def release(self, name: str) -&gt; None:\n        self._ensure_connected()\n        self._conn.execute(f\"RELEASE SAVEPOINT {name}\")\n        self._checkpoints.remove(name)\n\n    def reset(self) -&gt; None:\n        self._ensure_connected()\n        for table in self.tables_to_reset:\n            self._conn.execute(f\"TRUNCATE TABLE {table} CASCADE\")\n        self._conn.commit()\n</code></pre> <p>See Custom Backends for detailed implementation guides.</p>"},{"location":"concepts/state/#next-steps","title":"Next Steps","text":"<ul> <li>Database Backends - Configure different backends</li> <li>Custom Backends - Implement your own</li> <li>Checkpoints &amp; Branching - Use state management in journeys</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Real-world examples of VenomQA usage patterns.</p>"},{"location":"examples/#quick-links","title":"Quick Links","text":""},{"location":"examples/#crud-operations","title":"CRUD Operations","text":"<p>Test create, read, update, delete operations with proper validation.</p>"},{"location":"examples/#authentication-flows","title":"Authentication Flows","text":"<p>Login, registration, password reset, and token refresh patterns.</p>"},{"location":"examples/#e-commerce-checkout","title":"E-commerce Checkout","text":"<p>Complete checkout flow with multiple payment methods.</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":"Category Description CRUD Operations Basic CRUD with validation Authentication Auth flows and security testing E-commerce Shopping cart and checkout"},{"location":"examples/#minimal-example","title":"Minimal Example","text":"<p>The simplest possible journey:</p> Python<pre><code>from venomqa import Journey, Step\n\njourney = Journey(\n    name=\"health_check\",\n    steps=[\n        Step(\n            name=\"check_api\",\n            action=lambda c, ctx: c.get(\"/health\"),\n        ),\n    ],\n)\n</code></pre> <p>Run it:</p> Bash<pre><code>venomqa run health_check\n</code></pre>"},{"location":"examples/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/#context-sharing","title":"Context Sharing","text":"Python<pre><code>def create_user(client, context):\n    response = client.post(\"/api/users\", json={\"name\": \"John\"})\n    context[\"user_id\"] = response.json()[\"id\"]\n    return response\n\ndef get_user(client, context):\n    return client.get(f\"/api/users/{context['user_id']}\")\n\njourney = Journey(\n    name=\"user_flow\",\n    steps=[\n        Step(name=\"create\", action=create_user),\n        Step(name=\"retrieve\", action=get_user),\n    ],\n)\n</code></pre>"},{"location":"examples/#authentication","title":"Authentication","text":"Python<pre><code>def login(client, context):\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n    return response\n\ndef protected_action(client, context):\n    return client.get(\"/api/protected\")\n\njourney = Journey(\n    name=\"auth_flow\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"access\", action=protected_action),\n    ],\n)\n</code></pre>"},{"location":"examples/#error-testing","title":"Error Testing","text":"Python<pre><code>journey = Journey(\n    name=\"error_handling\",\n    steps=[\n        Step(\n            name=\"unauthorized\",\n            action=lambda c, ctx: c.get(\"/api/admin\"),\n            expect_failure=True,\n        ),\n        Step(\n            name=\"not_found\",\n            action=lambda c, ctx: c.get(\"/api/users/999999\"),\n            expect_failure=True,\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#branching","title":"Branching","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\njourney = Journey(\n    name=\"payment_test\",\n    steps=[\n        Step(name=\"setup\", action=setup_order),\n        Checkpoint(name=\"ready_to_pay\"),\n        Branch(\n            checkpoint_name=\"ready_to_pay\",\n            paths=[\n                Path(name=\"card\", steps=[\n                    Step(name=\"pay\", action=pay_with_card),\n                ]),\n                Path(name=\"wallet\", steps=[\n                    Step(name=\"pay\", action=pay_with_wallet),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#project-structure","title":"Project Structure","text":"<p>Recommended project layout:</p> Text Only<pre><code>my-tests/\n\u251c\u2500\u2500 venomqa.yaml              # Configuration\n\u251c\u2500\u2500 docker-compose.qa.yml     # Test infrastructure\n\u251c\u2500\u2500 journeys/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 login.py\n\u2502   \u2502   \u2514\u2500\u2500 registration.py\n\u2502   \u251c\u2500\u2500 checkout/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 payment.py\n\u2502   \u2514\u2500\u2500 admin/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 users.py\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth.py               # Reusable auth actions\n\u2502   \u2514\u2500\u2500 users.py              # Reusable user actions\n\u2514\u2500\u2500 reports/\n    \u2514\u2500\u2500 (generated)\n</code></pre>"},{"location":"examples/#more-examples","title":"More Examples","text":"<p>See the examples directory for complete working examples:</p> <ul> <li><code>quickstart/</code> - Getting started examples</li> <li><code>fastapi-example/</code> - Testing a FastAPI application</li> <li><code>test-server/</code> - Example test server</li> </ul>"},{"location":"examples/auth/","title":"Authentication Flows","text":"<p>Examples of testing authentication and authorization.</p>"},{"location":"examples/auth/#basic-loginlogout","title":"Basic Login/Logout","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef login(client, context):\n    \"\"\"Login with valid credentials.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"token\"] = data[\"token\"]\n        context[\"user_id\"] = data[\"user\"][\"id\"]\n        client.set_auth_token(data[\"token\"])\n\n    return response\n\n\ndef get_profile(client, context):\n    \"\"\"Get authenticated user's profile.\"\"\"\n    return client.get(\"/api/users/me\")\n\n\ndef logout(client, context):\n    \"\"\"Logout and invalidate token.\"\"\"\n    return client.post(\"/api/auth/logout\")\n\n\ndef access_after_logout(client, context):\n    \"\"\"Try to access protected endpoint after logout.\"\"\"\n    return client.get(\"/api/users/me\")\n\n\njourney = Journey(\n    name=\"login_logout\",\n    description=\"Test login and logout flow\",\n    tags=[\"auth\", \"login\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"get_profile\", action=get_profile),\n        Step(name=\"logout\", action=logout),\n        Step(\n            name=\"access_after_logout\",\n            action=access_after_logout,\n            expect_failure=True,\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#user-registration","title":"User Registration","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\nimport uuid\n\n\ndef register_user(client, context):\n    \"\"\"Register a new user.\"\"\"\n    email = f\"test-{uuid.uuid4().hex[:8]}@example.com\"\n    context[\"email\"] = email\n    context[\"password\"] = \"SecurePass123!\"\n\n    response = client.post(\"/api/auth/register\", json={\n        \"email\": email,\n        \"password\": context[\"password\"],\n        \"name\": \"Test User\",\n    })\n\n    if response.status_code in [200, 201]:\n        context[\"user_id\"] = response.json().get(\"user_id\")\n\n    return response\n\n\ndef verify_email(client, context):\n    \"\"\"Verify email (mock token).\"\"\"\n    return client.post(\"/api/auth/verify-email\", json={\n        \"token\": \"mock-verification-token\",\n    })\n\n\ndef login_verified(client, context):\n    \"\"\"Login with verified account.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": context[\"email\"],\n        \"password\": context[\"password\"],\n    })\n\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n\n    return response\n\n\ndef login_unverified(client, context):\n    \"\"\"Try login without verification.\"\"\"\n    return client.post(\"/api/auth/login\", json={\n        \"email\": context[\"email\"],\n        \"password\": context[\"password\"],\n    })\n\n\njourney = Journey(\n    name=\"user_registration\",\n    description=\"Test user registration flow\",\n    tags=[\"auth\", \"registration\"],\n    steps=[\n        Step(name=\"register\", action=register_user),\n        Checkpoint(name=\"registered\"),\n\n        Branch(\n            checkpoint_name=\"registered\",\n            paths=[\n                Path(name=\"verified_login\", steps=[\n                    Step(name=\"verify\", action=verify_email),\n                    Step(name=\"login\", action=login_verified),\n                ]),\n                Path(name=\"unverified_login\", steps=[\n                    Step(\n                        name=\"login\",\n                        action=login_unverified,\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#password-reset","title":"Password Reset","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef request_password_reset(client, context):\n    \"\"\"Request password reset email.\"\"\"\n    return client.post(\"/api/auth/forgot-password\", json={\n        \"email\": \"test@example.com\",\n    })\n\n\ndef reset_password(client, context):\n    \"\"\"Reset password with token.\"\"\"\n    return client.post(\"/api/auth/reset-password\", json={\n        \"token\": \"mock-reset-token\",\n        \"password\": \"NewSecurePass456!\",\n    })\n\n\ndef login_with_new_password(client, context):\n    \"\"\"Login with new password.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"NewSecurePass456!\",\n    })\n\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n\n    return response\n\n\ndef login_with_old_password(client, context):\n    \"\"\"Try login with old password.\"\"\"\n    return client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n\n\njourney = Journey(\n    name=\"password_reset\",\n    description=\"Test password reset flow\",\n    tags=[\"auth\", \"password\"],\n    steps=[\n        Step(name=\"request_reset\", action=request_password_reset),\n        Step(name=\"reset_password\", action=reset_password),\n        Step(name=\"login_new\", action=login_with_new_password),\n        Step(\n            name=\"login_old\",\n            action=login_with_old_password,\n            expect_failure=True,\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#token-refresh","title":"Token Refresh","text":"Python<pre><code>from venomqa import Journey, Step\nimport time\n\n\ndef login_get_tokens(client, context):\n    \"\"\"Login and get access + refresh tokens.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"access_token\"] = data[\"access_token\"]\n        context[\"refresh_token\"] = data[\"refresh_token\"]\n        client.set_auth_token(data[\"access_token\"])\n\n    return response\n\n\ndef access_protected(client, context):\n    \"\"\"Access protected resource.\"\"\"\n    return client.get(\"/api/protected\")\n\n\ndef refresh_token(client, context):\n    \"\"\"Refresh access token.\"\"\"\n    response = client.post(\"/api/auth/refresh\", json={\n        \"refresh_token\": context[\"refresh_token\"],\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"access_token\"] = data[\"access_token\"]\n        client.set_auth_token(data[\"access_token\"])\n\n    return response\n\n\ndef use_old_token(client, context):\n    \"\"\"Try using old access token after refresh.\"\"\"\n    old_token = context.get(\"old_access_token\", context[\"access_token\"])\n    client.set_auth_token(old_token)\n    return client.get(\"/api/protected\")\n\n\njourney = Journey(\n    name=\"token_refresh\",\n    description=\"Test token refresh flow\",\n    tags=[\"auth\", \"tokens\"],\n    steps=[\n        Step(name=\"login\", action=login_get_tokens),\n        Step(name=\"access\", action=access_protected),\n        Step(name=\"refresh\", action=refresh_token),\n        Step(name=\"access_new_token\", action=access_protected),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#authorization-testing","title":"Authorization Testing","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\n\ndef login_as_user(client, context):\n    \"\"\"Login as regular user.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"user@example.com\",\n        \"password\": \"userpass\",\n    })\n\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n        context[\"role\"] = \"user\"\n\n    return response\n\n\ndef login_as_admin(client, context):\n    \"\"\"Login as admin.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"admin@example.com\",\n        \"password\": \"adminpass\",\n    })\n\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n        context[\"role\"] = \"admin\"\n\n    return response\n\n\ndef access_user_endpoint(client, context):\n    \"\"\"Access user-level endpoint.\"\"\"\n    return client.get(\"/api/users/me\")\n\n\ndef access_admin_endpoint(client, context):\n    \"\"\"Access admin-only endpoint.\"\"\"\n    return client.get(\"/api/admin/users\")\n\n\ndef access_superadmin_endpoint(client, context):\n    \"\"\"Access superadmin-only endpoint.\"\"\"\n    return client.get(\"/api/admin/settings\")\n\n\njourney = Journey(\n    name=\"authorization\",\n    description=\"Test role-based authorization\",\n    tags=[\"auth\", \"authorization\", \"rbac\"],\n    steps=[\n        Checkpoint(name=\"start\"),\n\n        Branch(\n            checkpoint_name=\"start\",\n            paths=[\n                Path(name=\"user_permissions\", steps=[\n                    Step(name=\"login\", action=login_as_user),\n                    Step(name=\"user_endpoint\", action=access_user_endpoint),\n                    Step(\n                        name=\"admin_endpoint\",\n                        action=access_admin_endpoint,\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"admin_permissions\", steps=[\n                    Step(name=\"login\", action=login_as_admin),\n                    Step(name=\"user_endpoint\", action=access_user_endpoint),\n                    Step(name=\"admin_endpoint\", action=access_admin_endpoint),\n                    Step(\n                        name=\"superadmin_endpoint\",\n                        action=access_superadmin_endpoint,\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#oauth-flow","title":"OAuth Flow","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef initiate_oauth(client, context):\n    \"\"\"Start OAuth flow.\"\"\"\n    response = client.get(\"/api/auth/oauth/google/authorize\")\n\n    if response.status_code == 200:\n        context[\"oauth_url\"] = response.json()[\"authorize_url\"]\n        context[\"state\"] = response.json()[\"state\"]\n\n    return response\n\n\ndef oauth_callback(client, context):\n    \"\"\"Handle OAuth callback.\"\"\"\n    # Simulate OAuth provider callback\n    response = client.get(\"/api/auth/oauth/google/callback\", params={\n        \"code\": \"mock-oauth-code\",\n        \"state\": context[\"state\"],\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"token\"] = data[\"token\"]\n        client.set_auth_token(data[\"token\"])\n\n    return response\n\n\ndef get_oauth_profile(client, context):\n    \"\"\"Get profile after OAuth login.\"\"\"\n    return client.get(\"/api/users/me\")\n\n\njourney = Journey(\n    name=\"oauth_google\",\n    description=\"Test Google OAuth flow\",\n    tags=[\"auth\", \"oauth\"],\n    steps=[\n        Step(name=\"initiate\", action=initiate_oauth),\n        Step(name=\"callback\", action=oauth_callback),\n        Step(name=\"profile\", action=get_oauth_profile),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#security-testing","title":"Security Testing","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef test_sql_injection(client, context):\n    \"\"\"Test SQL injection prevention.\"\"\"\n    return client.post(\"/api/auth/login\", json={\n        \"email\": \"'; DROP TABLE users; --\",\n        \"password\": \"test\",\n    })\n\n\ndef test_xss_prevention(client, context):\n    \"\"\"Test XSS prevention.\"\"\"\n    return client.post(\"/api/users\", json={\n        \"name\": \"&lt;script&gt;alert('xss')&lt;/script&gt;\",\n    })\n\n\ndef test_rate_limiting(client, context):\n    \"\"\"Test rate limiting (many requests).\"\"\"\n    for i in range(100):\n        response = client.post(\"/api/auth/login\", json={\n            \"email\": \"test@example.com\",\n            \"password\": \"wrong\",\n        })\n        if response.status_code == 429:  # Rate limited\n            return response\n\n    return response\n\n\ndef test_brute_force_protection(client, context):\n    \"\"\"Test brute force protection.\"\"\"\n    for i in range(10):\n        client.post(\"/api/auth/login\", json={\n            \"email\": \"test@example.com\",\n            \"password\": f\"wrongpassword{i}\",\n        })\n\n    # Account should be locked\n    return client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"correctpassword\",\n    })\n\n\njourney = Journey(\n    name=\"security_tests\",\n    description=\"Test security measures\",\n    tags=[\"auth\", \"security\"],\n    steps=[\n        Step(\n            name=\"sql_injection\",\n            action=test_sql_injection,\n            expect_failure=True,\n        ),\n        Step(\n            name=\"xss_prevention\",\n            action=test_xss_prevention,\n            expect_failure=True,\n        ),\n        Step(\n            name=\"rate_limiting\",\n            action=test_rate_limiting,\n            expect_failure=True,\n        ),\n        Step(\n            name=\"brute_force\",\n            action=test_brute_force_protection,\n            expect_failure=True,\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/checkout/","title":"E-commerce Checkout","text":"<p>Complete examples of testing e-commerce checkout flows.</p>"},{"location":"examples/checkout/#complete-checkout-journey","title":"Complete Checkout Journey","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\n\n# ====================\n# Setup Actions\n# ====================\n\ndef login(client, context):\n    \"\"\"Authenticate user.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"shopper@example.com\",\n        \"password\": \"shopperpass\",\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"token\"] = data[\"token\"]\n        context[\"user_id\"] = data[\"user\"][\"id\"]\n        client.set_auth_token(data[\"token\"])\n\n    return response\n\n\ndef browse_products(client, context):\n    \"\"\"Browse available products.\"\"\"\n    response = client.get(\"/api/products\", params={\"category\": \"electronics\"})\n\n    if response.status_code == 200:\n        products = response.json()[\"products\"]\n        if products:\n            context[\"product_id\"] = products[0][\"id\"]\n            context[\"product_price\"] = products[0][\"price\"]\n\n    return response\n\n\ndef add_to_cart(client, context):\n    \"\"\"Add product to cart.\"\"\"\n    response = client.post(\"/api/cart/items\", json={\n        \"product_id\": context[\"product_id\"],\n        \"quantity\": 2,\n    })\n\n    if response.status_code in [200, 201]:\n        data = response.json()\n        context[\"cart_id\"] = data[\"cart_id\"]\n        context[\"cart_total\"] = data[\"total\"]\n\n    return response\n\n\ndef apply_coupon(client, context):\n    \"\"\"Apply discount coupon.\"\"\"\n    response = client.post(f\"/api/cart/{context['cart_id']}/coupon\", json={\n        \"code\": \"SAVE10\",\n    })\n\n    if response.status_code == 200:\n        context[\"discount\"] = response.json()[\"discount\"]\n        context[\"cart_total\"] = response.json()[\"total\"]\n\n    return response\n\n\ndef set_shipping_address(client, context):\n    \"\"\"Set shipping address.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/shipping\", json={\n        \"address\": {\n            \"name\": \"John Doe\",\n            \"street\": \"123 Main St\",\n            \"city\": \"New York\",\n            \"state\": \"NY\",\n            \"zip\": \"10001\",\n            \"country\": \"US\",\n        },\n    })\n\n\ndef create_order(client, context):\n    \"\"\"Create order from cart.\"\"\"\n    response = client.post(\"/api/orders\", json={\n        \"cart_id\": context[\"cart_id\"],\n    })\n\n    if response.status_code in [200, 201]:\n        data = response.json()\n        context[\"order_id\"] = data[\"id\"]\n        context[\"order_total\"] = data[\"total\"]\n\n    return response\n\n\n# ====================\n# Payment Actions\n# ====================\n\ndef pay_with_card_success(client, context):\n    \"\"\"Pay with valid credit card.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"credit_card\",\n        \"card\": {\n            \"number\": \"4242424242424242\",\n            \"exp_month\": 12,\n            \"exp_year\": 2025,\n            \"cvv\": \"123\",\n        },\n    })\n\n\ndef pay_with_card_declined(client, context):\n    \"\"\"Pay with card that will be declined.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"credit_card\",\n        \"card\": {\n            \"number\": \"4000000000000002\",  # Decline test card\n            \"exp_month\": 12,\n            \"exp_year\": 2025,\n            \"cvv\": \"123\",\n        },\n    })\n\n\ndef pay_with_paypal(client, context):\n    \"\"\"Pay with PayPal.\"\"\"\n    response = client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"paypal\",\n        \"return_url\": \"https://example.com/success\",\n        \"cancel_url\": \"https://example.com/cancel\",\n    })\n\n    if response.status_code == 200:\n        context[\"paypal_redirect\"] = response.json()[\"redirect_url\"]\n\n    return response\n\n\ndef pay_with_wallet(client, context):\n    \"\"\"Pay with digital wallet.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"wallet\",\n        \"wallet_id\": context.get(\"wallet_id\", \"default\"),\n    })\n\n\ndef pay_with_installments(client, context):\n    \"\"\"Pay in installments.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"installments\",\n        \"installment_plan\": {\n            \"count\": 3,\n            \"interval\": \"monthly\",\n        },\n    })\n\n\n# ====================\n# Verification Actions\n# ====================\n\ndef verify_order_completed(client, context):\n    \"\"\"Verify order status is completed.\"\"\"\n    response = client.get(f\"/api/orders/{context['order_id']}\")\n\n    if response.status_code == 200:\n        status = response.json()[\"status\"]\n        if status not in [\"completed\", \"processing\"]:\n            raise AssertionError(f\"Expected completed, got {status}\")\n\n    return response\n\n\ndef get_order_receipt(client, context):\n    \"\"\"Get order receipt.\"\"\"\n    return client.get(f\"/api/orders/{context['order_id']}/receipt\")\n\n\n# ====================\n# Journey Definition\n# ====================\n\njourney = Journey(\n    name=\"checkout_complete\",\n    description=\"Complete checkout flow with multiple payment options\",\n    tags=[\"checkout\", \"payment\", \"e-commerce\", \"critical\"],\n    steps=[\n        # Setup\n        Step(name=\"login\", action=login),\n        Step(name=\"browse\", action=browse_products),\n        Step(name=\"add_to_cart\", action=add_to_cart),\n        Step(name=\"apply_coupon\", action=apply_coupon),\n        Step(name=\"set_shipping\", action=set_shipping_address),\n        Step(name=\"create_order\", action=create_order),\n\n        # Save state before payment\n        Checkpoint(name=\"ready_to_pay\"),\n\n        # Test all payment methods\n        Branch(\n            checkpoint_name=\"ready_to_pay\",\n            paths=[\n                # Credit card success\n                Path(name=\"card_success\", steps=[\n                    Step(name=\"pay\", action=pay_with_card_success),\n                    Step(name=\"verify\", action=verify_order_completed),\n                    Step(name=\"receipt\", action=get_order_receipt),\n                ]),\n\n                # Credit card declined\n                Path(name=\"card_declined\", steps=[\n                    Step(\n                        name=\"pay\",\n                        action=pay_with_card_declined,\n                        expect_failure=True,\n                    ),\n                ]),\n\n                # PayPal\n                Path(name=\"paypal\", steps=[\n                    Step(name=\"pay\", action=pay_with_paypal),\n                ]),\n\n                # Digital wallet\n                Path(name=\"wallet\", steps=[\n                    Step(name=\"pay\", action=pay_with_wallet),\n                    Step(name=\"verify\", action=verify_order_completed),\n                ]),\n\n                # Installments\n                Path(name=\"installments\", steps=[\n                    Step(name=\"pay\", action=pay_with_installments),\n                    Step(name=\"verify\", action=verify_order_completed),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/checkout/#cart-operations","title":"Cart Operations","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint\n\n\ndef login(client, context):\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n    return response\n\n\ndef create_cart(client, context):\n    \"\"\"Create a new cart.\"\"\"\n    response = client.post(\"/api/cart\")\n    if response.status_code in [200, 201]:\n        context[\"cart_id\"] = response.json()[\"id\"]\n    return response\n\n\ndef add_item_1(client, context):\n    \"\"\"Add first item to cart.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/items\", json={\n        \"product_id\": 1,\n        \"quantity\": 2,\n    })\n\n\ndef add_item_2(client, context):\n    \"\"\"Add second item to cart.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/items\", json={\n        \"product_id\": 2,\n        \"quantity\": 1,\n    })\n\n\ndef update_quantity(client, context):\n    \"\"\"Update item quantity.\"\"\"\n    return client.patch(f\"/api/cart/{context['cart_id']}/items/1\", json={\n        \"quantity\": 5,\n    })\n\n\ndef remove_item(client, context):\n    \"\"\"Remove item from cart.\"\"\"\n    return client.delete(f\"/api/cart/{context['cart_id']}/items/2\")\n\n\ndef get_cart(client, context):\n    \"\"\"Get cart contents.\"\"\"\n    return client.get(f\"/api/cart/{context['cart_id']}\")\n\n\ndef clear_cart(client, context):\n    \"\"\"Clear all items from cart.\"\"\"\n    return client.delete(f\"/api/cart/{context['cart_id']}/items\")\n\n\njourney = Journey(\n    name=\"cart_operations\",\n    description=\"Test shopping cart operations\",\n    tags=[\"cart\", \"e-commerce\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"create_cart\", action=create_cart),\n        Checkpoint(name=\"cart_created\"),\n        Step(name=\"add_item_1\", action=add_item_1),\n        Step(name=\"add_item_2\", action=add_item_2),\n        Step(name=\"view_cart\", action=get_cart),\n        Step(name=\"update_quantity\", action=update_quantity),\n        Step(name=\"remove_item\", action=remove_item),\n        Step(name=\"view_updated\", action=get_cart),\n        Step(name=\"clear_cart\", action=clear_cart),\n    ],\n)\n</code></pre>"},{"location":"examples/checkout/#order-management","title":"Order Management","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\n\ndef setup_and_create_order(client, context):\n    \"\"\"Setup and create an order.\"\"\"\n    # Login\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n    client.set_auth_token(response.json()[\"token\"])\n\n    # Create order\n    response = client.post(\"/api/orders\", json={\n        \"items\": [{\"product_id\": 1, \"quantity\": 2}],\n        \"shipping_address\": {\"street\": \"123 Main St\", \"city\": \"NYC\"},\n    })\n    context[\"order_id\"] = response.json()[\"id\"]\n\n    return response\n\n\ndef pay_order(client, context):\n    \"\"\"Pay for the order.\"\"\"\n    return client.post(f\"/api/orders/{context['order_id']}/pay\", json={\n        \"method\": \"credit_card\",\n        \"card_token\": \"tok_visa\",\n    })\n\n\ndef cancel_order(client, context):\n    \"\"\"Cancel the order.\"\"\"\n    return client.post(f\"/api/orders/{context['order_id']}/cancel\", json={\n        \"reason\": \"Changed my mind\",\n    })\n\n\ndef request_refund(client, context):\n    \"\"\"Request a refund.\"\"\"\n    return client.post(f\"/api/orders/{context['order_id']}/refund\", json={\n        \"reason\": \"Product not as described\",\n    })\n\n\ndef get_order_status(client, context):\n    \"\"\"Get order status.\"\"\"\n    return client.get(f\"/api/orders/{context['order_id']}\")\n\n\ndef get_order_tracking(client, context):\n    \"\"\"Get shipping tracking info.\"\"\"\n    return client.get(f\"/api/orders/{context['order_id']}/tracking\")\n\n\njourney = Journey(\n    name=\"order_lifecycle\",\n    description=\"Test order lifecycle\",\n    tags=[\"orders\", \"e-commerce\"],\n    steps=[\n        Step(name=\"create_order\", action=setup_and_create_order),\n        Checkpoint(name=\"order_created\"),\n\n        Branch(\n            checkpoint_name=\"order_created\",\n            paths=[\n                # Normal flow: pay and track\n                Path(name=\"complete_flow\", steps=[\n                    Step(name=\"pay\", action=pay_order),\n                    Step(name=\"status\", action=get_order_status),\n                    Step(name=\"tracking\", action=get_order_tracking),\n                ]),\n\n                # Cancel before payment\n                Path(name=\"cancel_unpaid\", steps=[\n                    Step(name=\"cancel\", action=cancel_order),\n                    Step(name=\"verify_cancelled\", action=get_order_status),\n                ]),\n\n                # Pay then refund\n                Path(name=\"refund_flow\", steps=[\n                    Step(name=\"pay\", action=pay_order),\n                    Step(name=\"refund\", action=request_refund),\n                    Step(name=\"verify_refunded\", action=get_order_status),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/checkout/#inventory-testing","title":"Inventory Testing","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint\n\n\ndef check_stock(client, context):\n    \"\"\"Check product stock.\"\"\"\n    response = client.get(\"/api/products/1/stock\")\n    context[\"initial_stock\"] = response.json()[\"quantity\"]\n    return response\n\n\ndef add_to_cart_available(client, context):\n    \"\"\"Add available quantity to cart.\"\"\"\n    return client.post(\"/api/cart/items\", json={\n        \"product_id\": 1,\n        \"quantity\": 2,\n    })\n\n\ndef add_to_cart_excess(client, context):\n    \"\"\"Try to add more than available.\"\"\"\n    return client.post(\"/api/cart/items\", json={\n        \"product_id\": 1,\n        \"quantity\": 999999,\n    })\n\n\ndef complete_purchase(client, context):\n    \"\"\"Complete purchase.\"\"\"\n    return client.post(\"/api/checkout\", json={\n        \"payment_method\": \"credit_card\",\n        \"card_token\": \"tok_visa\",\n    })\n\n\ndef check_stock_after(client, context):\n    \"\"\"Check stock after purchase.\"\"\"\n    response = client.get(\"/api/products/1/stock\")\n    context[\"final_stock\"] = response.json()[\"quantity\"]\n    return response\n\n\njourney = Journey(\n    name=\"inventory_management\",\n    description=\"Test inventory during checkout\",\n    tags=[\"inventory\", \"stock\", \"e-commerce\"],\n    steps=[\n        Step(name=\"check_initial_stock\", action=check_stock),\n        Step(name=\"add_available\", action=add_to_cart_available),\n        Step(\n            name=\"add_excess\",\n            action=add_to_cart_excess,\n            expect_failure=True,\n        ),\n        Step(name=\"purchase\", action=complete_purchase),\n        Step(name=\"check_final_stock\", action=check_stock_after),\n    ],\n)\n</code></pre>"},{"location":"examples/checkout/#promotion-and-discount-testing","title":"Promotion and Discount Testing","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\n\ndef setup_cart(client, context):\n    \"\"\"Setup cart with items.\"\"\"\n    client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n\n    response = client.post(\"/api/cart/items\", json={\n        \"product_id\": 1,\n        \"quantity\": 3,\n    })\n    context[\"cart_id\"] = response.json()[\"cart_id\"]\n    context[\"original_total\"] = response.json()[\"total\"]\n\n    return response\n\n\ndef apply_percentage_coupon(client, context):\n    \"\"\"Apply percentage discount coupon.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/coupon\", json={\n        \"code\": \"SAVE20\",  # 20% off\n    })\n\n\ndef apply_fixed_coupon(client, context):\n    \"\"\"Apply fixed amount coupon.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/coupon\", json={\n        \"code\": \"FLAT10\",  # $10 off\n    })\n\n\ndef apply_expired_coupon(client, context):\n    \"\"\"Apply expired coupon.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/coupon\", json={\n        \"code\": \"EXPIRED2023\",\n    })\n\n\ndef apply_invalid_coupon(client, context):\n    \"\"\"Apply invalid coupon.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/coupon\", json={\n        \"code\": \"NOTREAL\",\n    })\n\n\ndef remove_coupon(client, context):\n    \"\"\"Remove applied coupon.\"\"\"\n    return client.delete(f\"/api/cart/{context['cart_id']}/coupon\")\n\n\njourney = Journey(\n    name=\"coupon_testing\",\n    description=\"Test coupon and discount functionality\",\n    tags=[\"coupons\", \"discounts\", \"e-commerce\"],\n    steps=[\n        Step(name=\"setup\", action=setup_cart),\n        Checkpoint(name=\"cart_ready\"),\n\n        Branch(\n            checkpoint_name=\"cart_ready\",\n            paths=[\n                Path(name=\"percentage_discount\", steps=[\n                    Step(name=\"apply\", action=apply_percentage_coupon),\n                    Step(name=\"remove\", action=remove_coupon),\n                ]),\n                Path(name=\"fixed_discount\", steps=[\n                    Step(name=\"apply\", action=apply_fixed_coupon),\n                ]),\n                Path(name=\"expired_coupon\", steps=[\n                    Step(\n                        name=\"apply\",\n                        action=apply_expired_coupon,\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"invalid_coupon\", steps=[\n                    Step(\n                        name=\"apply\",\n                        action=apply_invalid_coupon,\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/","title":"CRUD Operations","text":"<p>Examples of testing Create, Read, Update, Delete operations.</p>"},{"location":"examples/crud/#basic-crud-journey","title":"Basic CRUD Journey","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint\n\ndef create_item(client, context):\n    \"\"\"Create a new item.\"\"\"\n    response = client.post(\"/api/items\", json={\n        \"name\": \"Test Item\",\n        \"price\": 29.99,\n        \"description\": \"A test item\",\n    })\n\n    if response.status_code in [200, 201]:\n        context[\"item_id\"] = response.json()[\"id\"]\n        context[\"item_name\"] = response.json()[\"name\"]\n\n    return response\n\n\ndef read_item(client, context):\n    \"\"\"Read the created item.\"\"\"\n    item_id = context.get_required(\"item_id\")\n    return client.get(f\"/api/items/{item_id}\")\n\n\ndef update_item(client, context):\n    \"\"\"Update the item.\"\"\"\n    item_id = context.get_required(\"item_id\")\n    return client.put(f\"/api/items/{item_id}\", json={\n        \"name\": \"Updated Item\",\n        \"price\": 39.99,\n        \"description\": \"An updated test item\",\n    })\n\n\ndef delete_item(client, context):\n    \"\"\"Delete the item.\"\"\"\n    item_id = context.get_required(\"item_id\")\n    return client.delete(f\"/api/items/{item_id}\")\n\n\ndef verify_deleted(client, context):\n    \"\"\"Verify item no longer exists.\"\"\"\n    item_id = context.get_required(\"item_id\")\n    return client.get(f\"/api/items/{item_id}\")\n\n\njourney = Journey(\n    name=\"item_crud\",\n    description=\"Test complete CRUD operations for items\",\n    tags=[\"crud\", \"items\"],\n    steps=[\n        Step(name=\"create\", action=create_item),\n        Checkpoint(name=\"item_created\"),\n        Step(name=\"read\", action=read_item),\n        Step(name=\"update\", action=update_item),\n        Step(name=\"read_updated\", action=read_item),\n        Step(name=\"delete\", action=delete_item),\n        Step(\n            name=\"verify_deleted\",\n            action=verify_deleted,\n            expect_failure=True,\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/#crud-with-authentication","title":"CRUD with Authentication","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint\n\n\ndef login(client, context):\n    \"\"\"Login to get auth token.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"admin@example.com\",\n        \"password\": \"admin123\",\n    })\n\n    if response.status_code == 200:\n        token = response.json()[\"token\"]\n        context[\"token\"] = token\n        client.set_auth_token(token)\n\n    return response\n\n\ndef create_user(client, context):\n    \"\"\"Create a new user.\"\"\"\n    response = client.post(\"/api/users\", json={\n        \"email\": \"newuser@example.com\",\n        \"name\": \"New User\",\n        \"role\": \"member\",\n    })\n\n    if response.status_code in [200, 201]:\n        context[\"user_id\"] = response.json()[\"id\"]\n\n    return response\n\n\ndef read_user(client, context):\n    \"\"\"Read user details.\"\"\"\n    user_id = context.get_required(\"user_id\")\n    return client.get(f\"/api/users/{user_id}\")\n\n\ndef update_user(client, context):\n    \"\"\"Update user details.\"\"\"\n    user_id = context.get_required(\"user_id\")\n    return client.patch(f\"/api/users/{user_id}\", json={\n        \"name\": \"Updated User\",\n        \"role\": \"admin\",\n    })\n\n\ndef delete_user(client, context):\n    \"\"\"Delete user.\"\"\"\n    user_id = context.get_required(\"user_id\")\n    return client.delete(f\"/api/users/{user_id}\")\n\n\njourney = Journey(\n    name=\"user_crud_admin\",\n    description=\"Admin CRUD operations for users\",\n    tags=[\"crud\", \"users\", \"admin\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Checkpoint(name=\"authenticated\"),\n        Step(name=\"create_user\", action=create_user),\n        Checkpoint(name=\"user_created\"),\n        Step(name=\"read_user\", action=read_user),\n        Step(name=\"update_user\", action=update_user),\n        Step(name=\"verify_update\", action=read_user),\n        Step(name=\"delete_user\", action=delete_user),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/#crud-with-validation-testing","title":"CRUD with Validation Testing","text":"Python<pre><code>from venomqa import Journey, Step, Branch, Path, Checkpoint\n\n\ndef create_valid_item(client, context):\n    \"\"\"Create item with valid data.\"\"\"\n    return client.post(\"/api/items\", json={\n        \"name\": \"Valid Item\",\n        \"price\": 29.99,\n    })\n\n\ndef create_without_name(client, context):\n    \"\"\"Create item without required name.\"\"\"\n    return client.post(\"/api/items\", json={\n        \"price\": 29.99,\n    })\n\n\ndef create_with_negative_price(client, context):\n    \"\"\"Create item with invalid price.\"\"\"\n    return client.post(\"/api/items\", json={\n        \"name\": \"Invalid Item\",\n        \"price\": -10.00,\n    })\n\n\ndef create_with_empty_name(client, context):\n    \"\"\"Create item with empty name.\"\"\"\n    return client.post(\"/api/items\", json={\n        \"name\": \"\",\n        \"price\": 29.99,\n    })\n\n\njourney = Journey(\n    name=\"item_validation\",\n    description=\"Test item creation validation\",\n    tags=[\"crud\", \"validation\"],\n    steps=[\n        # Valid creation\n        Step(name=\"create_valid\", action=create_valid_item),\n\n        Checkpoint(name=\"baseline\"),\n\n        # Validation errors\n        Branch(\n            checkpoint_name=\"baseline\",\n            paths=[\n                Path(name=\"missing_name\", steps=[\n                    Step(\n                        name=\"create\",\n                        action=create_without_name,\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"negative_price\", steps=[\n                    Step(\n                        name=\"create\",\n                        action=create_with_negative_price,\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"empty_name\", steps=[\n                    Step(\n                        name=\"create\",\n                        action=create_with_empty_name,\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/#bulk-operations","title":"Bulk Operations","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef create_items_batch(client, context):\n    \"\"\"Create multiple items in one request.\"\"\"\n    items = [\n        {\"name\": f\"Item {i}\", \"price\": 10.00 + i}\n        for i in range(10)\n    ]\n\n    response = client.post(\"/api/items/batch\", json={\"items\": items})\n\n    if response.status_code in [200, 201]:\n        context[\"item_ids\"] = [item[\"id\"] for item in response.json()[\"items\"]]\n\n    return response\n\n\ndef list_items(client, context):\n    \"\"\"List all items.\"\"\"\n    return client.get(\"/api/items\", params={\"limit\": 100})\n\n\ndef delete_items_batch(client, context):\n    \"\"\"Delete multiple items.\"\"\"\n    item_ids = context.get_required(\"item_ids\")\n    return client.post(\"/api/items/batch-delete\", json={\"ids\": item_ids})\n\n\njourney = Journey(\n    name=\"bulk_operations\",\n    description=\"Test bulk create and delete\",\n    tags=[\"crud\", \"bulk\"],\n    steps=[\n        Step(name=\"create_batch\", action=create_items_batch),\n        Step(name=\"list_items\", action=list_items),\n        Step(name=\"delete_batch\", action=delete_items_batch),\n        Step(name=\"verify_empty\", action=list_items),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/#pagination-testing","title":"Pagination Testing","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef create_many_items(client, context):\n    \"\"\"Create items for pagination testing.\"\"\"\n    for i in range(25):\n        client.post(\"/api/items\", json={\n            \"name\": f\"Item {i}\",\n            \"price\": 10.00,\n        })\n    return {\"created\": 25}\n\n\ndef get_page_1(client, context):\n    \"\"\"Get first page.\"\"\"\n    response = client.get(\"/api/items\", params={\"page\": 1, \"limit\": 10})\n    context[\"page_1_count\"] = len(response.json()[\"items\"])\n    return response\n\n\ndef get_page_2(client, context):\n    \"\"\"Get second page.\"\"\"\n    response = client.get(\"/api/items\", params={\"page\": 2, \"limit\": 10})\n    context[\"page_2_count\"] = len(response.json()[\"items\"])\n    return response\n\n\ndef get_page_3(client, context):\n    \"\"\"Get third page (partial).\"\"\"\n    response = client.get(\"/api/items\", params={\"page\": 3, \"limit\": 10})\n    context[\"page_3_count\"] = len(response.json()[\"items\"])\n    return response\n\n\njourney = Journey(\n    name=\"pagination_test\",\n    description=\"Test pagination\",\n    tags=[\"crud\", \"pagination\"],\n    steps=[\n        Step(name=\"create_items\", action=create_many_items),\n        Step(name=\"page_1\", action=get_page_1),\n        Step(name=\"page_2\", action=get_page_2),\n        Step(name=\"page_3\", action=get_page_3),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/#search-and-filter","title":"Search and Filter","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef setup_items(client, context):\n    \"\"\"Create items with different categories.\"\"\"\n    items = [\n        {\"name\": \"Apple\", \"category\": \"fruit\", \"price\": 1.50},\n        {\"name\": \"Banana\", \"category\": \"fruit\", \"price\": 0.75},\n        {\"name\": \"Carrot\", \"category\": \"vegetable\", \"price\": 2.00},\n        {\"name\": \"Broccoli\", \"category\": \"vegetable\", \"price\": 3.00},\n    ]\n\n    for item in items:\n        client.post(\"/api/items\", json=item)\n\n    return {\"created\": len(items)}\n\n\ndef search_by_name(client, context):\n    \"\"\"Search items by name.\"\"\"\n    return client.get(\"/api/items\", params={\"q\": \"apple\"})\n\n\ndef filter_by_category(client, context):\n    \"\"\"Filter items by category.\"\"\"\n    return client.get(\"/api/items\", params={\"category\": \"fruit\"})\n\n\ndef filter_by_price_range(client, context):\n    \"\"\"Filter items by price range.\"\"\"\n    return client.get(\"/api/items\", params={\n        \"min_price\": 1.00,\n        \"max_price\": 2.00,\n    })\n\n\ndef sort_by_price(client, context):\n    \"\"\"Sort items by price.\"\"\"\n    return client.get(\"/api/items\", params={\n        \"sort\": \"price\",\n        \"order\": \"desc\",\n    })\n\n\njourney = Journey(\n    name=\"search_filter\",\n    description=\"Test search and filter\",\n    tags=[\"crud\", \"search\", \"filter\"],\n    steps=[\n        Step(name=\"setup\", action=setup_items),\n        Step(name=\"search_name\", action=search_by_name),\n        Step(name=\"filter_category\", action=filter_by_category),\n        Step(name=\"filter_price\", action=filter_by_price_range),\n        Step(name=\"sort_price\", action=sort_by_price),\n    ],\n)\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to VenomQA! This section will help you get up and running quickly.</p>"},{"location":"getting-started/#overview","title":"Overview","text":"<p>VenomQA is a stateful journey testing framework for API quality assurance. It enables you to:</p> <ul> <li>Test complex user flows as connected journeys rather than isolated tests</li> <li>Save and restore database state at checkpoints</li> <li>Branch execution to test multiple scenarios from the same starting point</li> <li>Generate detailed reports for debugging and CI/CD integration</li> </ul>"},{"location":"getting-started/#quick-links","title":"Quick Links","text":""},{"location":"getting-started/#quickstart","title":"Quickstart","text":"<p>Get your first journey running in 5 minutes.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Detailed installation instructions and dependencies.</p>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>Configure VenomQA for your project.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>Python 3.10 or higher installed</li> <li>pip (Python package manager)</li> <li>Docker (optional, for infrastructure management)</li> </ul>"},{"location":"getting-started/#your-first-steps","title":"Your First Steps","text":"<ol> <li> <p>Install VenomQA Bash<pre><code>pip install venomqa\n</code></pre></p> </li> <li> <p>Create a journey file Python<pre><code># journeys/hello.py\nfrom venomqa import Journey, Step\n\njourney = Journey(\n    name=\"hello_world\",\n    steps=[\n        Step(name=\"health_check\", action=lambda c, ctx: c.get(\"/health\")),\n    ],\n)\n</code></pre></p> </li> <li> <p>Run it Bash<pre><code>venomqa run hello_world\n</code></pre></p> </li> </ol>"},{"location":"getting-started/#whats-next","title":"What's Next?","text":"<p>After completing the quickstart, explore:</p> <ul> <li>Core Concepts - Understand Journeys, Checkpoints, and Branches</li> <li>Tutorials - Step-by-step guides for common scenarios</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>VenomQA can be configured through a YAML file, environment variables, or programmatically.</p>"},{"location":"getting-started/configuration/#configuration-file","title":"Configuration File","text":"<p>Create a <code>venomqa.yaml</code> file in your project root:</p> YAML<pre><code># API Configuration\nbase_url: \"http://localhost:8000\"\n\n# Database Configuration (for state management)\ndb_url: \"postgresql://qa:secret@localhost:5432/qa_test\"\ndb_backend: \"postgresql\"\n\n# Infrastructure\ndocker_compose_file: \"docker-compose.qa.yml\"\n\n# Request Settings\ntimeout: 30\nretry_count: 3\nretry_delay: 1.0\n\n# Execution\nparallel_paths: 1\nfail_fast: false\n\n# Logging\nverbose: false\ncapture_logs: true\nlog_lines: 50\n\n# Reporting\nreport_dir: \"reports\"\nreport_formats:\n  - markdown\n  - junit\n</code></pre>"},{"location":"getting-started/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"getting-started/configuration/#api-configuration","title":"API Configuration","text":"Option Type Default Description <code>base_url</code> string <code>\"http://localhost:8000\"</code> Base URL for all API requests <code>timeout</code> integer <code>30</code> Request timeout in seconds <code>retry_count</code> integer <code>3</code> Number of retry attempts on failure <code>retry_delay</code> float <code>1.0</code> Base delay between retries in seconds"},{"location":"getting-started/configuration/#database-configuration","title":"Database Configuration","text":"Option Type Default Description <code>db_url</code> string <code>null</code> Database connection URL <code>db_backend</code> string <code>\"postgresql\"</code> Database backend type <p>Supported backends:</p> <ul> <li><code>postgresql</code> - PostgreSQL with SAVEPOINT support</li> <li><code>sqlite</code> - SQLite (limited checkpoint support)</li> <li><code>mysql</code> - MySQL (community contributed)</li> </ul>"},{"location":"getting-started/configuration/#infrastructure-configuration","title":"Infrastructure Configuration","text":"Option Type Default Description <code>docker_compose_file</code> string <code>\"docker-compose.qa.yml\"</code> Path to Docker Compose file"},{"location":"getting-started/configuration/#execution-configuration","title":"Execution Configuration","text":"Option Type Default Description <code>parallel_paths</code> integer <code>1</code> Max concurrent branch paths <code>fail_fast</code> boolean <code>false</code> Stop on first failure <p>Parallel Execution with State</p> <p>When using <code>parallel_paths &gt; 1</code> with database state management, ensure your paths are isolated or use separate database connections.</p>"},{"location":"getting-started/configuration/#logging-configuration","title":"Logging Configuration","text":"Option Type Default Description <code>verbose</code> boolean <code>false</code> Enable verbose/debug output <code>capture_logs</code> boolean <code>true</code> Capture infrastructure logs <code>log_lines</code> integer <code>50</code> Number of log lines to capture"},{"location":"getting-started/configuration/#reporting-configuration","title":"Reporting Configuration","text":"Option Type Default Description <code>report_dir</code> string <code>\"reports\"</code> Output directory for reports <code>report_formats</code> list <code>[\"markdown\"]</code> Report formats to generate <p>Available formats: <code>markdown</code>, <code>json</code>, <code>junit</code>, <code>html</code>, <code>sarif</code></p>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>All configuration options can be overridden with environment variables prefixed with <code>VENOMQA_</code>:</p> Bash<pre><code># API Configuration\nexport VENOMQA_BASE_URL=\"http://api.staging.example.com\"\nexport VENOMQA_TIMEOUT=60\n\n# Database\nexport VENOMQA_DB_URL=\"postgresql://user:pass@host:5432/db\"\nexport VENOMQA_DB_BACKEND=\"postgresql\"\n\n# Execution\nexport VENOMQA_VERBOSE=true\nexport VENOMQA_FAIL_FAST=true\nexport VENOMQA_PARALLEL_PATHS=4\n</code></pre>"},{"location":"getting-started/configuration/#configuration-priority","title":"Configuration Priority","text":"<p>Configuration is loaded in this order (later sources override earlier):</p> <ol> <li>Default values (lowest priority)</li> <li>Configuration file (<code>venomqa.yaml</code>)</li> <li>Environment variables (<code>VENOMQA_*</code>)</li> <li>CLI arguments (highest priority)</li> </ol>"},{"location":"getting-started/configuration/#multiple-environments","title":"Multiple Environments","text":"<p>Use different configuration files for different environments:</p> Bash<pre><code># Development\nvenomqa run -c venomqa.dev.yaml\n\n# Staging\nvenomqa run -c venomqa.staging.yaml\n\n# Production (read-only tests)\nvenomqa run -c venomqa.prod.yaml\n</code></pre> <p>Or use environment variables in CI/CD:</p> YAML<pre><code># .github/workflows/test.yml\njobs:\n  test:\n    runs-on: ubuntu-latest\n    env:\n      VENOMQA_BASE_URL: ${{ secrets.API_URL }}\n      VENOMQA_DB_URL: ${{ secrets.DATABASE_URL }}\n    steps:\n      - uses: actions/checkout@v4\n      - run: pip install venomqa\n      - run: venomqa run\n</code></pre>"},{"location":"getting-started/configuration/#programmatic-configuration","title":"Programmatic Configuration","text":"<p>Configure VenomQA in Python:</p> Python<pre><code>from venomqa import QAConfig, Client, JourneyRunner\n\n# Create configuration\nconfig = QAConfig(\n    base_url=\"http://localhost:8000\",\n    db_url=\"postgresql://qa:secret@localhost:5432/qa_test\",\n    db_backend=\"postgresql\",\n    timeout=30,\n    retry_count=3,\n    parallel_paths=2,\n    capture_logs=True,\n)\n\n# Create client with config\nclient = Client(\n    base_url=config.base_url,\n    timeout=config.timeout,\n    retry_count=config.retry_count,\n)\n\n# Create runner\nrunner = JourneyRunner(\n    client=client,\n    parallel_paths=config.parallel_paths,\n    fail_fast=config.fail_fast,\n)\n\n# Run journey\nresult = runner.run(journey)\n</code></pre>"},{"location":"getting-started/configuration/#loading-configuration-from-file","title":"Loading Configuration from File","text":"Python<pre><code>from venomqa.config import load_config\n\n# Load from default location (venomqa.yaml)\nconfig = load_config()\n\n# Load from specific path\nconfig = load_config(\"path/to/config.yaml\")\n\n# Access values\nprint(config.base_url)\nprint(config.db_url)\n</code></pre>"},{"location":"getting-started/configuration/#docker-compose-integration","title":"Docker Compose Integration","text":"<p>VenomQA can manage test infrastructure via Docker Compose.</p>"},{"location":"getting-started/configuration/#example-docker-composeqayml","title":"Example docker-compose.qa.yml","text":"YAML<pre><code>version: \"3.8\"\n\nservices:\n  api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      DATABASE_URL: postgresql://qa:secret@db:5432/qa_test\n    depends_on:\n      db:\n        condition: service_healthy\n\n  db:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: qa_test\n      POSTGRES_USER: qa\n      POSTGRES_PASSWORD: secret\n    ports:\n      - \"5432:5432\"\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U qa -d qa_test\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n    # Use tmpfs for faster tests\n    tmpfs:\n      - /var/lib/postgresql/data\n\n  redis:\n    image: redis:7\n    ports:\n      - \"6379:6379\"\n\n  mailhog:\n    image: mailhog/mailhog\n    ports:\n      - \"1025:1025\"\n      - \"8025:8025\"\n</code></pre>"},{"location":"getting-started/configuration/#running-with-infrastructure","title":"Running with Infrastructure","text":"Bash<pre><code># Run with Docker management (starts, runs, stops)\nvenomqa run\n\n# Skip Docker management (services already running)\nvenomqa run --no-infra\n</code></pre>"},{"location":"getting-started/configuration/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/configuration/#1-use-environment-specific-configs","title":"1. Use Environment-Specific Configs","text":"Text Only<pre><code>project/\n\u251c\u2500\u2500 venomqa.yaml              # Default/development\n\u251c\u2500\u2500 venomqa.staging.yaml      # Staging environment\n\u251c\u2500\u2500 venomqa.prod.yaml         # Production (read-only)\n\u2514\u2500\u2500 journeys/\n</code></pre>"},{"location":"getting-started/configuration/#2-never-commit-secrets","title":"2. Never Commit Secrets","text":"<p>Use environment variables for sensitive data:</p> YAML<pre><code># venomqa.yaml (safe to commit)\nbase_url: \"http://localhost:8000\"\n\n# In CI/CD or shell (secrets)\nexport VENOMQA_DB_URL=\"postgresql://...\"\n</code></pre>"},{"location":"getting-started/configuration/#3-use-sensible-timeouts","title":"3. Use Sensible Timeouts","text":"YAML<pre><code># Short for local development\ntimeout: 10\n\n# Longer for CI/CD (network latency)\ntimeout: 60\n</code></pre>"},{"location":"getting-started/configuration/#4-enable-verbose-mode-for-debugging","title":"4. Enable Verbose Mode for Debugging","text":"Bash<pre><code>venomqa run my_journey -v\n</code></pre> <p>Or in config:</p> YAML<pre><code>verbose: true  # Temporary for debugging\n</code></pre>"},{"location":"getting-started/configuration/#configuration-schema-reference","title":"Configuration Schema Reference","text":"<p>For IDE autocompletion, here's the full schema:</p> YAML<pre><code># venomqa.yaml\n---\n# Required\nbase_url: string  # e.g., \"http://localhost:8000\"\n\n# Optional - Database\ndb_url: string | null  # e.g., \"postgresql://user:pass@host:5432/db\"\ndb_backend: string  # default: \"postgresql\"\n\n# Optional - Infrastructure\ndocker_compose_file: string  # default: \"docker-compose.qa.yml\"\n\n# Optional - Request\ntimeout: integer  # default: 30 (seconds)\nretry_count: integer  # default: 3\nretry_delay: float  # default: 1.0 (seconds)\n\n# Optional - Execution\nparallel_paths: integer  # default: 1\nfail_fast: boolean  # default: false\n\n# Optional - Logging\nverbose: boolean  # default: false\ncapture_logs: boolean  # default: true\nlog_lines: integer  # default: 50\n\n# Optional - Reporting\nreport_dir: string  # default: \"reports\"\nreport_formats: list[string]  # default: [\"markdown\"]\n</code></pre>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Quickstart - Create your first journey</li> <li>Core Concepts - Understand Journeys and Checkpoints</li> <li>CLI Reference - Command-line options</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers all installation options for VenomQA.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>pip (Python package manager)</li> <li>Docker (optional, for infrastructure management)</li> </ul>"},{"location":"getting-started/installation/#basic-installation","title":"Basic Installation","text":"<p>Install VenomQA from PyPI:</p> Bash<pre><code>pip install venomqa\n</code></pre> <p>Verify the installation:</p> Bash<pre><code>venomqa --version\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>VenomQA has optional dependencies for different features:</p>"},{"location":"getting-started/installation/#postgresql-state-management","title":"PostgreSQL State Management","text":"<p>For database checkpointing and rollback:</p> Bash<pre><code>pip install \"venomqa[postgres]\"\n</code></pre> <p>This installs <code>psycopg[binary]</code> for PostgreSQL connectivity.</p>"},{"location":"getting-started/installation/#redis-adapters","title":"Redis Adapters","text":"<p>For Redis cache and queue adapters:</p> Bash<pre><code>pip install \"venomqa[redis]\"\n</code></pre>"},{"location":"getting-started/installation/#s3minio-storage","title":"S3/MinIO Storage","text":"<p>For S3-compatible storage adapters:</p> Bash<pre><code>pip install \"venomqa[s3]\"\n</code></pre>"},{"location":"getting-started/installation/#all-optional-dependencies","title":"All Optional Dependencies","text":"<p>Install everything:</p> Bash<pre><code>pip install \"venomqa[all]\"\n</code></pre>"},{"location":"getting-started/installation/#multiple-extras","title":"Multiple Extras","text":"<p>Install specific combinations:</p> Bash<pre><code>pip install \"venomqa[postgres,redis]\"\n</code></pre>"},{"location":"getting-started/installation/#installation-options-summary","title":"Installation Options Summary","text":"Extra Dependencies Purpose <code>postgres</code> <code>psycopg[binary]</code> Database state management <code>redis</code> <code>redis</code> Redis cache/queue adapters <code>s3</code> <code>boto3</code> S3/MinIO storage adapter <code>all</code> All of the above Full functionality"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For contributing or development:</p> Bash<pre><code># Clone the repository\ngit clone https://github.com/venomqa/venomqa.git\ncd venomqa\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install with development dependencies\npip install -e \".[dev]\"\n\n# Run tests\npytest\n\n# Run linting\nruff check .\nmypy venomqa\n</code></pre>"},{"location":"getting-started/installation/#documentation-development","title":"Documentation Development","text":"<p>To work on documentation:</p> Bash<pre><code># Install docs dependencies\npip install -e \".[docs]\"\n\n# Serve documentation locally\nmkdocs serve\n\n# Build documentation\nmkdocs build\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#postgresql-installation-issues","title":"PostgreSQL Installation Issues","text":"<p>On some systems, you may need to install build dependencies:</p> Ubuntu/DebianmacOS (Homebrew)Windows Bash<pre><code>sudo apt-get install libpq-dev python3-dev\npip install \"venomqa[postgres]\"\n</code></pre> Bash<pre><code>brew install postgresql\npip install \"venomqa[postgres]\"\n</code></pre> <p>Install PostgreSQL from https://www.postgresql.org/download/windows/</p> <p>Then: Bash<pre><code>pip install \"venomqa[postgres]\"\n</code></pre></p>"},{"location":"getting-started/installation/#virtual-environment-recommended","title":"Virtual Environment Recommended","text":"<p>We strongly recommend using a virtual environment:</p> Bash<pre><code># Create virtual environment\npython -m venv venv\n\n# Activate it\nsource venv/bin/activate  # macOS/Linux\nvenv\\Scripts\\activate     # Windows\n\n# Install VenomQA\npip install venomqa\n</code></pre>"},{"location":"getting-started/installation/#upgrading-venomqa","title":"Upgrading VenomQA","text":"<p>To upgrade to the latest version:</p> Bash<pre><code>pip install --upgrade venomqa\n</code></pre> <p>To upgrade with extras:</p> Bash<pre><code>pip install --upgrade \"venomqa[all]\"\n</code></pre>"},{"location":"getting-started/installation/#checking-installed-version","title":"Checking Installed Version","text":"Bash<pre><code># Via CLI\nvenomqa --version\n\n# Via Python\npython -c \"import venomqa; print(venomqa.__version__)\"\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After installation, proceed to:</p> <ul> <li>Quickstart - Create your first journey</li> <li>Configuration - Configure VenomQA for your project</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Get VenomQA up and running in 5 minutes.</p>"},{"location":"getting-started/quickstart/#install-venomqa","title":"Install VenomQA","text":"Bash<pre><code>pip install venomqa\n</code></pre> <p>Verify the installation:</p> Bash<pre><code>venomqa --version\n</code></pre>"},{"location":"getting-started/quickstart/#create-your-first-journey","title":"Create Your First Journey","text":""},{"location":"getting-started/quickstart/#1-set-up-the-project-structure","title":"1. Set up the project structure","text":"Bash<pre><code>mkdir my-api-tests &amp;&amp; cd my-api-tests\nmkdir journeys\n</code></pre>"},{"location":"getting-started/quickstart/#2-create-a-configuration-file","title":"2. Create a configuration file","text":"<p>Create <code>venomqa.yaml</code>:</p> YAML<pre><code>base_url: \"http://localhost:8000\"\ntimeout: 30\nverbose: false\n</code></pre>"},{"location":"getting-started/quickstart/#3-write-your-first-journey","title":"3. Write your first journey","text":"<p>Create <code>journeys/hello.py</code>:</p> Python<pre><code>from venomqa import Journey, Step\n\ndef health_check(client, context):\n    \"\"\"Check if the API is healthy.\"\"\"\n    return client.get(\"/health\")\n\ndef get_version(client, context):\n    \"\"\"Get API version information.\"\"\"\n    response = client.get(\"/api/version\")\n    context[\"version\"] = response.json().get(\"version\")\n    return response\n\njourney = Journey(\n    name=\"hello_world\",\n    description=\"My first VenomQA journey\",\n    steps=[\n        Step(name=\"check_health\", action=health_check),\n        Step(name=\"get_version\", action=get_version),\n    ],\n)\n</code></pre>"},{"location":"getting-started/quickstart/#4-run-the-journey","title":"4. Run the journey","text":"Bash<pre><code>venomqa run hello_world\n</code></pre> <p>You should see output like:</p> Text Only<pre><code>Running journey: hello_world\n  [PASS] check_health (45ms)\n  [PASS] get_version (32ms)\n\nJourney completed: 2/2 steps passed\n</code></pre>"},{"location":"getting-started/quickstart/#add-authentication","title":"Add Authentication","text":"<p>Most APIs require authentication. Here's how to handle it:</p> Python<pre><code># journeys/auth_flow.py\nfrom venomqa import Journey, Step\n\ndef login(client, context):\n    \"\"\"Authenticate and store the token.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n\n    if response.status_code == 200:\n        token = response.json()[\"token\"]\n        context[\"token\"] = token\n        client.set_auth_token(token)  # Sets Authorization header\n\n    return response\n\ndef get_profile(client, context):\n    \"\"\"Fetch authenticated user's profile.\"\"\"\n    return client.get(\"/api/users/me\")\n\ndef update_profile(client, context):\n    \"\"\"Update user's name.\"\"\"\n    return client.patch(\"/api/users/me\", json={\n        \"name\": \"Updated Name\",\n    })\n\njourney = Journey(\n    name=\"auth_flow\",\n    description=\"Test authentication and profile operations\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"get_profile\", action=get_profile),\n        Step(name=\"update_profile\", action=update_profile),\n    ],\n)\n</code></pre> <p>Run it:</p> Bash<pre><code>venomqa run auth_flow\n</code></pre>"},{"location":"getting-started/quickstart/#use-checkpoints-and-branches","title":"Use Checkpoints and Branches","text":"<p>VenomQA's power comes from testing multiple scenarios from the same state:</p> Python<pre><code># journeys/checkout.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\n\ndef login(client, context):\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n    context[\"token\"] = response.json()[\"token\"]\n    client.set_auth_token(context[\"token\"])\n    return response\n\ndef add_to_cart(client, context):\n    response = client.post(\"/api/cart/items\", json={\n        \"product_id\": 1,\n        \"quantity\": 2,\n    })\n    context[\"cart_id\"] = response.json()[\"cart_id\"]\n    return response\n\ndef pay_with_card(client, context):\n    return client.post(\"/api/checkout/pay\", json={\n        \"method\": \"credit_card\",\n        \"card_token\": \"tok_test_visa\",\n    })\n\ndef pay_with_wallet(client, context):\n    return client.post(\"/api/checkout/pay\", json={\n        \"method\": \"wallet\",\n    })\n\ndef pay_insufficient_funds(client, context):\n    return client.post(\"/api/checkout/pay\", json={\n        \"method\": \"credit_card\",\n        \"card_token\": \"tok_test_declined\",\n    })\n\njourney = Journey(\n    name=\"checkout_flow\",\n    description=\"Test checkout with multiple payment methods\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"add_to_cart\", action=add_to_cart),\n        Checkpoint(name=\"cart_ready\"),  # Save state here\n        Branch(\n            checkpoint_name=\"cart_ready\",\n            paths=[\n                Path(name=\"credit_card\", steps=[\n                    Step(name=\"pay_card\", action=pay_with_card),\n                ]),\n                Path(name=\"wallet\", steps=[\n                    Step(name=\"pay_wallet\", action=pay_with_wallet),\n                ]),\n                Path(name=\"declined\", steps=[\n                    Step(\n                        name=\"pay_declined\",\n                        action=pay_insufficient_funds,\n                        expect_failure=True,  # We expect this to fail\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre> <p>Run it:</p> Bash<pre><code>venomqa run checkout_flow\n</code></pre> <p>Output:</p> Text Only<pre><code>Running journey: checkout_flow\n  [PASS] login (89ms)\n  [PASS] add_to_cart (45ms)\n  [CHECKPOINT] cart_ready\n\n  Branch: cart_ready\n    Path: credit_card\n      [PASS] pay_card (123ms)\n    Path: wallet\n      [PASS] pay_wallet (98ms)\n    Path: declined\n      [PASS] pay_declined (expected failure) (67ms)\n\nJourney completed: 3/3 paths passed\n</code></pre>"},{"location":"getting-started/quickstart/#generate-reports","title":"Generate Reports","text":"<p>After running tests, generate a report:</p> Bash<pre><code># Markdown report (human-readable)\nvenomqa report --format markdown --output reports/test.md\n\n# JUnit XML (for CI/CD)\nvenomqa report --format junit --output reports/junit.xml\n\n# HTML report (shareable)\nvenomqa report --format html --output reports/test.html\n</code></pre>"},{"location":"getting-started/quickstart/#list-available-journeys","title":"List Available Journeys","text":"Bash<pre><code>venomqa list\n</code></pre> <p>Output:</p> Text Only<pre><code>Found 3 journey(s):\n\n  - hello_world (journeys/hello.py)\n  - auth_flow (journeys/auth_flow.py)\n  - checkout_flow (journeys/checkout.py)\n</code></pre>"},{"location":"getting-started/quickstart/#using-with-docker","title":"Using with Docker","text":"<p>If your API runs in Docker, use the infrastructure management:</p> <p>Create <code>docker-compose.qa.yml</code>:</p> YAML<pre><code>version: \"3.8\"\nservices:\n  api:\n    image: your-api:latest\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      - db\n\n  db:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: qa_test\n      POSTGRES_USER: qa\n      POSTGRES_PASSWORD: secret\n    ports:\n      - \"5432:5432\"\n</code></pre> <p>Update <code>venomqa.yaml</code>:</p> YAML<pre><code>base_url: \"http://localhost:8000\"\ndocker_compose_file: \"docker-compose.qa.yml\"\ndb_url: \"postgresql://qa:secret@localhost:5432/qa_test\"\ndb_backend: \"postgresql\"\n</code></pre> <p>Run with infrastructure:</p> Bash<pre><code>venomqa run  # Starts Docker, runs tests, stops Docker\n</code></pre> <p>Or skip if services are already running:</p> Bash<pre><code>venomqa run --no-infra\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>You've learned the basics! Now explore:</p> <ul> <li>Core Concepts - Deep dive into Journeys, Checkpoints, and Branches</li> <li>Configuration - All configuration options</li> <li>Tutorials - Step-by-step guides for specific scenarios</li> <li>CLI Reference - Complete CLI documentation</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>Complete reference documentation for VenomQA.</p>"},{"location":"reference/#quick-links","title":"Quick Links","text":""},{"location":"reference/#api-reference","title":"API Reference","text":"<p>Complete documentation for all public classes and functions.</p>"},{"location":"reference/#cli-reference","title":"CLI Reference","text":"<p>Command-line interface documentation.</p>"},{"location":"reference/#configuration","title":"Configuration","text":"<p>All configuration options and environment variables.</p>"},{"location":"reference/#database-backends","title":"Database Backends","text":"<p>Configure state management backends.</p>"},{"location":"reference/#adapters","title":"Adapters","text":"<p>Available adapters for external services.</p>"},{"location":"reference/#reporters","title":"Reporters","text":"<p>Report formats and custom reporters.</p>"},{"location":"reference/#api-overview","title":"API Overview","text":""},{"location":"reference/#core-models","title":"Core Models","text":"Python<pre><code>from venomqa import (\n    Journey,          # Complete user scenario\n    Step,             # Single action\n    Checkpoint,       # Database savepoint\n    Branch,           # Multiple paths\n    Path,             # Path within a branch\n)\n</code></pre>"},{"location":"reference/#results","title":"Results","text":"Python<pre><code>from venomqa import (\n    JourneyResult,    # Journey execution result\n    StepResult,       # Step execution result\n    PathResult,       # Path execution result\n    Issue,            # Captured failure\n    Severity,         # Issue severity level\n)\n</code></pre>"},{"location":"reference/#execution","title":"Execution","text":"Python<pre><code>from venomqa import (\n    JourneyRunner,    # Execute journeys\n    Client,           # HTTP client\n    ExecutionContext, # Shared state\n    QAConfig,         # Configuration\n)\n</code></pre>"},{"location":"reference/#state-management","title":"State Management","text":"Python<pre><code>from venomqa.state import (\n    PostgreSQLStateManager,  # PostgreSQL backend\n    SQLiteStateManager,      # SQLite backend\n    BaseStateManager,        # Base class\n)\n</code></pre>"},{"location":"reference/#ports-adapters","title":"Ports &amp; Adapters","text":"Python<pre><code>from venomqa.ports import (\n    CachePort,        # Cache interface\n    MailPort,         # Email interface\n    QueuePort,        # Queue interface\n    # ... more ports\n)\n\nfrom venomqa.adapters import (\n    RedisCacheAdapter,   # Redis cache\n    MailhogAdapter,      # Mailhog email\n    # ... more adapters\n)\n</code></pre>"},{"location":"reference/#cli-commands","title":"CLI Commands","text":"Command Description <code>venomqa run [JOURNEYS]</code> Run journeys <code>venomqa list</code> List available journeys <code>venomqa report</code> Generate reports <code>venomqa --version</code> Show version <code>venomqa --help</code> Show help"},{"location":"reference/#configuration-quick-reference","title":"Configuration Quick Reference","text":"YAML<pre><code># venomqa.yaml\nbase_url: \"http://localhost:8000\"\ndb_url: \"postgresql://user:pass@host:5432/db\"\ndb_backend: \"postgresql\"\ntimeout: 30\nretry_count: 3\nparallel_paths: 1\nfail_fast: false\nverbose: false\nreport_dir: \"reports\"\nreport_formats: [\"markdown\", \"junit\"]\n</code></pre> <p>Environment variables:</p> Bash<pre><code>VENOMQA_BASE_URL=http://api.example.com\nVENOMQA_DB_URL=postgresql://...\nVENOMQA_TIMEOUT=60\nVENOMQA_VERBOSE=true\n</code></pre>"},{"location":"reference/adapters/","title":"Adapters Reference","text":"<p>This document provides detailed configuration and usage information for all available adapters in VenomQA.</p> <p>New to Ports &amp; Adapters? See the Ports Documentation for the architecture overview.</p>"},{"location":"reference/adapters/#available-adapters","title":"Available Adapters","text":"Adapter Port Description Dependencies MailhogAdapter MailPort MailHog email catcher <code>requests</code> MailpitAdapter MailPort Mailpit email catcher <code>requests</code> SMTPMockAdapter MailPort In-memory SMTP server None RedisCacheAdapter CachePort Redis cache backend <code>redis</code> RedisQueueAdapter QueuePort Redis Queue (RQ) <code>redis</code>, <code>rq</code> CeleryQueueAdapter QueuePort Celery task queue <code>celery</code>, <code>redis</code> ElasticsearchAdapter SearchPort Elasticsearch search <code>elasticsearch</code> S3StorageAdapter StoragePort AWS S3 / MinIO <code>boto3</code> LocalStorageAdapter StoragePort Local filesystem None WireMockAdapter MockPort WireMock mock server <code>requests</code> ControllableTimeAdapter TimePort Deterministic time None RealTimeAdapter TimePort Real system time None ThreadingConcurrencyAdapter ConcurrencyPort Thread pool None AsyncConcurrencyAdapter ConcurrencyPort Asyncio None"},{"location":"reference/adapters/#email-adapters","title":"Email Adapters","text":""},{"location":"reference/adapters/#mailhogadapter","title":"MailhogAdapter","text":"<p>Integration with MailHog, a popular email testing tool.</p> Python<pre><code>from venomqa.adapters import MailhogAdapter\n\nadapter = MailhogAdapter(\n    host=\"localhost\",\n    smtp_port=1025,\n    api_port=8025,\n    timeout=10.0,\n)\n</code></pre>"},{"location":"reference/adapters/#configuration","title":"Configuration","text":"Parameter Type Default Description <code>host</code> <code>str</code> <code>\"localhost\"</code> MailHog server hostname <code>smtp_port</code> <code>int</code> <code>1025</code> SMTP server port <code>api_port</code> <code>int</code> <code>8025</code> API server port <code>timeout</code> <code>float</code> <code>10.0</code> Request timeout in seconds"},{"location":"reference/adapters/#environment-variables","title":"Environment Variables","text":"Bash<pre><code>MAILHOG_HOST=localhost\nMAILHOG_SMTP_PORT=1025\nMAILHOG_API_PORT=8025\n</code></pre>"},{"location":"reference/adapters/#docker-setup","title":"Docker Setup","text":"Bash<pre><code>docker run -d -p 1025:1025 -p 8025:8025 mailhog/mailhog\n</code></pre>"},{"location":"reference/adapters/#usage-example","title":"Usage Example","text":"Python<pre><code>adapter = MailhogAdapter()\n\n# Wait for email\nemail = adapter.wait_for_email(\n    to=\"user@example.com\",\n    subject=\"Welcome\",\n    timeout=30.0,\n)\n\nassert email is not None\nassert \"Welcome\" in email.subject\n\n# Clean up\nadapter.delete_all_emails()\n</code></pre>"},{"location":"reference/adapters/#mailpitadapter","title":"MailpitAdapter","text":"<p>Integration with Mailpit, a modern email testing tool.</p> Python<pre><code>from venomqa.adapters import MailpitAdapter\n\nadapter = MailpitAdapter(\n    host=\"localhost\",\n    smtp_port=1025,\n    api_port=8025,\n    timeout=10.0,\n    use_tls=False,\n)\n</code></pre>"},{"location":"reference/adapters/#configuration_1","title":"Configuration","text":"Parameter Type Default Description <code>host</code> <code>str</code> <code>\"localhost\"</code> Mailpit server hostname <code>smtp_port</code> <code>int</code> <code>1025</code> SMTP server port <code>api_port</code> <code>int</code> <code>8025</code> API server port <code>timeout</code> <code>float</code> <code>10.0</code> Request timeout in seconds <code>use_tls</code> <code>bool</code> <code>False</code> Use TLS for SMTP"},{"location":"reference/adapters/#docker-setup_1","title":"Docker Setup","text":"Bash<pre><code>docker run -d -p 1025:1025 -p 8025:8025 axllent/mailpit\n</code></pre>"},{"location":"reference/adapters/#additional-methods","title":"Additional Methods","text":"Python<pre><code># Search emails using Mailpit's search syntax\nemails = adapter.search(\"from:admin@example.com\")\n\n# Get specific email by ID\nemail = adapter.get_message(\"msg_123\")\n\n# Mark email as read\nadapter.set_read(\"msg_123\", read=True)\n</code></pre>"},{"location":"reference/adapters/#smtpmockadapter","title":"SMTPMockAdapter","text":"<p>In-memory SMTP mock server for isolated testing.</p> Python<pre><code>from venomqa.adapters import SMTPMockAdapter\n\nadapter = SMTPMockAdapter(\n    host=\"localhost\",\n    port=2500,\n    timeout=10.0,\n)\n\n# Start the mock server\nadapter.start()\n\n# Use it...\n\n# Stop when done\nadapter.stop()\n</code></pre>"},{"location":"reference/adapters/#configuration_2","title":"Configuration","text":"Parameter Type Default Description <code>host</code> <code>str</code> <code>\"localhost\"</code> Hostname to bind to <code>port</code> <code>int</code> <code>2500</code> Port to listen on <code>timeout</code> <code>float</code> <code>10.0</code> Operation timeout"},{"location":"reference/adapters/#context-manager-usage","title":"Context Manager Usage","text":"Python<pre><code>import smtplib\nfrom email.message import EmailMessage\n\ndef test_with_smtp_mock():\n    mock = SMTPMockAdapter(port=2500)\n    mock.start()\n\n    try:\n        # Send email to mock\n        msg = EmailMessage()\n        msg[\"From\"] = \"sender@example.com\"\n        msg[\"To\"] = \"recipient@example.com\"\n        msg[\"Subject\"] = \"Test\"\n        msg.set_content(\"Hello\")\n\n        with smtplib.SMTP(\"localhost\", 2500) as server:\n            server.send_message(msg)\n\n        # Verify email was captured\n        emails = mock.get_emails_to(\"recipient@example.com\")\n        assert len(emails) == 1\n    finally:\n        mock.stop()\n</code></pre>"},{"location":"reference/adapters/#cache-adapters","title":"Cache Adapters","text":""},{"location":"reference/adapters/#rediscacheadapter","title":"RedisCacheAdapter","text":"<p>Redis cache backend with full TTL and statistics support.</p> Python<pre><code>from venomqa.adapters import RedisCacheAdapter\n\nadapter = RedisCacheAdapter(\n    host=\"localhost\",\n    port=6379,\n    db=0,\n    password=None,\n    prefix=\"venomqa:\",\n    default_ttl=3600,\n)\n</code></pre>"},{"location":"reference/adapters/#configuration_3","title":"Configuration","text":"Parameter Type Default Description <code>host</code> <code>str</code> <code>\"localhost\"</code> Redis server hostname <code>port</code> <code>int</code> <code>6379</code> Redis server port <code>db</code> <code>int</code> <code>0</code> Redis database number <code>password</code> <code>str \\| None</code> <code>None</code> Redis password <code>prefix</code> <code>str</code> <code>\"venomqa:\"</code> Key prefix for namespacing <code>default_ttl</code> <code>int</code> <code>3600</code> Default TTL in seconds"},{"location":"reference/adapters/#environment-variables_1","title":"Environment Variables","text":"Bash<pre><code>REDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_PASSWORD=secret\nREDIS_DB=0\n</code></pre>"},{"location":"reference/adapters/#additional-methods_1","title":"Additional Methods","text":"Python<pre><code># Increment/decrement counters\nadapter.increment(\"counter\", 1)\nadapter.decrement(\"counter\", 1)\n\n# Get or set default\nvalue = adapter.get_or_set(\"key\", default=\"default_value\", ttl=60)\n\n# Set operations\nadapter.add_to_set(\"tags\", \"python\", \"testing\")\ntags = adapter.get_set(\"tags\")\n\n# List operations\nadapter.push_to_list(\"queue\", \"item1\", \"item2\")\nitems = adapter.get_list(\"queue\")\n\n# Hash operations\nadapter.set_hash(\"user:1\", \"name\", \"John\")\nname = adapter.get_hash(\"user:1\", \"name\")\nuser_data = adapter.get_all_hash(\"user:1\")\n</code></pre>"},{"location":"reference/adapters/#queue-adapters","title":"Queue Adapters","text":""},{"location":"reference/adapters/#redisqueueadapter","title":"RedisQueueAdapter","text":"<p>Redis Queue (RQ) integration for job queue testing.</p> Python<pre><code>from venomqa.adapters import RedisQueueAdapter\n\nadapter = RedisQueueAdapter(\n    host=\"localhost\",\n    port=6379,\n    db=0,\n    password=None,\n    default_queue=\"default\",\n)\n</code></pre>"},{"location":"reference/adapters/#configuration_4","title":"Configuration","text":"Parameter Type Default Description <code>host</code> <code>str</code> <code>\"localhost\"</code> Redis server hostname <code>port</code> <code>int</code> <code>6379</code> Redis server port <code>db</code> <code>int</code> <code>0</code> Redis database number <code>password</code> <code>str \\| None</code> <code>None</code> Redis password <code>default_queue</code> <code>str</code> <code>\"default\"</code> Default queue name"},{"location":"reference/adapters/#installation","title":"Installation","text":"Bash<pre><code>pip install redis rq\n</code></pre>"},{"location":"reference/adapters/#usage-example_1","title":"Usage Example","text":"Python<pre><code>def process_data(data):\n    return data * 2\n\n# Enqueue job\njob_id = adapter.enqueue(process_data, {\"key\": \"value\"}, queue=\"processing\")\n\n# Wait for result\nresult = adapter.get_job_result(job_id, timeout=60.0)\nif result and result.success:\n    print(f\"Result: {result.result}\")\n\n# Check queue length\nqueue_length = adapter.get_queue_length(\"processing\")\n\n# Get failed jobs\nfailed = adapter.get_failed_jobs()\n\n# Get worker info\nworkers = adapter.get_workers()\n</code></pre>"},{"location":"reference/adapters/#celeryqueueadapter","title":"CeleryQueueAdapter","text":"<p>Celery task queue integration for distributed task testing.</p> Python<pre><code>from venomqa.adapters import CeleryQueueAdapter\n\nadapter = CeleryQueueAdapter(\n    broker_url=\"redis://localhost:6379/0\",\n    result_backend=\"redis://localhost:6379/1\",\n    default_queue=\"celery\",\n)\n</code></pre>"},{"location":"reference/adapters/#configuration_5","title":"Configuration","text":"Parameter Type Default Description <code>broker_url</code> <code>str</code> <code>\"redis://localhost:6379/0\"</code> Celery broker URL <code>result_backend</code> <code>str</code> <code>\"redis://localhost:6379/1\"</code> Result backend URL <code>default_queue</code> <code>str</code> <code>\"celery\"</code> Default queue name"},{"location":"reference/adapters/#installation_1","title":"Installation","text":"Bash<pre><code>pip install celery redis\n</code></pre>"},{"location":"reference/adapters/#usage-example_2","title":"Usage Example","text":"Python<pre><code># Enqueue task by name\njob_id = adapter.enqueue(\"myapp.tasks.send_email\", to=\"user@example.com\")\n\n# Wait for result\nresult = adapter.get_job_result(job_id, timeout=30.0)\n\n# Advanced scheduling\njob_id = adapter.apply_async(\n    \"myapp.tasks.process\",\n    args=(\"data\",),\n    kwargs={\"option\": True},\n    queue=\"priority\",\n    countdown=10,  # Delay 10 seconds\n)\n\n# Get registered tasks\ntasks = adapter.get_registered_tasks()\n\n# Get worker info\nworkers = adapter.get_workers()\n</code></pre>"},{"location":"reference/adapters/#search-adapters","title":"Search Adapters","text":""},{"location":"reference/adapters/#elasticsearchadapter","title":"ElasticsearchAdapter","text":"<p>Elasticsearch integration for full-text search testing.</p> Python<pre><code>from venomqa.adapters import ElasticsearchAdapter\n\nadapter = ElasticsearchAdapter(\n    hosts=[\"http://localhost:9200\"],\n    cloud_id=None,\n    api_key=None,\n    basic_auth=None,\n    timeout=30,\n    verify_certs=True,\n)\n</code></pre>"},{"location":"reference/adapters/#configuration_6","title":"Configuration","text":"Parameter Type Default Description <code>hosts</code> <code>list[str] \\| None</code> <code>None</code> List of Elasticsearch hosts <code>cloud_id</code> <code>str \\| None</code> <code>None</code> Elastic Cloud ID <code>api_key</code> <code>str \\| None</code> <code>None</code> API key for authentication <code>basic_auth</code> <code>tuple \\| None</code> <code>None</code> (username, password) tuple <code>timeout</code> <code>int</code> <code>30</code> Request timeout in seconds <code>verify_certs</code> <code>bool</code> <code>True</code> Verify SSL certificates"},{"location":"reference/adapters/#installation_2","title":"Installation","text":"Bash<pre><code>pip install elasticsearch\n</code></pre>"},{"location":"reference/adapters/#usage-example_3","title":"Usage Example","text":"Python<pre><code>from venomqa.ports import IndexedDocument\n\n# Create index\nadapter.create_index(\"products\", settings={\n    \"number_of_shards\": 1,\n    \"number_of_replicas\": 0,\n})\n\n# Index document\ndoc = IndexedDocument(\n    id=\"prod_1\",\n    content=\"Ergonomic office chair with lumbar support\",\n    title=\"Office Chair\",\n    fields={\"price\": 299.99, \"category\": \"furniture\"},\n    tags=[\"office\", \"furniture\"],\n)\nadapter.index_document(\"products\", doc, refresh=True)\n\n# Search\nresults, total = adapter.search(\n    \"products\",\n    query=\"chair\",\n    fields=[\"title\", \"content\"],\n    limit=10,\n)\n\n# Bulk index\ndocuments = [IndexedDocument(id=f\"prod_{i}\", content=f\"Product {i}\") for i in range(100)]\ncount = adapter.index_documents(\"products\", documents)\n\n# Get document\ndoc = adapter.get_document(\"products\", \"prod_1\")\n\n# Scroll through all results\nfor batch in adapter.scroll_search(\"products\", \"chair\", size=100):\n    for result in batch:\n        print(result.id, result.score)\n\n# Cluster health\nhealth = adapter.get_cluster_health()\n</code></pre>"},{"location":"reference/adapters/#storage-adapters","title":"Storage Adapters","text":""},{"location":"reference/adapters/#s3storageadapter","title":"S3StorageAdapter","text":"<p>AWS S3 and S3-compatible storage (MinIO, DigitalOcean Spaces, etc.).</p> Python<pre><code>from venomqa.adapters import S3StorageAdapter\n\nadapter = S3StorageAdapter(\n    endpoint_url=None,  # Use AWS S3\n    region_name=\"us-east-1\",\n    aws_access_key_id=None,\n    aws_secret_access_key=None,\n)\n</code></pre>"},{"location":"reference/adapters/#configuration_7","title":"Configuration","text":"Parameter Type Default Description <code>endpoint_url</code> <code>str \\| None</code> <code>None</code> S3 endpoint (for MinIO, etc.) <code>region_name</code> <code>str</code> <code>\"us-east-1\"</code> AWS region <code>aws_access_key_id</code> <code>str \\| None</code> <code>None</code> AWS access key <code>aws_secret_access_key</code> <code>str \\| None</code> <code>None</code> AWS secret key"},{"location":"reference/adapters/#environment-variables_2","title":"Environment Variables","text":"Bash<pre><code>AWS_ACCESS_KEY_ID=your_access_key\nAWS_SECRET_ACCESS_KEY=your_secret_key\nAWS_REGION=us-east-1\nS3_ENDPOINT=http://localhost:9000  # For MinIO\n</code></pre>"},{"location":"reference/adapters/#installation_3","title":"Installation","text":"Bash<pre><code>pip install boto3\n</code></pre>"},{"location":"reference/adapters/#usage-example_4","title":"Usage Example","text":"Python<pre><code># Create bucket\nadapter.create_bucket(\"test-bucket\")\n\n# Upload\nadapter.upload(\"test-bucket\", \"file.txt\", b\"Hello World\", content_type=\"text/plain\")\n\n# Download\ndata = adapter.download(\"test-bucket\", \"file.txt\")\nprint(data.decode())\n\n# Check existence\nexists = adapter.exists(\"test-bucket\", \"file.txt\")\n\n# List objects\nfor obj in adapter.list_objects(\"test-bucket\", prefix=\"files/\"):\n    print(obj.key, obj.size)\n\n# Presigned URL\nurl = adapter.get_presigned_url(\"test-bucket\", \"file.txt\", expires_in=3600)\n\n# Copy/move\nadapter.copy(\"test-bucket\", \"file.txt\", \"backup-bucket\", \"backup.txt\")\nadapter.move(\"test-bucket\", \"old.txt\", \"test-bucket\", \"new.txt\")\n\n# Tags\nadapter.set_object_tags(\"test-bucket\", \"file.txt\", {\"env\": \"test\", \"type\": \"data\"})\ntags = adapter.get_object_tags(\"test-bucket\", \"file.txt\")\n\n# Cleanup\nadapter.delete(\"test-bucket\", \"file.txt\")\nadapter.delete_bucket(\"test-bucket\", force=True)\n</code></pre>"},{"location":"reference/adapters/#minio-example","title":"MinIO Example","text":"Python<pre><code>adapter = S3StorageAdapter(\n    endpoint_url=\"http://localhost:9000\",\n    region_name=\"us-east-1\",\n    aws_access_key_id=\"minioadmin\",\n    aws_secret_access_key=\"minioadmin\",\n)\n</code></pre>"},{"location":"reference/adapters/#localstorageadapter","title":"LocalStorageAdapter","text":"<p>Local filesystem storage for testing without external dependencies.</p> Python<pre><code>from venomqa.adapters import LocalStorageAdapter\n\nadapter = LocalStorageAdapter(\n    base_path=\"./storage\",\n    create_dirs=True,\n    hash_key_paths=False,\n)\n</code></pre>"},{"location":"reference/adapters/#configuration_8","title":"Configuration","text":"Parameter Type Default Description <code>base_path</code> <code>str</code> <code>\"./storage\"</code> Base directory for storage <code>create_dirs</code> <code>bool</code> <code>True</code> Create directories automatically <code>hash_key_paths</code> <code>bool</code> <code>False</code> Hash keys for file paths"},{"location":"reference/adapters/#usage-example_5","title":"Usage Example","text":"Python<pre><code>adapter = LocalStorageAdapter(base_path=\"/tmp/test-storage\")\n\n# Create bucket (directory)\nadapter.create_bucket(\"test\")\n\n# Upload\nadapter.upload(\"test\", \"data.json\", b'{\"key\": \"value\"}')\n\n# Download\ndata = adapter.download(\"test\", \"data.json\")\n\n# List buckets\nbuckets = adapter.list_buckets()\n\n# Get bucket size\nsize = adapter.get_bucket_size(\"test\")\n\n# Clear bucket\ncount = adapter.clear_bucket(\"test\")\n</code></pre>"},{"location":"reference/adapters/#mock-adapters","title":"Mock Adapters","text":""},{"location":"reference/adapters/#wiremockadapter","title":"WireMockAdapter","text":"<p>WireMock integration for HTTP mocking.</p> Python<pre><code>from venomqa.adapters import WireMockAdapter\n\nadapter = WireMockAdapter(\n    host=\"localhost\",\n    port=8080,\n    timeout=10.0,\n)\n</code></pre>"},{"location":"reference/adapters/#configuration_9","title":"Configuration","text":"Parameter Type Default Description <code>host</code> <code>str</code> <code>\"localhost\"</code> WireMock server hostname <code>port</code> <code>int</code> <code>8080</code> WireMock server port <code>timeout</code> <code>float</code> <code>10.0</code> Request timeout in seconds"},{"location":"reference/adapters/#docker-setup_2","title":"Docker Setup","text":"Bash<pre><code>docker run -d -p 8080:8080 wiremock/wiremock\n</code></pre>"},{"location":"reference/adapters/#usage-example_6","title":"Usage Example","text":"Python<pre><code>from venomqa.ports import MockResponse\n\nadapter = WireMockAdapter()\n\n# Simple stub\nadapter.stub(\"GET\", \"/api/users\", body={\"users\": []}, status_code=200)\n\n# Stub with delay\nadapter.stub(\"GET\", \"/api/slow\", body={\"data\": \"...\"}, delay=2.0)\n\n# Stub with custom headers\nadapter.stub(\n    \"POST\", \"/api/auth\",\n    body={\"token\": \"abc123\"},\n    headers={\"X-Request-Id\": \"test-123\"},\n)\n\n# Sequential responses\nadapter.stub_sequence(\"GET\", \"/api/status\", responses=[\n    MockResponse(status_code=503, body={\"status\": \"starting\"}),\n    MockResponse(status_code=200, body={\"status\": \"ready\"}),\n])\n\n# Verify requests\nassert adapter.verify(\"GET\", \"/api/users\", count=1)\nassert adapter.verify(\"GET\", \"/api/users\", at_least=1)\n\n# Get recorded requests\nrequests = adapter.get_requests(method=\"GET\", path=\"/api/users\")\nfor req in requests:\n    print(f\"{req.method} {req.path}\")\n\n# Global delay\nadapter.set_global_delay(0.5)\n\n# Reset\nadapter.reset()\n\n# Get base URL for making requests\nbase_url = adapter.get_base_url()  # http://localhost:8080\n</code></pre>"},{"location":"reference/adapters/#time-adapters","title":"Time Adapters","text":""},{"location":"reference/adapters/#controllabletimeadapter","title":"ControllableTimeAdapter","text":"<p>Deterministic time for testing time-dependent functionality.</p> Python<pre><code>from datetime import timedelta\nfrom venomqa.adapters import ControllableTimeAdapter\n\nadapter = ControllableTimeAdapter(\n    initial_time=None,\n    timezone_name=\"UTC\",\n)\n</code></pre>"},{"location":"reference/adapters/#configuration_10","title":"Configuration","text":"Parameter Type Default Description <code>initial_time</code> <code>datetime \\| None</code> <code>None</code> Starting time (defaults to now) <code>timezone_name</code> <code>str</code> <code>\"UTC\"</code> Timezone name"},{"location":"reference/adapters/#usage-example_7","title":"Usage Example","text":"Python<pre><code>from datetime import datetime, timedelta\n\nadapter = ControllableTimeAdapter()\n\n# Freeze time\nadapter.freeze()\nnow = adapter.now()\nadapter.advance(timedelta(hours=1))\nassert adapter.now() &gt; now\n\n# Set specific time\nadapter.set_time(datetime(2024, 1, 1, 12, 0, 0))\n\n# Sleep advances time instantly when frozen\nadapter.sleep(60)  # Advances 60 seconds instantly\n\n# Schedule tasks\ndef callback():\n    print(\"Task executed!\")\n\ntask_id = adapter.schedule_after(30.0, callback)\nadapter.advance(timedelta(seconds=30))  # Triggers callback\n\n# Unfreeze to use real time\nadapter.unfreeze()\n\n# Reset everything\nadapter.reset()\n</code></pre>"},{"location":"reference/adapters/#realtimeadapter","title":"RealTimeAdapter","text":"<p>Real system time for production use.</p> Python<pre><code>from venomqa.adapters import RealTimeAdapter\n\nadapter = RealTimeAdapter(timezone_name=\"UTC\")\n</code></pre>"},{"location":"reference/adapters/#usage-example_8","title":"Usage Example","text":"Python<pre><code>adapter = RealTimeAdapter()\n\n# Get current time\nnow = adapter.now()\ntimestamp = adapter.timestamp()\n\n# Real sleep\nadapter.sleep(1.0)  # Actually sleeps 1 second\n\n# Schedule real tasks\ndef callback():\n    print(\"Executed after delay!\")\n\ntask_id = adapter.schedule_after(5.0, callback)\n# ... 5 seconds later, callback runs\n\n# Cancel scheduled task\nadapter.cancel_schedule(task_id)\n</code></pre>"},{"location":"reference/adapters/#concurrency-adapters","title":"Concurrency Adapters","text":""},{"location":"reference/adapters/#threadingconcurrencyadapter","title":"ThreadingConcurrencyAdapter","text":"<p>Thread-based parallel execution.</p> Python<pre><code>from venomqa.adapters import ThreadingConcurrencyAdapter\n\nadapter = ThreadingConcurrencyAdapter(\n    max_workers=4,\n    thread_name_prefix=\"venomqa-\",\n)\n</code></pre>"},{"location":"reference/adapters/#configuration_11","title":"Configuration","text":"Parameter Type Default Description <code>max_workers</code> <code>int</code> <code>4</code> Maximum worker threads <code>thread_name_prefix</code> <code>str</code> <code>\"venomqa-\"</code> Thread name prefix"},{"location":"reference/adapters/#usage-example_9","title":"Usage Example","text":"Python<pre><code>def process_item(item):\n    return item * 2\n\nadapter = ThreadingConcurrencyAdapter(max_workers=4)\n\n# Spawn task\ntask_id = adapter.spawn(process_item, 21)\n\n# Wait for result\nresult = adapter.join(task_id, timeout=10.0)\nprint(result.result)  # 42\n\n# Spawn multiple tasks\ntask_ids = adapter.spawn_many([process_item] * 10)\n\n# Wait for all\nresults = adapter.join_all(task_ids)\n\n# Map in parallel\nresults = adapter.map_parallel(process_item, range(10), max_workers=4)\n\n# Check task status\nif adapter.is_completed(task_id):\n    result = adapter.get_result(task_id)\n\n# Shutdown\nadapter.shutdown(wait=True)\n</code></pre>"},{"location":"reference/adapters/#asyncconcurrencyadapter","title":"AsyncConcurrencyAdapter","text":"<p>Asyncio-based parallel execution for async functions.</p> Python<pre><code>from venomqa.adapters import AsyncConcurrencyAdapter\n\nadapter = AsyncConcurrencyAdapter(max_concurrent=10)\n</code></pre>"},{"location":"reference/adapters/#usage-example_10","title":"Usage Example","text":"Python<pre><code>import asyncio\n\nasync def async_process(item):\n    await asyncio.sleep(0.1)\n    return item * 2\n\nasync def main():\n    adapter = AsyncConcurrencyAdapter(max_concurrent=10)\n\n    # Spawn async task\n    task_id = await adapter.spawn_async(async_process, 21)\n\n    # Wait for result\n    result = await adapter.join_async(task_id)\n    print(result.result)  # 42\n\n    # Parallel map\n    results = await adapter.map_parallel_async(async_process, range(10))\n\nasyncio.run(main())\n</code></pre>"},{"location":"reference/adapters/#adapter-registry","title":"Adapter Registry","text":"<p>You can register and retrieve adapters by name:</p> Python<pre><code>from venomqa.adapters import register_adapter, get_adapter, list_adapters\n\n# Register adapter\n@register_adapter(\"my_custom\")\nclass MyCustomAdapter(CachePort):\n    pass\n\n# Or register directly\nregister_adapter_class(\"another\", AnotherAdapter)\n\n# Get adapter class\nadapter_class = get_adapter(\"my_custom\")\n\n# List all adapters\nnames = list_adapters()\n</code></pre>"},{"location":"reference/api/","title":"API Reference","text":"<p>This document provides a comprehensive reference for all public classes and functions in VenomQA.</p> <p>Quick Start: New to VenomQA? See the Getting Started Guide first.</p>"},{"location":"reference/api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Core Models</li> <li>Journey</li> <li>Step</li> <li>Checkpoint</li> <li>Branch</li> <li>Path</li> <li>Result Models</li> <li>JourneyResult</li> <li>StepResult</li> <li>PathResult</li> <li>Issue</li> <li>Severity</li> <li>Execution</li> <li>JourneyRunner</li> <li>ExecutionContext</li> <li>Client</li> <li>Client</li> <li>AsyncClient</li> <li>RequestRecord</li> <li>Configuration</li> <li>QAConfig</li> <li>load_config</li> <li>State Management</li> <li>StateManager Protocol</li> <li>PostgreSQLStateManager</li> <li>Reporters</li> <li>BaseReporter</li> <li>MarkdownReporter</li> <li>JSONReporter</li> <li>JUnitReporter</li> <li>Infrastructure</li> <li>InfrastructureManager Protocol</li> <li>DockerInfrastructureManager</li> </ul>"},{"location":"reference/api/#related-documentation","title":"Related Documentation","text":"Topic Document Writing Journeys journeys.md Database Backends backends.md CLI Reference cli.md Ports &amp; Adapters ports.md Advanced Usage advanced.md FAQ FAQ.md"},{"location":"reference/api/#core-models","title":"Core Models","text":""},{"location":"reference/api/#journey","title":"Journey","text":"<p>A complete user scenario from start to finish. Contains a sequence of Steps, Checkpoints, and Branches.</p> Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch\n\njourney = Journey(\n    name=\"user_registration\",\n    description=\"Complete user registration flow\",\n    tags=[\"auth\", \"critical\"],\n    timeout=120.0,\n    steps=[\n        Step(name=\"register\", action=register_user),\n        Checkpoint(name=\"user_created\"),\n        Step(name=\"verify_email\", action=verify_email),\n    ],\n)\n</code></pre>"},{"location":"reference/api/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>name</code> <code>str</code> Required Unique identifier for the journey <code>steps</code> <code>list[Step \\| Checkpoint \\| Branch]</code> Required Sequence of steps to execute <code>description</code> <code>str</code> <code>\"\"</code> Human-readable description <code>tags</code> <code>list[str]</code> <code>[]</code> Tags for filtering/categorization <code>timeout</code> <code>float \\| None</code> <code>None</code> Maximum execution time in seconds"},{"location":"reference/api/#methods","title":"Methods","text":"Method Return Type Description <code>_validate_checkpoints()</code> <code>None</code> Validates that all Branch references point to existing Checkpoints"},{"location":"reference/api/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code>: If a Branch references a non-existent checkpoint</li> </ul>"},{"location":"reference/api/#step","title":"Step","text":"<p>A single action in a journey with optional assertions.</p> Python<pre><code>from venomqa import Step\n\ndef login_action(client, context):\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n    context[\"token\"] = response.json()[\"token\"]\n    return response\n\nstep = Step(\n    name=\"login\",\n    action=login_action,\n    description=\"Authenticate user\",\n    timeout=10.0,\n    retries=3,\n    expect_failure=False,\n)\n</code></pre>"},{"location":"reference/api/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>name</code> <code>str</code> Required Unique identifier for the step <code>action</code> <code>Callable[[Client, ExecutionContext], Any]</code> Required Function to execute <code>description</code> <code>str</code> <code>\"\"</code> Human-readable description <code>expect_failure</code> <code>bool</code> <code>False</code> If True, step passes when action fails <code>timeout</code> <code>float \\| None</code> <code>None</code> Maximum execution time in seconds <code>retries</code> <code>int</code> <code>0</code> Number of retry attempts on failure"},{"location":"reference/api/#action-function-signature","title":"Action Function Signature","text":"Python<pre><code>def action(client: Client, context: ExecutionContext) -&gt; Any:\n    \"\"\"\n    Args:\n        client: HTTP client for making requests\n        context: Execution context for sharing data between steps\n\n    Returns:\n        Any: Typically an httpx.Response object\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/api/#checkpoint","title":"Checkpoint","text":"<p>A savepoint for database state that enables rollback.</p> Python<pre><code>from venomqa import Checkpoint\n\ncheckpoint = Checkpoint(name=\"user_created\")\n</code></pre>"},{"location":"reference/api/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>name</code> <code>str</code> Required Unique identifier for the checkpoint"},{"location":"reference/api/#branch","title":"Branch","text":"<p>Forks execution to explore multiple paths from a checkpoint.</p> Python<pre><code>from venomqa import Branch, Path, Step\n\nbranch = Branch(\n    checkpoint_name=\"order_created\",\n    paths=[\n        Path(name=\"card_payment\", steps=[\n            Step(name=\"pay_card\", action=pay_with_card),\n        ]),\n        Path(name=\"wallet_payment\", steps=[\n            Step(name=\"pay_wallet\", action=pay_with_wallet),\n        ]),\n    ],\n)\n</code></pre>"},{"location":"reference/api/#parameters_3","title":"Parameters","text":"Parameter Type Default Description <code>checkpoint_name</code> <code>str</code> Required Name of the checkpoint to rollback to <code>paths</code> <code>list[Path]</code> Required List of paths to explore"},{"location":"reference/api/#path","title":"Path","text":"<p>A sequence of steps within a branch.</p> Python<pre><code>from venomqa import Path, Step\n\npath = Path(\n    name=\"successful_payment\",\n    description=\"Happy path for payment processing\",\n    steps=[\n        Step(name=\"submit_payment\", action=submit_payment),\n        Step(name=\"verify_receipt\", action=verify_receipt),\n    ],\n)\n</code></pre>"},{"location":"reference/api/#parameters_4","title":"Parameters","text":"Parameter Type Default Description <code>name</code> <code>str</code> Required Unique identifier for the path <code>steps</code> <code>list[Step \\| Checkpoint]</code> Required Sequence of steps to execute <code>description</code> <code>str</code> <code>\"\"</code> Human-readable description"},{"location":"reference/api/#result-models","title":"Result Models","text":""},{"location":"reference/api/#journeyresult","title":"JourneyResult","text":"<p>Result of executing a complete journey.</p> Python<pre><code>@dataclass\nclass JourneyResult:\n    journey_name: str\n    success: bool\n    started_at: datetime\n    finished_at: datetime\n    step_results: list[StepResult]\n    branch_results: list[BranchResult]\n    issues: list[Issue]\n    duration_ms: float\n</code></pre>"},{"location":"reference/api/#properties","title":"Properties","text":"Property Type Description <code>total_steps</code> <code>int</code> Total number of steps executed <code>passed_steps</code> <code>int</code> Number of successful steps <code>total_paths</code> <code>int</code> Total number of branch paths executed <code>passed_paths</code> <code>int</code> Number of successful paths"},{"location":"reference/api/#stepresult","title":"StepResult","text":"<p>Result of executing a single step.</p> Python<pre><code>@dataclass\nclass StepResult:\n    step_name: str\n    success: bool\n    started_at: datetime\n    finished_at: datetime\n    response: dict[str, Any] | None\n    error: str | None\n    request: dict[str, Any] | None\n    duration_ms: float\n</code></pre>"},{"location":"reference/api/#pathresult","title":"PathResult","text":"<p>Result of executing a path within a branch.</p> Python<pre><code>@dataclass\nclass PathResult:\n    path_name: str\n    success: bool\n    step_results: list[StepResult]\n    error: str | None\n</code></pre>"},{"location":"reference/api/#issue","title":"Issue","text":"<p>Captured failure with full context.</p> Python<pre><code>@dataclass\nclass Issue:\n    journey: str\n    path: str\n    step: str\n    error: str\n    severity: Severity\n    request: dict[str, Any] | None\n    response: dict[str, Any] | None\n    logs: list[str]\n    suggestion: str\n    timestamp: datetime\n</code></pre>"},{"location":"reference/api/#auto-generated-suggestions","title":"Auto-Generated Suggestions","text":"<p>The <code>Issue</code> class automatically generates fix suggestions based on error patterns:</p> Error Pattern Suggestion <code>401</code> Check authentication - token may be invalid or expired <code>403</code> Permission denied - check user roles and permissions <code>404</code> Endpoint not found - verify route registration and URL path <code>422</code> Validation error - check request body schema <code>500</code> Server error - check backend logs for exception traceback <code>timeout</code> Operation timed out - check if service is healthy <code>connection refused</code> Service not running - check Docker or network"},{"location":"reference/api/#severity","title":"Severity","text":"<p>Issue severity levels.</p> Python<pre><code>from venomqa import Severity\n\nclass Severity(Enum):\n    CRITICAL = \"critical\"\n    HIGH = \"high\"\n    MEDIUM = \"medium\"\n    LOW = \"low\"\n    INFO = \"info\"\n</code></pre>"},{"location":"reference/api/#execution","title":"Execution","text":""},{"location":"reference/api/#journeyrunner","title":"JourneyRunner","text":"<p>Executes journeys with state branching and rollback support.</p> Python<pre><code>from venomqa import JourneyRunner, Client\nfrom venomqa.state import PostgreSQLStateManager\n\nclient = Client(base_url=\"http://localhost:8000\")\nstate_manager = PostgreSQLStateManager(\"postgresql://qa:secret@localhost/qa_test\")\n\nrunner = JourneyRunner(\n    client=client,\n    state_manager=state_manager,\n    parallel_paths=4,\n    fail_fast=False,\n    capture_logs=True,\n    log_lines=50,\n)\n\nresult = runner.run(journey)\n</code></pre>"},{"location":"reference/api/#parameters_5","title":"Parameters","text":"Parameter Type Default Description <code>client</code> <code>Client</code> Required HTTP client for requests <code>state_manager</code> <code>StateManager \\| None</code> <code>None</code> State manager for checkpoints <code>parallel_paths</code> <code>int</code> <code>1</code> Max concurrent branch paths <code>fail_fast</code> <code>bool</code> <code>False</code> Stop on first failure <code>capture_logs</code> <code>bool</code> <code>True</code> Capture infrastructure logs <code>log_lines</code> <code>int</code> <code>50</code> Number of log lines to capture"},{"location":"reference/api/#methods_1","title":"Methods","text":"Method Return Type Description <code>run(journey: Journey)</code> <code>JourneyResult</code> Execute a complete journey <code>get_issues()</code> <code>list[Issue]</code> Get all captured issues"},{"location":"reference/api/#executioncontext","title":"ExecutionContext","text":"<p>Typed context for sharing state between steps.</p> Python<pre><code>from venomqa.core.context import ExecutionContext\n\ncontext = ExecutionContext()\n\n# Store values\ncontext[\"user_id\"] = 123\ncontext.set(\"token\", \"abc123\")\n\n# Retrieve values\nuser_id = context[\"user_id\"]\ntoken = context.get(\"token\")\nrequired_value = context.get_required(\"user_id\")  # Raises KeyError if missing\n\n# Store step results\ncontext.store_step_result(\"login\", response.json())\n\n# Get previous step result\nlogin_result = context.get_step_result(\"login\")\n\n# Snapshot and restore\nsnapshot = context.snapshot()\ncontext.restore(snapshot)\n</code></pre>"},{"location":"reference/api/#methods_2","title":"Methods","text":"Method Return Type Description <code>set(key, value)</code> <code>None</code> Store a value <code>get(key, default=None)</code> <code>Any</code> Retrieve a value <code>get_required(key)</code> <code>Any</code> Retrieve value or raise KeyError <code>store_step_result(name, result)</code> <code>None</code> Store step result <code>get_step_result(name)</code> <code>Any</code> Get previous step result <code>clear()</code> <code>None</code> Clear all data <code>snapshot()</code> <code>dict</code> Create context snapshot <code>restore(snapshot)</code> <code>None</code> Restore from snapshot <code>to_dict()</code> <code>dict</code> Export as dictionary"},{"location":"reference/api/#client","title":"Client","text":""},{"location":"reference/api/#client-class","title":"Client Class","text":"<p>HTTP client with history tracking and retry logic.</p> Python<pre><code>from venomqa import Client\n\nclient = Client(\n    base_url=\"http://localhost:8000\",\n    timeout=30.0,\n    retry_count=3,\n    retry_delay=1.0,\n    default_headers={\"X-API-Key\": \"secret\"},\n)\n\n# Connect (optional - auto-connects on first request)\nclient.connect()\n\n# Set authentication\nclient.set_auth_token(\"my-jwt-token\")\nclient.set_auth_token(\"my-api-key\", scheme=\"ApiKey\")\n\n# Make requests\nresponse = client.get(\"/api/users\")\nresponse = client.post(\"/api/users\", json={\"name\": \"John\"})\nresponse = client.put(\"/api/users/1\", json={\"name\": \"Jane\"})\nresponse = client.patch(\"/api/users/1\", json={\"active\": False})\nresponse = client.delete(\"/api/users/1\")\n\n# Access history\nhistory = client.get_history()\nlast = client.last_request()\n\n# Clear history\nclient.clear_history()\n\n# Disconnect\nclient.disconnect()\n</code></pre>"},{"location":"reference/api/#parameters_6","title":"Parameters","text":"Parameter Type Default Description <code>base_url</code> <code>str</code> Required Base URL for all requests <code>timeout</code> <code>float</code> <code>30.0</code> Request timeout in seconds <code>retry_count</code> <code>int</code> <code>3</code> Number of retry attempts <code>retry_delay</code> <code>float</code> <code>1.0</code> Base delay between retries <code>default_headers</code> <code>dict \\| None</code> <code>None</code> Headers for all requests"},{"location":"reference/api/#methods_3","title":"Methods","text":"Method Description <code>connect()</code> Initialize the HTTP client <code>disconnect()</code> Close the HTTP client <code>set_auth_token(token, scheme=\"Bearer\")</code> Set authentication header <code>clear_auth()</code> Clear authentication <code>request(method, path, **kwargs)</code> Make HTTP request <code>get(path, **kwargs)</code> GET request <code>post(path, **kwargs)</code> POST request <code>put(path, **kwargs)</code> PUT request <code>patch(path, **kwargs)</code> PATCH request <code>delete(path, **kwargs)</code> DELETE request <code>get_history()</code> Get all request records <code>clear_history()</code> Clear request history <code>last_request()</code> Get most recent request"},{"location":"reference/api/#asyncclient","title":"AsyncClient","text":"<p>Async HTTP client with the same interface as <code>Client</code>.</p> Python<pre><code>from venomqa.client import AsyncClient\n\nasync def run_tests():\n    client = AsyncClient(base_url=\"http://localhost:8000\")\n    await client.connect()\n\n    response = await client.get(\"/api/users\")\n\n    await client.disconnect()\n</code></pre>"},{"location":"reference/api/#requestrecord","title":"RequestRecord","text":"<p>Record of an HTTP request/response.</p> Python<pre><code>@dataclass\nclass RequestRecord:\n    method: str\n    url: str\n    request_body: Any | None\n    response_status: int\n    response_body: Any | None\n    headers: dict[str, str]\n    duration_ms: float\n    timestamp: datetime\n    error: str | None\n</code></pre>"},{"location":"reference/api/#configuration","title":"Configuration","text":""},{"location":"reference/api/#qaconfig","title":"QAConfig","text":"<p>Configuration settings for VenomQA.</p> Python<pre><code>from venomqa import QAConfig\n\nconfig = QAConfig(\n    base_url=\"http://localhost:8000\",\n    db_url=\"postgresql://qa:secret@localhost:5432/qa_test\",\n    db_backend=\"postgresql\",\n    docker_compose_file=\"docker-compose.qa.yml\",\n    timeout=30,\n    retry_count=3,\n    retry_delay=1.0,\n    capture_logs=True,\n    log_lines=50,\n    parallel_paths=1,\n    report_dir=\"reports\",\n    report_formats=[\"markdown\", \"junit\"],\n    verbose=False,\n    fail_fast=False,\n)\n</code></pre>"},{"location":"reference/api/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>base_url</code> <code>str</code> <code>\"http://localhost:8000\"</code> API base URL <code>db_url</code> <code>str \\| None</code> <code>None</code> Database connection URL <code>db_backend</code> <code>str</code> <code>\"postgresql\"</code> Database backend type <code>docker_compose_file</code> <code>str</code> <code>\"docker-compose.qa.yml\"</code> Docker compose file path <code>timeout</code> <code>int</code> <code>30</code> Request timeout in seconds <code>retry_count</code> <code>int</code> <code>3</code> Number of retry attempts <code>retry_delay</code> <code>float</code> <code>1.0</code> Delay between retries <code>capture_logs</code> <code>bool</code> <code>True</code> Capture infrastructure logs <code>log_lines</code> <code>int</code> <code>50</code> Number of log lines to capture <code>parallel_paths</code> <code>int</code> <code>1</code> Max concurrent branch paths <code>report_dir</code> <code>str</code> <code>\"reports\"</code> Output directory for reports <code>report_formats</code> <code>list[str]</code> <code>[\"markdown\"]</code> Report formats to generate <code>verbose</code> <code>bool</code> <code>False</code> Enable verbose logging <code>fail_fast</code> <code>bool</code> <code>False</code> Stop on first failure"},{"location":"reference/api/#environment-variables","title":"Environment Variables","text":"<p>All options can be overridden with <code>VENOMQA_</code> prefixed environment variables:</p> Bash<pre><code>export VENOMQA_BASE_URL=\"http://api.example.com\"\nexport VENOMQA_DB_URL=\"postgresql://user:pass@host/db\"\nexport VENOMQA_TIMEOUT=60\nexport VENOMQA_VERBOSE=true\n</code></pre>"},{"location":"reference/api/#load_config","title":"load_config","text":"<p>Load configuration from file and environment.</p> Python<pre><code>from venomqa.config import load_config\n\n# Load from default venomqa.yaml\nconfig = load_config()\n\n# Load from specific path\nconfig = load_config(\"path/to/config.yaml\")\n</code></pre>"},{"location":"reference/api/#parameters_7","title":"Parameters","text":"Parameter Type Default Description <code>config_path</code> <code>str \\| Path \\| None</code> <code>None</code> Path to config file"},{"location":"reference/api/#priority-order","title":"Priority Order","text":"<ol> <li>CLI arguments (highest)</li> <li>Environment variables</li> <li>Config file</li> <li>Defaults (lowest)</li> </ol>"},{"location":"reference/api/#state-management","title":"State Management","text":""},{"location":"reference/api/#statemanager-protocol","title":"StateManager Protocol","text":"<p>Protocol defining the state manager interface.</p> Python<pre><code>class StateManager(Protocol):\n    def connect(self) -&gt; None: ...\n    def disconnect(self) -&gt; None: ...\n    def checkpoint(self, name: str) -&gt; None: ...\n    def rollback(self, name: str) -&gt; None: ...\n    def release(self, name: str) -&gt; None: ...\n    def reset(self) -&gt; None: ...\n    def is_connected(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/api/#postgresqlstatemanager","title":"PostgreSQLStateManager","text":"<p>PostgreSQL state manager using SQL SAVEPOINT.</p> Python<pre><code>from venomqa.state import PostgreSQLStateManager\n\nstate_manager = PostgreSQLStateManager(\n    connection_url=\"postgresql://qa:secret@localhost:5432/qa_test\",\n    tables_to_reset=[\"users\", \"orders\", \"items\"],\n    exclude_tables=[\"migrations\", \"schema_versions\"],\n)\n\nstate_manager.connect()\nstate_manager.checkpoint(\"before_test\")\n# ... run tests ...\nstate_manager.rollback(\"before_test\")\nstate_manager.disconnect()\n</code></pre>"},{"location":"reference/api/#parameters_8","title":"Parameters","text":"Parameter Type Default Description <code>connection_url</code> <code>str</code> Required PostgreSQL connection string <code>tables_to_reset</code> <code>list[str] \\| None</code> <code>None</code> Tables to truncate on reset <code>exclude_tables</code> <code>list[str] \\| None</code> <code>None</code> Tables to exclude from reset"},{"location":"reference/api/#methods_4","title":"Methods","text":"Method Description <code>connect()</code> Establish database connection <code>disconnect()</code> Close database connection <code>checkpoint(name)</code> Create SQL SAVEPOINT <code>rollback(name)</code> Rollback to SAVEPOINT <code>release(name)</code> Release SAVEPOINT <code>reset()</code> Truncate all tables <code>commit()</code> Commit current transaction"},{"location":"reference/api/#reporters","title":"Reporters","text":""},{"location":"reference/api/#basereporter","title":"BaseReporter","text":"<p>Abstract base class for all reporters.</p> Python<pre><code>from venomqa.reporters.base import BaseReporter\n\nclass CustomReporter(BaseReporter):\n    @property\n    def file_extension(self) -&gt; str:\n        return \".custom\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        # Generate report\n        return \"report content\"\n</code></pre>"},{"location":"reference/api/#methods_5","title":"Methods","text":"Method Return Type Description <code>generate(results)</code> <code>str \\| dict \\| bytes</code> Generate report content <code>save(results, path)</code> <code>Path</code> Save report to file"},{"location":"reference/api/#markdownreporter","title":"MarkdownReporter","text":"<p>Generate human-readable Markdown reports.</p> Python<pre><code>from venomqa.reporters import MarkdownReporter\n\nreporter = MarkdownReporter(output_path=\"reports/test.md\")\nreporter.save([result1, result2])\n</code></pre>"},{"location":"reference/api/#jsonreporter","title":"JSONReporter","text":"<p>Generate JSON reports for programmatic consumption.</p> Python<pre><code>from venomqa.reporters import JSONReporter\n\nreporter = JSONReporter(output_path=\"reports/test.json\", indent=2)\nreporter.save([result1, result2])\n</code></pre>"},{"location":"reference/api/#junitreporter","title":"JUnitReporter","text":"<p>Generate JUnit XML for CI/CD integration.</p> Python<pre><code>from venomqa.reporters import JUnitReporter\n\nreporter = JUnitReporter(output_path=\"reports/junit.xml\")\nreporter.save([result1, result2])\n</code></pre>"},{"location":"reference/api/#infrastructure","title":"Infrastructure","text":""},{"location":"reference/api/#infrastructuremanager-protocol","title":"InfrastructureManager Protocol","text":"<p>Protocol defining the infrastructure manager interface.</p> Python<pre><code>class InfrastructureManager(Protocol):\n    def start(self) -&gt; None: ...\n    def stop(self) -&gt; None: ...\n    def wait_healthy(self, timeout: float = 60.0) -&gt; bool: ...\n    def logs(self, service_name: str) -&gt; str: ...\n    def is_running(self) -&gt; bool: ...\n</code></pre>"},{"location":"reference/api/#dockerinfrastructuremanager","title":"DockerInfrastructureManager","text":"<p>Docker Compose infrastructure manager.</p> Python<pre><code>from venomqa.infra import DockerInfrastructureManager\n\ninfra = DockerInfrastructureManager(\n    compose_file=\"docker-compose.qa.yml\",\n    project_name=\"venomqa_test\",\n    services=[\"api\", \"db\"],\n)\n\ninfra.start()\nif infra.wait_healthy(timeout=60):\n    # Run tests\n    pass\ninfra.stop()\n</code></pre>"},{"location":"reference/api/#parameters_9","title":"Parameters","text":"Parameter Type Default Description <code>compose_file</code> <code>str \\| Path \\| None</code> <code>None</code> Docker compose file path <code>project_name</code> <code>str \\| None</code> <code>None</code> Docker compose project name <code>services</code> <code>list[str] \\| None</code> <code>None</code> Specific services to start"},{"location":"reference/api/#methods_6","title":"Methods","text":"Method Description <code>start()</code> Start services with <code>docker compose up -d</code> <code>stop()</code> Stop services with <code>docker compose down</code> <code>wait_healthy(timeout)</code> Wait for services to be healthy <code>logs(service_name)</code> Get logs from a service <code>is_running()</code> Check if services are running <code>restart()</code> Restart all services <code>pull()</code> Pull images <code>build()</code> Build images"},{"location":"reference/api/#ports","title":"Ports","text":"<p>Ports are abstract interfaces that define contracts for external system interactions. See Ports Documentation for detailed information.</p>"},{"location":"reference/api/#importing-ports","title":"Importing Ports","text":"Python<pre><code>from venomqa.ports import (\n    ClientPort,\n    DatabasePort,\n    MailPort,\n    CachePort,\n    QueuePort,\n    SearchPort,\n    StoragePort,\n    FilePort,\n    TimePort,\n    ConcurrencyPort,\n    MockPort,\n    StatePort,\n    WebSocketPort,\n    WebhookPort,\n    NotificationPort,\n)\n</code></pre>"},{"location":"reference/api/#port-data-classes","title":"Port Data Classes","text":"<p>Each port has associated data classes for structured data:</p> Python<pre><code>from venomqa.ports import (\n    Request, Response, RequestBuilder,     # ClientPort\n    QueryResult, TableInfo, ColumnInfo,    # DatabasePort\n    Email, EmailAttachment,                 # MailPort\n    CacheEntry, CacheStats,                 # CachePort\n    JobInfo, JobResult, JobStatus,         # QueuePort\n    IndexedDocument, SearchIndex, SearchResult,  # SearchPort\n    StorageObject, FileInfo,                # StoragePort, FilePort\n    TimeInfo, ScheduledTask,                # TimePort\n    TaskInfo, TaskResult,                   # ConcurrencyPort\n    MockResponse, MockEndpoint, RecordedRequest,  # MockPort\n    StateEntry, StateQuery,                 # StatePort\n    WSMessage, WSConnection,                # WebSocketPort\n    WebhookRequest, WebhookResponse, WebhookSubscription,  # WebhookPort\n    PushNotification, SMSMessage,           # NotificationPort\n)\n</code></pre>"},{"location":"reference/api/#creating-custom-port-implementations","title":"Creating Custom Port Implementations","text":"Python<pre><code>from abc import ABC\nfrom venomqa.ports import CachePort, CacheStats\n\nclass CustomCacheAdapter(CachePort):\n    def get(self, key: str) -&gt; Any | None:\n        # Implementation\n        pass\n\n    def set(self, key: str, value: Any, ttl: int | None = None) -&gt; bool:\n        # Implementation\n        pass\n\n    # ... implement all abstract methods\n</code></pre>"},{"location":"reference/api/#adapters","title":"Adapters","text":"<p>Adapters are concrete implementations of Ports. See Adapters Documentation for detailed configuration.</p>"},{"location":"reference/api/#importing-adapters","title":"Importing Adapters","text":"Python<pre><code>from venomqa.adapters import (\n    MailhogAdapter,\n    MailpitAdapter,\n    SMTPMockAdapter,\n    RedisCacheAdapter,\n    RedisQueueAdapter,\n    CeleryQueueAdapter,\n    ElasticsearchAdapter,\n    S3StorageAdapter,\n    LocalStorageAdapter,\n    WireMockAdapter,\n    ControllableTimeAdapter,\n    RealTimeAdapter,\n    ThreadingConcurrencyAdapter,\n    AsyncConcurrencyAdapter,\n    register_adapter,\n    get_adapter,\n    list_adapters,\n)\n</code></pre>"},{"location":"reference/api/#adapter-registration","title":"Adapter Registration","text":"Python<pre><code>from venomqa.adapters import register_adapter, register_adapter_class, get_adapter\n\n# Decorator registration\n@register_adapter(\"my_adapter\")\nclass MyAdapter(CachePort):\n    pass\n\n# Direct registration\nregister_adapter_class(\"another_adapter\", AnotherAdapter)\n\n# Retrieval\nadapter_class = get_adapter(\"my_adapter\")\nall_adapters = list_adapters()\n</code></pre>"},{"location":"reference/backends/","title":"Database Backend Configuration","text":"<p>VenomQA supports database state management for checkpoint and rollback functionality. This enables testing multiple execution paths from the same database state.</p> <p>New to state branching? See Getting Started - Using State Branching for an introduction.</p>"},{"location":"reference/backends/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>PostgreSQL Backend</li> <li>Configuration</li> <li>Custom Backends</li> <li>Best Practices</li> <li>Troubleshooting</li> </ul>"},{"location":"reference/backends/#related-documentation","title":"Related Documentation","text":"Topic Document API Reference api.md#state-management Writing Journeys journeys.md#checkpoints-and-rollback Advanced Usage advanced.md#custom-state-backends FAQ FAQ.md#state-branching"},{"location":"reference/backends/#overview","title":"Overview","text":""},{"location":"reference/backends/#why-state-management","title":"Why State Management?","text":"<p>Without state management, each test must: 1. Set up fresh data before testing 2. Clean up data after testing 3. Deal with data conflicts when running tests in parallel</p> <p>With VenomQA's state management: 1. Create a checkpoint at a known state 2. Test multiple scenarios from that checkpoint 3. Automatically rollback between scenarios 4. No cleanup needed - rollback handles it</p>"},{"location":"reference/backends/#how-it-works","title":"How It Works","text":"Text Only<pre><code>Journey Start\n     \u2502\n     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Step 1: Login  \u2502\n\u2502  Step 2: Create \u2502\n\u2502  Order          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     SAVEPOINT order_created\n\u2502  Checkpoint     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\n\u2502  \"order_created\"\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Branch       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502Path \u2502Path \u2502  \u2502\n\u2502  \u2502  A  \u2502  B  \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u252c\u2500\u2500\u2534\u2500\u2500\u252c\u2500\u2500\u2518  \u2502\n\u2502     \u2502     \u2502     \u2502\n\u2502     \u2502 ROLLBACK  \u2502\n\u2502     \u25bc     \u25bc     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/backends/#postgresql-backend","title":"PostgreSQL Backend","text":""},{"location":"reference/backends/#installation","title":"Installation","text":"Bash<pre><code>pip install \"venomqa[postgres]\"\n</code></pre> <p>Or install psycopg directly:</p> Bash<pre><code>pip install psycopg[binary]\n</code></pre>"},{"location":"reference/backends/#basic-configuration","title":"Basic Configuration","text":"YAML<pre><code># venomqa.yaml\ndb_url: \"postgresql://qa_user:secret@localhost:5432/qa_test\"\ndb_backend: \"postgresql\"\n</code></pre>"},{"location":"reference/backends/#connection-string-format","title":"Connection String Format","text":"Text Only<pre><code>postgresql://[user[:password]@][host][:port]/database[?options]\n</code></pre> <p>Examples:</p> Bash<pre><code># Local development\npostgresql://postgres:postgres@localhost:5432/test_db\n\n# With SSL\npostgresql://user:pass@host:5432/db?sslmode=require\n\n# Docker service\npostgresql://qa:secret@postgres:5432/qa_test\n\n# Cloud database\npostgresql://user:pass@aws-0-us-east-1.pooler.supabase.com:5432/postgres\n</code></pre>"},{"location":"reference/backends/#environment-variable","title":"Environment Variable","text":"Bash<pre><code>export VENOMQA_DB_URL=\"postgresql://qa:secret@localhost:5432/qa_test\"\n</code></pre>"},{"location":"reference/backends/#docker-compose-setup","title":"Docker Compose Setup","text":"YAML<pre><code># docker-compose.qa.yml\nversion: \"3.8\"\n\nservices:\n  api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      db:\n        condition: service_healthy\n    environment:\n      DATABASE_URL: postgresql://qa:secret@db:5432/qa_test\n\n  db:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: qa_test\n      POSTGRES_USER: qa\n      POSTGRES_PASSWORD: secret\n    ports:\n      - \"5432:5432\"\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U qa -d qa_test\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n    tmpfs:\n      - /var/lib/postgresql/data  # Use tmpfs for faster tests\n</code></pre>"},{"location":"reference/backends/#programmatic-usage","title":"Programmatic Usage","text":"Python<pre><code>from venomqa import Journey, JourneyRunner, Client\nfrom venomqa.state import PostgreSQLStateManager\n\n# Create state manager\nstate_manager = PostgreSQLStateManager(\n    connection_url=\"postgresql://qa:secret@localhost:5432/qa_test\",\n    tables_to_reset=[\"users\", \"orders\", \"items\"],\n    exclude_tables=[\"migrations\", \"schema_versions\"],\n)\n\n# Create runner with state manager\nrunner = JourneyRunner(\n    client=Client(base_url=\"http://localhost:8000\"),\n    state_manager=state_manager,\n)\n\n# Run journey - checkpoints and rollbacks handled automatically\nresult = runner.run(journey)\n</code></pre>"},{"location":"reference/backends/#how-postgresql-checkpoints-work","title":"How PostgreSQL Checkpoints Work","text":"<p>VenomQA uses SQL <code>SAVEPOINT</code> for checkpoints:</p> SQL<pre><code>-- Creating a checkpoint\nSAVEPOINT chk_order_created;\n\n-- Rolling back to checkpoint\nROLLBACK TO SAVEPOINT chk_order_created;\n\n-- Releasing checkpoint (optional)\nRELEASE SAVEPOINT chk_order_created;\n</code></pre>"},{"location":"reference/backends/#table-reset-options","title":"Table Reset Options","text":"<p>Control which tables are truncated when resetting:</p> Python<pre><code># Only reset specific tables\nstate_manager = PostgreSQLStateManager(\n    connection_url=\"...\",\n    tables_to_reset=[\"users\", \"orders\", \"items\"],\n)\n\n# Reset all tables except some\nstate_manager = PostgreSQLStateManager(\n    connection_url=\"...\",\n    exclude_tables=[\"migrations\", \"audit_log\"],\n)\n\n# Reset all public tables (default when tables_to_reset is empty)\nstate_manager = PostgreSQLStateManager(\n    connection_url=\"...\",\n)\n</code></pre>"},{"location":"reference/backends/#configuration","title":"Configuration","text":""},{"location":"reference/backends/#configuration-file","title":"Configuration File","text":"YAML<pre><code># venomqa.yaml\nbase_url: \"http://localhost:8000\"\n\n# Database settings\ndb_url: \"postgresql://qa:secret@localhost:5432/qa_test\"\ndb_backend: \"postgresql\"\n\n# Docker settings\ndocker_compose_file: \"docker-compose.qa.yml\"\n\n# Execution settings\nparallel_paths: 1\nfail_fast: false\n\n# Logging\ncapture_logs: true\nlog_lines: 50\nverbose: false\n\n# Reporting\nreport_dir: \"reports\"\nreport_formats:\n  - markdown\n  - junit\n</code></pre>"},{"location":"reference/backends/#environment-variables","title":"Environment Variables","text":"Bash<pre><code># Database\nexport VENOMQA_DB_URL=\"postgresql://user:pass@host:5432/db\"\n\n# Connection\nexport VENOMQA_BASE_URL=\"http://api.example.com\"\n\n# Execution\nexport VENOMQA_TIMEOUT=60\nexport VENOMQA_PARALLEL_PATHS=4\nexport VENOMQA_VERBOSE=true\n</code></pre>"},{"location":"reference/backends/#python-configuration","title":"Python Configuration","text":"Python<pre><code>from venomqa import QAConfig\n\nconfig = QAConfig(\n    base_url=\"http://localhost:8000\",\n    db_url=\"postgresql://qa:secret@localhost:5432/qa_test\",\n    db_backend=\"postgresql\",\n    timeout=30,\n    parallel_paths=2,\n    capture_logs=True,\n)\n</code></pre>"},{"location":"reference/backends/#custom-backends","title":"Custom Backends","text":""},{"location":"reference/backends/#statemanager-protocol","title":"StateManager Protocol","text":"<p>Implement the <code>StateManager</code> protocol to create custom backends:</p> Python<pre><code>from typing import Protocol\n\nclass StateManager(Protocol):\n    def connect(self) -&gt; None:\n        \"\"\"Establish connection to the database/service.\"\"\"\n        ...\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Close connection to the database/service.\"\"\"\n        ...\n\n    def checkpoint(self, name: str) -&gt; None:\n        \"\"\"Create a savepoint with the given name.\"\"\"\n        ...\n\n    def rollback(self, name: str) -&gt; None:\n        \"\"\"Rollback to a previously created checkpoint.\"\"\"\n        ...\n\n    def release(self, name: str) -&gt; None:\n        \"\"\"Release a checkpoint (free resources).\"\"\"\n        ...\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset database to clean state (truncate tables).\"\"\"\n        ...\n\n    def is_connected(self) -&gt; bool:\n        \"\"\"Check if connection is active.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/backends/#mysql-backend-example","title":"MySQL Backend Example","text":"Python<pre><code>import mysql.connector\nfrom venomqa.state.base import BaseStateManager\n\nclass MySQLStateManager(BaseStateManager):\n    \"\"\"MySQL state manager using SAVEPOINT.\"\"\"\n\n    def __init__(self, connection_url: str, tables_to_reset: list[str] | None = None):\n        super().__init__(connection_url)\n        self.tables_to_reset = tables_to_reset or []\n        self._conn = None\n\n    def connect(self) -&gt; None:\n        # Parse connection URL and connect\n        self._conn = mysql.connector.connect(\n            host=\"localhost\",\n            user=\"qa\",\n            password=\"secret\",\n            database=\"qa_test\",\n        )\n        self._connected = True\n\n    def disconnect(self) -&gt; None:\n        if self._conn:\n            self._conn.close()\n            self._conn = None\n        self._connected = False\n\n    def checkpoint(self, name: str) -&gt; None:\n        self._ensure_connected()\n        cursor = self._conn.cursor()\n        cursor.execute(f\"SAVEPOINT {name}\")\n        self._checkpoints.append(name)\n\n    def rollback(self, name: str) -&gt; None:\n        self._ensure_connected()\n        cursor = self._conn.cursor()\n        cursor.execute(f\"ROLLBACK TO SAVEPOINT {name}\")\n\n    def release(self, name: str) -&gt; None:\n        self._ensure_connected()\n        cursor = self._conn.cursor()\n        cursor.execute(f\"RELEASE SAVEPOINT {name}\")\n        if name in self._checkpoints:\n            self._checkpoints.remove(name)\n\n    def reset(self) -&gt; None:\n        self._ensure_connected()\n        cursor = self._conn.cursor()\n        for table in self.tables_to_reset:\n            cursor.execute(f\"TRUNCATE TABLE {table}\")\n        self._conn.commit()\n        self._checkpoints.clear()\n</code></pre>"},{"location":"reference/backends/#redis-backend-example","title":"Redis Backend Example","text":"<p>For stateless applications using Redis:</p> Python<pre><code>import redis\nfrom venomqa.state.base import BaseStateManager\n\nclass RedisStateManager(BaseStateManager):\n    \"\"\"Redis state manager for key-value state.\"\"\"\n\n    def __init__(self, redis_url: str, key_prefix: str = \"qa:\"):\n        super().__init__(redis_url)\n        self.key_prefix = key_prefix\n        self._redis = None\n        self._snapshots: dict[str, dict] = {}\n\n    def connect(self) -&gt; None:\n        self._redis = redis.from_url(self.connection_url)\n        self._connected = True\n\n    def disconnect(self) -&gt; None:\n        if self._redis:\n            self._redis.close()\n            self._redis = None\n        self._connected = False\n\n    def checkpoint(self, name: str) -&gt; None:\n        self._ensure_connected()\n        # Save all keys matching prefix\n        keys = self._redis.keys(f\"{self.key_prefix}*\")\n        snapshot = {}\n        for key in keys:\n            snapshot[key] = self._redis.get(key)\n        self._snapshots[name] = snapshot\n        self._checkpoints.append(name)\n\n    def rollback(self, name: str) -&gt; None:\n        self._ensure_connected()\n        if name not in self._snapshots:\n            raise ValueError(f\"Checkpoint '{name}' not found\")\n\n        # Clear current state\n        keys = self._redis.keys(f\"{self.key_prefix}*\")\n        if keys:\n            self._redis.delete(*keys)\n\n        # Restore snapshot\n        for key, value in self._snapshots[name].items():\n            self._redis.set(key, value)\n\n    def release(self, name: str) -&gt; None:\n        if name in self._snapshots:\n            del self._snapshots[name]\n        if name in self._checkpoints:\n            self._checkpoints.remove(name)\n\n    def reset(self) -&gt; None:\n        self._ensure_connected()\n        keys = self._redis.keys(f\"{self.key_prefix}*\")\n        if keys:\n            self._redis.delete(*keys)\n        self._snapshots.clear()\n        self._checkpoints.clear()\n</code></pre>"},{"location":"reference/backends/#registering-custom-backends","title":"Registering Custom Backends","text":"<p>Add to your <code>pyproject.toml</code>:</p> TOML<pre><code>[project.entry-points.\"venomqa.state_backends\"]\nmysql = \"my_package.state:MySQLStateManager\"\nredis = \"my_package.state:RedisStateManager\"\n</code></pre>"},{"location":"reference/backends/#best-practices","title":"Best Practices","text":""},{"location":"reference/backends/#1-use-separate-test-database","title":"1. Use Separate Test Database","text":"<p>Never run tests against production or development databases:</p> Python<pre><code># Good - dedicated test database\ndb_url: \"postgresql://qa:secret@localhost:5432/qa_test\"\n\n# Bad - development database\ndb_url: \"postgresql://dev:dev@localhost:5432/dev_db\"\n</code></pre>"},{"location":"reference/backends/#2-reset-state-between-journeys","title":"2. Reset State Between Journeys","text":"<p>Start each journey with a clean state:</p> Python<pre><code># In your journey setup\nstate_manager.reset()\nstate_manager.checkpoint(\"clean_state\")\n</code></pre>"},{"location":"reference/backends/#3-use-checkpoints-strategically","title":"3. Use Checkpoints Strategically","text":"<p>Place checkpoints before state-modifying operations you want to test multiple ways:</p> Python<pre><code>Journey(\n    name=\"order_flow\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"create_order\", action=create_order),\n        Checkpoint(name=\"order_created\"),  # Good placement\n        Branch(\n            checkpoint_name=\"order_created\",\n            paths=[...],\n        ),\n    ],\n)\n</code></pre>"},{"location":"reference/backends/#4-exclude-system-tables","title":"4. Exclude System Tables","text":"<p>Prevent accidental truncation of migration tables:</p> Python<pre><code>state_manager = PostgreSQLStateManager(\n    connection_url=\"...\",\n    exclude_tables=[\n        \"alembic_version\",\n        \"django_migrations\",\n        \"schema_migrations\",\n    ],\n)\n</code></pre>"},{"location":"reference/backends/#5-use-docker-for-isolation","title":"5. Use Docker for Isolation","text":"<p>Run tests in isolated Docker containers:</p> YAML<pre><code># docker-compose.qa.yml\nservices:\n  db:\n    image: postgres:15\n    tmpfs:\n      - /var/lib/postgresql/data  # Fast, ephemeral storage\n</code></pre>"},{"location":"reference/backends/#6-connection-pooling","title":"6. Connection Pooling","text":"<p>For parallel execution, consider connection pooling:</p> Python<pre><code># Use a connection pool for parallel paths\nfrom psycopg_pool import ConnectionPool\n\npool = ConnectionPool(conninfo=\"postgresql://...\")\n</code></pre>"},{"location":"reference/backends/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/backends/#connection-refused","title":"Connection Refused","text":"Text Only<pre><code>Error: Connection refused to postgresql://localhost:5432\n</code></pre> <p>Solutions: 1. Ensure PostgreSQL is running: <code>docker compose up -d db</code> 2. Check port is correct and exposed 3. Verify connection string credentials</p>"},{"location":"reference/backends/#checkpoint-not-found","title":"Checkpoint Not Found","text":"Text Only<pre><code>ValueError: Checkpoint 'order_created' not found\n</code></pre> <p>Causes: 1. Checkpoint was never created 2. Checkpoint name is misspelled 3. Connection was reset</p> <p>Solution: Ensure checkpoint is created before branch references it:</p> Python<pre><code># Correct order\nCheckpoint(name=\"order_created\"),  # Create first\nBranch(checkpoint_name=\"order_created\", ...)  # Reference later\n</code></pre>"},{"location":"reference/backends/#transaction-issues","title":"Transaction Issues","text":"Text Only<pre><code>Error: SAVEPOINT can only be used in transaction blocks\n</code></pre> <p>Solution: Ensure autocommit is disabled:</p> Python<pre><code>self._conn.autocommit = False\n</code></pre>"},{"location":"reference/backends/#table-locks","title":"Table Locks","text":"Text Only<pre><code>Error: relation \"users\" is locked\n</code></pre> <p>Solutions: 1. Wait for locks to release 2. Kill blocking queries 3. Use shorter transactions</p>"},{"location":"reference/backends/#reset-taking-too-long","title":"Reset Taking Too Long","text":"<p>If <code>reset()</code> is slow with many tables:</p> Python<pre><code># Specify only tables you need to reset\nstate_manager = PostgreSQLStateManager(\n    connection_url=\"...\",\n    tables_to_reset=[\"users\", \"orders\", \"items\"],  # Only these\n)\n</code></pre>"},{"location":"reference/backends/#parallel-path-conflicts","title":"Parallel Path Conflicts","text":"<p>When running parallel paths with database operations:</p> Python<pre><code># Limit parallelism if seeing conflicts\nrunner = JourneyRunner(\n    client=client,\n    state_manager=state_manager,\n    parallel_paths=1,  # Run sequentially\n)\n</code></pre>"},{"location":"reference/backends/#debugging-state-issues","title":"Debugging State Issues","text":"<p>Enable verbose logging:</p> Bash<pre><code>venomqa run -v\n</code></pre> <p>Check logs for checkpoint operations: Text Only<pre><code>DEBUG - Created checkpoint: chk_order_created\nDEBUG - Rolled back to checkpoint: chk_order_created\n</code></pre></p>"},{"location":"reference/cli/","title":"CLI Documentation","text":"<p>VenomQA provides a command-line interface for running journeys, listing available tests, and generating reports.</p> <p>New here? See Getting Started for basic CLI usage.</p>"},{"location":"reference/cli/#installation","title":"Installation","text":"Bash<pre><code>pip install venomqa\n</code></pre> <p>The CLI is installed as the <code>venomqa</code> command.</p>"},{"location":"reference/cli/#related-documentation","title":"Related Documentation","text":"Topic Document Configuration backends.md Reports api.md#reporters FAQ FAQ.md"},{"location":"reference/cli/#global-options","title":"Global Options","text":"Option Short Description <code>--verbose</code> <code>-v</code> Enable verbose/debug output <code>--config</code> <code>-c</code> Path to configuration file <code>--help</code> <code>-h</code> Show help message"},{"location":"reference/cli/#commands","title":"Commands","text":""},{"location":"reference/cli/#venomqa-run","title":"<code>venomqa run</code>","text":"<p>Run one or more journeys.</p> Bash<pre><code># Run all discovered journeys\nvenomqa run\n\n# Run specific journeys\nvenomqa run checkout_flow payment_flow\n\n# Run with options\nvenomqa run checkout_flow --fail-fast --format json\n\n# Skip infrastructure setup\nvenomqa run --no-infra\n</code></pre>"},{"location":"reference/cli/#arguments","title":"Arguments","text":"Argument Description <code>JOURNEY_NAMES</code> One or more journey names to run (optional)"},{"location":"reference/cli/#options","title":"Options","text":"Option Type Default Description <code>--no-infra</code> flag - Skip Docker setup/teardown <code>--format</code>, <code>-f</code> choice <code>text</code> Output format (<code>text</code> or <code>json</code>) <code>--fail-fast</code> flag - Stop on first failure <code>--verbose</code>, <code>-v</code> flag - Enable debug logging <code>--config</code>, <code>-c</code> path - Path to config file"},{"location":"reference/cli/#exit-codes","title":"Exit Codes","text":"Code Meaning <code>0</code> All journeys passed <code>1</code> One or more journeys failed"},{"location":"reference/cli/#examples","title":"Examples","text":"<p>Run all journeys: Bash<pre><code>venomqa run\n</code></pre></p> <p>Run specific journeys: Bash<pre><code>venomqa run user_registration checkout_flow\n</code></pre></p> <p>Run with JSON output: Bash<pre><code>venomqa run --format json\n</code></pre></p> <p>Run with fail-fast mode: Bash<pre><code>venomqa run --fail-fast\n</code></pre></p> <p>Run without infrastructure management: Bash<pre><code># Use when services are already running\nvenomqa run --no-infra\n</code></pre></p> <p>Run with verbose logging: Bash<pre><code>venomqa run -v\n</code></pre></p> <p>Run with custom config: Bash<pre><code>venomqa run -c /path/to/venomqa.yaml\n</code></pre></p> <p>Combine options: Bash<pre><code>venomqa run checkout_flow --fail-fast --format json --verbose\n</code></pre></p>"},{"location":"reference/cli/#venomqa-list","title":"<code>venomqa list</code>","text":"<p>List all discovered journeys.</p> Bash<pre><code># List journeys in text format\nvenomqa list\n\n# List in JSON format\nvenomqa list --format json\n</code></pre>"},{"location":"reference/cli/#options_1","title":"Options","text":"Option Type Default Description <code>--format</code>, <code>-f</code> choice <code>text</code> Output format (<code>text</code> or <code>json</code>)"},{"location":"reference/cli/#examples_1","title":"Examples","text":"<p>Text output: Bash<pre><code>$ venomqa list\nFound 3 journey(s):\n\n  \u2022 checkout_flow (journeys/checkout_flow.py)\n  \u2022 user_registration (journeys/user_registration.py)\n  \u2022 admin_flow (journeys/admin_flow.py)\n</code></pre></p> <p>JSON output: Bash<pre><code>$ venomqa list --format json\n{\n  \"checkout_flow\": {\n    \"name\": \"checkout_flow\",\n    \"path\": \"journeys/checkout_flow.py\"\n  },\n  \"user_registration\": {\n    \"name\": \"user_registration\",\n    \"path\": \"journeys/user_registration.py\"\n  },\n  \"admin_flow\": {\n    \"name\": \"admin_flow\",\n    \"path\": \"journeys/admin_flow.py\"\n  }\n}\n</code></pre></p>"},{"location":"reference/cli/#venomqa-report","title":"<code>venomqa report</code>","text":"<p>Generate a report from the last run.</p> Bash<pre><code># Generate markdown report (default)\nvenomqa report\n\n# Generate specific format\nvenomqa report --format junit --output reports/junit.xml\n\n# Generate HTML report\nvenomqa report --format html --output reports/test.html\n</code></pre>"},{"location":"reference/cli/#options_2","title":"Options","text":"Option Type Default Description <code>--format</code>, <code>-f</code> choice <code>markdown</code> Report format (<code>markdown</code>, <code>json</code>, <code>junit</code>, <code>html</code>) <code>--output</code>, <code>-o</code> path <code>reports/report.{ext}</code> Output file path"},{"location":"reference/cli/#supported-formats","title":"Supported Formats","text":"Format Extension Description <code>markdown</code> <code>.md</code> Human-readable Markdown report <code>json</code> <code>.json</code> Structured JSON for programmatic use <code>junit</code> <code>.xml</code> JUnit XML for CI/CD integration <code>html</code> <code>.html</code> Standalone HTML report"},{"location":"reference/cli/#examples_2","title":"Examples","text":"<p>Generate markdown report: Bash<pre><code>venomqa report --format markdown --output reports/test.md\n</code></pre></p> <p>Generate JUnit XML for CI: Bash<pre><code>venomqa report --format junit --output reports/junit.xml\n</code></pre></p> <p>Generate JSON for processing: Bash<pre><code>venomqa report --format json --output reports/results.json\n</code></pre></p> <p>Generate HTML for sharing: Bash<pre><code>venomqa report --format html --output reports/test.html\n</code></pre></p>"},{"location":"reference/cli/#configuration-file","title":"Configuration File","text":"<p>Create a <code>venomqa.yaml</code> file in your project root:</p> YAML<pre><code># API Configuration\nbase_url: \"http://localhost:8000\"\n\n# Database Configuration\ndb_url: \"postgresql://qa:secret@localhost:5432/qa_test\"\ndb_backend: \"postgresql\"\n\n# Infrastructure\ndocker_compose_file: \"docker-compose.qa.yml\"\n\n# Request Settings\ntimeout: 30\nretry_count: 3\nretry_delay: 1.0\n\n# Logging\ncapture_logs: true\nlog_lines: 50\nverbose: false\n\n# Execution\nparallel_paths: 1\nfail_fast: false\n\n# Reporting\nreport_dir: \"reports\"\nreport_formats:\n  - markdown\n  - junit\n</code></pre>"},{"location":"reference/cli/#environment-variables","title":"Environment Variables","text":"<p>All configuration options can be overridden with environment variables prefixed with <code>VENOMQA_</code>:</p> Bash<pre><code># API Configuration\nexport VENOMQA_BASE_URL=\"http://api.example.com\"\n\n# Database\nexport VENOMQA_DB_URL=\"postgresql://user:pass@host/db\"\n\n# Execution\nexport VENOMQA_TIMEOUT=60\nexport VENOMQA_VERBOSE=true\nexport VENOMQA_FAIL_FAST=true\n</code></pre>"},{"location":"reference/cli/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"reference/cli/#github-actions","title":"GitHub Actions","text":"YAML<pre><code>name: QA Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_DB: qa_test\n          POSTGRES_USER: qa\n          POSTGRES_PASSWORD: secret\n        ports:\n          - 5432:5432\n        options: &gt;-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n\n      - name: Install dependencies\n        run: |\n          pip install -e \".[dev]\"\n\n      - name: Run QA tests\n        env:\n          VENOMQA_BASE_URL: http://localhost:8000\n          VENOMQA_DB_URL: postgresql://qa:secret@localhost:5432/qa_test\n        run: |\n          venomqa run --format json\n\n      - name: Generate JUnit report\n        if: always()\n        run: |\n          venomqa report --format junit --output reports/junit.xml\n\n      - name: Upload test results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: qa-reports\n          path: reports/\n\n      - name: Publish test results\n        if: always()\n        uses: dorny/test-reporter@v1\n        with:\n          name: QA Tests\n          path: reports/junit.xml\n          reporter: java-junit\n</code></pre>"},{"location":"reference/cli/#gitlab-ci","title":"GitLab CI","text":"YAML<pre><code>qa-tests:\n  stage: test\n  image: python:3.11\n\n  services:\n    - name: postgres:15\n      alias: postgres\n\n  variables:\n    POSTGRES_DB: qa_test\n    POSTGRES_USER: qa\n    POSTGRES_PASSWORD: secret\n    VENOMQA_BASE_URL: http://localhost:8000\n    VENOMQA_DB_URL: postgresql://qa:secret@postgres:5432/qa_test\n\n  before_script:\n    - pip install -e \".[dev]\"\n\n  script:\n    - venomqa run --format json\n    - venomqa report --format junit --output reports/junit.xml\n\n  artifacts:\n    when: always\n    paths:\n      - reports/\n    reports:\n      junit: reports/junit.xml\n</code></pre>"},{"location":"reference/cli/#circleci","title":"CircleCI","text":"YAML<pre><code>version: 2.1\n\njobs:\n  qa-tests:\n    docker:\n      - image: python:3.11\n      - image: postgres:15\n        environment:\n          POSTGRES_DB: qa_test\n          POSTGRES_USER: qa\n          POSTGRES_PASSWORD: secret\n\n    environment:\n      VENOMQA_BASE_URL: http://localhost:8000\n      VENOMQA_DB_URL: postgresql://qa:secret@localhost:5432/qa_test\n\n    steps:\n      - checkout\n\n      - run:\n          name: Install dependencies\n          command: pip install -e \".[dev]\"\n\n      - run:\n          name: Run QA tests\n          command: venomqa run\n\n      - run:\n          name: Generate reports\n          when: always\n          command: |\n            venomqa report --format junit --output reports/junit.xml\n            venomqa report --format html --output reports/test.html\n\n      - store_test_results:\n          path: reports\n\n      - store_artifacts:\n          path: reports\n\nworkflows:\n  version: 2\n  test:\n    jobs:\n      - qa-tests\n</code></pre>"},{"location":"reference/cli/#jenkins-pipeline","title":"Jenkins Pipeline","text":"Groovy<pre><code>pipeline {\n    agent any\n\n    environment {\n        VENOMQA_BASE_URL = 'http://localhost:8000'\n        VENOMQA_DB_URL = 'postgresql://qa:secret@localhost:5432/qa_test'\n    }\n\n    stages {\n        stage('Setup') {\n            steps {\n                sh 'pip install -e \".[dev]\"'\n            }\n        }\n\n        stage('Run Tests') {\n            steps {\n                sh 'venomqa run --format json'\n            }\n        }\n\n        stage('Generate Reports') {\n            steps {\n                sh '''\n                    venomqa report --format junit --output reports/junit.xml\n                    venomqa report --format html --output reports/test.html\n                '''\n            }\n        }\n    }\n\n    post {\n        always {\n            junit 'reports/junit.xml'\n            publishHTML(target: [\n                allowMissing: false,\n                alwaysLinkToLastBuild: true,\n                keepAll: true,\n                reportDir: 'reports',\n                reportFiles: 'test.html',\n                reportName: 'QA Report'\n            ])\n        }\n    }\n}\n</code></pre>"},{"location":"reference/cli/#exit-codes_1","title":"Exit Codes","text":"Code Description <code>0</code> Success - all tests passed <code>1</code> Failure - one or more tests failed <code>2</code> Error - configuration or runtime error"},{"location":"reference/cli/#debugging","title":"Debugging","text":""},{"location":"reference/cli/#verbose-mode","title":"Verbose Mode","text":"<p>Enable detailed logging to debug issues:</p> Bash<pre><code>venomqa run -v\n</code></pre>"},{"location":"reference/cli/#check-configuration","title":"Check Configuration","text":"<p>Verify configuration is loaded correctly:</p> Bash<pre><code># Run with debug logging to see config values\nvenomqa run -v 2&gt;&amp;1 | grep -i config\n</code></pre>"},{"location":"reference/cli/#common-issues","title":"Common Issues","text":"<p>Journey not found: Bash<pre><code>$ venomqa run missing_journey\nJourney not found: missing_journey\n</code></pre> Ensure the journey file exists in <code>journeys/</code> directory and exports a <code>journey</code> variable.</p> <p>Connection refused: Bash<pre><code># Check if services are running\ndocker compose -f docker-compose.qa.yml ps\n\n# Start services\ndocker compose -f docker-compose.qa.yml up -d\n</code></pre></p> <p>Database connection failed: Bash<pre><code># Verify database URL\necho $VENOMQA_DB_URL\n\n# Test connection\npsql \"$VENOMQA_DB_URL\" -c \"SELECT 1\"\n</code></pre></p>"},{"location":"reference/config/","title":"Configuration Reference","text":"<p>Complete reference for all VenomQA configuration options.</p>"},{"location":"reference/config/#configuration-file","title":"Configuration File","text":"<p>VenomQA reads configuration from <code>venomqa.yaml</code> in the project root.</p> YAML<pre><code># venomqa.yaml - Complete configuration reference\n\n# ====================\n# API Configuration\n# ====================\nbase_url: \"http://localhost:8000\"    # Base URL for all API requests\ntimeout: 30                          # Request timeout in seconds\nretry_count: 3                       # Number of retry attempts\nretry_delay: 1.0                     # Base delay between retries (seconds)\n\n# ====================\n# Database Configuration\n# ====================\ndb_url: \"postgresql://qa:secret@localhost:5432/qa_test\"\ndb_backend: \"postgresql\"             # postgresql, sqlite, mysql\n\n# ====================\n# Infrastructure\n# ====================\ndocker_compose_file: \"docker-compose.qa.yml\"\n\n# ====================\n# Execution\n# ====================\nparallel_paths: 1                    # Max concurrent branch paths\nfail_fast: false                     # Stop on first failure\n\n# ====================\n# Logging\n# ====================\nverbose: false                       # Enable verbose/debug output\ncapture_logs: true                   # Capture infrastructure logs\nlog_lines: 50                        # Number of log lines to capture\n\n# ====================\n# Reporting\n# ====================\nreport_dir: \"reports\"                # Output directory for reports\nreport_formats:                      # Report formats to generate\n  - markdown\n  - junit\n</code></pre>"},{"location":"reference/config/#configuration-options","title":"Configuration Options","text":""},{"location":"reference/config/#api-configuration","title":"API Configuration","text":"Option Type Default Environment Variable Description <code>base_url</code> string <code>\"http://localhost:8000\"</code> <code>VENOMQA_BASE_URL</code> Base URL for API requests <code>timeout</code> integer <code>30</code> <code>VENOMQA_TIMEOUT</code> Request timeout (seconds) <code>retry_count</code> integer <code>3</code> <code>VENOMQA_RETRY_COUNT</code> Retry attempts on failure <code>retry_delay</code> float <code>1.0</code> <code>VENOMQA_RETRY_DELAY</code> Base delay between retries"},{"location":"reference/config/#database-configuration","title":"Database Configuration","text":"Option Type Default Environment Variable Description <code>db_url</code> string <code>null</code> <code>VENOMQA_DB_URL</code> Database connection URL <code>db_backend</code> string <code>\"postgresql\"</code> <code>VENOMQA_DB_BACKEND</code> Database backend type <p>Supported backends:</p> <ul> <li><code>postgresql</code> - PostgreSQL with SAVEPOINT support (recommended)</li> <li><code>sqlite</code> - SQLite with limited checkpoint support</li> <li><code>mysql</code> - MySQL with SAVEPOINT support</li> </ul> <p>Connection URL formats:</p> Bash<pre><code># PostgreSQL\npostgresql://user:password@host:5432/database\npostgresql://user:password@host:5432/database?sslmode=require\n\n# SQLite\nsqlite:///path/to/database.db\nsqlite:///:memory:\n\n# MySQL\nmysql://user:password@host:3306/database\n</code></pre>"},{"location":"reference/config/#infrastructure-configuration","title":"Infrastructure Configuration","text":"Option Type Default Environment Variable Description <code>docker_compose_file</code> string <code>\"docker-compose.qa.yml\"</code> <code>VENOMQA_DOCKER_COMPOSE_FILE</code> Docker Compose file path"},{"location":"reference/config/#execution-configuration","title":"Execution Configuration","text":"Option Type Default Environment Variable Description <code>parallel_paths</code> integer <code>1</code> <code>VENOMQA_PARALLEL_PATHS</code> Max concurrent paths <code>fail_fast</code> boolean <code>false</code> <code>VENOMQA_FAIL_FAST</code> Stop on first failure <p>Parallel Execution</p> <p>Using <code>parallel_paths &gt; 1</code> with database state management may cause isolation issues. Use sequential execution (<code>parallel_paths=1</code>) when state isolation is critical.</p>"},{"location":"reference/config/#logging-configuration","title":"Logging Configuration","text":"Option Type Default Environment Variable Description <code>verbose</code> boolean <code>false</code> <code>VENOMQA_VERBOSE</code> Enable debug output <code>capture_logs</code> boolean <code>true</code> <code>VENOMQA_CAPTURE_LOGS</code> Capture infra logs <code>log_lines</code> integer <code>50</code> <code>VENOMQA_LOG_LINES</code> Log lines to capture"},{"location":"reference/config/#reporting-configuration","title":"Reporting Configuration","text":"Option Type Default Environment Variable Description <code>report_dir</code> string <code>\"reports\"</code> <code>VENOMQA_REPORT_DIR</code> Report output directory <code>report_formats</code> list <code>[\"markdown\"]</code> <code>VENOMQA_REPORT_FORMATS</code> Formats to generate <p>Available formats:</p> <ul> <li><code>markdown</code> - Human-readable Markdown</li> <li><code>json</code> - Structured JSON</li> <li><code>junit</code> - JUnit XML for CI/CD</li> <li><code>html</code> - Standalone HTML report</li> <li><code>sarif</code> - SARIF for security tools</li> </ul>"},{"location":"reference/config/#environment-variables","title":"Environment Variables","text":"<p>All configuration options can be overridden with environment variables prefixed with <code>VENOMQA_</code>:</p> Bash<pre><code># API\nexport VENOMQA_BASE_URL=\"http://api.example.com\"\nexport VENOMQA_TIMEOUT=60\nexport VENOMQA_RETRY_COUNT=5\n\n# Database\nexport VENOMQA_DB_URL=\"postgresql://user:pass@host:5432/db\"\nexport VENOMQA_DB_BACKEND=\"postgresql\"\n\n# Execution\nexport VENOMQA_PARALLEL_PATHS=4\nexport VENOMQA_FAIL_FAST=true\nexport VENOMQA_VERBOSE=true\n\n# Reporting\nexport VENOMQA_REPORT_DIR=\"/tmp/reports\"\nexport VENOMQA_REPORT_FORMATS=\"markdown,junit\"\n</code></pre> <p>Type conversion:</p> YAML Type Environment Variable string As-is integer Parsed as int float Parsed as float boolean <code>true</code>/<code>false</code>, <code>1</code>/<code>0</code>, <code>yes</code>/<code>no</code> list Comma-separated values"},{"location":"reference/config/#priority-order","title":"Priority Order","text":"<p>Configuration is loaded in this order (later sources override earlier):</p> <ol> <li>Default values (lowest priority)</li> <li>Configuration file (<code>venomqa.yaml</code>)</li> <li>Environment variables (<code>VENOMQA_*</code>)</li> <li>CLI arguments (highest priority)</li> </ol>"},{"location":"reference/config/#multiple-environments","title":"Multiple Environments","text":""},{"location":"reference/config/#using-different-config-files","title":"Using Different Config Files","text":"Bash<pre><code># Development\nvenomqa run -c venomqa.dev.yaml\n\n# Staging\nvenomqa run -c venomqa.staging.yaml\n\n# Production (read-only tests)\nvenomqa run -c venomqa.prod.yaml\n</code></pre>"},{"location":"reference/config/#example-development-config","title":"Example: Development Config","text":"YAML<pre><code># venomqa.dev.yaml\nbase_url: \"http://localhost:8000\"\ndb_url: \"postgresql://dev:dev@localhost:5432/dev_db\"\nverbose: true\ntimeout: 10\n</code></pre>"},{"location":"reference/config/#example-staging-config","title":"Example: Staging Config","text":"YAML<pre><code># venomqa.staging.yaml\nbase_url: \"https://api.staging.example.com\"\ndb_url: \"postgresql://qa:secret@staging-db:5432/qa_test\"\nverbose: false\ntimeout: 60\n</code></pre>"},{"location":"reference/config/#example-cicd-config","title":"Example: CI/CD Config","text":"YAML<pre><code># venomqa.ci.yaml\nbase_url: \"${API_URL}\"  # Replaced by environment variable\ntimeout: 120\nfail_fast: true\nreport_formats:\n  - junit\n  - html\n</code></pre>"},{"location":"reference/config/#programmatic-configuration","title":"Programmatic Configuration","text":""},{"location":"reference/config/#qaconfig-class","title":"QAConfig Class","text":"Python<pre><code>from venomqa import QAConfig\n\nconfig = QAConfig(\n    base_url=\"http://localhost:8000\",\n    db_url=\"postgresql://qa:secret@localhost:5432/qa_test\",\n    db_backend=\"postgresql\",\n    timeout=30,\n    retry_count=3,\n    retry_delay=1.0,\n    parallel_paths=2,\n    fail_fast=False,\n    verbose=True,\n    capture_logs=True,\n    log_lines=100,\n    report_dir=\"reports\",\n    report_formats=[\"markdown\", \"junit\"],\n)\n</code></pre>"},{"location":"reference/config/#loading-from-file","title":"Loading from File","text":"Python<pre><code>from venomqa.config import load_config\n\n# Load from default location\nconfig = load_config()\n\n# Load from specific path\nconfig = load_config(\"path/to/config.yaml\")\n\n# Access values\nprint(config.base_url)\nprint(config.db_url)\nprint(config.timeout)\n</code></pre>"},{"location":"reference/config/#creating-client-from-config","title":"Creating Client from Config","text":"Python<pre><code>from venomqa import Client, QAConfig\n\nconfig = load_config()\n\nclient = Client(\n    base_url=config.base_url,\n    timeout=config.timeout,\n    retry_count=config.retry_count,\n    retry_delay=config.retry_delay,\n)\n</code></pre>"},{"location":"reference/config/#validation","title":"Validation","text":"<p>VenomQA validates configuration on load:</p> Python<pre><code>from venomqa.config import load_config, ConfigValidationError\n\ntry:\n    config = load_config()\nexcept ConfigValidationError as e:\n    print(f\"Invalid configuration: {e}\")\n</code></pre> <p>Validation rules:</p> <ul> <li><code>base_url</code> must be a valid URL</li> <li><code>timeout</code> must be positive</li> <li><code>retry_count</code> must be non-negative</li> <li><code>db_url</code> must be valid connection string (if provided)</li> <li><code>report_formats</code> must contain valid format names</li> </ul>"},{"location":"reference/config/#best-practices","title":"Best Practices","text":""},{"location":"reference/config/#1-use-environment-variables-for-secrets","title":"1. Use Environment Variables for Secrets","text":"YAML<pre><code># venomqa.yaml (safe to commit)\nbase_url: \"http://localhost:8000\"\ndb_backend: \"postgresql\"\n\n# Set secrets via environment\n# export VENOMQA_DB_URL=\"postgresql://...\"\n</code></pre>"},{"location":"reference/config/#2-different-timeouts-for-different-environments","title":"2. Different Timeouts for Different Environments","text":"YAML<pre><code># Local development - fast feedback\ntimeout: 10\n\n# CI/CD - allow for network latency\ntimeout: 60\n\n# Production smoke tests - be patient\ntimeout: 120\n</code></pre>"},{"location":"reference/config/#3-enable-verbose-only-for-debugging","title":"3. Enable Verbose Only for Debugging","text":"YAML<pre><code># Development\nverbose: true\n\n# CI/CD - too noisy\nverbose: false\n</code></pre>"},{"location":"reference/config/#4-use-sequential-execution-with-database-state","title":"4. Use Sequential Execution with Database State","text":"YAML<pre><code># Safe for database checkpointing\nparallel_paths: 1\n</code></pre>"},{"location":"reference/config/#5-specify-report-formats-for-cicd","title":"5. Specify Report Formats for CI/CD","text":"YAML<pre><code># CI/CD\nreport_formats:\n  - junit    # For test results\n  - html     # For artifacts\n</code></pre>"},{"location":"reference/reporters/","title":"Reporters Reference","text":"<p>VenomQA supports multiple report formats for different use cases.</p>"},{"location":"reference/reporters/#available-formats","title":"Available Formats","text":"Format Extension Use Case <code>markdown</code> <code>.md</code> Human-readable reports <code>json</code> <code>.json</code> Programmatic processing <code>junit</code> <code>.xml</code> CI/CD integration <code>html</code> <code>.html</code> Standalone web reports <code>sarif</code> <code>.sarif</code> Security tools integration <code>slack</code> - Slack notifications <code>discord</code> - Discord notifications"},{"location":"reference/reporters/#using-reporters","title":"Using Reporters","text":""},{"location":"reference/reporters/#cli","title":"CLI","text":"Bash<pre><code># Generate single format\nvenomqa report --format markdown --output reports/test.md\n\n# Generate multiple formats\nvenomqa report --format junit --output reports/junit.xml\nvenomqa report --format html --output reports/test.html\n</code></pre>"},{"location":"reference/reporters/#configuration","title":"Configuration","text":"YAML<pre><code># venomqa.yaml\nreport_dir: \"reports\"\nreport_formats:\n  - markdown\n  - junit\n  - html\n</code></pre>"},{"location":"reference/reporters/#programmatic","title":"Programmatic","text":"Python<pre><code>from venomqa.reporters import (\n    MarkdownReporter,\n    JSONReporter,\n    JUnitReporter,\n    HTMLReporter,\n)\n\n# Generate markdown\nreporter = MarkdownReporter(output_path=\"reports/test.md\")\nreporter.save([journey_result])\n\n# Generate JSON\nreporter = JSONReporter(output_path=\"reports/test.json\", indent=2)\nreporter.save([journey_result])\n\n# Generate JUnit XML\nreporter = JUnitReporter(output_path=\"reports/junit.xml\")\nreporter.save([journey_result])\n\n# Generate HTML\nreporter = HTMLReporter(output_path=\"reports/test.html\")\nreporter.save([journey_result])\n</code></pre>"},{"location":"reference/reporters/#format-details","title":"Format Details","text":""},{"location":"reference/reporters/#markdown-reporter","title":"Markdown Reporter","text":"<p>Human-readable Markdown format.</p> Python<pre><code>from venomqa.reporters import MarkdownReporter\n\nreporter = MarkdownReporter(\n    output_path=\"reports/test.md\",\n    include_request_details=True,   # Include request/response\n    include_timing=True,            # Include timing info\n)\n</code></pre> <p>Example output:</p> Markdown<pre><code># VenomQA Test Report\n\n**Generated:** 2024-01-15 10:30:00\n**Total Journeys:** 2\n**Passed:** 2\n**Failed:** 0\n\n## Journey: checkout_flow\n\n**Status:** PASSED\n**Duration:** 1.23s\n\n### Steps\n\n| Step | Status | Duration |\n|------|--------|----------|\n| login | PASS | 89ms |\n| add_to_cart | PASS | 45ms |\n| checkout | PASS | 67ms |\n\n### Branches\n\n#### Branch: order_ready\n\n| Path | Status | Steps |\n|------|--------|-------|\n| credit_card | PASS | 2/2 |\n| wallet | PASS | 2/2 |\n</code></pre>"},{"location":"reference/reporters/#json-reporter","title":"JSON Reporter","text":"<p>Structured JSON for programmatic processing.</p> Python<pre><code>from venomqa.reporters import JSONReporter\n\nreporter = JSONReporter(\n    output_path=\"reports/test.json\",\n    indent=2,                       # Pretty print\n    include_request_details=True,   # Include full request/response\n)\n</code></pre> <p>Example output:</p> JSON<pre><code>{\n  \"generated_at\": \"2024-01-15T10:30:00Z\",\n  \"summary\": {\n    \"total_journeys\": 2,\n    \"passed\": 2,\n    \"failed\": 0,\n    \"total_duration_ms\": 2456\n  },\n  \"journeys\": [\n    {\n      \"name\": \"checkout_flow\",\n      \"success\": true,\n      \"duration_ms\": 1234,\n      \"steps\": [\n        {\n          \"name\": \"login\",\n          \"success\": true,\n          \"duration_ms\": 89\n        }\n      ],\n      \"branches\": [...]\n    }\n  ]\n}\n</code></pre>"},{"location":"reference/reporters/#junit-reporter","title":"JUnit Reporter","text":"<p>JUnit XML format for CI/CD integration.</p> Python<pre><code>from venomqa.reporters import JUnitReporter\n\nreporter = JUnitReporter(\n    output_path=\"reports/junit.xml\",\n    suite_name=\"VenomQA Tests\",     # Test suite name\n)\n</code></pre> <p>Example output:</p> XML<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;testsuites name=\"VenomQA Tests\" tests=\"6\" failures=\"0\" time=\"1.234\"&gt;\n  &lt;testsuite name=\"checkout_flow\" tests=\"6\" failures=\"0\" time=\"1.234\"&gt;\n    &lt;testcase name=\"login\" classname=\"checkout_flow\" time=\"0.089\"/&gt;\n    &lt;testcase name=\"add_to_cart\" classname=\"checkout_flow\" time=\"0.045\"/&gt;\n    &lt;testcase name=\"checkout\" classname=\"checkout_flow\" time=\"0.067\"/&gt;\n    &lt;testcase name=\"credit_card.pay_card\" classname=\"checkout_flow\" time=\"0.156\"/&gt;\n    &lt;testcase name=\"credit_card.verify\" classname=\"checkout_flow\" time=\"0.023\"/&gt;\n  &lt;/testsuite&gt;\n&lt;/testsuites&gt;\n</code></pre>"},{"location":"reference/reporters/#html-reporter","title":"HTML Reporter","text":"<p>Standalone HTML report with styling.</p> Python<pre><code>from venomqa.reporters import HTMLReporter\n\nreporter = HTMLReporter(\n    output_path=\"reports/test.html\",\n    title=\"QA Test Results\",        # Page title\n    include_charts=True,            # Include charts\n)\n</code></pre>"},{"location":"reference/reporters/#sarif-reporter","title":"SARIF Reporter","text":"<p>SARIF format for security tools.</p> Python<pre><code>from venomqa.reporters import SARIFReporter\n\nreporter = SARIFReporter(\n    output_path=\"reports/test.sarif\",\n    tool_name=\"VenomQA\",\n    tool_version=\"0.2.0\",\n)\n</code></pre>"},{"location":"reference/reporters/#slack-reporter","title":"Slack Reporter","text":"<p>Send results to Slack.</p> Python<pre><code>from venomqa.reporters import SlackReporter\n\nreporter = SlackReporter(\n    webhook_url=\"https://hooks.slack.com/services/...\",\n    channel=\"#qa-results\",          # Optional channel override\n    mention_on_failure=\"@channel\",  # Mention on failures\n)\n\nreporter.send([journey_result])\n</code></pre>"},{"location":"reference/reporters/#discord-reporter","title":"Discord Reporter","text":"<p>Send results to Discord.</p> Python<pre><code>from venomqa.reporters import DiscordReporter\n\nreporter = DiscordReporter(\n    webhook_url=\"https://discord.com/api/webhooks/...\",\n    mention_on_failure=\"@here\",\n)\n\nreporter.send([journey_result])\n</code></pre>"},{"location":"reference/reporters/#custom-reporters","title":"Custom Reporters","text":"<p>Create custom reporters by extending <code>BaseReporter</code>:</p> Python<pre><code>from pathlib import Path\nfrom typing import Any\nfrom venomqa.reporters.base import BaseReporter\nfrom venomqa.core.models import JourneyResult\n\n\nclass CSVReporter(BaseReporter):\n    \"\"\"Generate CSV reports for spreadsheet analysis.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".csv\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        lines = [\n            \"journey_name,success,duration_ms,total_steps,passed_steps,issue_count\"\n        ]\n\n        for result in results:\n            lines.append(\n                f\"{result.journey_name},\"\n                f\"{result.success},\"\n                f\"{result.duration_ms:.0f},\"\n                f\"{result.total_steps},\"\n                f\"{result.passed_steps},\"\n                f\"{len(result.issues)}\"\n            )\n\n        return \"\\n\".join(lines)\n\n\n# Usage\nreporter = CSVReporter(output_path=\"reports/results.csv\")\nreporter.save([journey_result])\n</code></pre>"},{"location":"reference/reporters/#basereporter-interface","title":"BaseReporter Interface","text":"Python<pre><code>from abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import Any\n\n\nclass BaseReporter(ABC):\n    \"\"\"Base class for all reporters.\"\"\"\n\n    def __init__(self, output_path: str | Path | None = None):\n        self.output_path = Path(output_path) if output_path else None\n\n    @property\n    @abstractmethod\n    def file_extension(self) -&gt; str:\n        \"\"\"Return the file extension for this reporter.\"\"\"\n        ...\n\n    @abstractmethod\n    def generate(self, results: list[JourneyResult]) -&gt; str | dict | bytes:\n        \"\"\"Generate report content from results.\"\"\"\n        ...\n\n    def save(self, results: list[JourneyResult], path: Path | None = None) -&gt; Path:\n        \"\"\"Save report to file.\"\"\"\n        output_path = path or self.output_path\n        if output_path is None:\n            output_path = Path(f\"report{self.file_extension}\")\n\n        content = self.generate(results)\n\n        if isinstance(content, bytes):\n            output_path.write_bytes(content)\n        elif isinstance(content, dict):\n            import json\n            output_path.write_text(json.dumps(content, indent=2))\n        else:\n            output_path.write_text(content)\n\n        return output_path\n</code></pre>"},{"location":"reference/reporters/#reporter-registration","title":"Reporter Registration","text":"<p>Register custom reporters:</p> Python<pre><code>from venomqa.reporters import register_reporter\n\n@register_reporter(\"csv\")\nclass CSVReporter(BaseReporter):\n    ...\n\n# Or register directly\nfrom venomqa.reporters import register_reporter_class\nregister_reporter_class(\"csv\", CSVReporter)\n</code></pre> <p>Add to <code>pyproject.toml</code> for plugin discovery:</p> TOML<pre><code>[project.entry-points.\"venomqa.reporters\"]\ncsv = \"my_package.reporters:CSVReporter\"\n</code></pre>"},{"location":"reference/reporters/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"reference/reporters/#github-actions","title":"GitHub Actions","text":"YAML<pre><code>- name: Generate JUnit report\n  if: always()\n  run: venomqa report --format junit --output reports/junit.xml\n\n- name: Publish test results\n  if: always()\n  uses: dorny/test-reporter@v1\n  with:\n    name: QA Tests\n    path: reports/junit.xml\n    reporter: java-junit\n</code></pre>"},{"location":"reference/reporters/#gitlab-ci","title":"GitLab CI","text":"YAML<pre><code>qa-tests:\n  artifacts:\n    reports:\n      junit: reports/junit.xml\n</code></pre>"},{"location":"reference/reporters/#jenkins","title":"Jenkins","text":"Groovy<pre><code>post {\n    always {\n        junit 'reports/junit.xml'\n    }\n}\n</code></pre>"},{"location":"reference/reporters/#best-practices","title":"Best Practices","text":""},{"location":"reference/reporters/#1-generate-multiple-formats","title":"1. Generate Multiple Formats","text":"YAML<pre><code>report_formats:\n  - junit      # For CI/CD\n  - html       # For humans\n  - json       # For processing\n</code></pre>"},{"location":"reference/reporters/#2-use-junit-for-cicd","title":"2. Use JUnit for CI/CD","text":"<p>JUnit XML is universally supported:</p> Bash<pre><code>venomqa report --format junit --output reports/junit.xml\n</code></pre>"},{"location":"reference/reporters/#3-include-request-details-for-debugging","title":"3. Include Request Details for Debugging","text":"Python<pre><code>reporter = MarkdownReporter(\n    output_path=\"reports/debug.md\",\n    include_request_details=True,\n)\n</code></pre>"},{"location":"reference/reporters/#4-send-notifications-on-failure","title":"4. Send Notifications on Failure","text":"Python<pre><code>if not all(r.success for r in results):\n    slack_reporter.send(results)\n</code></pre>"},{"location":"specs/VISION/","title":"VenomQA Vision: State-Based Application Testing","text":""},{"location":"specs/VISION/#the-core-problem","title":"The Core Problem","text":"<p>Traditional API testing checks: \"Did this endpoint return 200?\"</p> <p>But real applications are interconnected. Every user action has cascading impacts across the entire app. A file upload doesn't just create a file\u2014it affects: - File listing - Storage usage display - Quota remaining - Billing calculations - Search results - Activity logs - And more...</p> <p>Human QA testers understand this intuitively. They don't just check \"did the upload work?\"\u2014they verify the ENTIRE app state is consistent after every action.</p> <p>VenomQA should test like a human QA thinks.</p>"},{"location":"specs/VISION/#the-venomqa-approach","title":"The VenomQA Approach","text":""},{"location":"specs/VISION/#1-state-model-define-your-apps-reality","title":"1. State Model: Define Your App's Reality","text":"<p>Before testing, define what \"state\" exists in your application:</p> YAML<pre><code>state_model:\n  files:\n    - id\n    - name\n    - size\n    - created_at\n    - owner_id\n\n  usage:\n    - user_id\n    - bytes_used\n    - bytes_remaining\n    - file_count\n\n  user:\n    - id\n    - plan_type\n    - quota_limit\n</code></pre> <p>This is the \"shape\" of your application's data.</p>"},{"location":"specs/VISION/#2-invariants-rules-that-must-always-be-true","title":"2. Invariants: Rules That Must ALWAYS Be True","text":"<p>Define consistency rules that should hold after EVERY action:</p> YAML<pre><code>invariants:\n  - name: \"usage_matches_files\"\n    check: \"usage.bytes_used == SUM(files.size WHERE files.owner_id == user.id)\"\n    severity: critical\n\n  - name: \"quota_calculation\"\n    check: \"usage.bytes_remaining == user.quota_limit - usage.bytes_used\"\n    severity: critical\n\n  - name: \"file_count_accurate\"\n    check: \"usage.file_count == COUNT(files WHERE files.owner_id == user.id)\"\n    severity: high\n</code></pre> <p>After EVERY step in EVERY journey, VenomQA verifies all invariants still hold.</p>"},{"location":"specs/VISION/#3-journeys-with-branches-test-all-paths","title":"3. Journeys With Branches: Test All Paths","text":"<p>A journey isn't linear. At each step, users can take different paths:</p> Text Only<pre><code>Upload File Journey:\n    \u2502\n    \u251c\u2500\u25ba Upload CSV file\n    \u2502   \u251c\u2500\u25ba Valid CSV \u2192 success\n    \u2502   \u2514\u2500\u25ba Invalid CSV \u2192 error handling\n    \u2502\n    \u251c\u2500\u25ba Upload Excel file\n    \u2502   \u251c\u2500\u25ba .xlsx \u2192 success\n    \u2502   \u2514\u2500\u25ba .xls (legacy) \u2192 conversion + success\n    \u2502\n    \u251c\u2500\u25ba Upload image\n    \u2502   \u251c\u2500\u25ba Under size limit \u2192 success\n    \u2502   \u2514\u2500\u25ba Over size limit \u2192 rejection\n    \u2502\n    \u2514\u2500\u25ba Upload duplicate file\n        \u251c\u2500\u25ba Dedup enabled \u2192 reference existing\n        \u2514\u2500\u25ba Dedup disabled \u2192 create copy\n</code></pre> <p>VenomQA explores ALL branches, not just the happy path.</p>"},{"location":"specs/VISION/#4-cross-journey-state-real-user-behavior","title":"4. Cross-Journey State: Real User Behavior","text":"<p>Real users don't complete one journey then start another fresh. They: - Start journey A - Stop halfway - Do something in journey B - Come back to journey A - Jump to journey C</p> <p>VenomQA should test these combinations:</p> YAML<pre><code>test_scenarios:\n  - name: \"interrupted_upload\"\n    steps:\n      - journey: \"file_upload\"\n        stop_at: \"file_selected\"  # Stop before upload completes\n      - journey: \"check_usage\"    # Does usage page handle partial state?\n      - journey: \"file_upload\"\n        resume: true              # Come back and complete\n      - journey: \"check_usage\"    # Now verify final state\n</code></pre>"},{"location":"specs/VISION/#5-node-based-architecture","title":"5. Node-Based Architecture","text":"<p>Think of your app as a graph of NODES (states) and EDGES (actions):</p> Text Only<pre><code>[Logged Out] \u2500\u2500login\u2500\u2500\u25ba [Dashboard] \u2500\u2500upload\u2500\u2500\u25ba [File Uploaded]\n                \u2502                                    \u2502\n                \u2502                                    \u25bc\n                \u2502                            [Usage Updated]\n                \u2502                                    \u2502\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500check_usage\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Each NODE is a state. Each EDGE is an action that transitions between states.</p> <p>VenomQA: 1. Maps all your nodes and edges 2. Traverses every possible path 3. At each node, verifies invariants 4. Reports which nodes/edges are broken</p>"},{"location":"specs/VISION/#how-it-works","title":"How It Works","text":""},{"location":"specs/VISION/#developer-defines","title":"Developer Defines:","text":"<ol> <li>State Model - What data exists in the app</li> <li>Invariants - Rules that must always be true</li> <li>Nodes - Possible states the app can be in</li> <li>Edges/Actions - How to transition between states</li> <li>Assertions - What to check at each node</li> </ol>"},{"location":"specs/VISION/#venomqa-executes","title":"VenomQA Executes:","text":"<ol> <li>Starts at initial node</li> <li>Explores all possible paths (edges)</li> <li>At each node:</li> <li>Executes the action (HTTP call)</li> <li>Captures the new state</li> <li>Verifies ALL invariants</li> <li>Records pass/fail</li> <li>Branches into all possible next paths</li> <li>Continues until all paths explored</li> </ol>"},{"location":"specs/VISION/#venomqa-reports","title":"VenomQA Reports:","text":"Text Only<pre><code>Journey Exploration Complete\n============================\n\nNodes Tested: 47\nEdges Tested: 156\nPaths Explored: 23\n\nBROKEN NODES:\n  \u2717 [Usage Page] - Invariant failed: usage_matches_files\n    After: file_upload \u2192 delete_file\n    Expected: bytes_used = 0\n    Actual: bytes_used = 1048576 (stale data)\n\n  \u2717 [Search Results] - File still appears after deletion\n    After: file_upload \u2192 delete_file \u2192 search\n\nBROKEN EDGES:\n  \u2717 upload_duplicate_file \u2192 [Error State]\n    Expected: Dedup to create reference\n    Actual: Created duplicate (2x storage used)\n\nCOMPLETE JOURNEYS: 19/23\nINVARIANT VIOLATIONS: 7\n</code></pre>"},{"location":"specs/VISION/#the-venom-philosophy","title":"The \"Venom\" Philosophy","text":"<p>The name Venom represents: - Penetrating - Gets into every corner of your app - Spreading - Tests cascading effects across features - Revealing - Exposes hidden bugs in state consistency - Thorough - Explores all paths, not just happy paths</p> <p>Like venom spreading through a system, VenomQA touches every part of your application to find weaknesses.</p>"},{"location":"specs/VISION/#example-file-storage-app","title":"Example: File Storage App","text":"YAML<pre><code># venomqa.yaml\n\napp:\n  name: \"CloudStorage\"\n  base_url: \"http://localhost:8000\"\n  database: \"postgresql://localhost/cloudstorage\"\n\nstate_model:\n  files:\n    table: files\n    fields: [id, name, size, owner_id, created_at, checksum]\n\n  usage:\n    table: user_usage\n    fields: [user_id, bytes_used, file_count]\n\n  users:\n    table: users\n    fields: [id, email, plan, quota_bytes]\n\ninvariants:\n  - name: usage_accurate\n    sql: |\n      SELECT u.bytes_used = COALESCE(SUM(f.size), 0)\n      FROM user_usage u\n      LEFT JOIN files f ON f.owner_id = u.user_id\n      GROUP BY u.user_id\n    expect: true\n\n  - name: quota_not_exceeded\n    sql: |\n      SELECT u.bytes_used &lt;= us.quota_bytes\n      FROM user_usage u\n      JOIN users us ON us.id = u.user_id\n    expect: true\n\n  - name: file_count_matches\n    sql: |\n      SELECT u.file_count = COUNT(f.id)\n      FROM user_usage u\n      LEFT JOIN files f ON f.owner_id = u.user_id\n      GROUP BY u.user_id\n    expect: true\n\nnodes:\n  logged_out:\n    description: \"User not authenticated\"\n\n  dashboard:\n    description: \"Main dashboard after login\"\n    verify:\n      - endpoint: GET /api/dashboard\n      - status: 200\n\n  file_list:\n    description: \"Viewing file list\"\n    verify:\n      - endpoint: GET /api/files\n      - check: response.count == state.usage.file_count\n\n  usage_page:\n    description: \"Viewing storage usage\"\n    verify:\n      - endpoint: GET /api/usage\n      - check: response.bytes_used == state.usage.bytes_used\n\nedges:\n  login:\n    from: logged_out\n    to: dashboard\n    action:\n      endpoint: POST /api/auth/login\n      body: { email: \"{{user.email}}\", password: \"{{user.password}}\" }\n\n  upload_file:\n    from: [dashboard, file_list]\n    to: file_list\n    variants:\n      - name: small_csv\n        action:\n          endpoint: POST /api/files/upload\n          file: \"test_data/small.csv\"\n      - name: large_excel\n        action:\n          endpoint: POST /api/files/upload\n          file: \"test_data/large.xlsx\"\n      - name: duplicate\n        action:\n          endpoint: POST /api/files/upload\n          file: \"{{last_uploaded_file}}\"\n\n  delete_file:\n    from: file_list\n    to: file_list\n    action:\n      endpoint: DELETE /api/files/{{file.id}}\n\n  view_usage:\n    from: [dashboard, file_list]\n    to: usage_page\n    action:\n      endpoint: GET /api/usage\n\nexploration:\n  strategy: exhaustive  # or: random_walk, priority_based\n  max_depth: 10\n  stop_on_invariant_failure: false  # Continue to find all bugs\n</code></pre>"},{"location":"specs/VISION/#summary","title":"Summary","text":"<p>VenomQA is NOT just an API testing tool. It is a state-based application testing framework that:</p> <ol> <li>Models your app's state - Understands what data exists</li> <li>Defines consistency rules - Knows what \"correct\" looks like</li> <li>Explores all paths - Tests every combination users might take</li> <li>Verifies after every action - Checks invariants at each step</li> <li>Reports broken nodes - Tells you exactly what's wrong and where</li> </ol> <p>The goal: Test your app the way a thorough human QA would\u2014checking everything, everywhere, after every action.</p>"},{"location":"specs/framework-spec/","title":"Framework Spec","text":"<p>clauc# Stateful Journey QA Framework Specification</p> <p>A generic framework for end-to-end testing with state exploration</p>"},{"location":"specs/framework-spec/#1-overview","title":"1. Overview","text":"<p>A testing framework that: - Tests applications as a user would (API calls, not function calls) - Explores multiple paths through stateful systems - Uses database savepoints to branch and rollback - Captures full context on failures (request, response, logs) - Manages real infrastructure (Docker, databases, services)</p> Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    JOURNEY FRAMEWORK                         \u2502\n\u2502                                                              \u2502\n\u2502   Journey \u2500\u252c\u2500 Step \u2500\u2500\u2500 Step \u2500\u2500\u2500 Checkpoint \u2500\u252c\u2500 Path A       \u2502\n\u2502            \u2502                                 \u251c\u2500 Path B       \u2502\n\u2502            \u2502                                 \u2514\u2500 Path C       \u2502\n\u2502            \u2502                                                 \u2502\n\u2502            \u2514\u2500 Branch (explores all paths, rolls back)        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"specs/framework-spec/#2-core-concepts","title":"2. Core Concepts","text":""},{"location":"specs/framework-spec/#21-journey","title":"2.1 Journey","text":"<p>A complete user scenario from start to finish.</p> Python<pre><code>Journey(\n    name=\"user_registration\",\n    description=\"User signs up, verifies email, logs in\",\n    steps=[...]\n)\n</code></pre>"},{"location":"specs/framework-spec/#22-step","title":"2.2 Step","text":"<p>A single action with assertions.</p> Python<pre><code>Step(\n    name=\"create_account\",\n    action=create_account,      # Callable\n    description=\"Create new user account\",\n    expect_failure=False,       # Set True to test error paths\n)\n</code></pre>"},{"location":"specs/framework-spec/#23-checkpoint","title":"2.3 Checkpoint","text":"<p>A savepoint for state - can rollback here later.</p> Python<pre><code>Checkpoint(\"before_payment\")\n</code></pre>"},{"location":"specs/framework-spec/#24-branch","title":"2.4 Branch","text":"<p>Fork execution to explore multiple paths from a checkpoint.</p> Python<pre><code>Branch(\n    checkpoint_name=\"before_payment\",\n    paths=[\n        Path(\"payment_success\", [...]),\n        Path(\"payment_declined\", [...]),\n        Path(\"payment_timeout\", [...]),\n    ]\n)\n</code></pre>"},{"location":"specs/framework-spec/#25-path","title":"2.5 Path","text":"<p>A sequence of steps within a branch.</p> Python<pre><code>Path(\n    name=\"payment_success\",\n    description=\"Happy path - payment completes\",\n    steps=[\n        Step(\"submit_payment\", submit_payment),\n        Step(\"verify_receipt\", verify_receipt),\n    ]\n)\n</code></pre>"},{"location":"specs/framework-spec/#3-architecture","title":"3. Architecture","text":"Text Only<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         QA FRAMEWORK                             \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502  \u2502   Runner    \u2502  \u2502   State     \u2502  \u2502   Client    \u2502              \u2502\n\u2502  \u2502             \u2502  \u2502   Manager   \u2502  \u2502             \u2502              \u2502\n\u2502  \u2502 Executes    \u2502  \u2502             \u2502  \u2502 HTTP calls  \u2502              \u2502\n\u2502  \u2502 journeys    \u2502  \u2502 Savepoints  \u2502  \u2502 + history   \u2502              \u2502\n\u2502  \u2502 + branches  \u2502  \u2502 + rollback  \u2502  \u2502 + auth      \u2502              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2502         \u2502                \u2502                \u2502                      \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                      \u2502\n\u2502                          \u2502                                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502  \u2502  Reporter   \u2502  \u2502Infrastructure\u2502 \u2502   Actions   \u2502              \u2502\n\u2502  \u2502             \u2502  \u2502             \u2502  \u2502             \u2502              \u2502\n\u2502  \u2502 Issue list  \u2502  \u2502 Docker up/  \u2502  \u2502 Reusable    \u2502              \u2502\n\u2502  \u2502 + markdown  \u2502  \u2502 down/logs   \u2502  \u2502 API calls   \u2502              \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"specs/framework-spec/#31-runner","title":"3.1 Runner","text":"<p>Executes journeys, handles branching logic.</p> Python<pre><code>class JourneyRunner:\n    def run(self, journey: Journey) -&gt; JourneyResult:\n        for step in journey.steps:\n            if isinstance(step, Checkpoint):\n                self.state.checkpoint(step.name)\n            elif isinstance(step, Branch):\n                for path in step.paths:\n                    self._run_path(path)\n                    self.state.rollback(step.checkpoint_name)\n            elif isinstance(step, Step):\n                self._run_step(step)\n</code></pre>"},{"location":"specs/framework-spec/#32-state-manager","title":"3.2 State Manager","text":"<p>Manages database state via savepoints.</p> Python<pre><code>class StateManager:\n    def checkpoint(self, name: str):\n        self.conn.execute(f\"SAVEPOINT {name}\")\n\n    def rollback(self, name: str):\n        self.conn.execute(f\"ROLLBACK TO SAVEPOINT {name}\")\n\n    def reset(self):\n        # Truncate all tables for clean slate\n</code></pre>"},{"location":"specs/framework-spec/#33-client","title":"3.3 Client","text":"<p>HTTP client that captures everything.</p> Python<pre><code>class Client:\n    def request(self, method, path, **kwargs) -&gt; Response:\n        response = self.http.request(method, path, **kwargs)\n        self.history.append({\n            \"request\": {\"method\": method, \"path\": path, \"body\": kwargs},\n            \"response\": {\"status\": response.status, \"body\": response.json()},\n            \"timestamp\": now(),\n        })\n        return response\n</code></pre>"},{"location":"specs/framework-spec/#34-reporter","title":"3.4 Reporter","text":"<p>Generates human-readable reports.</p> Python<pre><code>class Reporter:\n    def generate(self) -&gt; str:\n        return f\"\"\"\n        # QA Report\n\n        ## Summary: {passed}/{total} journeys passed\n\n        ## Issues Found\n        {self._format_issues()}\n        \"\"\"\n</code></pre>"},{"location":"specs/framework-spec/#35-infrastructure","title":"3.5 Infrastructure","text":"<p>Manages external dependencies.</p> Python<pre><code>class Infrastructure:\n    def start(self):\n        subprocess.run([\"docker\", \"compose\", \"up\", \"-d\"])\n        self._wait_healthy()\n\n    def stop(self):\n        subprocess.run([\"docker\", \"compose\", \"down\", \"-v\"])\n\n    def logs(self, service: str) -&gt; str:\n        return subprocess.check_output([\"docker\", \"logs\", service])\n</code></pre>"},{"location":"specs/framework-spec/#4-issue-capture","title":"4. Issue Capture","text":"<p>When a step fails, capture full context:</p> Python<pre><code>@dataclass\nclass Issue:\n    journey: str          # Which journey\n    path: str             # Which branch path\n    step: str             # Which step failed\n    error: str            # Error message\n    request: dict | None  # HTTP request that failed\n    response: dict | None # HTTP response received\n    logs: list[str]       # Recent server logs\n    suggestion: str       # Auto-generated fix suggestion\n</code></pre>"},{"location":"specs/framework-spec/#41-auto-suggestions","title":"4.1 Auto-Suggestions","text":"<p>Pattern match errors to suggestions:</p> Python<pre><code>SUGGESTIONS = {\n    \"401\": \"Check authentication - token may be invalid\",\n    \"404\": \"Endpoint not found - check route registration\",\n    \"422\": \"Validation error - check request schema\",\n    \"500\": \"Server error - check logs for traceback\",\n    \"timeout\": \"Operation timed out - check if service is running\",\n    \"connection refused\": \"Service not running - check Docker\",\n}\n</code></pre>"},{"location":"specs/framework-spec/#5-journey-definition-dsl","title":"5. Journey Definition DSL","text":""},{"location":"specs/framework-spec/#51-simple-journey","title":"5.1 Simple Journey","text":"Python<pre><code>journey = Journey(\n    name=\"basic_crud\",\n    steps=[\n        Step(\"create\", lambda c, ctx: c.post(\"/items\", json={\"name\": \"test\"})),\n        Step(\"read\", lambda c, ctx: c.get(f\"/items/{ctx['create']['id']}\")),\n        Step(\"update\", lambda c, ctx: c.put(f\"/items/{ctx['create']['id']}\", json={\"name\": \"updated\"})),\n        Step(\"delete\", lambda c, ctx: c.delete(f\"/items/{ctx['create']['id']}\")),\n    ]\n)\n</code></pre>"},{"location":"specs/framework-spec/#52-branching-journey","title":"5.2 Branching Journey","text":"Python<pre><code>journey = Journey(\n    name=\"payment_flow\",\n    steps=[\n        Step(\"add_to_cart\", add_item_to_cart),\n        Step(\"checkout\", start_checkout),\n        Checkpoint(\"before_payment\"),\n        Branch(\n            checkpoint_name=\"before_payment\",\n            paths=[\n                Path(\"success\", [\n                    Step(\"pay\", pay_with_valid_card),\n                    Step(\"verify_order\", check_order_confirmed),\n                ]),\n                Path(\"declined\", [\n                    Step(\"pay\", pay_with_declined_card, expect_failure=True),\n                    Step(\"verify_cart\", check_cart_still_exists),\n                ]),\n                Path(\"cancel\", [\n                    Step(\"cancel\", cancel_checkout),\n                    Step(\"verify_cart\", check_cart_restored),\n                ]),\n            ]\n        ),\n    ]\n)\n</code></pre>"},{"location":"specs/framework-spec/#6-execution-model","title":"6. Execution Model","text":"Text Only<pre><code>Journey Start\n     \u2502\n     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Step 1 \u2500\u2500\u25ba Step 2 \u2500\u2500\u25ba Checkpoint(\"X\") \u2500\u2500\u25ba Branch          \u2502\n\u2502                                              \u2502              \u2502\n\u2502                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502                            \u25bc                 \u25bc          \u25bc   \u2502\n\u2502                        Path A            Path B      Path C \u2502\n\u2502                            \u2502                 \u2502          \u2502   \u2502\n\u2502                            \u25bc                 \u25bc          \u25bc   \u2502\n\u2502                        [steps]           [steps]    [steps] \u2502\n\u2502                            \u2502                 \u2502          \u2502   \u2502\n\u2502                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                      \u2502                      \u2502\n\u2502                            Rollback to \"X\" after each       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502\n     \u25bc\nJourney End (all paths explored)\n</code></pre>"},{"location":"specs/framework-spec/#7-configuration","title":"7. Configuration","text":"Python<pre><code>@dataclass\nclass QAConfig:\n    base_url: str = \"http://localhost:8000\"\n    db_url: str = \"postgresql://...\"\n    docker_compose_file: str = \"docker-compose.qa.yml\"\n    timeout: int = 30\n    retry_count: int = 3\n    capture_logs: bool = True\n    log_lines: int = 50\n</code></pre>"},{"location":"specs/framework-spec/#8-cli-interface","title":"8. CLI Interface","text":"Bash<pre><code># Run all journeys\nqa run\n\n# Run specific journeys\nqa run j01 j02 j05\n\n# Skip infrastructure management\nqa run --no-infra\n\n# Generate report only\nqa report\n\n# List available journeys\nqa list\n</code></pre>"},{"location":"specs/framework-spec/#9-integration-points","title":"9. Integration Points","text":""},{"location":"specs/framework-spec/#91-cicd-pipeline","title":"9.1 CI/CD Pipeline","text":"YAML<pre><code># .github/workflows/qa.yml\nqa:\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v4\n    - run: docker compose -f docker-compose.qa.yml up -d\n    - run: python -m qa\n    - uses: actions/upload-artifact@v4\n      with:\n        name: qa-report\n        path: qa/QA-REPORT.md\n</code></pre>"},{"location":"specs/framework-spec/#92-pre-commit-hook","title":"9.2 Pre-commit Hook","text":"Bash<pre><code>#!/bin/bash\n# Run smoke test before push\npython -m qa j01 --no-infra || exit 1\n</code></pre>"},{"location":"specs/framework-spec/#10-improvements-roadmap","title":"10. Improvements Roadmap","text":""},{"location":"specs/framework-spec/#phase-1-bug-detection-automation","title":"Phase 1: Bug Detection Automation","text":"<ul> <li> Fuzzing: Random valid inputs to find edge cases</li> <li> Property-based testing: Hypothesis integration</li> <li> Invariant checking: Assert system invariants after each step</li> </ul>"},{"location":"specs/framework-spec/#phase-2-intelligence","title":"Phase 2: Intelligence","text":"<ul> <li> Failure clustering: Group similar failures</li> <li> Root cause analysis: Trace failures to code changes</li> <li> Flaky test detection: Track intermittent failures</li> </ul>"},{"location":"specs/framework-spec/#phase-3-generation","title":"Phase 3: Generation","text":"<ul> <li> Journey generation from OpenAPI spec</li> <li> Action generation from route definitions</li> <li> Assertion generation from response schemas</li> </ul>"},{"location":"specs/framework-spec/#phase-4-continuous-qa","title":"Phase 4: Continuous QA","text":"<ul> <li> Watch mode: Re-run on file changes</li> <li> Parallel execution: Run journeys concurrently</li> <li> Distributed execution: Run across machines</li> </ul>"},{"location":"specs/framework-spec/#11-comparison-to-existing-tools","title":"11. Comparison to Existing Tools","text":"Feature Our Framework Playwright Postman pytest-bdd API testing \u2705 \u2705 \u2705 \u2705 State branching \u2705 \u274c \u274c \u274c DB savepoints \u2705 \u274c \u274c \u274c Docker mgmt \u2705 \u274c \u274c \u274c Issue capture \u2705 Partial Partial \u274c Auto-suggestions \u2705 \u274c \u274c \u274c Journey DSL \u2705 \u274c Collections Gherkin"},{"location":"specs/framework-spec/#12-generic-implementation-checklist","title":"12. Generic Implementation Checklist","text":"<p>To implement for any codebase:</p> <ol> <li> Define <code>Client</code> for your API (HTTP, gRPC, GraphQL)</li> <li> Define <code>StateManager</code> for your database</li> <li> Define <code>Infrastructure</code> for your services</li> <li> Create <code>actions/</code> with reusable API calls</li> <li> Create <code>journeys/</code> with user scenarios</li> <li> Create <code>docker-compose.qa.yml</code> for test infra</li> <li> Add <code>__main__.py</code> entry point</li> <li> Add to CI/CD pipeline</li> </ol>"},{"location":"specs/publishing/","title":"Publishing VenomQA to PyPI","text":"<p>This guide covers the complete process for publishing VenomQA to PyPI and TestPyPI.</p>"},{"location":"specs/publishing/#prerequisites","title":"Prerequisites","text":"<ol> <li>PyPI Account: Create accounts at:</li> <li>PyPI</li> <li> <p>TestPyPI</p> </li> <li> <p>API Tokens: Generate API tokens for secure publishing:</p> </li> <li>PyPI: https://pypi.org/manage/account/token/</li> <li> <p>TestPyPI: https://test.pypi.org/manage/account/token/</p> </li> <li> <p>Install Build Tools:    Bash<pre><code>pip install build twine\n</code></pre></p> </li> </ol>"},{"location":"specs/publishing/#configuration","title":"Configuration","text":""},{"location":"specs/publishing/#1-configure-pypirc","title":"1. Configure .pypirc","text":"<p>Copy the template and add your tokens:</p> Bash<pre><code>cp .pypirc.template ~/.pypirc\nchmod 600 ~/.pypirc\n</code></pre> <p>Edit <code>~/.pypirc</code> and replace the placeholder tokens:</p> INI<pre><code>[distutils]\nindex-servers =\n    pypi\n    testpypi\n\n[pypi]\nusername = __token__\npassword = pypi-xxxx...  # Your PyPI token\n\n[testpypi]\nusername = __token__\npassword = pypi-xxxx...  # Your TestPyPI token\n</code></pre>"},{"location":"specs/publishing/#2-trusted-publishing-recommended","title":"2. Trusted Publishing (Recommended)","text":"<p>For GitHub Actions CI/CD, use trusted publishing instead of tokens:</p> <ol> <li>Go to PyPI \u2192 Publishing \u2192 Add GitHub repository</li> <li>Configure the workflow name (e.g., <code>publish.yml</code>)</li> </ol> <p>See: https://docs.pypi.org/trusted-publishers/</p>"},{"location":"specs/publishing/#pre-publish-checklist","title":"Pre-Publish Checklist","text":"<p>Before publishing, verify:</p> <ul> <li> Version updated in <code>pyproject.toml</code> and <code>venomqa/__init__.py</code></li> <li> <code>CHANGELOG.md</code> updated with release notes</li> <li> All tests pass: <code>pytest</code></li> <li> Linting passes: <code>ruff check .</code></li> <li> Type checking passes: <code>mypy venomqa</code></li> <li> Documentation is up to date</li> <li> Git tag created for the version</li> </ul>"},{"location":"specs/publishing/#building-the-package","title":"Building the Package","text":""},{"location":"specs/publishing/#clean-previous-builds","title":"Clean Previous Builds","text":"Bash<pre><code>rm -rf dist/ build/ *.egg-info\n</code></pre>"},{"location":"specs/publishing/#build-source-and-wheel-distributions","title":"Build Source and Wheel Distributions","text":"Bash<pre><code>python -m build\n</code></pre> <p>This creates: - <code>dist/venomqa-0.2.0.tar.gz</code> (source distribution) - <code>dist/venomqa-0.2.0-py3-none-any.whl</code> (wheel)</p>"},{"location":"specs/publishing/#verify-the-build","title":"Verify the Build","text":"Bash<pre><code># Check package metadata\ntwine check dist/*\n\n# List package contents\ntar -tzf dist/venomqa-0.2.0.tar.gz\nunzip -l dist/venomqa-0.2.0-py3-none-any.whl\n</code></pre>"},{"location":"specs/publishing/#publishing-to-testpypi-recommended-first","title":"Publishing to TestPyPI (Recommended First)","text":"<p>Always test with TestPyPI before publishing to the main PyPI:</p> Bash<pre><code># Upload to TestPyPI\ntwine upload --repository testpypi dist/*\n\n# Test installation from TestPyPI\npip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ venomqa\n</code></pre> <p>Verify the installed package works:</p> Bash<pre><code>python -c \"import venomqa; print(venomqa.__version__)\"\nvenomqa --help\n</code></pre>"},{"location":"specs/publishing/#publishing-to-pypi","title":"Publishing to PyPI","text":"<p>Once verified on TestPyPI:</p> Bash<pre><code># Upload to PyPI\ntwine upload dist/*\n</code></pre> <p>The package will be available at: https://pypi.org/project/venomqa/</p>"},{"location":"specs/publishing/#version-management","title":"Version Management","text":""},{"location":"specs/publishing/#semantic-versioning","title":"Semantic Versioning","text":"<p>Follow SemVer: - MAJOR: Breaking changes - MINOR: New features (backward compatible) - PATCH: Bug fixes</p>"},{"location":"specs/publishing/#updating-version","title":"Updating Version","text":"<ol> <li> <p>Update <code>pyproject.toml</code>:    TOML<pre><code>version = \"0.3.0\"\n</code></pre></p> </li> <li> <p>Update <code>venomqa/__init__.py</code>:    Python<pre><code>__version__ = \"0.3.0\"\n</code></pre></p> </li> <li> <p>Update <code>CHANGELOG.md</code> with release notes</p> </li> <li> <p>Create git tag:    Bash<pre><code>git tag -a v0.3.0 -m \"Release 0.3.0\"\ngit push origin v0.3.0\n</code></pre></p> </li> </ol>"},{"location":"specs/publishing/#github-actions-cicd","title":"GitHub Actions CI/CD","text":"<p>Create <code>.github/workflows/publish.yml</code> for automated publishing:</p> YAML<pre><code>name: Publish to PyPI\n\non:\n  release:\n    types: [published]\n\npermissions:\n  id-token: write  # For trusted publishing\n  contents: read\n\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n\n      - name: Install dependencies\n        run: |\n          pip install build twine\n\n      - name: Build package\n        run: python -m build\n\n      - name: Check package\n        run: twine check dist/*\n\n      - name: Publish to PyPI\n        uses: pypa/gh-action-pypi-publish@release/v1\n</code></pre>"},{"location":"specs/publishing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"specs/publishing/#file-already-exists-error","title":"File Already Exists Error","text":"Text Only<pre><code>HTTPError: 400 Bad Request from https://upload.pypi.org/legacy/\nFile already exists\n</code></pre> <p>Solution: You cannot re-upload the same version. Bump the version number.</p>"},{"location":"specs/publishing/#invalid-distribution","title":"Invalid Distribution","text":"Text Only<pre><code>error: invalid command 'bdist_wheel'\n</code></pre> <p>Solution: Install wheel: <code>pip install wheel build</code></p>"},{"location":"specs/publishing/#missing-files-in-distribution","title":"Missing Files in Distribution","text":"<p>Solution: Check <code>MANIFEST.in</code> and ensure files are included. For <code>hatchling</code>, files tracked by git are included by default.</p>"},{"location":"specs/publishing/#import-errors-after-install","title":"Import Errors After Install","text":"<p>Solution: Verify <code>__init__.py</code> exports are correct and all dependencies are listed in <code>pyproject.toml</code>.</p>"},{"location":"specs/publishing/#quick-reference-commands","title":"Quick Reference Commands","text":"Bash<pre><code># Clean\nrm -rf dist/ build/ *.egg-info\n\n# Build\npython -m build\n\n# Check\ntwine check dist/*\n\n# Upload to TestPyPI\ntwine upload --repository testpypi dist/*\n\n# Upload to PyPI\ntwine upload dist/*\n\n# Test install\npip install --index-url https://test.pypi.org/simple/ venomqa\n</code></pre>"},{"location":"specs/publishing/#resources","title":"Resources","text":"<ul> <li>PyPI Publishing Guide</li> <li>Twine Documentation</li> <li>Trusted Publishers</li> <li>Semantic Versioning</li> </ul>"},{"location":"specs/state-chain/","title":"VenomQA State Chain Specification","text":"<p>The definitive spec for context-aware state exploration that mimics human QA</p>"},{"location":"specs/state-chain/#the-problem","title":"The Problem","text":"<p>Current \"exploration\" is broken: - Calls endpoints with placeholder values (<code>{todoId}</code> instead of real IDs) - Each call is independent - no context passing - Results in 404s and dead-ends everywhere - NOT how a human QA works</p>"},{"location":"specs/state-chain/#the-vision","title":"The Vision","text":"<p>A human QA does this: 1. Creates something \u2192 Gets back an ID 2. Uses that ID in the next call 3. Gets back more data (file IDs, tokens, statuses) 4. Uses THAT data in subsequent calls 5. Builds a CHAIN of connected states</p>"},{"location":"specs/state-chain/#core-concept-state-chain","title":"Core Concept: State Chain","text":"Text Only<pre><code>Action \u2192 Response \u2192 Extract Context \u2192 Next Action (using context) \u2192 Response \u2192 ...\n</code></pre>"},{"location":"specs/state-chain/#example-chain","title":"Example Chain","text":"Text Only<pre><code>POST /todos {\"title\": \"Test\"}\n    \u2502\n    \u25bc Response: {\"id\": 42, \"title\": \"Test\", \"completed\": false}\n    \u2502\n    \u2502 EXTRACT: todo_id = 42\n    \u2502\n    \u25bc\nGET /todos/42  \u2190 Uses extracted todo_id\n    \u2502\n    \u25bc Response: {\"id\": 42, \"title\": \"Test\", \"completed\": false}\n    \u2502\n    \u25bc\nPUT /todos/42 {\"completed\": true}  \u2190 Same todo_id\n    \u2502\n    \u25bc Response: {\"id\": 42, \"completed\": true}\n    \u2502\n    \u2502 STATE CHANGED: todo is now completed\n    \u2502\n    \u25bc\nPOST /todos/42/attachments {file: binary}\n    \u2502\n    \u25bc Response: {\"id\": \"abc-123\", \"filename\": \"doc.pdf\", \"todo_id\": 42}\n    \u2502\n    \u2502 EXTRACT: attachment_id = \"abc-123\"\n    \u2502\n    \u25bc\nGET /todos/42/attachments/abc-123  \u2190 Uses BOTH extracted IDs\n    \u2502\n    \u25bc Response: &lt;file content&gt;\n    \u2502\n    \u25bc\nDELETE /todos/42/attachments/abc-123\n    \u2502\n    \u25bc Response: 204 No Content\n    \u2502\n    \u2502 STATE CHANGED: attachment removed\n    \u2502\n    \u25bc\nDELETE /todos/42\n    \u2502\n    \u25bc Response: 204 No Content\n    \u2502\n    \u2502 STATE CHANGED: todo deleted\n    \u2502\n    \u25bc\nGET /todos/42  \u2190 Verify deletion\n    \u2502\n    \u25bc Response: 404 {\"error\": \"Not found\"}  \u2190 EXPECTED!\n</code></pre>"},{"location":"specs/state-chain/#context-object","title":"Context Object","text":"<p>The context accumulates data through the chain:</p> Python<pre><code>context = {\n    \"todo_id\": None,        # Extracted from POST /todos\n    \"attachment_id\": None,  # Extracted from POST /attachments\n    \"auth_token\": None,     # Extracted from POST /login\n    \"user_id\": None,        # Extracted from auth response\n    \"order_id\": None,       # Extracted from POST /orders\n    # ... any ID or token from any response\n}\n</code></pre>"},{"location":"specs/state-chain/#context-extraction-rules","title":"Context Extraction Rules","text":"<p>From each response, extract:</p> <ol> <li>IDs: Any field ending in <code>_id</code>, <code>Id</code>, or named <code>id</code></li> <li>Tokens: <code>token</code>, <code>access_token</code>, <code>refresh_token</code>, <code>api_key</code></li> <li>References: <code>href</code>, <code>url</code>, <code>link</code> fields</li> <li>Status: <code>status</code>, <code>state</code>, <code>completed</code>, <code>active</code></li> </ol> Python<pre><code>def extract_context(response_json, context):\n    \"\"\"Extract relevant data from response into context.\"\"\"\n\n    # Extract IDs\n    for key, value in flatten(response_json):\n        if key == \"id\" or key.endswith(\"_id\") or key.endswith(\"Id\"):\n            # Infer context key from endpoint or response structure\n            context_key = infer_context_key(key, endpoint)\n            context[context_key] = value\n\n        if key in [\"token\", \"access_token\", \"auth_token\"]:\n            context[\"auth_token\"] = value\n\n    return context\n</code></pre>"},{"location":"specs/state-chain/#path-parameter-substitution","title":"Path Parameter Substitution","text":"<p>Before executing an action, substitute context values:</p> Python<pre><code>def substitute_path_params(endpoint, context):\n    \"\"\"Replace {param} with actual values from context.\"\"\"\n\n    # /todos/{todoId} + context[\"todo_id\"]=42 \u2192 /todos/42\n    # /todos/{todoId}/attachments/{fileId} + context \u2192 /todos/42/attachments/abc-123\n\n    result = endpoint\n    for match in re.findall(r'\\{(\\w+)\\}', endpoint):\n        # Try exact match\n        if match in context:\n            result = result.replace(f'{{{match}}}', str(context[match]))\n        # Try common variations\n        elif match.lower() + \"_id\" in context:\n            result = result.replace(f'{{{match}}}', str(context[match.lower() + \"_id\"]))\n        elif match.replace(\"Id\", \"_id\") in context:\n            result = result.replace(f'{{{match}}}', str(context[match.replace(\"Id\", \"_id\")]))\n\n    return result\n</code></pre>"},{"location":"specs/state-chain/#state-definition","title":"State Definition","text":"<p>A state is defined by:</p> Python<pre><code>@dataclass\nclass ChainState:\n    \"\"\"State in the exploration chain.\"\"\"\n\n    id: str                          # Unique identifier\n    name: str                        # Human-readable name\n    context: Dict[str, Any]          # Accumulated context (IDs, tokens)\n    response: Dict[str, Any]         # Response that led to this state\n    available_actions: List[Action]  # What can be done from here\n    depth: int                       # How deep in the chain\n    parent_state: Optional[str]      # Previous state ID\n    parent_action: Optional[Action]  # Action that led here\n</code></pre>"},{"location":"specs/state-chain/#chain-exploration-algorithm","title":"Chain Exploration Algorithm","text":"Python<pre><code>def explore_chain(initial_actions, max_depth=10):\n    \"\"\"BFS exploration with context passing.\"\"\"\n\n    context = {}  # Shared context accumulates through chain\n    graph = StateGraph()\n    queue = [(initial_state, context.copy(), 0)]  # (state, context, depth)\n\n    while queue:\n        current_state, current_context, depth = queue.pop(0)\n\n        if depth &gt;= max_depth:\n            continue\n\n        for action in current_state.available_actions:\n            # 1. Substitute path parameters with context values\n            resolved_endpoint = substitute_path_params(action.endpoint, current_context)\n\n            # 2. Skip if we can't resolve all parameters\n            if '{' in resolved_endpoint:\n                continue  # Missing required context\n\n            # 3. Execute the action\n            response = execute(action.method, resolved_endpoint, action.body)\n\n            # 4. Extract new context from response\n            new_context = current_context.copy()\n            extract_context(response.json(), new_context)\n\n            # 5. Determine the new state\n            new_state = create_state(response, new_context, depth + 1)\n\n            # 6. Record transition\n            graph.add_transition(current_state, action, new_state)\n\n            # 7. Queue for further exploration\n            if new_state not in visited:\n                queue.append((new_state, new_context, depth + 1))\n\n    return graph\n</code></pre>"},{"location":"specs/state-chain/#state-naming","title":"State Naming","text":"<p>States should have meaningful names based on context:</p> Python<pre><code>def generate_state_name(context, response):\n    \"\"\"Generate human-readable state name.\"\"\"\n\n    parts = []\n\n    if context.get(\"auth_token\"):\n        parts.append(\"Authenticated\")\n    else:\n        parts.append(\"Anonymous\")\n\n    if context.get(\"todo_id\"):\n        parts.append(f\"Todo:{context['todo_id']}\")\n\n    if context.get(\"attachment_id\"):\n        parts.append(f\"Attachment:{context['attachment_id']}\")\n\n    if response.get(\"completed\"):\n        parts.append(\"Completed\")\n\n    return \" | \".join(parts) or \"Initial\"\n</code></pre>"},{"location":"specs/state-chain/#expected-state-graph-todo-app","title":"Expected State Graph (Todo App)","text":"Text Only<pre><code>                        [Anonymous]\n                             \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u25bc              \u25bc              \u25bc\n         [GET /health]  [GET /todos]  [POST /todos]\n              \u2502              \u2502              \u2502\n              \u25bc              \u25bc              \u25bc\n          [Healthy]    [Empty List]   [Todo:1 Created]\n                                           \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u25bc                      \u25bc                      \u25bc\n             [GET /todos/1]         [PUT /todos/1]         [DELETE /todos/1]\n                    \u2502                      \u2502                      \u2502\n                    \u25bc                      \u25bc                      \u25bc\n             [Viewing Todo:1]       [Todo:1 Completed]      [Todo:1 Deleted]\n                    \u2502                      \u2502                      \u2502\n                    \u25bc                      \u25bc                      \u25bc\n          [POST /todos/1/attach]    [POST /todos/1/attach]  [GET /todos/1]\n                    \u2502                      \u2502                      \u2502\n                    \u25bc                      \u25bc                      \u25bc\n          [Todo:1 + Attach:abc]    [Todo:1 Completed       [404 - Expected]\n                    \u2502               + Attach:xyz]\n                    \u25bc\n          [GET /todos/1/attach/abc]\n                    \u2502\n                    \u25bc\n          [Downloaded File]\n                    \u2502\n                    \u25bc\n          [DELETE /todos/1/attach/abc]\n                    \u2502\n                    \u25bc\n          [Todo:1 No Attachments]\n</code></pre>"},{"location":"specs/state-chain/#key-differences-from-current-implementation","title":"Key Differences from Current Implementation","text":"Current (Broken) Required (Real) <code>GET /todos/{todoId}</code> with literal <code>{todoId}</code> <code>GET /todos/42</code> with real ID Context ignored Context passed through chain Flat graph, all from initial Deep tree, states depend on parents 404s are failures 404s after DELETE are expected No relationship between calls Each call builds on previous"},{"location":"specs/state-chain/#success-criteria","title":"Success Criteria","text":"<ol> <li>Zero placeholder 404s - All path params resolved from context</li> <li>Deep chains - At least 5-6 levels deep for CRUD apps</li> <li>Context accumulation - IDs extracted and reused</li> <li>Meaningful state names - Based on context, not random hashes</li> <li>Expected errors identified - 404 after DELETE is OK, 404 on GET is bug</li> </ol>"},{"location":"specs/state-chain/#implementation-checklist","title":"Implementation Checklist","text":"<ul> <li> Context object passed through exploration</li> <li> <code>extract_context()</code> pulls IDs/tokens from responses</li> <li> <code>substitute_path_params()</code> replaces <code>{param}</code> with context values</li> <li> Actions skipped if path params can't be resolved</li> <li> State names generated from context</li> <li> Parent-child relationships tracked</li> <li> Deep exploration (not just initial \u2192 first level)</li> </ul>"},{"location":"specs/state-chain/#files-to-modify","title":"Files to Modify","text":"<ol> <li><code>venomqa/explorer/engine.py</code> - Add context passing to BFS/DFS</li> <li><code>venomqa/explorer/detector.py</code> - Add <code>extract_context()</code> function</li> <li><code>venomqa/explorer/models.py</code> - Add <code>ChainState</code> with context field</li> <li><code>venomqa/explorer/explorer.py</code> - Wire up context-aware exploration</li> </ol>"},{"location":"specs/state-chain/#example-usage-target-api","title":"Example Usage (Target API)","text":"Python<pre><code>from venomqa.explorer import StateExplorer\n\nexplorer = StateExplorer(\n    base_url=\"http://localhost:5001\",\n    openapi_spec=\"openapi.yaml\"\n)\n\n# This should produce a DEEP, CONNECTED state graph\nresult = explorer.explore_with_context()\n\n# States should have meaningful names\nfor state in result.graph.states.values():\n    print(state.name)\n    # \"Anonymous\"\n    # \"Anonymous | Todo:1\"\n    # \"Anonymous | Todo:1 | Completed\"\n    # \"Anonymous | Todo:1 | Attachment:abc\"\n    # \"Anonymous | Todo:1 Deleted\"\n\n# Transitions should use real IDs\nfor t in result.graph.transitions:\n    print(f\"{t.from_state} --[{t.action.endpoint}]--&gt; {t.to_state}\")\n    # \"Anonymous --[POST /todos]--&gt; Anonymous | Todo:1\"\n    # \"Anonymous | Todo:1 --[GET /todos/1]--&gt; Anonymous | Todo:1 | Viewing\"\n    # \"Anonymous | Todo:1 --[PUT /todos/1]--&gt; Anonymous | Todo:1 | Completed\"\n</code></pre> <p>This is the spec. No more placeholder garbage. Real context-aware state chains.</p>"},{"location":"specs/state-explorer/","title":"VenomQA State Explorer - Technical Specification","text":""},{"location":"specs/state-explorer/#overview","title":"Overview","text":"<p>The State Explorer is an automated testing component that discovers and explores all possible application states by systematically executing API actions and tracking state transitions. It builds a complete state graph representation of the application, enabling comprehensive test coverage analysis and issue detection.</p> <p>Key Capabilities: - Automated state space exploration using BFS/DFS algorithms - State signature computation from API responses - State graph construction and visualization - Issue detection (dead ends, cycles, errors, unreachable states) - Coverage metrics computation - Integration with existing VenomQA infrastructure</p>"},{"location":"specs/state-explorer/#1-state-detection-algorithm","title":"1. State Detection Algorithm","text":""},{"location":"specs/state-explorer/#11-state-signature-computation","title":"1.1 State Signature Computation","text":"<p>A state signature uniquely identifies an application state based on observable properties from API responses. The signature is computed as a hash of normalized state components.</p>"},{"location":"specs/state-explorer/#state-components","title":"State Components","text":"Python<pre><code>@dataclass\nclass StateComponents:\n    \"\"\"Components used to compute state signature.\"\"\"\n\n    # Authentication status\n    auth_status: AuthStatus  # ANONYMOUS, AUTHENTICATED, ADMIN, etc.\n    user_id: str | None      # Current user identifier\n\n    # Entity presence and statuses\n    entity_ids: frozenset[tuple[str, str]]  # Set of (entity_type, entity_id)\n    entity_statuses: frozenset[tuple[str, str, str]]  # (type, id, status)\n\n    # Resource counts (for aggregate state)\n    resource_counts: frozenset[tuple[str, int]]  # (resource_type, count)\n\n    # Feature flags / permissions\n    permissions: frozenset[str]  # Active permission flags\n\nclass AuthStatus(Enum):\n    ANONYMOUS = \"anonymous\"\n    AUTHENTICATED = \"authenticated\"\n    ADMIN = \"admin\"\n    EXPIRED = \"expired\"\n</code></pre>"},{"location":"specs/state-explorer/#signature-computation-algorithm","title":"Signature Computation Algorithm","text":"Python<pre><code>import hashlib\nimport json\nfrom typing import Any\n\nclass StateSignature:\n    \"\"\"Computes unique state signatures from API responses.\"\"\"\n\n    HASH_ALGORITHM = \"sha256\"\n    SIGNATURE_LENGTH = 16  # First 16 chars of hex digest\n\n    @classmethod\n    def compute(cls, components: StateComponents) -&gt; str:\n        \"\"\"Compute a deterministic state signature.\n\n        Args:\n            components: State components extracted from API response.\n\n        Returns:\n            16-character hex string uniquely identifying this state.\n        \"\"\"\n        # Normalize components to ensure deterministic ordering\n        normalized = {\n            \"auth_status\": components.auth_status.value,\n            \"user_id\": components.user_id,\n            \"entity_ids\": sorted(list(components.entity_ids)),\n            \"entity_statuses\": sorted(list(components.entity_statuses)),\n            \"resource_counts\": sorted(list(components.resource_counts)),\n            \"permissions\": sorted(list(components.permissions)),\n        }\n\n        # Serialize to canonical JSON\n        canonical = json.dumps(normalized, sort_keys=True, separators=(\",\", \":\"))\n\n        # Compute hash\n        digest = hashlib.new(cls.HASH_ALGORITHM, canonical.encode()).hexdigest()\n\n        return digest[:cls.SIGNATURE_LENGTH]\n\n    @classmethod\n    def extract_components(\n        cls,\n        response: dict[str, Any],\n        auth_header: str | None = None,\n    ) -&gt; StateComponents:\n        \"\"\"Extract state components from an API response.\n\n        Args:\n            response: Parsed JSON response from API.\n            auth_header: Current authorization header value.\n\n        Returns:\n            StateComponents for signature computation.\n        \"\"\"\n        # Determine auth status\n        auth_status = cls._extract_auth_status(response, auth_header)\n        user_id = cls._extract_user_id(response)\n\n        # Extract entities\n        entity_ids = cls._extract_entity_ids(response)\n        entity_statuses = cls._extract_entity_statuses(response)\n\n        # Extract counts\n        resource_counts = cls._extract_resource_counts(response)\n\n        # Extract permissions\n        permissions = cls._extract_permissions(response)\n\n        return StateComponents(\n            auth_status=auth_status,\n            user_id=user_id,\n            entity_ids=frozenset(entity_ids),\n            entity_statuses=frozenset(entity_statuses),\n            resource_counts=frozenset(resource_counts),\n            permissions=frozenset(permissions),\n        )\n</code></pre>"},{"location":"specs/state-explorer/#12-state-inference-examples","title":"1.2 State Inference Examples","text":""},{"location":"specs/state-explorer/#example-1-e-commerce-cart-state","title":"Example 1: E-commerce Cart State","text":"JSON<pre><code>// API Response: GET /api/cart\n{\n  \"cart_id\": \"cart_123\",\n  \"user_id\": \"user_456\",\n  \"items\": [\n    {\"product_id\": \"prod_1\", \"quantity\": 2, \"status\": \"available\"},\n    {\"product_id\": \"prod_2\", \"quantity\": 1, \"status\": \"backordered\"}\n  ],\n  \"total\": 149.99,\n  \"checkout_ready\": false\n}\n</code></pre> <p>Extracted Components: Python<pre><code>StateComponents(\n    auth_status=AuthStatus.AUTHENTICATED,\n    user_id=\"user_456\",\n    entity_ids=frozenset([\n        (\"cart\", \"cart_123\"),\n        (\"product\", \"prod_1\"),\n        (\"product\", \"prod_2\"),\n    ]),\n    entity_statuses=frozenset([\n        (\"cart_item\", \"prod_1\", \"available\"),\n        (\"cart_item\", \"prod_2\", \"backordered\"),\n        (\"cart\", \"cart_123\", \"not_checkout_ready\"),\n    ]),\n    resource_counts=frozenset([\n        (\"cart_items\", 2),\n    ]),\n    permissions=frozenset(),\n)\n</code></pre></p> <p>Signature: <code>\"a3f2b1c9e8d7f6a5\"</code></p>"},{"location":"specs/state-explorer/#example-2-user-authentication-state","title":"Example 2: User Authentication State","text":"JSON<pre><code>// API Response: GET /api/me\n{\n  \"id\": \"user_456\",\n  \"email\": \"user@example.com\",\n  \"role\": \"admin\",\n  \"permissions\": [\"read:users\", \"write:users\", \"delete:users\"],\n  \"session_expires_at\": \"2024-01-15T10:00:00Z\"\n}\n</code></pre> <p>Extracted Components: Python<pre><code>StateComponents(\n    auth_status=AuthStatus.ADMIN,\n    user_id=\"user_456\",\n    entity_ids=frozenset([(\"user\", \"user_456\")]),\n    entity_statuses=frozenset([(\"user\", \"user_456\", \"active\")]),\n    resource_counts=frozenset(),\n    permissions=frozenset([\"read:users\", \"write:users\", \"delete:users\"]),\n)\n</code></pre></p> <p>Signature: <code>\"7c8d9e0f1a2b3c4d\"</code></p>"},{"location":"specs/state-explorer/#2-exploration-algorithm","title":"2. Exploration Algorithm","text":""},{"location":"specs/state-explorer/#21-algorithm-selection-bfs-vs-dfs","title":"2.1 Algorithm Selection: BFS vs DFS","text":"Aspect BFS (Breadth-First) DFS (Depth-First) Coverage Finds shortest paths first Explores full depths first Memory O(branching_factor^depth) O(depth) State Discovery Level-by-level Path-by-path Best For Finding minimum-step transitions Deep workflow testing Cycle Detection Early detection Late detection <p>Recommended Default: Hybrid approach with BFS for initial exploration and DFS for deep path verification.</p>"},{"location":"specs/state-explorer/#22-core-exploration-algorithm","title":"2.2 Core Exploration Algorithm","text":"Python<pre><code>from collections import deque\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Callable, Iterator\n\nclass ExplorationStrategy(Enum):\n    BFS = \"bfs\"\n    DFS = \"dfs\"\n    HYBRID = \"hybrid\"  # BFS to depth N, then DFS\n\n@dataclass\nclass ExplorationConfig:\n    \"\"\"Configuration for state exploration.\"\"\"\n\n    strategy: ExplorationStrategy = ExplorationStrategy.HYBRID\n    max_depth: int = 10\n    max_states: int = 1000\n    max_transitions: int = 5000\n    bfs_switch_depth: int = 3  # For HYBRID: switch to DFS after this depth\n    timeout_seconds: float = 300.0\n    parallel_workers: int = 4\n    cycle_detection: bool = True\n    rollback_on_mutation: bool = True\n\n@dataclass\nclass ExplorationState:\n    \"\"\"State during exploration.\"\"\"\n\n    signature: str\n    depth: int\n    path: list[str]  # Sequence of action names leading here\n    response_data: dict\n    parent_signature: str | None = None\n    action_from_parent: str | None = None\n\nclass StateExplorer:\n    \"\"\"Core state exploration engine.\"\"\"\n\n    def __init__(\n        self,\n        client: \"BaseClient\",\n        state_manager: \"StateManager\",\n        action_generator: \"ActionGenerator\",\n        config: ExplorationConfig | None = None,\n    ):\n        self.client = client\n        self.state_manager = state_manager\n        self.action_generator = action_generator\n        self.config = config or ExplorationConfig()\n\n        # Exploration tracking\n        self.visited_states: dict[str, ExplorationState] = {}\n        self.transitions: list[StateTransition] = []\n        self.frontier: deque[ExplorationState] = deque()\n\n        # Metrics\n        self.states_discovered = 0\n        self.transitions_executed = 0\n        self.cycles_detected = 0\n        self.errors_encountered = 0\n\n    def explore(self, initial_response: dict) -&gt; StateGraph:\n        \"\"\"Execute state space exploration.\n\n        Args:\n            initial_response: Response from initial state query.\n\n        Returns:\n            Complete StateGraph of discovered states and transitions.\n        \"\"\"\n        # Initialize with starting state\n        initial_state = self._create_initial_state(initial_response)\n        self.frontier.append(initial_state)\n        self.visited_states[initial_state.signature] = initial_state\n\n        # Create initial checkpoint for rollback\n        self.state_manager.checkpoint(\"exploration_start\")\n\n        while self._should_continue():\n            current = self._get_next_state()\n            if current is None:\n                break\n\n            # Explore all available actions from current state\n            for action in self.action_generator.generate_actions(current):\n                self._explore_action(current, action)\n\n        return self._build_graph()\n\n    def _get_next_state(self) -&gt; ExplorationState | None:\n        \"\"\"Get next state to explore based on strategy.\"\"\"\n        if not self.frontier:\n            return None\n\n        if self.config.strategy == ExplorationStrategy.BFS:\n            return self.frontier.popleft()\n        elif self.config.strategy == ExplorationStrategy.DFS:\n            return self.frontier.pop()\n        else:  # HYBRID\n            # Use BFS until switch depth, then DFS\n            if self.frontier and self.frontier[0].depth &lt; self.config.bfs_switch_depth:\n                return self.frontier.popleft()\n            return self.frontier.pop()\n\n    def _explore_action(\n        self,\n        current: ExplorationState,\n        action: \"GeneratedAction\",\n    ) -&gt; None:\n        \"\"\"Execute an action and record the transition.\n\n        Args:\n            current: Current state.\n            action: Action to execute.\n        \"\"\"\n        # Checkpoint before mutation\n        checkpoint_name = f\"pre_{action.name}_{self.transitions_executed}\"\n        if self.config.rollback_on_mutation and action.is_mutation:\n            self.state_manager.checkpoint(checkpoint_name)\n\n        try:\n            # Execute action\n            start_time = time.time()\n            response = self.client.request(\n                method=action.method,\n                url=action.url,\n                json=action.body,\n                headers=action.headers,\n            )\n            duration_ms = (time.time() - start_time) * 1000\n\n            # Compute new state\n            new_signature = StateSignature.compute(\n                StateSignature.extract_components(response.json())\n            )\n\n            # Record transition\n            transition = StateTransition(\n                from_state=current.signature,\n                to_state=new_signature,\n                action=action.name,\n                method=action.method,\n                url=action.url,\n                status_code=response.status_code,\n                duration_ms=duration_ms,\n                is_error=response.status_code &gt;= 400,\n            )\n            self.transitions.append(transition)\n            self.transitions_executed += 1\n\n            # Handle new state discovery\n            if new_signature not in self.visited_states:\n                new_state = ExplorationState(\n                    signature=new_signature,\n                    depth=current.depth + 1,\n                    path=current.path + [action.name],\n                    response_data=response.json(),\n                    parent_signature=current.signature,\n                    action_from_parent=action.name,\n                )\n\n                if new_state.depth &lt;= self.config.max_depth:\n                    self.visited_states[new_signature] = new_state\n                    self.frontier.append(new_state)\n                    self.states_discovered += 1\n            else:\n                # Cycle detected\n                self.cycles_detected += 1\n\n        except Exception as e:\n            self.errors_encountered += 1\n            self._record_error(current, action, e)\n\n        finally:\n            # Rollback mutation\n            if self.config.rollback_on_mutation and action.is_mutation:\n                self.state_manager.rollback(checkpoint_name)\n\n    def _should_continue(self) -&gt; bool:\n        \"\"\"Check if exploration should continue.\"\"\"\n        if not self.frontier:\n            return False\n        if self.states_discovered &gt;= self.config.max_states:\n            return False\n        if self.transitions_executed &gt;= self.config.max_transitions:\n            return False\n        return True\n</code></pre>"},{"location":"specs/state-explorer/#23-handling-infinite-state-spaces","title":"2.3 Handling Infinite State Spaces","text":""},{"location":"specs/state-explorer/#depth-limiting","title":"Depth Limiting","text":"Python<pre><code>@dataclass\nclass DepthLimitConfig:\n    \"\"\"Configuration for depth limiting.\"\"\"\n\n    # Hard maximum depth\n    max_depth: int = 10\n\n    # Per-action-type depth limits (some actions go deeper)\n    action_depth_limits: dict[str, int] = field(default_factory=lambda: {\n        \"create\": 5,\n        \"delete\": 3,\n        \"update\": 7,\n        \"read\": 10,\n    })\n\n    # Depth penalty for repeated action types\n    repetition_penalty: float = 0.5  # Each repeat costs 0.5 depth units\n</code></pre>"},{"location":"specs/state-explorer/#cycle-detection","title":"Cycle Detection","text":"Python<pre><code>class CycleDetector:\n    \"\"\"Detects and handles cycles in state exploration.\"\"\"\n\n    def __init__(self, max_cycle_visits: int = 2):\n        self.max_cycle_visits = max_cycle_visits\n        self.visit_counts: dict[str, int] = defaultdict(int)\n        self.detected_cycles: list[Cycle] = []\n\n    def should_explore(self, state_signature: str) -&gt; bool:\n        \"\"\"Check if state should be explored again.\"\"\"\n        return self.visit_counts[state_signature] &lt; self.max_cycle_visits\n\n    def record_visit(self, state_signature: str) -&gt; None:\n        \"\"\"Record a state visit.\"\"\"\n        self.visit_counts[state_signature] += 1\n\n    def detect_cycle(\n        self,\n        current_path: list[str],\n        new_signature: str,\n        visited: dict[str, ExplorationState],\n    ) -&gt; Cycle | None:\n        \"\"\"Detect if transitioning creates a cycle.\n\n        Returns:\n            Cycle object if cycle detected, None otherwise.\n        \"\"\"\n        if new_signature in visited:\n            existing = visited[new_signature]\n\n            # Find cycle start in path\n            cycle_start_idx = len(existing.path)\n            cycle_actions = current_path[cycle_start_idx:]\n\n            return Cycle(\n                start_state=new_signature,\n                actions=cycle_actions,\n                length=len(cycle_actions),\n            )\n        return None\n\n@dataclass\nclass Cycle:\n    \"\"\"Represents a detected cycle in the state graph.\"\"\"\n\n    start_state: str\n    actions: list[str]\n    length: int\n\n    @property\n    def is_self_loop(self) -&gt; bool:\n        return self.length == 1\n</code></pre>"},{"location":"specs/state-explorer/#24-parallel-exploration-strategy","title":"2.4 Parallel Exploration Strategy","text":"Python<pre><code>import asyncio\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass ParallelStateExplorer:\n    \"\"\"Parallel state exploration using worker pools.\"\"\"\n\n    def __init__(\n        self,\n        client_factory: Callable[[], \"BaseClient\"],\n        state_manager: \"StateManager\",\n        action_generator: \"ActionGenerator\",\n        config: ExplorationConfig,\n    ):\n        self.client_factory = client_factory\n        self.state_manager = state_manager\n        self.action_generator = action_generator\n        self.config = config\n\n        # Shared state (thread-safe)\n        self.visited_lock = asyncio.Lock()\n        self.visited_states: dict[str, ExplorationState] = {}\n        self.work_queue: asyncio.Queue[ExplorationState] = asyncio.Queue()\n        self.results_queue: asyncio.Queue[StateTransition] = asyncio.Queue()\n\n    async def explore_parallel(self, initial_response: dict) -&gt; StateGraph:\n        \"\"\"Execute parallel state space exploration.\"\"\"\n\n        # Initialize\n        initial_state = self._create_initial_state(initial_response)\n        await self.work_queue.put(initial_state)\n\n        # Create worker pool\n        workers = [\n            asyncio.create_task(self._worker(i))\n            for i in range(self.config.parallel_workers)\n        ]\n\n        # Wait for completion or timeout\n        try:\n            await asyncio.wait_for(\n                self._wait_for_completion(),\n                timeout=self.config.timeout_seconds,\n            )\n        except asyncio.TimeoutError:\n            pass  # Timeout reached, stop exploration\n\n        # Cancel workers\n        for worker in workers:\n            worker.cancel()\n\n        return self._build_graph()\n\n    async def _worker(self, worker_id: int) -&gt; None:\n        \"\"\"Worker coroutine for parallel exploration.\"\"\"\n\n        # Each worker gets its own client\n        client = self.client_factory()\n        client.connect()\n\n        try:\n            while True:\n                # Get work item\n                state = await asyncio.wait_for(\n                    self.work_queue.get(),\n                    timeout=5.0,\n                )\n\n                # Explore actions from this state\n                for action in self.action_generator.generate_actions(state):\n                    transition = await self._execute_action(\n                        client, state, action\n                    )\n\n                    if transition and transition.to_state not in self.visited_states:\n                        async with self.visited_lock:\n                            if transition.to_state not in self.visited_states:\n                                new_state = self._create_state_from_transition(\n                                    state, transition\n                                )\n                                self.visited_states[transition.to_state] = new_state\n                                await self.work_queue.put(new_state)\n\n                    await self.results_queue.put(transition)\n        finally:\n            client.disconnect()\n</code></pre>"},{"location":"specs/state-explorer/#25-rollback-strategy-using-database-savepoints","title":"2.5 Rollback Strategy Using Database Savepoints","text":"Python<pre><code>class ExplorationRollbackManager:\n    \"\"\"Manages database state rollback during exploration.\"\"\"\n\n    def __init__(self, state_manager: \"StateManager\"):\n        self.state_manager = state_manager\n        self.checkpoint_stack: list[str] = []\n        self.checkpoint_counter = 0\n\n    def create_exploration_checkpoint(self, prefix: str = \"explore\") -&gt; str:\n        \"\"\"Create a new checkpoint for exploration.\n\n        Returns:\n            Checkpoint name for later rollback.\n        \"\"\"\n        self.checkpoint_counter += 1\n        name = f\"{prefix}_{self.checkpoint_counter}\"\n        self.state_manager.checkpoint(name)\n        self.checkpoint_stack.append(name)\n        return name\n\n    def rollback_to_checkpoint(self, checkpoint_name: str) -&gt; None:\n        \"\"\"Rollback to a specific checkpoint.\n\n        Args:\n            checkpoint_name: Name of checkpoint to rollback to.\n        \"\"\"\n        self.state_manager.rollback(checkpoint_name)\n\n        # Remove all checkpoints after this one\n        while self.checkpoint_stack and self.checkpoint_stack[-1] != checkpoint_name:\n            self.checkpoint_stack.pop()\n\n    def rollback_last(self) -&gt; None:\n        \"\"\"Rollback to the most recent checkpoint.\"\"\"\n        if self.checkpoint_stack:\n            checkpoint_name = self.checkpoint_stack[-1]\n            self.rollback_to_checkpoint(checkpoint_name)\n\n    def release_checkpoint(self, checkpoint_name: str) -&gt; None:\n        \"\"\"Release a checkpoint when no longer needed.\"\"\"\n        self.state_manager.release(checkpoint_name)\n        if checkpoint_name in self.checkpoint_stack:\n            self.checkpoint_stack.remove(checkpoint_name)\n\n    def __enter__(self) -&gt; \"ExplorationRollbackManager\":\n        \"\"\"Context manager entry.\"\"\"\n        self.state_manager.connect()\n        self.create_exploration_checkpoint(\"exploration_root\")\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Context manager exit - cleanup all checkpoints.\"\"\"\n        # Rollback to root to clean up exploration changes\n        if self.checkpoint_stack:\n            root = self.checkpoint_stack[0]\n            self.rollback_to_checkpoint(root)\n\n        self.state_manager.disconnect()\n</code></pre>"},{"location":"specs/state-explorer/#3-action-generation","title":"3. Action Generation","text":""},{"location":"specs/state-explorer/#31-openapi-schema-based-generation","title":"3.1 OpenAPI Schema-Based Generation","text":"Python<pre><code>from dataclasses import dataclass, field\nfrom typing import Any\n\n@dataclass\nclass GeneratedAction:\n    \"\"\"An action generated from API schema.\"\"\"\n\n    name: str\n    method: str  # GET, POST, PUT, PATCH, DELETE\n    url: str\n    body: dict[str, Any] | None = None\n    headers: dict[str, str] = field(default_factory=dict)\n    query_params: dict[str, str] = field(default_factory=dict)\n\n    # Action metadata\n    operation_id: str = \"\"\n    tags: list[str] = field(default_factory=list)\n    requires_auth: bool = False\n    is_mutation: bool = False  # True for POST, PUT, PATCH, DELETE\n\nclass OpenAPIActionGenerator:\n    \"\"\"Generates valid API requests from OpenAPI specifications.\"\"\"\n\n    def __init__(\n        self,\n        spec: dict[str, Any],\n        data_generator: \"DataGenerator\",\n        base_url: str,\n    ):\n        self.spec = spec\n        self.data_generator = data_generator\n        self.base_url = base_url.rstrip(\"/\")\n\n        # Parse spec\n        self.paths = spec.get(\"paths\", {})\n        self.schemas = spec.get(\"components\", {}).get(\"schemas\", {})\n        self.security_schemes = spec.get(\"components\", {}).get(\"securitySchemes\", {})\n\n    def generate_actions(\n        self,\n        current_state: ExplorationState,\n        filter_tags: list[str] | None = None,\n    ) -&gt; Iterator[GeneratedAction]:\n        \"\"\"Generate all valid actions for current state.\n\n        Args:\n            current_state: Current application state.\n            filter_tags: Optional tags to filter actions.\n\n        Yields:\n            GeneratedAction objects for each valid action.\n        \"\"\"\n        for path, path_item in self.paths.items():\n            for method, operation in path_item.items():\n                if method.upper() not in [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]:\n                    continue\n\n                # Check tag filter\n                if filter_tags:\n                    op_tags = operation.get(\"tags\", [])\n                    if not any(t in filter_tags for t in op_tags):\n                        continue\n\n                # Generate action\n                action = self._generate_action(\n                    path, method.upper(), operation, current_state\n                )\n                if action:\n                    yield action\n\n    def _generate_action(\n        self,\n        path: str,\n        method: str,\n        operation: dict,\n        current_state: ExplorationState,\n    ) -&gt; GeneratedAction | None:\n        \"\"\"Generate a single action from operation spec.\"\"\"\n\n        # Resolve path parameters\n        resolved_path = self._resolve_path_params(path, operation, current_state)\n        if resolved_path is None:\n            return None  # Cannot resolve required path params\n\n        # Generate request body\n        body = None\n        if \"requestBody\" in operation:\n            body = self._generate_request_body(operation[\"requestBody\"])\n\n        # Generate query parameters\n        query_params = self._generate_query_params(operation, current_state)\n\n        # Build URL with query params\n        url = f\"{self.base_url}{resolved_path}\"\n        if query_params:\n            url += \"?\" + \"&amp;\".join(f\"{k}={v}\" for k, v in query_params.items())\n\n        # Determine if auth required\n        requires_auth = bool(operation.get(\"security\", self.spec.get(\"security\", [])))\n\n        return GeneratedAction(\n            name=operation.get(\"operationId\", f\"{method}_{path}\"),\n            method=method,\n            url=url,\n            body=body,\n            operation_id=operation.get(\"operationId\", \"\"),\n            tags=operation.get(\"tags\", []),\n            requires_auth=requires_auth,\n            is_mutation=method in [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"],\n        )\n\n    def _resolve_path_params(\n        self,\n        path: str,\n        operation: dict,\n        current_state: ExplorationState,\n    ) -&gt; str | None:\n        \"\"\"Resolve path parameters using current state context.\n\n        Returns:\n            Resolved path string, or None if required params unavailable.\n        \"\"\"\n        import re\n\n        resolved = path\n        params = operation.get(\"parameters\", [])\n\n        for param in params:\n            if param.get(\"in\") != \"path\":\n                continue\n\n            param_name = param[\"name\"]\n            placeholder = f\"{{{param_name}}}\"\n\n            if placeholder in resolved:\n                # Try to get value from current state\n                value = self._get_param_value_from_state(\n                    param_name, param, current_state\n                )\n\n                if value is None:\n                    if param.get(\"required\", True):\n                        return None  # Required param not available\n                    # Generate a value\n                    value = self.data_generator.generate_for_schema(\n                        param.get(\"schema\", {\"type\": \"string\"})\n                    )\n\n                resolved = resolved.replace(placeholder, str(value))\n\n        return resolved\n\n    def _get_param_value_from_state(\n        self,\n        param_name: str,\n        param_spec: dict,\n        current_state: ExplorationState,\n    ) -&gt; Any:\n        \"\"\"Extract parameter value from current state.\"\"\"\n\n        # Common mappings\n        mappings = {\n            \"id\": lambda s: self._extract_id(s.response_data),\n            \"user_id\": lambda s: s.response_data.get(\"user_id\"),\n            \"product_id\": lambda s: self._extract_entity_id(s.response_data, \"product\"),\n            \"order_id\": lambda s: self._extract_entity_id(s.response_data, \"order\"),\n        }\n\n        if param_name in mappings:\n            return mappings[param_name](current_state)\n\n        # Try to find in response data\n        return current_state.response_data.get(param_name)\n\n    def _generate_request_body(\n        self,\n        request_body_spec: dict,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Generate request body from schema.\"\"\"\n\n        content = request_body_spec.get(\"content\", {})\n\n        # Prefer JSON\n        if \"application/json\" in content:\n            schema = content[\"application/json\"].get(\"schema\", {})\n            return self.data_generator.generate_for_schema(schema)\n\n        return None\n</code></pre>"},{"location":"specs/state-explorer/#32-data-generation-with-faker","title":"3.2 Data Generation with Faker","text":"Python<pre><code>from typing import Any\nfrom faker import Faker\n\nclass DataGenerator:\n    \"\"\"Generates valid test data for API requests.\"\"\"\n\n    def __init__(self, locale: str = \"en_US\", seed: int | None = None):\n        self.faker = Faker(locale)\n        if seed is not None:\n            Faker.seed(seed)\n\n        # Schema type generators\n        self.type_generators: dict[str, Callable[[], Any]] = {\n            \"string\": self._generate_string,\n            \"integer\": lambda: self.faker.random_int(1, 10000),\n            \"number\": lambda: round(self.faker.pyfloat(min_value=0, max_value=10000), 2),\n            \"boolean\": lambda: self.faker.boolean(),\n            \"array\": self._generate_array,\n            \"object\": self._generate_object,\n        }\n\n        # Format-specific generators\n        self.format_generators: dict[str, Callable[[], Any]] = {\n            \"email\": lambda: self.faker.email(),\n            \"date\": lambda: self.faker.date(),\n            \"date-time\": lambda: self.faker.iso8601(),\n            \"uri\": lambda: self.faker.url(),\n            \"uuid\": lambda: str(self.faker.uuid4()),\n            \"phone\": lambda: self.faker.phone_number(),\n            \"password\": lambda: self.faker.password(length=16),\n        }\n\n    def generate_for_schema(\n        self,\n        schema: dict[str, Any],\n        required_only: bool = False,\n    ) -&gt; Any:\n        \"\"\"Generate data matching an OpenAPI schema.\n\n        Args:\n            schema: OpenAPI schema definition.\n            required_only: If True, only generate required fields.\n\n        Returns:\n            Generated data matching the schema.\n        \"\"\"\n        # Handle $ref\n        if \"$ref\" in schema:\n            # Resolve reference (simplified)\n            return self._generate_default_value(schema.get(\"type\", \"string\"))\n\n        # Handle enum\n        if \"enum\" in schema:\n            return self.faker.random_element(schema[\"enum\"])\n\n        # Handle format\n        fmt = schema.get(\"format\")\n        if fmt and fmt in self.format_generators:\n            return self.format_generators[fmt]()\n\n        # Handle type\n        schema_type = schema.get(\"type\", \"string\")\n\n        if schema_type == \"object\":\n            return self._generate_object(schema, required_only)\n        elif schema_type == \"array\":\n            return self._generate_array(schema)\n        elif schema_type in self.type_generators:\n            return self.type_generators[schema_type]()\n\n        return self._generate_default_value(schema_type)\n\n    def _generate_object(\n        self,\n        schema: dict[str, Any],\n        required_only: bool = False,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Generate an object matching schema properties.\"\"\"\n\n        result = {}\n        properties = schema.get(\"properties\", {})\n        required = set(schema.get(\"required\", []))\n\n        for prop_name, prop_schema in properties.items():\n            # Skip optional fields if required_only\n            if required_only and prop_name not in required:\n                continue\n\n            # Generate value\n            result[prop_name] = self.generate_for_schema(prop_schema)\n\n        return result\n\n    def _generate_array(self, schema: dict[str, Any]) -&gt; list[Any]:\n        \"\"\"Generate an array matching schema items.\"\"\"\n\n        items_schema = schema.get(\"items\", {\"type\": \"string\"})\n        min_items = schema.get(\"minItems\", 1)\n        max_items = schema.get(\"maxItems\", 3)\n\n        count = self.faker.random_int(min_items, max_items)\n        return [self.generate_for_schema(items_schema) for _ in range(count)]\n\n    def _generate_string(self) -&gt; str:\n        \"\"\"Generate a random string.\"\"\"\n        return self.faker.word()\n</code></pre>"},{"location":"specs/state-explorer/#33-handling-authentication-requirements","title":"3.3 Handling Authentication Requirements","text":"Python<pre><code>class AuthenticationHandler:\n    \"\"\"Manages authentication for action generation.\"\"\"\n\n    def __init__(\n        self,\n        auth_config: dict[str, Any],\n        credentials_provider: Callable[[], dict[str, str]],\n    ):\n        self.auth_config = auth_config\n        self.credentials_provider = credentials_provider\n        self._cached_token: str | None = None\n        self._token_expires_at: datetime | None = None\n\n    def prepare_action(\n        self,\n        action: GeneratedAction,\n        auth_status: AuthStatus,\n    ) -&gt; GeneratedAction:\n        \"\"\"Add authentication to action if required.\n\n        Args:\n            action: Action to authenticate.\n            auth_status: Required authentication level.\n\n        Returns:\n            Action with authentication headers added.\n        \"\"\"\n        if not action.requires_auth:\n            return action\n\n        if auth_status == AuthStatus.ANONYMOUS:\n            return action  # No auth needed\n\n        # Get or refresh token\n        token = self._get_valid_token(auth_status)\n\n        # Add auth header\n        action.headers[\"Authorization\"] = f\"Bearer {token}\"\n\n        return action\n\n    def _get_valid_token(self, auth_status: AuthStatus) -&gt; str:\n        \"\"\"Get or refresh authentication token.\"\"\"\n\n        # Check cache\n        if self._cached_token and self._token_expires_at:\n            if datetime.now() &lt; self._token_expires_at - timedelta(minutes=5):\n                return self._cached_token\n\n        # Get fresh credentials\n        credentials = self.credentials_provider()\n\n        # Exchange for token (implementation-specific)\n        token_response = self._exchange_credentials(credentials, auth_status)\n\n        self._cached_token = token_response[\"access_token\"]\n        self._token_expires_at = datetime.now() + timedelta(\n            seconds=token_response.get(\"expires_in\", 3600)\n        )\n\n        return self._cached_token\n</code></pre>"},{"location":"specs/state-explorer/#4-state-graph-data-structure","title":"4. State Graph Data Structure","text":""},{"location":"specs/state-explorer/#41-adjacency-list-representation","title":"4.1 Adjacency List Representation","text":"Python<pre><code>from dataclasses import dataclass, field\nfrom typing import Iterator\n\n@dataclass\nclass StateTransition:\n    \"\"\"A transition between two states.\"\"\"\n\n    from_state: str  # Source state signature\n    to_state: str    # Target state signature\n    action: str      # Action name that caused transition\n    method: str      # HTTP method\n    url: str         # Request URL\n    status_code: int # Response status code\n    duration_ms: float\n    is_error: bool = False\n    error_message: str | None = None\n    timestamp: datetime = field(default_factory=datetime.now)\n\n@dataclass\nclass StateNode:\n    \"\"\"A node in the state graph.\"\"\"\n\n    signature: str\n    depth: int\n    discovery_path: list[str]  # Actions leading to first discovery\n    response_snapshot: dict[str, Any]\n    metadata: dict[str, Any] = field(default_factory=dict)\n\n    # Graph properties\n    is_terminal: bool = False  # No outgoing transitions\n    is_error_state: bool = False\n    visit_count: int = 0\n\n    # Computed during analysis\n    incoming_transitions: list[str] = field(default_factory=list)\n    outgoing_transitions: list[str] = field(default_factory=list)\n\nclass StateGraph:\n    \"\"\"Directed graph representing application state space.\"\"\"\n\n    def __init__(self):\n        # Adjacency list: state_signature -&gt; list of transitions\n        self._adjacency: dict[str, list[StateTransition]] = defaultdict(list)\n\n        # Node storage\n        self._nodes: dict[str, StateNode] = {}\n\n        # Reverse adjacency for incoming edges\n        self._reverse_adjacency: dict[str, list[StateTransition]] = defaultdict(list)\n\n        # Root state\n        self.root_state: str | None = None\n\n    def add_node(self, node: StateNode) -&gt; None:\n        \"\"\"Add a state node to the graph.\"\"\"\n        self._nodes[node.signature] = node\n        if self.root_state is None:\n            self.root_state = node.signature\n\n    def add_transition(self, transition: StateTransition) -&gt; None:\n        \"\"\"Add a transition edge to the graph.\"\"\"\n        self._adjacency[transition.from_state].append(transition)\n        self._reverse_adjacency[transition.to_state].append(transition)\n\n        # Update node edge lists\n        if transition.from_state in self._nodes:\n            self._nodes[transition.from_state].outgoing_transitions.append(\n                transition.to_state\n            )\n        if transition.to_state in self._nodes:\n            self._nodes[transition.to_state].incoming_transitions.append(\n                transition.from_state\n            )\n\n    def get_node(self, signature: str) -&gt; StateNode | None:\n        \"\"\"Get a node by signature.\"\"\"\n        return self._nodes.get(signature)\n\n    def get_outgoing(self, signature: str) -&gt; list[StateTransition]:\n        \"\"\"Get all outgoing transitions from a state.\"\"\"\n        return self._adjacency.get(signature, [])\n\n    def get_incoming(self, signature: str) -&gt; list[StateTransition]:\n        \"\"\"Get all incoming transitions to a state.\"\"\"\n        return self._reverse_adjacency.get(signature, [])\n\n    @property\n    def nodes(self) -&gt; Iterator[StateNode]:\n        \"\"\"Iterate over all nodes.\"\"\"\n        return iter(self._nodes.values())\n\n    @property\n    def transitions(self) -&gt; Iterator[StateTransition]:\n        \"\"\"Iterate over all transitions.\"\"\"\n        for transitions in self._adjacency.values():\n            yield from transitions\n\n    @property\n    def node_count(self) -&gt; int:\n        return len(self._nodes)\n\n    @property\n    def edge_count(self) -&gt; int:\n        return sum(len(t) for t in self._adjacency.values())\n</code></pre>"},{"location":"specs/state-explorer/#42-efficient-lookup-and-traversal","title":"4.2 Efficient Lookup and Traversal","text":"Python<pre><code>class StateGraphQuery:\n    \"\"\"Query interface for state graph analysis.\"\"\"\n\n    def __init__(self, graph: StateGraph):\n        self.graph = graph\n\n    def find_paths(\n        self,\n        from_state: str,\n        to_state: str,\n        max_depth: int = 10,\n    ) -&gt; list[list[StateTransition]]:\n        \"\"\"Find all paths between two states.\n\n        Args:\n            from_state: Source state signature.\n            to_state: Target state signature.\n            max_depth: Maximum path length.\n\n        Returns:\n            List of transition sequences (paths).\n        \"\"\"\n        paths = []\n\n        def dfs(current: str, path: list[StateTransition], visited: set[str]):\n            if len(path) &gt; max_depth:\n                return\n\n            if current == to_state:\n                paths.append(path.copy())\n                return\n\n            for transition in self.graph.get_outgoing(current):\n                if transition.to_state not in visited:\n                    visited.add(transition.to_state)\n                    path.append(transition)\n                    dfs(transition.to_state, path, visited)\n                    path.pop()\n                    visited.remove(transition.to_state)\n\n        dfs(from_state, [], {from_state})\n        return paths\n\n    def find_shortest_path(\n        self,\n        from_state: str,\n        to_state: str,\n    ) -&gt; list[StateTransition] | None:\n        \"\"\"Find shortest path between two states using BFS.\"\"\"\n\n        if from_state == to_state:\n            return []\n\n        visited = {from_state}\n        queue = deque([(from_state, [])])\n\n        while queue:\n            current, path = queue.popleft()\n\n            for transition in self.graph.get_outgoing(current):\n                if transition.to_state == to_state:\n                    return path + [transition]\n\n                if transition.to_state not in visited:\n                    visited.add(transition.to_state)\n                    queue.append((transition.to_state, path + [transition]))\n\n        return None\n\n    def find_dead_ends(self) -&gt; list[StateNode]:\n        \"\"\"Find states with no outgoing transitions.\"\"\"\n        return [\n            node for node in self.graph.nodes\n            if not self.graph.get_outgoing(node.signature)\n            and not node.is_error_state\n        ]\n\n    def find_unreachable_states(self) -&gt; list[StateNode]:\n        \"\"\"Find states not reachable from root.\"\"\"\n        if not self.graph.root_state:\n            return []\n\n        reachable = set()\n        queue = deque([self.graph.root_state])\n\n        while queue:\n            current = queue.popleft()\n            if current in reachable:\n                continue\n            reachable.add(current)\n\n            for transition in self.graph.get_outgoing(current):\n                queue.append(transition.to_state)\n\n        return [\n            node for node in self.graph.nodes\n            if node.signature not in reachable\n        ]\n\n    def find_cycles(self) -&gt; list[list[str]]:\n        \"\"\"Detect all cycles in the graph using Tarjan's algorithm.\"\"\"\n\n        index_counter = [0]\n        stack = []\n        lowlink = {}\n        index = {}\n        on_stack = set()\n        sccs = []  # Strongly connected components\n\n        def strongconnect(node: str):\n            index[node] = index_counter[0]\n            lowlink[node] = index_counter[0]\n            index_counter[0] += 1\n            stack.append(node)\n            on_stack.add(node)\n\n            for transition in self.graph.get_outgoing(node):\n                successor = transition.to_state\n                if successor not in index:\n                    strongconnect(successor)\n                    lowlink[node] = min(lowlink[node], lowlink[successor])\n                elif successor in on_stack:\n                    lowlink[node] = min(lowlink[node], index[successor])\n\n            if lowlink[node] == index[node]:\n                scc = []\n                while True:\n                    w = stack.pop()\n                    on_stack.remove(w)\n                    scc.append(w)\n                    if w == node:\n                        break\n                if len(scc) &gt; 1 or any(\n                    t.to_state == node\n                    for t in self.graph.get_outgoing(node)\n                ):\n                    sccs.append(scc)\n\n        for node in self.graph._nodes:\n            if node not in index:\n                strongconnect(node)\n\n        return sccs\n</code></pre>"},{"location":"specs/state-explorer/#43-serialization-format-json","title":"4.3 Serialization Format (JSON)","text":"Python<pre><code>import json\nfrom datetime import datetime\nfrom typing import Any\n\nclass StateGraphSerializer:\n    \"\"\"Serializes state graph to/from JSON.\"\"\"\n\n    @classmethod\n    def to_dict(cls, graph: StateGraph) -&gt; dict[str, Any]:\n        \"\"\"Convert graph to dictionary representation.\"\"\"\n\n        return {\n            \"version\": \"1.0\",\n            \"generated_at\": datetime.now().isoformat(),\n            \"root_state\": graph.root_state,\n            \"nodes\": [\n                cls._node_to_dict(node)\n                for node in graph.nodes\n            ],\n            \"transitions\": [\n                cls._transition_to_dict(t)\n                for t in graph.transitions\n            ],\n            \"metadata\": {\n                \"node_count\": graph.node_count,\n                \"edge_count\": graph.edge_count,\n            },\n        }\n\n    @classmethod\n    def to_json(cls, graph: StateGraph, indent: int = 2) -&gt; str:\n        \"\"\"Serialize graph to JSON string.\"\"\"\n        return json.dumps(cls.to_dict(graph), indent=indent, default=str)\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -&gt; StateGraph:\n        \"\"\"Reconstruct graph from dictionary.\"\"\"\n\n        graph = StateGraph()\n        graph.root_state = data.get(\"root_state\")\n\n        # Reconstruct nodes\n        for node_data in data.get(\"nodes\", []):\n            node = cls._dict_to_node(node_data)\n            graph.add_node(node)\n\n        # Reconstruct transitions\n        for trans_data in data.get(\"transitions\", []):\n            transition = cls._dict_to_transition(trans_data)\n            graph.add_transition(transition)\n\n        return graph\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; StateGraph:\n        \"\"\"Deserialize graph from JSON string.\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    @classmethod\n    def _node_to_dict(cls, node: StateNode) -&gt; dict[str, Any]:\n        return {\n            \"signature\": node.signature,\n            \"depth\": node.depth,\n            \"discovery_path\": node.discovery_path,\n            \"response_snapshot\": node.response_snapshot,\n            \"is_terminal\": node.is_terminal,\n            \"is_error_state\": node.is_error_state,\n            \"visit_count\": node.visit_count,\n            \"metadata\": node.metadata,\n        }\n\n    @classmethod\n    def _transition_to_dict(cls, t: StateTransition) -&gt; dict[str, Any]:\n        return {\n            \"from_state\": t.from_state,\n            \"to_state\": t.to_state,\n            \"action\": t.action,\n            \"method\": t.method,\n            \"url\": t.url,\n            \"status_code\": t.status_code,\n            \"duration_ms\": t.duration_ms,\n            \"is_error\": t.is_error,\n            \"error_message\": t.error_message,\n            \"timestamp\": t.timestamp.isoformat() if t.timestamp else None,\n        }\n</code></pre>"},{"location":"specs/state-explorer/#5-issue-detection-rules","title":"5. Issue Detection Rules","text":""},{"location":"specs/state-explorer/#51-issue-categories-and-detection","title":"5.1 Issue Categories and Detection","text":"Python<pre><code>from enum import Enum\nfrom dataclasses import dataclass\n\nclass IssueType(Enum):\n    ERROR_RESPONSE = \"error_response\"\n    DEAD_END = \"dead_end\"\n    UNREACHABLE_STATE = \"unreachable_state\"\n    CYCLE_DETECTED = \"cycle_detected\"\n    SLOW_TRANSITION = \"slow_transition\"\n    INCONSISTENT_STATE = \"inconsistent_state\"\n    AUTHENTICATION_FAILURE = \"authentication_failure\"\n    VALIDATION_ERROR = \"validation_error\"\n\n@dataclass\nclass DetectedIssue:\n    \"\"\"An issue detected during exploration.\"\"\"\n\n    issue_type: IssueType\n    severity: Severity\n    state_signature: str | None\n    transition: StateTransition | None\n    message: str\n    details: dict[str, Any]\n    suggestion: str\n\nclass IssueDetector:\n    \"\"\"Detects issues in state graph exploration results.\"\"\"\n\n    def __init__(\n        self,\n        graph: StateGraph,\n        config: \"IssueDetectionConfig\",\n    ):\n        self.graph = graph\n        self.config = config\n        self.detected_issues: list[DetectedIssue] = []\n\n    def detect_all(self) -&gt; list[DetectedIssue]:\n        \"\"\"Run all issue detection rules.\"\"\"\n\n        self.detected_issues = []\n\n        # Run each detector\n        self._detect_error_responses()\n        self._detect_dead_ends()\n        self._detect_unreachable_states()\n        self._detect_cycles()\n        self._detect_slow_transitions()\n        self._detect_inconsistent_states()\n\n        return self.detected_issues\n\n    def _detect_error_responses(self) -&gt; None:\n        \"\"\"Detect transitions resulting in error responses (4xx, 5xx).\"\"\"\n\n        for transition in self.graph.transitions:\n            if transition.is_error:\n                severity = (\n                    Severity.CRITICAL if transition.status_code &gt;= 500\n                    else Severity.HIGH if transition.status_code &gt;= 400\n                    else Severity.MEDIUM\n                )\n\n                self.detected_issues.append(DetectedIssue(\n                    issue_type=IssueType.ERROR_RESPONSE,\n                    severity=severity,\n                    state_signature=transition.from_state,\n                    transition=transition,\n                    message=f\"Action '{transition.action}' resulted in HTTP {transition.status_code}\",\n                    details={\n                        \"status_code\": transition.status_code,\n                        \"error_message\": transition.error_message,\n                        \"url\": transition.url,\n                        \"method\": transition.method,\n                    },\n                    suggestion=self._get_error_suggestion(transition.status_code),\n                ))\n\n    def _detect_dead_ends(self) -&gt; None:\n        \"\"\"Detect states with no valid outgoing transitions.\"\"\"\n\n        query = StateGraphQuery(self.graph)\n        dead_ends = query.find_dead_ends()\n\n        for node in dead_ends:\n            self.detected_issues.append(DetectedIssue(\n                issue_type=IssueType.DEAD_END,\n                severity=Severity.MEDIUM,\n                state_signature=node.signature,\n                transition=None,\n                message=f\"State '{node.signature[:8]}...' has no outgoing transitions\",\n                details={\n                    \"depth\": node.depth,\n                    \"discovery_path\": node.discovery_path,\n                },\n                suggestion=\"Consider adding recovery actions from this state or verify this is expected terminal state\",\n            ))\n\n    def _detect_unreachable_states(self) -&gt; None:\n        \"\"\"Detect states not reachable from root state.\"\"\"\n\n        query = StateGraphQuery(self.graph)\n        unreachable = query.find_unreachable_states()\n\n        for node in unreachable:\n            self.detected_issues.append(DetectedIssue(\n                issue_type=IssueType.UNREACHABLE_STATE,\n                severity=Severity.HIGH,\n                state_signature=node.signature,\n                transition=None,\n                message=f\"State '{node.signature[:8]}...' is not reachable from initial state\",\n                details={\n                    \"incoming_transitions\": node.incoming_transitions,\n                },\n                suggestion=\"This state may be orphaned or only reachable through external means\",\n            ))\n\n    def _detect_cycles(self) -&gt; None:\n        \"\"\"Detect cyclic transitions (potential infinite loops).\"\"\"\n\n        query = StateGraphQuery(self.graph)\n        cycles = query.find_cycles()\n\n        for cycle in cycles:\n            # Only report if cycle is short (likely problematic)\n            if len(cycle) &lt;= self.config.max_reportable_cycle_length:\n                self.detected_issues.append(DetectedIssue(\n                    issue_type=IssueType.CYCLE_DETECTED,\n                    severity=Severity.LOW,\n                    state_signature=cycle[0],\n                    transition=None,\n                    message=f\"Cycle detected involving {len(cycle)} states\",\n                    details={\n                        \"cycle_states\": cycle,\n                        \"cycle_length\": len(cycle),\n                    },\n                    suggestion=\"Review if this cycle is intentional behavior or indicates missing exit conditions\",\n                ))\n\n    def _detect_slow_transitions(self) -&gt; None:\n        \"\"\"Detect transitions exceeding performance thresholds.\"\"\"\n\n        threshold_ms = self.config.slow_transition_threshold_ms\n\n        for transition in self.graph.transitions:\n            if transition.duration_ms &gt; threshold_ms:\n                self.detected_issues.append(DetectedIssue(\n                    issue_type=IssueType.SLOW_TRANSITION,\n                    severity=Severity.LOW,\n                    state_signature=transition.from_state,\n                    transition=transition,\n                    message=f\"Action '{transition.action}' took {transition.duration_ms:.0f}ms (threshold: {threshold_ms}ms)\",\n                    details={\n                        \"duration_ms\": transition.duration_ms,\n                        \"threshold_ms\": threshold_ms,\n                        \"url\": transition.url,\n                    },\n                    suggestion=\"Consider optimizing this endpoint or increasing timeout thresholds\",\n                ))\n\n    def _detect_inconsistent_states(self) -&gt; None:\n        \"\"\"Detect same action producing different results from same state.\"\"\"\n\n        # Group transitions by (from_state, action)\n        transition_groups: dict[tuple[str, str], list[StateTransition]] = defaultdict(list)\n\n        for transition in self.graph.transitions:\n            key = (transition.from_state, transition.action)\n            transition_groups[key].append(transition)\n\n        for (from_state, action), transitions in transition_groups.items():\n            if len(transitions) &lt; 2:\n                continue\n\n            # Check for different outcomes\n            outcomes = set()\n            for t in transitions:\n                outcome = (t.to_state, t.status_code, t.is_error)\n                outcomes.add(outcome)\n\n            if len(outcomes) &gt; 1:\n                self.detected_issues.append(DetectedIssue(\n                    issue_type=IssueType.INCONSISTENT_STATE,\n                    severity=Severity.HIGH,\n                    state_signature=from_state,\n                    transition=transitions[0],\n                    message=f\"Action '{action}' produces inconsistent results from state '{from_state[:8]}...'\",\n                    details={\n                        \"action\": action,\n                        \"outcome_count\": len(outcomes),\n                        \"outcomes\": [\n                            {\"to_state\": t.to_state[:8], \"status\": t.status_code}\n                            for t in transitions\n                        ],\n                    },\n                    suggestion=\"Non-deterministic behavior detected - investigate race conditions or state-dependent logic\",\n                ))\n\n    def _get_error_suggestion(self, status_code: int) -&gt; str:\n        \"\"\"Generate suggestion based on HTTP status code.\"\"\"\n\n        suggestions = {\n            400: \"Check request validation - body or parameters may be malformed\",\n            401: \"Authentication required - ensure valid credentials are provided\",\n            403: \"Permission denied - check user roles and access control\",\n            404: \"Resource not found - verify the resource exists in current state\",\n            409: \"Conflict - resource may already exist or be in invalid state\",\n            422: \"Validation failed - check request body against schema\",\n            429: \"Rate limited - add delays between requests\",\n            500: \"Server error - check backend logs for exception details\",\n            502: \"Bad gateway - upstream service may be down\",\n            503: \"Service unavailable - check service health\",\n            504: \"Gateway timeout - upstream service too slow\",\n        }\n\n        return suggestions.get(status_code, \"Review error response for details\")\n\n@dataclass\nclass IssueDetectionConfig:\n    \"\"\"Configuration for issue detection.\"\"\"\n\n    slow_transition_threshold_ms: float = 5000.0\n    max_reportable_cycle_length: int = 5\n    detect_error_responses: bool = True\n    detect_dead_ends: bool = True\n    detect_cycles: bool = True\n    detect_slow_transitions: bool = True\n    detect_inconsistent_states: bool = True\n</code></pre>"},{"location":"specs/state-explorer/#6-coverage-metrics","title":"6. Coverage Metrics","text":""},{"location":"specs/state-explorer/#61-metric-definitions","title":"6.1 Metric Definitions","text":"Python<pre><code>from dataclasses import dataclass\n\n@dataclass\nclass CoverageMetrics:\n    \"\"\"Coverage metrics from state exploration.\"\"\"\n\n    # State coverage\n    states_visited: int\n    states_discovered: int\n    state_coverage_pct: float\n\n    # Transition coverage\n    transitions_executed: int\n    transitions_possible: int\n    transition_coverage_pct: float\n\n    # Endpoint coverage\n    endpoints_tested: int\n    endpoints_total: int\n    endpoint_coverage_pct: float\n\n    # Path coverage\n    unique_paths: int\n    total_paths: int\n    path_coverage_pct: float\n\n    # Additional metrics\n    max_depth_reached: int\n    avg_path_length: float\n    cycles_detected: int\n    error_rate: float\n\nclass CoverageCalculator:\n    \"\"\"Calculates coverage metrics from exploration results.\"\"\"\n\n    def __init__(\n        self,\n        graph: StateGraph,\n        openapi_spec: dict[str, Any] | None = None,\n    ):\n        self.graph = graph\n        self.openapi_spec = openapi_spec\n\n    def calculate(self) -&gt; CoverageMetrics:\n        \"\"\"Calculate all coverage metrics.\"\"\"\n\n        # State coverage\n        states_visited = len([n for n in self.graph.nodes if n.visit_count &gt; 0])\n        states_discovered = self.graph.node_count\n\n        # Transition coverage\n        transitions_executed = self.graph.edge_count\n        transitions_possible = self._estimate_possible_transitions()\n\n        # Endpoint coverage\n        endpoints_tested = self._count_tested_endpoints()\n        endpoints_total = self._count_total_endpoints()\n\n        # Path coverage\n        unique_paths = self._count_unique_paths()\n        total_paths = self._estimate_total_paths()\n\n        # Additional metrics\n        max_depth = max((n.depth for n in self.graph.nodes), default=0)\n        avg_path = self._calculate_avg_path_length()\n        cycles = len(StateGraphQuery(self.graph).find_cycles())\n        error_rate = self._calculate_error_rate()\n\n        return CoverageMetrics(\n            states_visited=states_visited,\n            states_discovered=states_discovered,\n            state_coverage_pct=self._pct(states_visited, states_discovered),\n            transitions_executed=transitions_executed,\n            transitions_possible=transitions_possible,\n            transition_coverage_pct=self._pct(transitions_executed, transitions_possible),\n            endpoints_tested=endpoints_tested,\n            endpoints_total=endpoints_total,\n            endpoint_coverage_pct=self._pct(endpoints_tested, endpoints_total),\n            unique_paths=unique_paths,\n            total_paths=total_paths,\n            path_coverage_pct=self._pct(unique_paths, total_paths),\n            max_depth_reached=max_depth,\n            avg_path_length=avg_path,\n            cycles_detected=cycles,\n            error_rate=error_rate,\n        )\n\n    def _count_tested_endpoints(self) -&gt; int:\n        \"\"\"Count unique endpoints that were tested.\"\"\"\n        endpoints = set()\n        for transition in self.graph.transitions:\n            # Normalize URL (remove path params)\n            import re\n            normalized = re.sub(r'/[a-f0-9-]{36}', '/{id}', transition.url)\n            normalized = re.sub(r'/\\d+', '/{id}', normalized)\n            endpoints.add((transition.method, normalized))\n        return len(endpoints)\n\n    def _count_total_endpoints(self) -&gt; int:\n        \"\"\"Count total endpoints from OpenAPI spec.\"\"\"\n        if not self.openapi_spec:\n            return self._count_tested_endpoints()  # Best estimate\n\n        count = 0\n        for path, methods in self.openapi_spec.get(\"paths\", {}).items():\n            for method in methods:\n                if method.upper() in [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]:\n                    count += 1\n        return count\n\n    def _count_unique_paths(self) -&gt; int:\n        \"\"\"Count unique state paths discovered.\"\"\"\n        paths = set()\n        for node in self.graph.nodes:\n            paths.add(tuple(node.discovery_path))\n        return len(paths)\n\n    def _estimate_total_paths(self) -&gt; int:\n        \"\"\"Estimate total possible paths (exponential).\"\"\"\n        # Simplified estimate based on graph structure\n        avg_branching = self.graph.edge_count / max(self.graph.node_count, 1)\n        max_depth = max((n.depth for n in self.graph.nodes), default=0)\n        return int(avg_branching ** max_depth)\n\n    def _estimate_possible_transitions(self) -&gt; int:\n        \"\"\"Estimate total possible transitions.\"\"\"\n        # Each state could potentially transition to any other state\n        return self.graph.node_count * max(self._count_total_endpoints(), 1)\n\n    def _calculate_avg_path_length(self) -&gt; float:\n        \"\"\"Calculate average path length to states.\"\"\"\n        depths = [n.depth for n in self.graph.nodes]\n        return sum(depths) / len(depths) if depths else 0.0\n\n    def _calculate_error_rate(self) -&gt; float:\n        \"\"\"Calculate percentage of error transitions.\"\"\"\n        errors = sum(1 for t in self.graph.transitions if t.is_error)\n        total = self.graph.edge_count\n        return self._pct(errors, total) if total &gt; 0 else 0.0\n\n    @staticmethod\n    def _pct(numerator: int, denominator: int) -&gt; float:\n        return (numerator / denominator * 100) if denominator &gt; 0 else 100.0\n</code></pre>"},{"location":"specs/state-explorer/#62-coverage-report-generation","title":"6.2 Coverage Report Generation","text":"Python<pre><code>class CoverageReporter:\n    \"\"\"Generates coverage reports.\"\"\"\n\n    def __init__(self, metrics: CoverageMetrics):\n        self.metrics = metrics\n\n    def to_summary(self) -&gt; str:\n        \"\"\"Generate human-readable coverage summary.\"\"\"\n\n        m = self.metrics\n\n        return f\"\"\"\nState Explorer Coverage Report\n==============================\n\nState Coverage:\n  - States Visited:    {m.states_visited}/{m.states_discovered} ({m.state_coverage_pct:.1f}%)\n\nTransition Coverage:\n  - Transitions:       {m.transitions_executed}/{m.transitions_possible} ({m.transition_coverage_pct:.1f}%)\n\nEndpoint Coverage:\n  - Endpoints Tested:  {m.endpoints_tested}/{m.endpoints_total} ({m.endpoint_coverage_pct:.1f}%)\n\nPath Coverage:\n  - Unique Paths:      {m.unique_paths}/{m.total_paths} ({m.path_coverage_pct:.1f}%)\n\nExploration Metrics:\n  - Max Depth:         {m.max_depth_reached}\n  - Avg Path Length:   {m.avg_path_length:.2f}\n  - Cycles Detected:   {m.cycles_detected}\n  - Error Rate:        {m.error_rate:.1f}%\n\"\"\"\n</code></pre>"},{"location":"specs/state-explorer/#7-visualization-specification","title":"7. Visualization Specification","text":""},{"location":"specs/state-explorer/#71-graphviz-dot-format","title":"7.1 Graphviz DOT Format","text":"Python<pre><code>class GraphvizExporter:\n    \"\"\"Exports state graph to Graphviz DOT format.\"\"\"\n\n    COLOR_MAP = {\n        \"normal\": \"#22c55e\",      # Green - OK\n        \"error\": \"#ef4444\",       # Red - Error\n        \"warning\": \"#f59e0b\",     # Yellow - Warning\n        \"terminal\": \"#6b7280\",    # Gray - Terminal\n        \"start\": \"#3b82f6\",       # Blue - Start\n    }\n\n    def __init__(self, graph: StateGraph):\n        self.graph = graph\n\n    def to_dot(self, title: str = \"State Graph\") -&gt; str:\n        \"\"\"Generate DOT format string.\"\"\"\n\n        lines = [\n            f'digraph \"{title}\" {{',\n            '    rankdir=TB;',\n            '    node [shape=box, style=rounded];',\n            '',\n        ]\n\n        # Add nodes\n        for node in self.graph.nodes:\n            color = self._get_node_color(node)\n            label = self._get_node_label(node)\n            lines.append(\n                f'    \"{node.signature[:8]}\" ['\n                f'label=\"{label}\", '\n                f'fillcolor=\"{color}\", '\n                f'style=\"filled,rounded\"'\n                f'];'\n            )\n\n        lines.append('')\n\n        # Add edges\n        for transition in self.graph.transitions:\n            color = self._get_edge_color(transition)\n            label = self._get_edge_label(transition)\n            lines.append(\n                f'    \"{transition.from_state[:8]}\" -&gt; \"{transition.to_state[:8]}\" ['\n                f'label=\"{label}\", '\n                f'color=\"{color}\"'\n                f'];'\n            )\n\n        lines.append('}')\n\n        return '\\n'.join(lines)\n\n    def _get_node_color(self, node: StateNode) -&gt; str:\n        if node.signature == self.graph.root_state:\n            return self.COLOR_MAP[\"start\"]\n        if node.is_error_state:\n            return self.COLOR_MAP[\"error\"]\n        if node.is_terminal:\n            return self.COLOR_MAP[\"terminal\"]\n        return self.COLOR_MAP[\"normal\"]\n\n    def _get_node_label(self, node: StateNode) -&gt; str:\n        return f\"{node.signature[:8]}\\\\ndepth: {node.depth}\"\n\n    def _get_edge_color(self, transition: StateTransition) -&gt; str:\n        if transition.is_error:\n            return self.COLOR_MAP[\"error\"]\n        if transition.duration_ms &gt; 1000:\n            return self.COLOR_MAP[\"warning\"]\n        return self.COLOR_MAP[\"normal\"]\n\n    def _get_edge_label(self, transition: StateTransition) -&gt; str:\n        return f\"{transition.method} {transition.action}\\\\n{transition.status_code}\"\n</code></pre>"},{"location":"specs/state-explorer/#72-mermaid-format","title":"7.2 Mermaid Format","text":"Python<pre><code>class MermaidExporter:\n    \"\"\"Exports state graph to Mermaid diagram format.\"\"\"\n\n    def __init__(self, graph: StateGraph):\n        self.graph = graph\n\n    def to_mermaid(self) -&gt; str:\n        \"\"\"Generate Mermaid flowchart syntax.\"\"\"\n\n        lines = [\n            \"```mermaid\",\n            \"flowchart TD\",\n        ]\n\n        # Define node styles\n        lines.extend([\n            \"    classDef success fill:#dcfce7,stroke:#22c55e\",\n            \"    classDef error fill:#fee2e2,stroke:#ef4444\",\n            \"    classDef start fill:#dbeafe,stroke:#3b82f6\",\n            \"\",\n        ])\n\n        # Add nodes with shapes\n        for node in self.graph.nodes:\n            node_id = node.signature[:8]\n            shape = self._get_node_shape(node)\n            lines.append(f\"    {node_id}{shape}\")\n\n        lines.append(\"\")\n\n        # Add edges\n        for transition in self.graph.transitions:\n            from_id = transition.from_state[:8]\n            to_id = transition.to_state[:8]\n            label = f\"{transition.method}\"\n            arrow = \"--&gt;|\" + label + \"|\" if not transition.is_error else \"-.-&gt;|\" + label + \"|\"\n            lines.append(f\"    {from_id} {arrow} {to_id}\")\n\n        # Apply styles\n        for node in self.graph.nodes:\n            node_id = node.signature[:8]\n            style_class = self._get_style_class(node)\n            lines.append(f\"    class {node_id} {style_class}\")\n\n        lines.append(\"```\")\n\n        return '\\n'.join(lines)\n\n    def _get_node_shape(self, node: StateNode) -&gt; str:\n        label = f\"State: {node.signature[:8]}\"\n        if node.signature == self.graph.root_state:\n            return f\"([{label}])\"  # Stadium shape for start\n        if node.is_terminal:\n            return f\"[/{label}/]\"  # Parallelogram for terminal\n        return f\"[{label}]\"  # Rectangle for normal\n\n    def _get_style_class(self, node: StateNode) -&gt; str:\n        if node.signature == self.graph.root_state:\n            return \"start\"\n        if node.is_error_state:\n            return \"error\"\n        return \"success\"\n</code></pre>"},{"location":"specs/state-explorer/#73-interactive-html-visjs","title":"7.3 Interactive HTML (vis.js)","text":"Python<pre><code>class HTMLVisualizationExporter:\n    \"\"\"Exports interactive HTML visualization using vis.js.\"\"\"\n\n    def __init__(self, graph: StateGraph, metrics: CoverageMetrics):\n        self.graph = graph\n        self.metrics = metrics\n\n    def to_html(self, title: str = \"State Explorer Visualization\") -&gt; str:\n        \"\"\"Generate self-contained interactive HTML.\"\"\"\n\n        # Prepare node data\n        nodes_data = []\n        for node in self.graph.nodes:\n            nodes_data.append({\n                \"id\": node.signature,\n                \"label\": f\"{node.signature[:8]}\\\\nDepth: {node.depth}\",\n                \"color\": self._get_node_color(node),\n                \"shape\": \"box\",\n                \"title\": self._get_node_tooltip(node),\n            })\n\n        # Prepare edge data\n        edges_data = []\n        for i, transition in enumerate(self.graph.transitions):\n            edges_data.append({\n                \"id\": i,\n                \"from\": transition.from_state,\n                \"to\": transition.to_state,\n                \"label\": transition.action,\n                \"color\": {\"color\": self._get_edge_color(transition)},\n                \"arrows\": \"to\",\n                \"title\": self._get_edge_tooltip(transition),\n            })\n\n        return f'''&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;{title}&lt;/title&gt;\n    &lt;script src=\"https://unpkg.com/vis-network/standalone/umd/vis-network.min.js\"&gt;&lt;/script&gt;\n    &lt;style&gt;\n        body {{\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            margin: 0;\n            padding: 20px;\n            background: #f3f4f6;\n        }}\n        .container {{ max-width: 1400px; margin: 0 auto; }}\n        .header {{\n            background: linear-gradient(135deg, #6366f1, #4f46e5);\n            color: white;\n            padding: 20px;\n            border-radius: 12px;\n            margin-bottom: 20px;\n        }}\n        .metrics {{\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n            gap: 15px;\n            margin-bottom: 20px;\n        }}\n        .metric-card {{\n            background: white;\n            padding: 15px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n            text-align: center;\n        }}\n        .metric-value {{\n            font-size: 2rem;\n            font-weight: bold;\n            color: #6366f1;\n        }}\n        .metric-label {{\n            color: #6b7280;\n            font-size: 0.875rem;\n        }}\n        #graph-container {{\n            width: 100%;\n            height: 600px;\n            background: white;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }}\n        .legend {{\n            display: flex;\n            gap: 20px;\n            margin-top: 15px;\n            justify-content: center;\n        }}\n        .legend-item {{\n            display: flex;\n            align-items: center;\n            gap: 8px;\n        }}\n        .legend-color {{\n            width: 16px;\n            height: 16px;\n            border-radius: 4px;\n        }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;div class=\"header\"&gt;\n            &lt;h1&gt;{title}&lt;/h1&gt;\n            &lt;p&gt;Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}&lt;/p&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"metrics\"&gt;\n            &lt;div class=\"metric-card\"&gt;\n                &lt;div class=\"metric-value\"&gt;{self.metrics.states_discovered}&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;States Discovered&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric-card\"&gt;\n                &lt;div class=\"metric-value\"&gt;{self.metrics.transitions_executed}&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Transitions&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric-card\"&gt;\n                &lt;div class=\"metric-value\"&gt;{self.metrics.endpoint_coverage_pct:.1f}%&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Endpoint Coverage&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric-card\"&gt;\n                &lt;div class=\"metric-value\"&gt;{self.metrics.error_rate:.1f}%&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Error Rate&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div id=\"graph-container\"&gt;&lt;/div&gt;\n\n        &lt;div class=\"legend\"&gt;\n            &lt;div class=\"legend-item\"&gt;\n                &lt;div class=\"legend-color\" style=\"background: #3b82f6;\"&gt;&lt;/div&gt;\n                &lt;span&gt;Start State&lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div class=\"legend-item\"&gt;\n                &lt;div class=\"legend-color\" style=\"background: #22c55e;\"&gt;&lt;/div&gt;\n                &lt;span&gt;Normal State&lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div class=\"legend-item\"&gt;\n                &lt;div class=\"legend-color\" style=\"background: #ef4444;\"&gt;&lt;/div&gt;\n                &lt;span&gt;Error State&lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div class=\"legend-item\"&gt;\n                &lt;div class=\"legend-color\" style=\"background: #6b7280;\"&gt;&lt;/div&gt;\n                &lt;span&gt;Terminal State&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        var nodes = new vis.DataSet({json.dumps(nodes_data)});\n        var edges = new vis.DataSet({json.dumps(edges_data)});\n\n        var container = document.getElementById('graph-container');\n        var data = {{ nodes: nodes, edges: edges }};\n        var options = {{\n            layout: {{\n                hierarchical: {{\n                    direction: 'UD',\n                    sortMethod: 'directed',\n                    nodeSpacing: 150,\n                    levelSeparation: 100,\n                }}\n            }},\n            physics: false,\n            interaction: {{\n                hover: true,\n                tooltipDelay: 100,\n            }},\n            nodes: {{\n                font: {{ size: 12 }},\n                borderWidth: 2,\n            }},\n            edges: {{\n                font: {{ size: 10, align: 'middle' }},\n                width: 2,\n            }},\n        }};\n\n        var network = new vis.Network(container, data, options);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;'''\n\n    def _get_node_color(self, node: StateNode) -&gt; str:\n        if node.signature == self.graph.root_state:\n            return \"#3b82f6\"\n        if node.is_error_state:\n            return \"#ef4444\"\n        if node.is_terminal:\n            return \"#6b7280\"\n        return \"#22c55e\"\n\n    def _get_edge_color(self, transition: StateTransition) -&gt; str:\n        if transition.is_error:\n            return \"#ef4444\"\n        return \"#6b7280\"\n\n    def _get_node_tooltip(self, node: StateNode) -&gt; str:\n        return f\"\"\"\nState: {node.signature}\nDepth: {node.depth}\nVisits: {node.visit_count}\nPath: {' -&gt; '.join(node.discovery_path[:3])}{'...' if len(node.discovery_path) &gt; 3 else ''}\n        \"\"\".strip()\n\n    def _get_edge_tooltip(self, transition: StateTransition) -&gt; str:\n        return f\"\"\"\nAction: {transition.action}\nMethod: {transition.method}\nURL: {transition.url}\nStatus: {transition.status_code}\nDuration: {transition.duration_ms:.0f}ms\n        \"\"\".strip()\n</code></pre>"},{"location":"specs/state-explorer/#8-integration-points","title":"8. Integration Points","text":""},{"location":"specs/state-explorer/#81-integration-with-venomqa-client","title":"8.1 Integration with VenomQA Client","text":"Python<pre><code>from venomqa.clients.base import BaseClient\n\nclass StateExplorerClient:\n    \"\"\"Wrapper around VenomQA client for state exploration.\"\"\"\n\n    def __init__(self, client: BaseClient):\n        self.client = client\n        self._ensure_connected()\n\n    def _ensure_connected(self) -&gt; None:\n        \"\"\"Ensure client is connected.\"\"\"\n        if not self.client.is_connected():\n            self.client.connect()\n\n    def execute_action(\n        self,\n        action: GeneratedAction,\n    ) -&gt; tuple[dict[str, Any], int, float]:\n        \"\"\"Execute an action and return response data.\n\n        Returns:\n            Tuple of (response_json, status_code, duration_ms)\n        \"\"\"\n        import time\n\n        start = time.time()\n\n        # Build headers\n        headers = {**self.client.default_headers, **action.headers}\n\n        # Execute request using VenomQA client internals\n        response = self.client._session.request(\n            method=action.method,\n            url=action.url,\n            json=action.body,\n            headers=headers,\n            timeout=self.client.timeout,\n        )\n\n        duration_ms = (time.time() - start) * 1000\n\n        # Record in history\n        self.client._record_request(\n            operation=f\"{action.method} {action.url}\",\n            request_data=action.body,\n            response_data=response.json() if response.content else None,\n            duration_ms=duration_ms,\n        )\n\n        return response.json(), response.status_code, duration_ms\n</code></pre>"},{"location":"specs/state-explorer/#82-integration-with-statemanager-for-rollbacks","title":"8.2 Integration with StateManager for Rollbacks","text":"Python<pre><code>from venomqa.state import StateManager\n\nclass ExplorationStateIntegration:\n    \"\"\"Integration between State Explorer and VenomQA StateManager.\"\"\"\n\n    def __init__(self, state_manager: StateManager):\n        self.state_manager = state_manager\n        self.exploration_checkpoints: dict[str, str] = {}\n\n    def initialize(self) -&gt; str:\n        \"\"\"Initialize exploration with base checkpoint.\n\n        Returns:\n            Name of the base checkpoint.\n        \"\"\"\n        self.state_manager.connect()\n        checkpoint_name = \"exploration_base\"\n        self.state_manager.checkpoint(checkpoint_name)\n        self.exploration_checkpoints[\"base\"] = checkpoint_name\n        return checkpoint_name\n\n    def create_state_checkpoint(self, state_signature: str) -&gt; str:\n        \"\"\"Create checkpoint for a specific state.\n\n        Args:\n            state_signature: State signature to checkpoint.\n\n        Returns:\n            Checkpoint name.\n        \"\"\"\n        checkpoint_name = f\"state_{state_signature[:16]}\"\n        self.state_manager.checkpoint(checkpoint_name)\n        self.exploration_checkpoints[state_signature] = checkpoint_name\n        return checkpoint_name\n\n    def rollback_to_state(self, state_signature: str) -&gt; bool:\n        \"\"\"Rollback to a previously checkpointed state.\n\n        Args:\n            state_signature: State to rollback to.\n\n        Returns:\n            True if rollback successful, False if checkpoint not found.\n        \"\"\"\n        checkpoint_name = self.exploration_checkpoints.get(state_signature)\n        if not checkpoint_name:\n            return False\n\n        self.state_manager.rollback(checkpoint_name)\n        return True\n\n    def cleanup(self) -&gt; None:\n        \"\"\"Clean up all exploration checkpoints.\"\"\"\n        # Rollback to base\n        base = self.exploration_checkpoints.get(\"base\")\n        if base:\n            self.state_manager.rollback(base)\n\n        # Release all checkpoints\n        for checkpoint_name in self.exploration_checkpoints.values():\n            try:\n                self.state_manager.release(checkpoint_name)\n            except Exception:\n                pass  # Ignore release errors\n\n        self.state_manager.disconnect()\n</code></pre>"},{"location":"specs/state-explorer/#83-integration-with-reporters","title":"8.3 Integration with Reporters","text":"Python<pre><code>from venomqa.reporters.base import BaseReporter\nfrom venomqa.core.models import JourneyResult, StepResult, Issue, Severity\n\nclass StateExplorerReporter(BaseReporter):\n    \"\"\"Reporter for state exploration results.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".html\"\n\n    def __init__(\n        self,\n        output_path: str | Path | None = None,\n        include_graph: bool = True,\n        include_coverage: bool = True,\n    ):\n        super().__init__(output_path)\n        self.include_graph = include_graph\n        self.include_coverage = include_coverage\n\n    def generate_from_exploration(\n        self,\n        graph: StateGraph,\n        metrics: CoverageMetrics,\n        issues: list[DetectedIssue],\n    ) -&gt; str:\n        \"\"\"Generate HTML report from exploration results.\"\"\"\n\n        # Create HTML visualization\n        visualizer = HTMLVisualizationExporter(graph, metrics)\n        base_html = visualizer.to_html(\"State Explorer Results\")\n\n        # Inject issues section\n        issues_html = self._render_issues(issues)\n\n        # Insert before closing body tag\n        return base_html.replace(\"&lt;/body&gt;\", f\"{issues_html}&lt;/body&gt;\")\n\n    def _render_issues(self, issues: list[DetectedIssue]) -&gt; str:\n        \"\"\"Render detected issues as HTML.\"\"\"\n\n        if not issues:\n            return \"\"\"\n            &lt;div class=\"container\" style=\"margin-top: 20px;\"&gt;\n                &lt;div style=\"background: white; padding: 20px; border-radius: 8px; text-align: center;\"&gt;\n                    &lt;span style=\"color: #22c55e; font-size: 1.5rem;\"&gt;&amp;#10003;&lt;/span&gt;\n                    &lt;span style=\"margin-left: 10px;\"&gt;No issues detected&lt;/span&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\"\"\"\n\n        issue_cards = []\n        for issue in issues:\n            color = self._get_severity_color(issue.severity)\n            issue_cards.append(f\"\"\"\n            &lt;div style=\"border-left: 4px solid {color}; background: white; padding: 15px; margin-bottom: 10px; border-radius: 0 8px 8px 0;\"&gt;\n                &lt;div style=\"display: flex; justify-content: space-between; margin-bottom: 10px;\"&gt;\n                    &lt;strong&gt;{issue.issue_type.value.replace('_', ' ').title()}&lt;/strong&gt;\n                    &lt;span style=\"background: {color}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem;\"&gt;\n                        {issue.severity.value.upper()}\n                    &lt;/span&gt;\n                &lt;/div&gt;\n                &lt;p style=\"color: #6b7280; margin-bottom: 10px;\"&gt;{issue.message}&lt;/p&gt;\n                &lt;div style=\"background: #dcfce7; color: #166534; padding: 10px; border-radius: 4px;\"&gt;\n                    &lt;strong&gt;Suggestion:&lt;/strong&gt; {issue.suggestion}\n                &lt;/div&gt;\n            &lt;/div&gt;\n            \"\"\")\n\n        return f\"\"\"\n        &lt;div class=\"container\" style=\"margin-top: 20px;\"&gt;\n            &lt;h2 style=\"margin-bottom: 15px;\"&gt;Detected Issues ({len(issues)})&lt;/h2&gt;\n            {''.join(issue_cards)}\n        &lt;/div&gt;\"\"\"\n\n    def _get_severity_color(self, severity: Severity) -&gt; str:\n        colors = {\n            Severity.CRITICAL: \"#dc2626\",\n            Severity.HIGH: \"#ea580c\",\n            Severity.MEDIUM: \"#d97706\",\n            Severity.LOW: \"#2563eb\",\n            Severity.INFO: \"#6b7280\",\n        }\n        return colors.get(severity, \"#6b7280\")\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        \"\"\"Generate standard VenomQA report format.\n\n        Note: Use generate_from_exploration() for state exploration results.\n        \"\"\"\n        raise NotImplementedError(\n            \"Use generate_from_exploration() for state exploration results\"\n        )\n</code></pre>"},{"location":"specs/state-explorer/#84-cli-integration","title":"8.4 CLI Integration","text":"Python<pre><code># In venomqa/cli/commands.py\n\nimport click\n\n@click.command()\n@click.option(\"--openapi\", \"-o\", type=click.Path(exists=True), help=\"OpenAPI spec file\")\n@click.option(\"--base-url\", \"-u\", required=True, help=\"API base URL\")\n@click.option(\"--max-depth\", \"-d\", default=10, help=\"Maximum exploration depth\")\n@click.option(\"--max-states\", \"-s\", default=1000, help=\"Maximum states to discover\")\n@click.option(\"--output\", \"-O\", default=\"state_graph.html\", help=\"Output file\")\n@click.option(\"--format\", \"-f\", type=click.Choice([\"html\", \"dot\", \"mermaid\", \"json\"]), default=\"html\")\ndef explore(openapi, base_url, max_depth, max_states, output, format):\n    \"\"\"Explore API state space automatically.\n\n    Example:\n        venomqa explore -o openapi.yaml -u http://localhost:8000 -d 5 -O report.html\n    \"\"\"\n    from venomqa.exploration import StateExplorer, ExplorationConfig\n    from venomqa.clients import HTTPClient\n\n    # Load OpenAPI spec\n    spec = load_openapi_spec(openapi) if openapi else None\n\n    # Configure exploration\n    config = ExplorationConfig(\n        max_depth=max_depth,\n        max_states=max_states,\n    )\n\n    # Create client and explorer\n    client = HTTPClient(base_url)\n    explorer = StateExplorer(\n        client=client,\n        action_generator=OpenAPIActionGenerator(spec, DataGenerator(), base_url),\n        config=config,\n    )\n\n    # Run exploration\n    click.echo(\"Starting state exploration...\")\n    with click.progressbar(length=max_states, label=\"Exploring\") as bar:\n        graph = explorer.explore(get_initial_state())\n        bar.update(explorer.states_discovered)\n\n    # Calculate metrics and detect issues\n    metrics = CoverageCalculator(graph, spec).calculate()\n    issues = IssueDetector(graph, IssueDetectionConfig()).detect_all()\n\n    # Generate output\n    if format == \"html\":\n        reporter = StateExplorerReporter()\n        content = reporter.generate_from_exploration(graph, metrics, issues)\n    elif format == \"dot\":\n        content = GraphvizExporter(graph).to_dot()\n    elif format == \"mermaid\":\n        content = MermaidExporter(graph).to_mermaid()\n    else:  # json\n        content = StateGraphSerializer.to_json(graph)\n\n    # Write output\n    with open(output, \"w\") as f:\n        f.write(content)\n\n    click.echo(f\"\\nExploration complete!\")\n    click.echo(f\"  States discovered: {metrics.states_discovered}\")\n    click.echo(f\"  Transitions: {metrics.transitions_executed}\")\n    click.echo(f\"  Issues found: {len(issues)}\")\n    click.echo(f\"  Output: {output}\")\n</code></pre>"},{"location":"specs/state-explorer/#appendix-a-complete-usage-example","title":"Appendix A: Complete Usage Example","text":"Python<pre><code>from venomqa.clients import HTTPClient\nfrom venomqa.state import PostgreSQLStateManager\nfrom venomqa.exploration import (\n    StateExplorer,\n    ExplorationConfig,\n    OpenAPIActionGenerator,\n    DataGenerator,\n    IssueDetector,\n    CoverageCalculator,\n    StateExplorerReporter,\n)\n\n# Load OpenAPI spec\nwith open(\"openapi.yaml\") as f:\n    import yaml\n    spec = yaml.safe_load(f)\n\n# Configure exploration\nconfig = ExplorationConfig(\n    strategy=ExplorationStrategy.HYBRID,\n    max_depth=8,\n    max_states=500,\n    max_transitions=2000,\n    parallel_workers=4,\n    rollback_on_mutation=True,\n)\n\n# Set up components\nclient = HTTPClient(\"http://localhost:8000\")\nstate_manager = PostgreSQLStateManager(\"postgresql://localhost/testdb\")\naction_generator = OpenAPIActionGenerator(spec, DataGenerator(), \"http://localhost:8000\")\n\n# Create explorer\nexplorer = StateExplorer(\n    client=client,\n    state_manager=state_manager,\n    action_generator=action_generator,\n    config=config,\n)\n\n# Run exploration\nwith state_manager:\n    # Get initial state\n    initial_response = client.get(\"/api/health\").json()\n\n    # Explore state space\n    graph = explorer.explore(initial_response)\n\n    # Calculate coverage\n    metrics = CoverageCalculator(graph, spec).calculate()\n\n    # Detect issues\n    issues = IssueDetector(graph, IssueDetectionConfig()).detect_all()\n\n    # Generate report\n    reporter = StateExplorerReporter(output_path=\"state_exploration_report.html\")\n    reporter.save_from_exploration(graph, metrics, issues)\n\n    # Print summary\n    print(f\"Exploration complete!\")\n    print(f\"  States: {metrics.states_discovered}\")\n    print(f\"  Transitions: {metrics.transitions_executed}\")\n    print(f\"  Endpoint Coverage: {metrics.endpoint_coverage_pct:.1f}%\")\n    print(f\"  Issues: {len(issues)} ({len([i for i in issues if i.severity == Severity.CRITICAL])} critical)\")\n</code></pre>"},{"location":"specs/state-explorer/#appendix-b-diagram-state-explorer-architecture","title":"Appendix B: Diagram - State Explorer Architecture","text":"Text Only<pre><code>                    +------------------+\n                    |   OpenAPI Spec   |\n                    +--------+---------+\n                             |\n                             v\n                    +------------------+\n                    | ActionGenerator  |\n                    +--------+---------+\n                             |\n                             v\n+-------------+     +------------------+     +----------------+\n| VenomQA     | --&gt; | State Explorer   | --&gt; | State Graph    |\n| HTTPClient  |     |  (BFS/DFS/Hybrid)|     | (Adjacency List)|\n+-------------+     +--------+---------+     +--------+-------+\n                             |                        |\n                             v                        v\n                    +------------------+     +----------------+\n                    | StateManager     |     | Issue Detector |\n                    | (Rollbacks)      |     +--------+-------+\n                    +------------------+              |\n                                                     v\n                                            +----------------+\n                                            | Coverage Calc  |\n                                            +--------+-------+\n                                                     |\n                                                     v\n                                            +----------------+\n                                            | Reporters      |\n                                            | - HTML (vis.js)|\n                                            | - DOT          |\n                                            | - Mermaid      |\n                                            | - JSON         |\n                                            +----------------+\n</code></pre>"},{"location":"specs/state-explorer/#version-history","title":"Version History","text":"Version Date Author Changes 1.0 2024-01-15 VenomQA Initial specification <p>This specification is part of the VenomQA framework documentation.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step guides for common testing scenarios with VenomQA.</p>"},{"location":"tutorials/#getting-started","title":"Getting Started","text":""},{"location":"tutorials/#your-first-journey","title":"Your First Journey","text":"<p>Create a complete journey from scratch, covering authentication, CRUD operations, and error handling.</p> <p>Time: 15 minutes</p>"},{"location":"tutorials/#testing-payment-flows","title":"Testing Payment Flows","text":"<p>Use checkpoints and branching to test multiple payment methods from a single setup.</p> <p>Time: 20 minutes</p>"},{"location":"tutorials/#cicd-integration","title":"CI/CD Integration","text":"<p>Set up VenomQA in GitHub Actions, GitLab CI, and other CI/CD systems.</p> <p>Time: 10 minutes</p>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting these tutorials, ensure you have:</p> <ul> <li> VenomQA installed (<code>pip install venomqa</code>)</li> <li> A running API to test (or use the example server below)</li> <li> Basic Python knowledge</li> </ul>"},{"location":"tutorials/#example-test-server","title":"Example Test Server","text":"<p>For tutorials, you can use this simple FastAPI server:</p> Python<pre><code># server.py\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel\nimport jwt\nfrom datetime import datetime, timedelta\n\napp = FastAPI()\nsecurity = HTTPBearer()\n\n# In-memory storage (for demo)\nusers = {\"test@example.com\": {\"password\": \"secret123\", \"name\": \"Test User\"}}\nitems = {}\ncarts = {}\n\nSECRET_KEY = \"your-secret-key\"\n\nclass LoginRequest(BaseModel):\n    email: str\n    password: str\n\nclass ItemCreate(BaseModel):\n    name: str\n    price: float\n\n@app.get(\"/health\")\ndef health():\n    return {\"status\": \"healthy\"}\n\n@app.post(\"/api/auth/login\")\ndef login(request: LoginRequest):\n    user = users.get(request.email)\n    if not user or user[\"password\"] != request.password:\n        raise HTTPException(status_code=401, detail=\"Invalid credentials\")\n\n    token = jwt.encode(\n        {\"email\": request.email, \"exp\": datetime.utcnow() + timedelta(hours=1)},\n        SECRET_KEY,\n        algorithm=\"HS256\"\n    )\n    return {\"token\": token, \"user\": {\"email\": request.email, \"name\": user[\"name\"]}}\n\ndef get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload[\"email\"]\n    except:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n@app.get(\"/api/users/me\")\ndef get_profile(email: str = Depends(get_current_user)):\n    user = users.get(email)\n    return {\"email\": email, \"name\": user[\"name\"]}\n\n@app.post(\"/api/items\")\ndef create_item(item: ItemCreate, email: str = Depends(get_current_user)):\n    item_id = len(items) + 1\n    items[item_id] = {\"id\": item_id, **item.dict(), \"owner\": email}\n    return items[item_id]\n\n@app.get(\"/api/items/{item_id}\")\ndef get_item(item_id: int):\n    if item_id not in items:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return items[item_id]\n\n@app.delete(\"/api/items/{item_id}\")\ndef delete_item(item_id: int, email: str = Depends(get_current_user)):\n    if item_id not in items:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    del items[item_id]\n    return {\"status\": \"deleted\"}\n\n# Run with: uvicorn server:app --reload\n</code></pre> <p>Start the server:</p> Bash<pre><code>pip install fastapi uvicorn pyjwt\nuvicorn server:app --reload\n</code></pre>"},{"location":"tutorials/#tutorial-structure","title":"Tutorial Structure","text":"<p>Each tutorial follows this structure:</p> <ol> <li>Goal: What you'll build</li> <li>Prerequisites: What you need</li> <li>Steps: Detailed instructions</li> <li>Code: Complete working examples</li> <li>Next Steps: Where to go from here</li> </ol>"},{"location":"tutorials/#quick-links","title":"Quick Links","text":"Tutorial Level Time Topics Your First Journey Beginner 15 min Basics, Steps, Context Testing Payment Flows Intermediate 20 min Checkpoints, Branching CI/CD Integration Intermediate 10 min GitHub Actions, JUnit"},{"location":"tutorials/#need-help","title":"Need Help?","text":"<ul> <li>Check the FAQ for common questions</li> <li>See Examples for more code samples</li> <li>Join our Discord for community support</li> </ul>"},{"location":"tutorials/ci-cd/","title":"CI/CD Integration","text":"<p>Learn how to integrate VenomQA into your continuous integration and deployment pipelines.</p> <p>Time: 10 minutes</p> <p>What you'll learn:</p> <ul> <li>Running VenomQA in GitHub Actions</li> <li>Generating JUnit XML reports</li> <li>Uploading test artifacts</li> <li>Configuring other CI/CD systems</li> </ul>"},{"location":"tutorials/ci-cd/#github-actions","title":"GitHub Actions","text":""},{"location":"tutorials/ci-cd/#basic-setup","title":"Basic Setup","text":"<p>Create <code>.github/workflows/qa-tests.yml</code>:</p> YAML<pre><code>name: QA Tests\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.11\"\n          cache: \"pip\"\n\n      - name: Install dependencies\n        run: |\n          pip install venomqa\n          pip install -r requirements.txt  # Your app dependencies\n\n      - name: Run QA tests\n        run: venomqa run\n\n      - name: Generate JUnit report\n        if: always()\n        run: venomqa report --format junit --output reports/junit.xml\n\n      - name: Upload test results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: qa-reports\n          path: reports/\n\n      - name: Publish test results\n        if: always()\n        uses: dorny/test-reporter@v1\n        with:\n          name: QA Tests\n          path: reports/junit.xml\n          reporter: java-junit\n</code></pre>"},{"location":"tutorials/ci-cd/#with-postgresql-service","title":"With PostgreSQL Service","text":"YAML<pre><code>name: QA Tests with Database\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_DB: qa_test\n          POSTGRES_USER: qa\n          POSTGRES_PASSWORD: secret\n        ports:\n          - 5432:5432\n        options: &gt;-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n      api:\n        image: your-api:latest\n        env:\n          DATABASE_URL: postgresql://qa:secret@postgres:5432/qa_test\n        ports:\n          - 8000:8000\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.11\"\n\n      - name: Install VenomQA\n        run: pip install \"venomqa[postgres]\"\n\n      - name: Run QA tests\n        env:\n          VENOMQA_BASE_URL: http://localhost:8000\n          VENOMQA_DB_URL: postgresql://qa:secret@localhost:5432/qa_test\n        run: venomqa run --no-infra\n\n      - name: Generate reports\n        if: always()\n        run: |\n          venomqa report --format junit --output reports/junit.xml\n          venomqa report --format html --output reports/test.html\n\n      - name: Upload artifacts\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: qa-reports\n          path: reports/\n</code></pre>"},{"location":"tutorials/ci-cd/#matrix-testing","title":"Matrix Testing","text":"<p>Test across multiple Python versions:</p> YAML<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.10\", \"3.11\", \"3.12\"]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install and test\n        run: |\n          pip install venomqa\n          venomqa run\n</code></pre>"},{"location":"tutorials/ci-cd/#gitlab-ci","title":"GitLab CI","text":"<p>Create <code>.gitlab-ci.yml</code>:</p> YAML<pre><code>stages:\n  - test\n\nvariables:\n  POSTGRES_DB: qa_test\n  POSTGRES_USER: qa\n  POSTGRES_PASSWORD: secret\n\nqa-tests:\n  stage: test\n  image: python:3.11\n\n  services:\n    - name: postgres:15\n      alias: postgres\n\n  variables:\n    VENOMQA_BASE_URL: http://api:8000\n    VENOMQA_DB_URL: postgresql://qa:secret@postgres:5432/qa_test\n\n  before_script:\n    - pip install \"venomqa[postgres]\"\n\n  script:\n    - venomqa run --no-infra\n\n  after_script:\n    - venomqa report --format junit --output reports/junit.xml\n\n  artifacts:\n    when: always\n    paths:\n      - reports/\n    reports:\n      junit: reports/junit.xml\n</code></pre>"},{"location":"tutorials/ci-cd/#circleci","title":"CircleCI","text":"<p>Create <code>.circleci/config.yml</code>:</p> YAML<pre><code>version: 2.1\n\njobs:\n  qa-tests:\n    docker:\n      - image: python:3.11\n      - image: postgres:15\n        environment:\n          POSTGRES_DB: qa_test\n          POSTGRES_USER: qa\n          POSTGRES_PASSWORD: secret\n\n    environment:\n      VENOMQA_BASE_URL: http://localhost:8000\n      VENOMQA_DB_URL: postgresql://qa:secret@localhost:5432/qa_test\n\n    steps:\n      - checkout\n\n      - run:\n          name: Install dependencies\n          command: pip install \"venomqa[postgres]\"\n\n      - run:\n          name: Run QA tests\n          command: venomqa run --no-infra\n\n      - run:\n          name: Generate reports\n          when: always\n          command: |\n            venomqa report --format junit --output reports/junit.xml\n            venomqa report --format html --output reports/test.html\n\n      - store_test_results:\n          path: reports\n\n      - store_artifacts:\n          path: reports\n\nworkflows:\n  version: 2\n  test:\n    jobs:\n      - qa-tests\n</code></pre>"},{"location":"tutorials/ci-cd/#jenkins-pipeline","title":"Jenkins Pipeline","text":"<p>Create <code>Jenkinsfile</code>:</p> Groovy<pre><code>pipeline {\n    agent any\n\n    environment {\n        VENOMQA_BASE_URL = 'http://localhost:8000'\n        VENOMQA_DB_URL = credentials('qa-database-url')\n    }\n\n    stages {\n        stage('Setup') {\n            steps {\n                sh 'pip install \"venomqa[postgres]\"'\n            }\n        }\n\n        stage('Start Services') {\n            steps {\n                sh 'docker compose -f docker-compose.qa.yml up -d'\n                sh 'sleep 10'  // Wait for services\n            }\n        }\n\n        stage('Run Tests') {\n            steps {\n                sh 'venomqa run --no-infra'\n            }\n        }\n\n        stage('Generate Reports') {\n            steps {\n                sh '''\n                    venomqa report --format junit --output reports/junit.xml\n                    venomqa report --format html --output reports/test.html\n                '''\n            }\n        }\n    }\n\n    post {\n        always {\n            sh 'docker compose -f docker-compose.qa.yml down'\n\n            junit 'reports/junit.xml'\n\n            publishHTML(target: [\n                allowMissing: false,\n                alwaysLinkToLastBuild: true,\n                keepAll: true,\n                reportDir: 'reports',\n                reportFiles: 'test.html',\n                reportName: 'QA Report'\n            ])\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/ci-cd/#azure-devops","title":"Azure DevOps","text":"<p>Create <code>azure-pipelines.yml</code>:</p> YAML<pre><code>trigger:\n  - main\n  - develop\n\npool:\n  vmImage: 'ubuntu-latest'\n\nservices:\n  postgres:\n    image: postgres:15\n    ports:\n      - 5432:5432\n    env:\n      POSTGRES_DB: qa_test\n      POSTGRES_USER: qa\n      POSTGRES_PASSWORD: secret\n\nvariables:\n  VENOMQA_BASE_URL: http://localhost:8000\n  VENOMQA_DB_URL: postgresql://qa:secret@localhost:5432/qa_test\n\nsteps:\n  - task: UsePythonVersion@0\n    inputs:\n      versionSpec: '3.11'\n\n  - script: pip install \"venomqa[postgres]\"\n    displayName: 'Install VenomQA'\n\n  - script: venomqa run --no-infra\n    displayName: 'Run QA Tests'\n\n  - script: |\n      venomqa report --format junit --output $(Build.ArtifactStagingDirectory)/junit.xml\n    displayName: 'Generate Report'\n    condition: always()\n\n  - task: PublishTestResults@2\n    inputs:\n      testResultsFormat: 'JUnit'\n      testResultsFiles: '$(Build.ArtifactStagingDirectory)/junit.xml'\n    condition: always()\n</code></pre>"},{"location":"tutorials/ci-cd/#report-formats","title":"Report Formats","text":"<p>VenomQA supports multiple report formats for CI/CD:</p> Format Use Case Command JUnit XML CI/CD test results <code>--format junit</code> HTML Human-readable <code>--format html</code> JSON Custom processing <code>--format json</code> Markdown PR comments <code>--format markdown</code> SARIF Security tools <code>--format sarif</code>"},{"location":"tutorials/ci-cd/#generating-multiple-reports","title":"Generating Multiple Reports","text":"Bash<pre><code>venomqa report --format junit --output reports/junit.xml\nvenomqa report --format html --output reports/test.html\nvenomqa report --format markdown --output reports/summary.md\n</code></pre>"},{"location":"tutorials/ci-cd/#environment-variables","title":"Environment Variables","text":"<p>Configure VenomQA via environment variables in CI/CD:</p> Bash<pre><code># Required\nexport VENOMQA_BASE_URL=\"http://api:8000\"\n\n# Database (optional)\nexport VENOMQA_DB_URL=\"postgresql://user:pass@host:5432/db\"\nexport VENOMQA_DB_BACKEND=\"postgresql\"\n\n# Execution\nexport VENOMQA_TIMEOUT=60\nexport VENOMQA_FAIL_FAST=true\nexport VENOMQA_PARALLEL_PATHS=1\n\n# Debugging\nexport VENOMQA_VERBOSE=true\n</code></pre>"},{"location":"tutorials/ci-cd/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/ci-cd/#1-use-no-infra-in-ci","title":"1. Use <code>--no-infra</code> in CI","text":"<p>When services are provided by CI, skip Docker management:</p> Bash<pre><code>venomqa run --no-infra\n</code></pre>"},{"location":"tutorials/ci-cd/#2-always-generate-reports","title":"2. Always Generate Reports","text":"<p>Use <code>if: always()</code> (GitHub) or <code>when: always</code> (GitLab):</p> YAML<pre><code>- name: Generate report\n  if: always()  # Run even if tests fail\n  run: venomqa report --format junit --output reports/junit.xml\n</code></pre>"},{"location":"tutorials/ci-cd/#3-upload-artifacts","title":"3. Upload Artifacts","text":"<p>Always upload reports for debugging:</p> YAML<pre><code>- uses: actions/upload-artifact@v4\n  if: always()\n  with:\n    name: qa-reports\n    path: reports/\n</code></pre>"},{"location":"tutorials/ci-cd/#4-use-secrets-for-credentials","title":"4. Use Secrets for Credentials","text":"<p>Never hardcode credentials:</p> YAML<pre><code># GitHub Actions\nenv:\n  VENOMQA_DB_URL: ${{ secrets.QA_DATABASE_URL }}\n\n# GitLab CI\nvariables:\n  VENOMQA_DB_URL: $CI_QA_DATABASE_URL\n</code></pre>"},{"location":"tutorials/ci-cd/#5-fail-fast-in-prs","title":"5. Fail Fast in PRs","text":"<p>For pull requests, fail fast to get quick feedback:</p> YAML<pre><code>- name: Run tests\n  run: venomqa run --fail-fast\n</code></pre>"},{"location":"tutorials/ci-cd/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/ci-cd/#tests-timeout-in-ci","title":"Tests timeout in CI","text":"<p>Increase timeout for CI environments:</p> YAML<pre><code>env:\n  VENOMQA_TIMEOUT: 120  # 2 minutes\n</code></pre>"},{"location":"tutorials/ci-cd/#database-connection-fails","title":"Database connection fails","text":"<p>Ensure service is ready:</p> YAML<pre><code>services:\n  postgres:\n    options: &gt;-\n      --health-cmd pg_isready\n      --health-interval 10s\n      --health-timeout 5s\n      --health-retries 5\n</code></pre>"},{"location":"tutorials/ci-cd/#journey-not-found","title":"\"Journey not found\"","text":"<p>Ensure journeys directory is included:</p> YAML<pre><code>- uses: actions/checkout@v4  # Includes all files\n</code></pre>"},{"location":"tutorials/ci-cd/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - All configuration options</li> <li>CLI Reference - Complete CLI documentation</li> <li>Examples - More CI/CD examples</li> </ul>"},{"location":"tutorials/first-journey/","title":"Your First Journey","text":"<p>In this tutorial, you'll create a complete journey that tests a user authentication and item management flow.</p> <p>Time: 15 minutes</p> <p>What you'll learn:</p> <ul> <li>Creating a journey with multiple steps</li> <li>Sharing data between steps using context</li> <li>Handling authentication</li> <li>Testing error conditions</li> </ul>"},{"location":"tutorials/first-journey/#prerequisites","title":"Prerequisites","text":"<ul> <li>VenomQA installed (<code>pip install venomqa</code>)</li> <li>A running API server (see Tutorial Index for example server)</li> </ul>"},{"location":"tutorials/first-journey/#step-1-create-project-structure","title":"Step 1: Create Project Structure","text":"Bash<pre><code>mkdir my-api-tests\ncd my-api-tests\nmkdir journeys actions\n</code></pre> <p>Your project structure:</p> Text Only<pre><code>my-api-tests/\n\u251c\u2500\u2500 venomqa.yaml\n\u251c\u2500\u2500 journeys/\n\u2502   \u2514\u2500\u2500 item_management.py\n\u2514\u2500\u2500 actions/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 auth.py\n</code></pre>"},{"location":"tutorials/first-journey/#step-2-configure-venomqa","title":"Step 2: Configure VenomQA","text":"<p>Create <code>venomqa.yaml</code>:</p> YAML<pre><code>base_url: \"http://localhost:8000\"\ntimeout: 30\nverbose: false\nreport_dir: \"reports\"\nreport_formats:\n  - markdown\n  - junit\n</code></pre>"},{"location":"tutorials/first-journey/#step-3-create-reusable-auth-actions","title":"Step 3: Create Reusable Auth Actions","text":"<p>Create <code>actions/__init__.py</code>:</p> Python<pre><code># Empty file to make this a Python package\n</code></pre> <p>Create <code>actions/auth.py</code>:</p> Python<pre><code>\"\"\"Reusable authentication actions.\"\"\"\n\n\ndef login(client, context):\n    \"\"\"\n    Authenticate user and store token.\n\n    Stores:\n        - context[\"token\"]: JWT auth token\n        - context[\"user_email\"]: User's email\n        - context[\"user_name\"]: User's name\n    \"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"token\"] = data[\"token\"]\n        context[\"user_email\"] = data[\"user\"][\"email\"]\n        context[\"user_name\"] = data[\"user\"][\"name\"]\n\n        # Set auth header for all future requests\n        client.set_auth_token(data[\"token\"])\n\n    return response\n\n\ndef login_invalid(client, context):\n    \"\"\"\n    Attempt login with invalid credentials.\n    This should fail with 401.\n    \"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"wrong@example.com\",\n        \"password\": \"wrongpassword\",\n    })\n    return response\n\n\ndef get_profile(client, context):\n    \"\"\"Get the authenticated user's profile.\"\"\"\n    return client.get(\"/api/users/me\")\n</code></pre>"},{"location":"tutorials/first-journey/#step-4-create-the-journey","title":"Step 4: Create the Journey","text":"<p>Create <code>journeys/item_management.py</code>:</p> Python<pre><code>\"\"\"\nItem Management Journey\n\nTests the complete flow of:\n1. User authentication\n2. Creating an item\n3. Retrieving the item\n4. Deleting the item\n5. Verifying deletion\n\"\"\"\nfrom venomqa import Journey, Step\n\n# Import our reusable actions\nimport sys\nsys.path.insert(0, '.')\nfrom actions.auth import login, login_invalid, get_profile\n\n\ndef create_item(client, context):\n    \"\"\"Create a new item.\"\"\"\n    response = client.post(\"/api/items\", json={\n        \"name\": \"Test Widget\",\n        \"price\": 29.99,\n    })\n\n    if response.status_code in [200, 201]:\n        item_data = response.json()\n        context[\"item_id\"] = item_data[\"id\"]\n        context[\"item_name\"] = item_data[\"name\"]\n\n    return response\n\n\ndef get_item(client, context):\n    \"\"\"Retrieve the created item.\"\"\"\n    item_id = context.get_required(\"item_id\")\n    return client.get(f\"/api/items/{item_id}\")\n\n\ndef delete_item(client, context):\n    \"\"\"Delete the item.\"\"\"\n    item_id = context.get_required(\"item_id\")\n    return client.delete(f\"/api/items/{item_id}\")\n\n\ndef get_deleted_item(client, context):\n    \"\"\"\n    Try to get the deleted item.\n    This should fail with 404.\n    \"\"\"\n    item_id = context.get_required(\"item_id\")\n    return client.get(f\"/api/items/{item_id}\")\n\n\n# Define the journey\njourney = Journey(\n    name=\"item_management\",\n    description=\"Test complete item CRUD operations with authentication\",\n    tags=[\"items\", \"crud\", \"auth\"],\n    steps=[\n        # Authentication\n        Step(\n            name=\"login\",\n            action=login,\n            description=\"Authenticate user\",\n        ),\n        Step(\n            name=\"verify_profile\",\n            action=get_profile,\n            description=\"Verify authentication works\",\n        ),\n\n        # Create and Read\n        Step(\n            name=\"create_item\",\n            action=create_item,\n            description=\"Create a new item\",\n        ),\n        Step(\n            name=\"get_item\",\n            action=get_item,\n            description=\"Retrieve the created item\",\n        ),\n\n        # Delete and verify\n        Step(\n            name=\"delete_item\",\n            action=delete_item,\n            description=\"Delete the item\",\n        ),\n        Step(\n            name=\"verify_deleted\",\n            action=get_deleted_item,\n            description=\"Verify item no longer exists\",\n            expect_failure=True,  # We expect a 404 error\n        ),\n    ],\n)\n</code></pre>"},{"location":"tutorials/first-journey/#step-5-run-the-journey","title":"Step 5: Run the Journey","text":"<p>Make sure your API server is running, then:</p> Bash<pre><code>venomqa run item_management\n</code></pre> <p>Expected output:</p> Text Only<pre><code>Running journey: item_management\n  [PASS] login (89ms)\n  [PASS] verify_profile (23ms)\n  [PASS] create_item (45ms)\n  [PASS] get_item (18ms)\n  [PASS] delete_item (31ms)\n  [PASS] verify_deleted (expected failure) (15ms)\n\nJourney completed: 6/6 steps passed\n</code></pre>"},{"location":"tutorials/first-journey/#step-6-add-error-testing","title":"Step 6: Add Error Testing","text":"<p>Let's add a journey that specifically tests error conditions.</p> <p>Create <code>journeys/auth_errors.py</code>:</p> Python<pre><code>\"\"\"\nAuthentication Error Testing\n\nTests that the API correctly handles:\n1. Invalid login credentials\n2. Missing authentication\n3. Invalid tokens\n\"\"\"\nfrom venomqa import Journey, Step\n\n\ndef login_invalid_email(client, context):\n    \"\"\"Login with non-existent email.\"\"\"\n    return client.post(\"/api/auth/login\", json={\n        \"email\": \"nonexistent@example.com\",\n        \"password\": \"secret123\",\n    })\n\n\ndef login_wrong_password(client, context):\n    \"\"\"Login with wrong password.\"\"\"\n    return client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"wrongpassword\",\n    })\n\n\ndef access_without_auth(client, context):\n    \"\"\"Try to access protected endpoint without auth.\"\"\"\n    # Don't set any auth headers\n    client.clear_auth()\n    return client.get(\"/api/users/me\")\n\n\ndef access_with_invalid_token(client, context):\n    \"\"\"Try to access with an invalid token.\"\"\"\n    client.set_auth_token(\"invalid-token-12345\")\n    return client.get(\"/api/users/me\")\n\n\njourney = Journey(\n    name=\"auth_errors\",\n    description=\"Test authentication error handling\",\n    tags=[\"auth\", \"errors\", \"security\"],\n    steps=[\n        Step(\n            name=\"invalid_email\",\n            action=login_invalid_email,\n            description=\"Should reject non-existent email\",\n            expect_failure=True,\n        ),\n        Step(\n            name=\"wrong_password\",\n            action=login_wrong_password,\n            description=\"Should reject wrong password\",\n            expect_failure=True,\n        ),\n        Step(\n            name=\"missing_auth\",\n            action=access_without_auth,\n            description=\"Should reject requests without auth\",\n            expect_failure=True,\n        ),\n        Step(\n            name=\"invalid_token\",\n            action=access_with_invalid_token,\n            description=\"Should reject invalid tokens\",\n            expect_failure=True,\n        ),\n    ],\n)\n</code></pre> <p>Run it:</p> Bash<pre><code>venomqa run auth_errors\n</code></pre>"},{"location":"tutorials/first-journey/#step-7-list-and-run-all-journeys","title":"Step 7: List and Run All Journeys","text":"<p>List all available journeys:</p> Bash<pre><code>venomqa list\n</code></pre> <p>Output:</p> Text Only<pre><code>Found 2 journey(s):\n\n  - item_management (journeys/item_management.py)\n  - auth_errors (journeys/auth_errors.py)\n</code></pre> <p>Run all journeys:</p> Bash<pre><code>venomqa run\n</code></pre>"},{"location":"tutorials/first-journey/#step-8-generate-reports","title":"Step 8: Generate Reports","text":"<p>Generate a markdown report:</p> Bash<pre><code>venomqa report --format markdown --output reports/test.md\n</code></pre> <p>Generate a JUnit XML report for CI:</p> Bash<pre><code>venomqa report --format junit --output reports/junit.xml\n</code></pre>"},{"location":"tutorials/first-journey/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"tutorials/first-journey/#context-sharing","title":"Context Sharing","text":"<p>Data flows between steps via the <code>context</code> object:</p> Python<pre><code>def create_item(client, context):\n    response = client.post(\"/api/items\", json={...})\n    context[\"item_id\"] = response.json()[\"id\"]  # Store\n    return response\n\ndef get_item(client, context):\n    item_id = context.get_required(\"item_id\")  # Retrieve\n    return client.get(f\"/api/items/{item_id}\")\n</code></pre>"},{"location":"tutorials/first-journey/#authentication","title":"Authentication","text":"<p>The client maintains auth state:</p> Python<pre><code>def login(client, context):\n    response = client.post(\"/api/auth/login\", json={...})\n    client.set_auth_token(response.json()[\"token\"])\n    return response\n\n# All subsequent requests include the auth header\ndef get_profile(client, context):\n    return client.get(\"/api/users/me\")  # Auth header added automatically\n</code></pre>"},{"location":"tutorials/first-journey/#expected-failures","title":"Expected Failures","text":"<p>Use <code>expect_failure=True</code> for error testing:</p> Python<pre><code>Step(\n    name=\"verify_deleted\",\n    action=get_deleted_item,\n    expect_failure=True,  # Pass if action fails (404)\n)\n</code></pre>"},{"location":"tutorials/first-journey/#next-steps","title":"Next Steps","text":"<p>You've created your first journey! Now learn:</p> <ul> <li>Testing Payment Flows - Use checkpoints and branching</li> <li>CI/CD Integration - Run tests in your pipeline</li> <li>Core Concepts - Deep dive into VenomQA</li> </ul>"},{"location":"tutorials/payment-flows/","title":"Testing Payment Flows","text":"<p>In this tutorial, you'll use checkpoints and branching to test multiple payment methods from a single setup.</p> <p>Time: 20 minutes</p> <p>What you'll learn:</p> <ul> <li>Creating checkpoints to save state</li> <li>Using branches to test multiple scenarios</li> <li>Testing success and failure paths</li> <li>Organizing complex journeys</li> </ul>"},{"location":"tutorials/payment-flows/#the-challenge","title":"The Challenge","text":"<p>Testing payment flows typically requires:</p> <ol> <li>User authentication</li> <li>Adding items to cart</li> <li>Creating an order</li> <li>Testing multiple payment methods (card, wallet, PayPal, etc.)</li> </ol> <p>Without checkpoints, you'd need to repeat steps 1-3 for each payment method. With VenomQA, you run setup once and branch to test all methods.</p>"},{"location":"tutorials/payment-flows/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Your First Journey tutorial</li> <li>VenomQA installed with <code>pip install venomqa</code></li> </ul>"},{"location":"tutorials/payment-flows/#step-1-set-up-project-structure","title":"Step 1: Set Up Project Structure","text":"Bash<pre><code>mkdir payment-tests\ncd payment-tests\nmkdir journeys\n</code></pre> <p>Create <code>venomqa.yaml</code>:</p> YAML<pre><code>base_url: \"http://localhost:8000\"\ntimeout: 30\nverbose: false\n</code></pre>"},{"location":"tutorials/payment-flows/#step-2-create-the-payment-journey","title":"Step 2: Create the Payment Journey","text":"<p>Create <code>journeys/checkout.py</code>:</p> Python<pre><code>\"\"\"\nCheckout Flow Journey\n\nTests the complete checkout flow with multiple payment methods:\n1. Login\n2. Add items to cart\n3. Create order\n4. [CHECKPOINT] - Save state here\n5. [BRANCH] - Test each payment method from saved state\n   - Credit card (success)\n   - Digital wallet (success)\n   - Credit card declined (expected failure)\n   - Insufficient wallet balance (expected failure)\n\"\"\"\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\n\n\n# ====================\n# Setup Actions\n# ====================\n\ndef login(client, context):\n    \"\"\"Authenticate user.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"token\"] = data[\"token\"]\n        context[\"user_id\"] = data[\"user\"].get(\"id\")\n        client.set_auth_token(data[\"token\"])\n\n    return response\n\n\ndef add_to_cart(client, context):\n    \"\"\"Add items to shopping cart.\"\"\"\n    response = client.post(\"/api/cart/items\", json={\n        \"product_id\": 1,\n        \"quantity\": 2,\n    })\n\n    if response.status_code in [200, 201]:\n        data = response.json()\n        context[\"cart_id\"] = data.get(\"cart_id\")\n        context[\"cart_total\"] = data.get(\"total\", 59.98)\n\n    return response\n\n\ndef create_order(client, context):\n    \"\"\"Create order from cart.\"\"\"\n    response = client.post(\"/api/orders\", json={\n        \"cart_id\": context.get(\"cart_id\"),\n        \"shipping_address\": {\n            \"street\": \"123 Test St\",\n            \"city\": \"Test City\",\n            \"zip\": \"12345\",\n        },\n    })\n\n    if response.status_code in [200, 201]:\n        data = response.json()\n        context[\"order_id\"] = data.get(\"id\")\n        context[\"order_total\"] = data.get(\"total\", context.get(\"cart_total\"))\n\n    return response\n\n\n# ====================\n# Payment Actions\n# ====================\n\ndef pay_with_card_success(client, context):\n    \"\"\"Pay with valid credit card.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context.get(\"order_id\"),\n        \"method\": \"credit_card\",\n        \"card_token\": \"tok_visa_success\",\n        \"amount\": context.get(\"order_total\"),\n    })\n\n\ndef pay_with_card_declined(client, context):\n    \"\"\"Pay with card that gets declined.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context.get(\"order_id\"),\n        \"method\": \"credit_card\",\n        \"card_token\": \"tok_visa_declined\",\n        \"amount\": context.get(\"order_total\"),\n    })\n\n\ndef pay_with_wallet_success(client, context):\n    \"\"\"Pay with digital wallet (sufficient balance).\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context.get(\"order_id\"),\n        \"method\": \"digital_wallet\",\n        \"wallet_id\": \"wallet_sufficient\",\n        \"amount\": context.get(\"order_total\"),\n    })\n\n\ndef pay_with_wallet_insufficient(client, context):\n    \"\"\"Pay with wallet (insufficient balance).\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context.get(\"order_id\"),\n        \"method\": \"digital_wallet\",\n        \"wallet_id\": \"wallet_empty\",\n        \"amount\": context.get(\"order_total\"),\n    })\n\n\ndef verify_payment_success(client, context):\n    \"\"\"Verify order status after successful payment.\"\"\"\n    order_id = context.get(\"order_id\")\n    return client.get(f\"/api/orders/{order_id}\")\n\n\n# ====================\n# Journey Definition\n# ====================\n\njourney = Journey(\n    name=\"checkout_payment_methods\",\n    description=\"Test checkout with multiple payment methods using branching\",\n    tags=[\"checkout\", \"payment\", \"critical\"],\n    steps=[\n        # ===== Setup Phase =====\n        Step(\n            name=\"login\",\n            action=login,\n            description=\"Authenticate user\",\n        ),\n        Step(\n            name=\"add_to_cart\",\n            action=add_to_cart,\n            description=\"Add items to cart\",\n        ),\n        Step(\n            name=\"create_order\",\n            action=create_order,\n            description=\"Create order from cart\",\n        ),\n\n        # ===== Save State =====\n        Checkpoint(name=\"order_ready\"),\n\n        # ===== Test Multiple Payment Methods =====\n        Branch(\n            checkpoint_name=\"order_ready\",\n            paths=[\n                # Happy path: Credit card\n                Path(\n                    name=\"credit_card_success\",\n                    description=\"Pay with valid credit card\",\n                    steps=[\n                        Step(name=\"pay_card\", action=pay_with_card_success),\n                        Step(name=\"verify_order\", action=verify_payment_success),\n                    ],\n                ),\n\n                # Happy path: Digital wallet\n                Path(\n                    name=\"wallet_success\",\n                    description=\"Pay with digital wallet\",\n                    steps=[\n                        Step(name=\"pay_wallet\", action=pay_with_wallet_success),\n                        Step(name=\"verify_order\", action=verify_payment_success),\n                    ],\n                ),\n\n                # Error path: Declined card\n                Path(\n                    name=\"card_declined\",\n                    description=\"Test declined credit card handling\",\n                    steps=[\n                        Step(\n                            name=\"pay_card_declined\",\n                            action=pay_with_card_declined,\n                            expect_failure=True,\n                        ),\n                    ],\n                ),\n\n                # Error path: Insufficient wallet balance\n                Path(\n                    name=\"wallet_insufficient\",\n                    description=\"Test insufficient wallet balance handling\",\n                    steps=[\n                        Step(\n                            name=\"pay_wallet_empty\",\n                            action=pay_with_wallet_insufficient,\n                            expect_failure=True,\n                        ),\n                    ],\n                ),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"tutorials/payment-flows/#step-3-run-the-journey","title":"Step 3: Run the Journey","text":"Bash<pre><code>venomqa run checkout_payment_methods\n</code></pre> <p>Expected output:</p> Text Only<pre><code>Running journey: checkout_payment_methods\n  [PASS] login (92ms)\n  [PASS] add_to_cart (45ms)\n  [PASS] create_order (67ms)\n  [CHECKPOINT] order_ready\n\n  Branch: order_ready\n    Path: credit_card_success\n      [PASS] pay_card (156ms)\n      [PASS] verify_order (23ms)\n    Path: wallet_success\n      [PASS] pay_wallet (134ms)\n      [PASS] verify_order (21ms)\n    Path: card_declined\n      [PASS] pay_card_declined (expected failure) (89ms)\n    Path: wallet_insufficient\n      [PASS] pay_wallet_empty (expected failure) (76ms)\n\nJourney completed: 4/4 paths passed\n</code></pre>"},{"location":"tutorials/payment-flows/#step-4-understanding-checkpoints","title":"Step 4: Understanding Checkpoints","text":"<p>The key insight is what happens at the checkpoint:</p> Text Only<pre><code>Timeline:\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n1. login          \u2192 context[\"token\"] = \"abc123\"\n2. add_to_cart    \u2192 context[\"cart_id\"] = 1\n3. create_order   \u2192 context[\"order_id\"] = 42\n4. CHECKPOINT     \u2192 [State Saved: context + database]\n5. BRANCH\n   \u251c\u2500 Path 1: Starts from checkpoint state\n   \u251c\u2500 Path 2: Starts from checkpoint state (rollback first)\n   \u251c\u2500 Path 3: Starts from checkpoint state (rollback first)\n   \u2514\u2500 Path 4: Starts from checkpoint state (rollback first)\n</code></pre> <p>Each path gets:</p> <ul> <li>Fresh context restored to checkpoint values</li> <li>Database rolled back to checkpoint state</li> <li>Same <code>order_id</code>, <code>cart_id</code>, etc.</li> </ul>"},{"location":"tutorials/payment-flows/#step-5-add-nested-checkpoints","title":"Step 5: Add Nested Checkpoints","text":"<p>For more complex flows, add checkpoints inside paths:</p> Python<pre><code>Path(\n    name=\"credit_card_with_retry\",\n    description=\"Test card payment with retry on soft decline\",\n    steps=[\n        Step(name=\"first_attempt\", action=pay_with_card_soft_decline),\n        Checkpoint(name=\"after_soft_decline\"),  # Nested checkpoint\n        Step(name=\"retry_with_3ds\", action=pay_with_card_3ds),\n        Step(name=\"verify_order\", action=verify_payment_success),\n    ],\n),\n</code></pre>"},{"location":"tutorials/payment-flows/#step-6-add-more-payment-methods","title":"Step 6: Add More Payment Methods","text":"<p>Extend the journey with additional payment methods:</p> Python<pre><code># Add more payment actions\ndef pay_with_paypal(client, context):\n    \"\"\"Pay with PayPal.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context.get(\"order_id\"),\n        \"method\": \"paypal\",\n        \"return_url\": \"https://example.com/success\",\n        \"cancel_url\": \"https://example.com/cancel\",\n    })\n\ndef pay_with_crypto(client, context):\n    \"\"\"Pay with cryptocurrency.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context.get(\"order_id\"),\n        \"method\": \"crypto\",\n        \"currency\": \"BTC\",\n    })\n\ndef pay_with_installments(client, context):\n    \"\"\"Pay in installments.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context.get(\"order_id\"),\n        \"method\": \"installments\",\n        \"installment_count\": 3,\n    })\n\n# Add paths to the branch\nBranch(\n    checkpoint_name=\"order_ready\",\n    paths=[\n        # ... existing paths ...\n\n        Path(name=\"paypal\", steps=[\n            Step(name=\"pay_paypal\", action=pay_with_paypal),\n        ]),\n\n        Path(name=\"crypto\", steps=[\n            Step(name=\"pay_crypto\", action=pay_with_crypto),\n        ]),\n\n        Path(name=\"installments\", steps=[\n            Step(name=\"pay_installments\", action=pay_with_installments),\n        ]),\n    ],\n)\n</code></pre>"},{"location":"tutorials/payment-flows/#step-7-test-with-database-state","title":"Step 7: Test with Database State","text":"<p>For true state isolation, configure a database backend:</p> YAML<pre><code># venomqa.yaml\nbase_url: \"http://localhost:8000\"\ndb_url: \"postgresql://qa:secret@localhost:5432/qa_test\"\ndb_backend: \"postgresql\"\n</code></pre> <p>Now checkpoints will:</p> <ol> <li>Create SQL SAVEPOINTs</li> <li>Roll back database state between paths</li> <li>Ensure each path sees the same data</li> </ol>"},{"location":"tutorials/payment-flows/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/payment-flows/#1-name-paths-clearly","title":"1. Name Paths Clearly","text":"Python<pre><code># Good\nPath(name=\"credit_card_success\", ...)\nPath(name=\"credit_card_declined\", ...)\n\n# Bad\nPath(name=\"test1\", ...)\nPath(name=\"path_a\", ...)\n</code></pre>"},{"location":"tutorials/payment-flows/#2-group-related-paths","title":"2. Group Related Paths","text":"Python<pre><code>Branch(\n    checkpoint_name=\"order_ready\",\n    paths=[\n        # Credit card paths\n        Path(name=\"card_success\", ...),\n        Path(name=\"card_declined\", ...),\n        Path(name=\"card_expired\", ...),\n\n        # Wallet paths\n        Path(name=\"wallet_success\", ...),\n        Path(name=\"wallet_insufficient\", ...),\n\n        # Alternative methods\n        Path(name=\"paypal_success\", ...),\n        Path(name=\"bank_transfer\", ...),\n    ],\n)\n</code></pre>"},{"location":"tutorials/payment-flows/#3-test-both-success-and-failure","title":"3. Test Both Success and Failure","text":"<p>Always test error handling:</p> Python<pre><code># Success path\nPath(name=\"card_success\", steps=[\n    Step(name=\"pay\", action=pay_valid_card),\n]),\n\n# Failure paths\nPath(name=\"card_declined\", steps=[\n    Step(name=\"pay\", action=pay_declined_card, expect_failure=True),\n]),\nPath(name=\"card_expired\", steps=[\n    Step(name=\"pay\", action=pay_expired_card, expect_failure=True),\n]),\n</code></pre>"},{"location":"tutorials/payment-flows/#4-verify-state-after-actions","title":"4. Verify State After Actions","text":"<p>Always verify the expected outcome:</p> Python<pre><code>Path(name=\"success\", steps=[\n    Step(name=\"pay\", action=pay),\n    Step(name=\"verify\", action=verify_payment_completed),  # Verify!\n]),\n</code></pre>"},{"location":"tutorials/payment-flows/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/payment-flows/#checkpoint-not-found","title":"\"Checkpoint not found\"","text":"<p>Ensure checkpoint is created before the branch:</p> Python<pre><code># Correct\nCheckpoint(name=\"order_ready\"),\nBranch(checkpoint_name=\"order_ready\", ...)\n\n# Wrong - checkpoint after branch reference\nBranch(checkpoint_name=\"order_ready\", ...)\nCheckpoint(name=\"order_ready\"),\n</code></pre>"},{"location":"tutorials/payment-flows/#paths-interfering-with-each-other","title":"Paths interfering with each other","text":"<p>Use <code>parallel_paths=1</code> for sequential execution:</p> YAML<pre><code># venomqa.yaml\nparallel_paths: 1\n</code></pre>"},{"location":"tutorials/payment-flows/#context-values-missing-in-paths","title":"Context values missing in paths","text":"<p>Remember: context is restored at each path start:</p> Python<pre><code># Setup\ncontext[\"order_id\"] = 42  # Set before checkpoint\n\n# At checkpoint: context[\"order_id\"] = 42\n\n# Path 1: context[\"order_id\"] = 42 (restored)\n# Path 2: context[\"order_id\"] = 42 (restored, not 43!)\n</code></pre>"},{"location":"tutorials/payment-flows/#next-steps","title":"Next Steps","text":"<ul> <li>CI/CD Integration - Run payment tests in your pipeline</li> <li>State Management - Deep dive into state handling</li> <li>Examples - More checkout examples</li> </ul>"}]}