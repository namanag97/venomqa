{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Find sequence bugsyour tests will never catch <p>       VenomQA autonomously explores every API call sequence \u2014 the stateful bugs that pytest, Schemathesis, and Postman all miss.     </p> Get Started View on GitHub Watch it work <p>VenomQA explores every state transition</p> create() update() delete() Empty initial Has Data 1+ items Modified changed 0 Paths Explored 0 States Visited 0 Checks Run Exploring paths... Traditional testing has blind spots \u2717           Traditional Testing          Test 1 Test 2 Test 3 <ul> <li>Each test runs in isolation</li> <li>State combinations untested</li> <li>Flaky from test order</li> <li>Manual scenario setup</li> </ul> \u2713           VenomQA          A B C <ul> <li>Explores ALL paths automatically</li> <li>Finds state transition bugs</li> <li>Database checkpoints for branching</li> <li>Invariants checked everywhere</li> </ul> How it works Step 1 Define States <p>Model your app as states and transitions. Empty cart, has items, checked out.</p> Step 2 Add Invariants <p>Define rules that must always hold. \"Cart total = sum of items\" checked everywhere.</p> Step 3 Explore <p>VenomQA traverses every path, checks invariants, reports violations.</p> <p>TOOL COMPARISON</p> The only tool that tests sequences <p>Other tools test endpoints in isolation. VenomQA tests what happens between them.</p> Capability VenomQA Schemathesis pytest Postman Hypothesis Dredd Sequence / ordering bugs \u2713 Only tool \u2717 \u2717 \u2717 \u2717 \u2717 DB rollback &amp; branching \u2713 Only tool \u2717 \u2717 \u2717 \u2717 \u2717 Autonomous exploration \u2713 Sequences ~ Per endpoint \u2717 Manual \u2717 Manual ~ Per function \u2717 OpenAPI / Swagger \u2713 \u2713 \u2717 \u2713 \u2717 \u2713 Fuzz / random inputs \u2717 \u2713 Best-in-class \u2717 \u2717 \u2713 Best-in-class \u2717 Contract compliance \u2717 \u2713 \u2717 ~ \u2717 \u2713 Best-in-class Zero test writing \u2713 \u2713 \u2717 \u2717 \u2717 \u2713 Python native \u2713 \u2713 \u2713 \u2717 JS/GUI \u2713 \u2717 JS Recommended stack: Use Schemathesis to fuzz individual endpoints + VenomQA to find sequence bugs. They catch completely different bugs.      Features \ud83d\udd00 State Graph Exploration <p>Model as nodes &amp; edges. Auto-explore all reachable paths.</p> \u2705 Invariant Checking <p>Rules checked after every action. Catch consistency bugs.</p> \ud83d\udcbe DB Checkpoint &amp; Rollback <p>Save database state. Branch to test multiple paths.</p> \ud83d\udee1\ufe0f Resilience <p>Circuit breakers, retries, rate limiting built-in.</p> \ud83d\udcca Reports <p>HTML, JSON, JUnit. Slack &amp; Discord notifications.</p> \ud83d\udd0c Adapters <p>Postgres, MySQL, Redis. Mock external services.</p> Ready to find sequence bugs automatically? <p>pip install venomqa \u2014 finds bugs in 30 seconds, no configuration needed</p> <code>pip install venomqa &amp;&amp; venomqa demo</code> Read the Docs Stateful API Testing Tool for Python <p>VenomQA is a Python library for autonomous stateful API testing. Unlike pytest which tests functions in isolation, or Schemathesis which fuzzes individual endpoints, VenomQA tests sequences of API calls: create then refund then refund, finding the double-refund bug that your unit tests miss.</p> <p>Use VenomQA to find sequence bugs, state machine bugs, and ordering bugs in REST APIs. Works with PostgreSQL, SQLite, Redis. Generates test actions from OpenAPI specs. Alternatives: Schemathesis, Dredd, Newman, Postman, pytest-httpx.</p> <p>Install with pip install venomqa. Python 3.10+. MIT license. Open source.</p>"},{"location":"ARCHITECTURE_V2/","title":"VenomQA v2 Architecture","text":""},{"location":"ARCHITECTURE_V2/#problem-statement","title":"Problem Statement","text":"<p>User feedback identified critical ergonomic issues: 1. No preconditions on actions - manual guards in every action 2. No auto-invalidation - 22 keys to clear when workspace deleted 3. No loop detection - <code>confirm_member x38</code> loops 4. Context is unstructured - relationships invisible to framework</p>"},{"location":"ARCHITECTURE_V2/#solution-resourcegraph","title":"Solution: ResourceGraph","text":"<p>Add a typed resource graph that tracks: - What resources exist (by type and ID) - Parent-child relationships - Auto-cascade deletes to children</p>"},{"location":"ARCHITECTURE_V2/#core-data-models","title":"Core Data Models","text":""},{"location":"ARCHITECTURE_V2/#typesystem-static","title":"TypeSystem (Static)","text":"Text Only<pre><code>ResourceSchema = { types: dict[str, ResourceType] }\nResourceType = { name, parent, id_field, path_param }\n</code></pre> <p>Defines what CAN exist and relationships between types.</p>"},{"location":"ARCHITECTURE_V2/#resourcegraph-dynamic","title":"ResourceGraph (Dynamic)","text":"Text Only<pre><code>Resource = { type, id, parent, data, alive }\nResourceGraph = { resources: dict[(type, id), Resource] }\n</code></pre> <p>Tracks what DOES exist at runtime.</p>"},{"location":"ARCHITECTURE_V2/#operations","title":"Operations","text":"<ul> <li><code>create(type, id, parent_id)</code> - add resource</li> <li><code>destroy(type, id)</code> - remove resource + all descendants</li> <li><code>exists(type, id)</code> - check if alive</li> <li><code>checkpoint()</code> / <code>rollback(snapshot)</code> - state management</li> </ul>"},{"location":"ARCHITECTURE_V2/#integration-with-venomqa-v1","title":"Integration with VenomQA v1","text":""},{"location":"ARCHITECTURE_V2/#layer-1-runtime-core-standalone","title":"Layer 1: runtime-core/ (standalone)","text":"<p>Reusable library with: - <code>ResourceGraph</code> - <code>ResourceSchema</code> - <code>OpenAPIParser</code></p>"},{"location":"ARCHITECTURE_V2/#layer-2-resourcegraphadapter","title":"Layer 2: ResourceGraphAdapter","text":"<p>Implements <code>Rollbackable</code> protocol: Python<pre><code>class ResourceGraphAdapter(Rollbackable):\n    def observe(self) -&gt; Observation\n    def checkpoint(name) -&gt; SystemCheckpoint\n    def rollback(cp) -&gt; None\n</code></pre></p>"},{"location":"ARCHITECTURE_V2/#layer-3-world-integration","title":"Layer 3: World Integration","text":"Python<pre><code>world = World(\n    api=http,\n    systems={\n        \"db\": PostgresAdapter(db_url),\n        \"resources\": ResourceGraphAdapter(schema),\n    },\n)\n</code></pre>"},{"location":"ARCHITECTURE_V2/#layer-4-agent-integration","title":"Layer 4: Agent Integration","text":"Python<pre><code>def _valid_actions(self, state):\n    graph = self.world.systems.get(\"resources\")\n    for action in self.actions:\n        if graph and not graph.can_execute(action.requires, bindings):\n            continue  # skip - resources don't exist\n        # ... existing precondition checks\n</code></pre>"},{"location":"ARCHITECTURE_V2/#openapi-action-generation","title":"OpenAPI Action Generation","text":"<p>From spec: YAML<pre><code>paths:\n  /workspaces/{workspace_id}/uploads:\n    post:\n      responses:\n        201:\n          content:\n            application/json:\n              schema:\n                properties:\n                  id: {type: string}\n</code></pre></p> <p>Infer: - <code>upload</code> is child of <code>workspace</code> - <code>POST /workspaces/{id}/uploads</code> creates <code>upload</code> - Requires <code>workspace</code> to exist</p> <p>Generate: Python<pre><code>Action(\n    name=\"create_upload\",\n    requires=[\"workspace\"],\n    execute=auto_generated_fn,\n)\n</code></pre></p>"},{"location":"ARCHITECTURE_V2/#user-experience","title":"User Experience","text":""},{"location":"ARCHITECTURE_V2/#before-manual","title":"Before (manual)","text":"Python<pre><code>def delete_workspace(api, ctx):\n    resp = api.delete(f\"/workspaces/{ctx['workspace_id']}\")\n    ctx.clear(\"workspace_id\")\n    ctx.clear(\"upload_id\")  # manual\n    ctx.clear(\"member_id\")  # manual\n    # ... 19 more keys\n    return resp\n</code></pre>"},{"location":"ARCHITECTURE_V2/#after-resourcegraph","title":"After (ResourceGraph)","text":"Python<pre><code>def delete_workspace(api, ctx, resources):\n    resp = api.delete(f\"/workspaces/{ctx['workspace_id']}\")\n    resources.destroy(\"workspace\", ctx[\"workspace_id\"])  # auto-cascades\n    return resp\n</code></pre>"},{"location":"ARCHITECTURE_V2/#task-dependencies","title":"Task Dependencies","text":"Text Only<pre><code>Task 1: runtime-core/ template\n    \u2193\nTask 2: ResourceGraphAdapter \u2500\u2500\u2192 Task 3: Wire into World\n    \u2193                                    \u2193\nTask 5: OpenAPI generator         Task 4: Agent preconditions\n    \u2193                                    \u2193\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Task 6: Integration tests \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"ARCHITECTURE_V2/#research-sources","title":"Research Sources","text":"<ul> <li>QuickCheck State Machine - symbolic references</li> <li>Hypothesis Stateful Testing - bundles, consumes()</li> <li>RESTler - producer-consumer inference</li> <li>Schemathesis - OpenAPI-driven testing</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances   of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at conduct@venomqa.dev or via GitHub's private reporting feature.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"INVARIANTS_GUIDE/","title":"Understanding Violations in VenomQA","text":""},{"location":"INVARIANTS_GUIDE/#what-is-a-violation","title":"What is a Violation?","text":"<p>A violation occurs when an invariant returns <code>False</code>.</p> <ul> <li>Invariant = A rule that must ALWAYS be true, no matter what sequence of actions was executed</li> <li>Violation = The invariant returned <code>False</code> \u2014 something is broken</li> </ul>"},{"location":"INVARIANTS_GUIDE/#how-developers-define-whats-a-violation","title":"How Developers Define What's a Violation","text":""},{"location":"INVARIANTS_GUIDE/#step-1-identify-business-rules","title":"Step 1: Identify Business Rules","text":"<p>Before writing code, list your business rules:</p> Text Only<pre><code>1. A user can't have negative balance\n2. Refunds can't exceed the original payment\n3. Deleted resources must return 404\n4. Open issues list must not contain closed issues\n5. Order total must equal sum of line items\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#step-2-write-the-invariant-function","title":"Step 2: Write the Invariant Function","text":"<p>Each invariant is a function that returns <code>True</code> (pass) or <code>False</code> (violation):</p> Python<pre><code>def refund_cannot_exceed_payment(world):\n    \"\"\"VIOLATION if refunded_amount &gt; payment_amount.\"\"\"\n    refund = world.context.get(\"refund_amount\") or 0\n    payment = world.context.get(\"payment_amount\") or 0\n\n    # Return True = OK, False = VIOLATION\n    return refund &lt;= payment\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#step-3-register-with-severity","title":"Step 3: Register with Severity","text":"Python<pre><code>from venomqa import Invariant, Severity\n\nInvariant(\n    name=\"refund_cannot_exceed_payment\",\n    check=refund_cannot_exceed_payment,\n    message=\"Refunded amount exceeds original payment. Billing integrity bug!\",\n    severity=Severity.CRITICAL,  # CRITICAL, HIGH, MEDIUM, LOW\n)\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#severity-guidelines","title":"Severity Guidelines","text":"Severity When to Use Examples <code>CRITICAL</code> Data corruption, security breach, money issues Over-refund, data leak, auth bypass <code>HIGH</code> Major feature broken Can't checkout, can't login <code>MEDIUM</code> Partial functionality loss Wrong count displayed, slow response <code>LOW</code> Minor issues Typo in response, extra whitespace"},{"location":"INVARIANTS_GUIDE/#common-invariant-patterns","title":"Common Invariant Patterns","text":""},{"location":"INVARIANTS_GUIDE/#pattern-1-check-context-state","title":"Pattern 1: Check Context State","text":"Python<pre><code>def user_must_exist_after_login(world):\n    \"\"\"After login action runs, user_id must be set.\"\"\"\n    if not world.context.has(\"logged_in\"):\n        return True  # Login hasn't run yet, skip\n    return world.context.get(\"user_id\") is not None\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#pattern-2-make-live-api-call","title":"Pattern 2: Make Live API Call","text":"Python<pre><code>def deleted_resource_returns_404(world):\n    \"\"\"After delete, GET must return 404.\"\"\"\n    deleted_id = world.context.get(\"deleted_resource_id\")\n    if not deleted_id:\n        return True  # Nothing deleted yet\n\n    resp = world.api.get(f\"/resources/{deleted_id}\")\n    return resp.status_code == 404\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#pattern-3-cross-reference-data","title":"Pattern 3: Cross-Reference Data","text":"Python<pre><code>def order_total_matches_items(world):\n    \"\"\"Order total must equal sum of line items.\"\"\"\n    order = world.context.get(\"order\")\n    if not order:\n        return True\n\n    expected_total = sum(item[\"price\"] * item[\"qty\"] for item in order[\"items\"])\n    return order[\"total\"] == expected_total\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#pattern-4-compare-api-vs-database","title":"Pattern 4: Compare API vs Database","text":"Python<pre><code>def api_count_matches_db(world):\n    \"\"\"API response count must match database count.\"\"\"\n    api_count = world.context.get(\"api_item_count\")\n\n    # Query database directly (if db adapter registered)\n    db = world.systems.get(\"db\")\n    if not db or api_count is None:\n        return True\n\n    db_count = db.query_one(\"SELECT COUNT(*) FROM items\")\n    return api_count == db_count\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#understanding-violation-output","title":"Understanding Violation Output","text":"<p>When a violation is detected:</p> Text Only<pre><code>[CRITICAL] refund_cannot_exceed_payment\n  Message: Refunded amount exceeds original payment. Billing integrity bug!\n\n  Reproduction Path:\n    -&gt; create_customer\n    -&gt; create_payment_intent\n    -&gt; confirm_payment\n    -&gt; create_refund           \u2190 This action triggered the violation\n\n  Request: POST http://localhost:8102/refunds\n  Response: 200\n  Body: {\"id\": \"re_123\", \"amount\": 2000, ...}\n</code></pre> <p>Key information: - Invariant name: Which rule was broken - Message: Human explanation of the issue - Reproduction path: Exact sequence of actions to reproduce - Request/Response: The HTTP call that led to the violation</p>"},{"location":"INVARIANTS_GUIDE/#good-defaults-for-complex-projects","title":"Good Defaults for Complex Projects","text":""},{"location":"INVARIANTS_GUIDE/#recommended-config-venomqayaml","title":"Recommended Config (<code>venomqa.yaml</code>)","text":"YAML<pre><code># Target API\nbase_url: \"http://localhost:8000\"\ntimeout: 30\n\n# Retry configuration\nretry:\n  max_attempts: 3\n  delay: 1\n  backoff_multiplier: 2\n  max_delay: 30\n  retry_on_status: [429, 500, 502, 503, 504]\n\n# Exploration settings\nexploration:\n  strategy: \"bfs\"           # bfs, dfs, random, coverage_guided\n  max_steps: 500            # Increase for more coverage\n  stop_on_first_violation: false  # Set true for fast feedback\n\n# Reporting\nreport:\n  formats: [html, json, junit]\n  output_dir: \"./reports\"\n  include_request_response: true  # Show full HTTP payloads\n\n# For CI/CD\nfail_on_severity: \"high\"    # Fail pipeline if HIGH or CRITICAL found\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#recommended-project-structure","title":"Recommended Project Structure","text":"Text Only<pre><code>qa/\n\u251c\u2500\u2500 venomqa.yaml           # Config\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth.py            # Login, logout, register\n\u2502   \u251c\u2500\u2500 users.py           # CRUD for users\n\u2502   \u2514\u2500\u2500 orders.py          # Order operations\n\u251c\u2500\u2500 invariants/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth.py            # Auth invariants\n\u2502   \u251c\u2500\u2500 data_integrity.py  # Cross-reference checks\n\u2502   \u2514\u2500\u2500 security.py        # Security invariants\n\u251c\u2500\u2500 journeys/\n\u2502   \u251c\u2500\u2500 auth_flow.py       # Focused: auth actions only\n\u2502   \u251c\u2500\u2500 order_flow.py      # Focused: order actions only\n\u2502   \u2514\u2500\u2500 full_exploration.py # All actions (needs more steps)\n\u2514\u2500\u2500 reports/\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#recommended-invariants-by-domain","title":"Recommended Invariants by Domain","text":"<p>Authentication: Python<pre><code>INVARIANTS = [\n    Invariant(name=\"logged_out_cant_access_protected\", check=..., severity=Severity.CRITICAL),\n    Invariant(name=\"session_expires_correctly\", check=..., severity=Severity.HIGH),\n    Invariant(name=\"password_not_in_response\", check=..., severity=Severity.CRITICAL),\n]\n</code></pre></p> <p>E-commerce: Python<pre><code>INVARIANTS = [\n    Invariant(name=\"cart_total_matches_items\", check=..., severity=Severity.CRITICAL),\n    Invariant(name=\"inventory_not_negative\", check=..., severity=Severity.CRITICAL),\n    Invariant(name=\"order_total_correct\", check=..., severity=Severity.CRITICAL),\n    Invariant(name=\"refund_within_bounds\", check=..., severity=Severity.CRITICAL),\n]\n</code></pre></p> <p>Data Integrity: Python<pre><code>INVARIANTS = [\n    Invariant(name=\"deleted_returns_404\", check=..., severity=Severity.HIGH),\n    Invariant(name=\"created_is_retrievable\", check=..., severity=Severity.CRITICAL),\n    Invariant(name=\"list_count_matches_db\", check=..., severity=Severity.MEDIUM),\n]\n</code></pre></p>"},{"location":"INVARIANTS_GUIDE/#testing-your-invariants","title":"Testing Your Invariants","text":""},{"location":"INVARIANTS_GUIDE/#1-plant-known-bugs","title":"1. Plant Known Bugs","text":"<p>Create a mock server with deliberate bugs to verify detection:</p> Python<pre><code># mock_server.py\n@app.post(\"/refunds\")\ndef create_refund(amount: int):\n    # BUG: No validation - allows over-refund\n    return {\"refund_id\": \"123\", \"amount\": amount}\n</code></pre> <p>Then run exploration: Bash<pre><code>python3 qa/journeys/payment_flow.py\n</code></pre></p> <p>Expected: VenomQA should find the <code>refund_cannot_exceed_payment</code> violation.</p>"},{"location":"INVARIANTS_GUIDE/#2-run-focused-explorations","title":"2. Run Focused Explorations","text":"<p>Don't start with 50 actions. Start focused:</p> Python<pre><code># Test just auth (5 actions, finds bugs in ~30 steps)\nagent = Agent(\n    actions=[login, logout, register, change_password, delete_account],\n    invariants=AUTH_INVARIANTS,\n    max_steps=100,\n)\n\n# Test just payments (5 actions, finds bugs in ~30 steps)\nagent = Agent(\n    actions=[create_customer, create_payment, confirm, refund, get_status],\n    invariants=PAYMENT_INVARIANTS,\n    max_steps=100,\n)\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#3-verify-reproduction-paths","title":"3. Verify Reproduction Paths","text":"<p>When a violation is found, manually replay the path:</p> Bash<pre><code># Violation says: create_user -&gt; create_order -&gt; apply_discount -&gt; checkout\ncurl -X POST localhost:8000/users -d '{\"name\": \"test\"}'\ncurl -X POST localhost:8000/orders -d '{\"user_id\": 1}'\ncurl -X POST localhost:8000/orders/1/discount -d '{\"code\": \"50OFF\"}'\ncurl -X POST localhost:8000/orders/1/checkout\n# Verify the bug exists\n</code></pre>"},{"location":"INVARIANTS_GUIDE/#performance-avoid-slow-invariants","title":"Performance: Avoid Slow Invariants","text":"<p>Invariants are checked after every action. If an invariant makes HTTP calls, it can slow exploration significantly.</p> <p>Slow (HTTP call per check): Python<pre><code>def list_shows_only_open(world):\n    resp = world.api.get(\"/issues?state=open\")  # HTTP call every check!\n    issues = resp.json()\n    return all(i[\"state\"] == \"open\" for i in issues)\n</code></pre></p> <p>Fast (use context instead): Python<pre><code># Action stores data in context\ndef list_open_issues(api, context):\n    resp = api.get(\"/issues?state=open\")\n    context.set(\"open_issues\", resp.json())\n    return resp\n\n# Invariant reads from context (no HTTP call)\ndef list_shows_only_open(world):\n    issues = world.context.get(\"open_issues\")\n    if not issues:\n        return True  # Not fetched yet\n    return all(i[\"state\"] == \"open\" for i in issues)\n</code></pre></p> <p>Rule of thumb: - Store API responses in context via actions - Invariants should read from context, not call APIs - Exception: Cross-reference checks that MUST call the API</p>"},{"location":"INVARIANTS_GUIDE/#quick-reference","title":"Quick Reference","text":"Question Answer What's a violation? Invariant returned <code>False</code> What severity to use? CRITICAL for money/security, HIGH for broken features How many actions? Start with 5-10 per exploration How many steps? 100-500 depending on action count BFS vs DFS? BFS finds shallow bugs faster When to check invariants? After every action (default)"},{"location":"advanced/","title":"Advanced Usage","text":"<p>This guide covers advanced features and patterns in VenomQA.</p> <p>Prerequisites: Familiarity with Journeys and Configuration.</p>"},{"location":"advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Caching</li> <li>Parallel Execution</li> <li>Custom Reporters</li> <li>Custom State Backends</li> <li>Hooks and Extensions</li> <li>Performance Optimization</li> <li>Error Handling Strategies</li> <li>Testing Patterns</li> </ul>"},{"location":"advanced/#related-documentation","title":"Related Documentation","text":"Topic Document API Reference api.md Adapters adapters.md Examples examples.md FAQ FAQ.md"},{"location":"advanced/#caching","title":"Caching","text":""},{"location":"advanced/#response-caching","title":"Response Caching","text":"<p>Cache responses to speed up repeated requests:</p> Python<pre><code>from functools import lru_cache\nfrom venomqa import Client\n\nclass CachedClient(Client):\n    \"\"\"HTTP client with response caching for GET requests.\"\"\"\n\n    def __init__(self, *args, cache_size: int = 100, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._cache_size = cache_size\n        self._get_cached = lru_cache(maxsize=cache_size)(self._get_uncached)\n\n    def _get_uncached(self, path: str, cache_key: str) -&gt; dict:\n        \"\"\"Uncached GET implementation.\"\"\"\n        return super().get(path)\n\n    def get(self, path: str, **kwargs) -&gt; dict:\n        # Create cache key from path and params\n        import json\n        cache_key = json.dumps({\"path\": path, \"kwargs\": kwargs}, sort_keys=True)\n        return self._get_cached(path, cache_key)\n\n    def clear_cache(self):\n        \"\"\"Clear the response cache.\"\"\"\n        self._get_cached.cache_clear()\n</code></pre>"},{"location":"advanced/#authentication-token-caching","title":"Authentication Token Caching","text":"<p>Cache auth tokens across steps:</p> Python<pre><code>from venomqa.core.context import ExecutionContext\n\ndef login_with_cache(client, context: ExecutionContext):\n    \"\"\"Login with token caching to avoid repeated auth.\"\"\"\n    cached_token = context.get(\"_cached_auth_token\")\n\n    if cached_token:\n        client.set_auth_token(cached_token)\n        # Verify token still works\n        response = client.get(\"/api/auth/verify\")\n        if response.status_code == 200:\n            return response\n\n    # Perform fresh login\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n\n    if response.status_code == 200:\n        token = response.json()[\"token\"]\n        context[\"_cached_auth_token\"] = token\n        client.set_auth_token(token)\n\n    return response\n</code></pre>"},{"location":"advanced/#fixture-data-caching","title":"Fixture Data Caching","text":"<p>Cache expensive setup operations:</p> Python<pre><code>import hashlib\nimport pickle\nfrom pathlib import Path\n\nclass FixtureCache:\n    \"\"\"Cache fixture data to disk.\"\"\"\n\n    def __init__(self, cache_dir: str = \".venomqa_cache\"):\n        self.cache_dir = Path(cache_dir)\n        self.cache_dir.mkdir(exist_ok=True)\n\n    def _cache_key(self, data: dict) -&gt; str:\n        return hashlib.md5(pickle.dumps(data)).hexdigest()\n\n    def get(self, key: str) -&gt; dict | None:\n        cache_file = self.cache_dir / f\"{key}.pkl\"\n        if cache_file.exists():\n            return pickle.loads(cache_file.read_bytes())\n        return None\n\n    def set(self, key: str, data: dict) -&gt; None:\n        cache_file = self.cache_dir / f\"{key}.pkl\"\n        cache_file.write_bytes(pickle.dumps(data))\n\n    def cached_setup(self, setup_func, *args, **kwargs):\n        \"\"\"Run setup function with caching.\"\"\"\n        cache_key = self._cache_key({\"func\": setup_func.__name__, \"args\": args, \"kwargs\": kwargs})\n\n        cached = self.get(cache_key)\n        if cached is not None:\n            return cached\n\n        result = setup_func(*args, **kwargs)\n        self.set(cache_key, result)\n        return result\n</code></pre>"},{"location":"advanced/#parallel-execution","title":"Parallel Execution","text":""},{"location":"advanced/#enabling-parallel-paths","title":"Enabling Parallel Paths","text":"<p>Run branch paths in parallel:</p> Python<pre><code>from venomqa import JourneyRunner\n\nrunner = JourneyRunner(\n    client=client,\n    state_manager=state_manager,\n    parallel_paths=4,  # Run up to 4 paths concurrently\n)\n\nresult = runner.run(journey)\n</code></pre>"},{"location":"advanced/#configuration","title":"Configuration","text":"YAML<pre><code># venomqa.yaml\nparallel_paths: 4\n</code></pre>"},{"location":"advanced/#considerations-for-parallel-execution","title":"Considerations for Parallel Execution","text":"<ol> <li>State Isolation: Each parallel path needs isolated state</li> <li>Resource Limits: Don't exceed database connection limits</li> <li>Rate Limiting: APIs may have rate limits</li> </ol>"},{"location":"advanced/#isolating-state-for-parallel-paths","title":"Isolating State for Parallel Paths","text":"<p>When running in parallel, each path needs its own context:</p> Python<pre><code># The runner automatically handles this by:\n# 1. Creating a context snapshot before the branch\n# 2. Restoring the snapshot for each path\n# 3. Each path gets its own isolated context\n\n# For database state, ensure:\n# 1. Each path uses different record IDs\n# 2. Or use database-level transactions with SAVEPOINT\n</code></pre>"},{"location":"advanced/#parallel-journey-execution","title":"Parallel Journey Execution","text":"<p>Run multiple journeys in parallel:</p> Python<pre><code>from concurrent.futures import ThreadPoolExecutor, as_completed\nfrom venomqa import JourneyRunner, Client\n\ndef run_journey(journey, config):\n    client = Client(base_url=config.base_url)\n    runner = JourneyRunner(client=client)\n    return runner.run(journey)\n\ndef run_all_parallel(journeys, config, max_workers=4):\n    results = []\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(run_journey, j, config): j\n            for j in journeys\n        }\n\n        for future in as_completed(futures):\n            journey = futures[future]\n            try:\n                result = future.result()\n                results.append(result)\n            except Exception as e:\n                print(f\"Journey {journey.name} failed: {e}\")\n\n    return results\n</code></pre>"},{"location":"advanced/#custom-reporters","title":"Custom Reporters","text":""},{"location":"advanced/#creating-a-custom-reporter","title":"Creating a Custom Reporter","text":"Python<pre><code>from pathlib import Path\nfrom typing import Any\nfrom venomqa.reporters.base import BaseReporter\nfrom venomqa.core.models import JourneyResult\n\nclass CSVReporter(BaseReporter):\n    \"\"\"Generate CSV reports for spreadsheet analysis.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".csv\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        lines = [\n            \"journey_name,success,duration_ms,total_steps,passed_steps,issue_count\"\n        ]\n\n        for result in results:\n            lines.append(\n                f\"{result.journey_name},\"\n                f\"{result.success},\"\n                f\"{result.duration_ms:.0f},\"\n                f\"{result.total_steps},\"\n                f\"{result.passed_steps},\"\n                f\"{len(result.issues)}\"\n            )\n\n        return \"\\n\".join(lines)\n\n\nclass SlackReporter(BaseReporter):\n    \"\"\"Send test results to Slack.\"\"\"\n\n    def __init__(self, webhook_url: str, output_path: str | Path | None = None):\n        super().__init__(output_path)\n        self.webhook_url = webhook_url\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".json\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; dict[str, Any]:\n        passed = sum(1 for r in results if r.success)\n        failed = len(results) - passed\n\n        color = \"good\" if failed == 0 else \"danger\"\n        status = \"All tests passed!\" if failed == 0 else f\"{failed} test(s) failed\"\n\n        return {\n            \"attachments\": [{\n                \"color\": color,\n                \"title\": \"VenomQA Test Results\",\n                \"text\": status,\n                \"fields\": [\n                    {\"title\": \"Passed\", \"value\": str(passed), \"short\": True},\n                    {\"title\": \"Failed\", \"value\": str(failed), \"short\": True},\n                ],\n            }]\n        }\n\n    def send_to_slack(self, results: list[JourneyResult]) -&gt; None:\n        import httpx\n\n        payload = self.generate(results)\n        httpx.post(self.webhook_url, json=payload)\n\n\nclass HTMLDashboardReporter(BaseReporter):\n    \"\"\"Generate interactive HTML dashboard.\"\"\"\n\n    @property\n    def file_extension(self) -&gt; str:\n        return \".html\"\n\n    def generate(self, results: list[JourneyResult]) -&gt; str:\n        return f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;VenomQA Dashboard&lt;/title&gt;\n    &lt;style&gt;\n        body {{ font-family: system-ui, sans-serif; margin: 40px; }}\n        .card {{ border: 1px solid #e5e5e5; border-radius: 8px; padding: 16px; margin: 16px 0; }}\n        .passed {{ border-left: 4px solid #22c55e; }}\n        .failed {{ border-left: 4px solid #ef4444; }}\n        .metrics {{ display: flex; gap: 24px; }}\n        .metric {{ text-align: center; }}\n        .metric-value {{ font-size: 2em; font-weight: bold; }}\n        .metric-label {{ color: #666; }}\n        table {{ width: 100%; border-collapse: collapse; }}\n        th, td {{ padding: 8px; text-align: left; border-bottom: 1px solid #e5e5e5; }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;VenomQA Dashboard&lt;/h1&gt;\n\n    &lt;div class=\"card\"&gt;\n        &lt;div class=\"metrics\"&gt;\n            {self._generate_metrics(results)}\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"card\"&gt;\n        &lt;h2&gt;Journey Results&lt;/h2&gt;\n        &lt;table&gt;\n            &lt;tr&gt;\n                &lt;th&gt;Journey&lt;/th&gt;\n                &lt;th&gt;Status&lt;/th&gt;\n                &lt;th&gt;Duration&lt;/th&gt;\n                &lt;th&gt;Steps&lt;/th&gt;\n                &lt;th&gt;Issues&lt;/th&gt;\n            &lt;/tr&gt;\n            {self._generate_rows(results)}\n        &lt;/table&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n\n    def _generate_metrics(self, results: list[JourneyResult]) -&gt; str:\n        passed = sum(1 for r in results if r.success)\n        failed = len(results) - passed\n        total_duration = sum(r.duration_ms for r in results)\n\n        return f\"\"\"\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\" style=\"color: #22c55e;\"&gt;{passed}&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Passed&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\" style=\"color: #ef4444;\"&gt;{failed}&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Failed&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"metric\"&gt;\n                &lt;div class=\"metric-value\"&gt;{total_duration/1000:.1f}s&lt;/div&gt;\n                &lt;div class=\"metric-label\"&gt;Duration&lt;/div&gt;\n            &lt;/div&gt;\n        \"\"\"\n\n    def _generate_rows(self, results: list[JourneyResult]) -&gt; str:\n        rows = []\n        for r in results:\n            status_class = \"passed\" if r.success else \"failed\"\n            status_icon = \"\u2713\" if r.success else \"\u2717\"\n            rows.append(f\"\"\"\n                &lt;tr class=\"{status_class}\"&gt;\n                    &lt;td&gt;{r.journey_name}&lt;/td&gt;\n                    &lt;td&gt;{status_icon}&lt;/td&gt;\n                    &lt;td&gt;{r.duration_ms:.0f}ms&lt;/td&gt;\n                    &lt;td&gt;{r.passed_steps}/{r.total_steps}&lt;/td&gt;\n                    &lt;td&gt;{len(r.issues)}&lt;/td&gt;\n                &lt;/tr&gt;\n            \"\"\")\n        return \"\\n\".join(rows)\n</code></pre>"},{"location":"advanced/#using-custom-reporters","title":"Using Custom Reporters","text":"Python<pre><code>from venomqa.reporters import MarkdownReporter\n\n# Use built-in reporter\nreporter = MarkdownReporter(output_path=\"reports/test.md\")\nreporter.save([result1, result2])\n\n# Use custom reporter\ncsv_reporter = CSVReporter(output_path=\"reports/results.csv\")\ncsv_reporter.save([result1, result2])\n\nslack_reporter = SlackReporter(webhook_url=\"https://hooks.slack.com/...\")\nslack_reporter.send_to_slack([result1, result2])\n</code></pre>"},{"location":"advanced/#custom-state-backends","title":"Custom State Backends","text":"<p>See Database Backends for implementing custom state backends.</p>"},{"location":"advanced/#hooks-and-extensions","title":"Hooks and Extensions","text":""},{"location":"advanced/#prepost-step-hooks","title":"Pre/Post Step Hooks","text":"Python<pre><code>from venomqa import JourneyRunner, Step\nfrom venomqa.core.models import StepResult\nfrom typing import Callable\n\nclass HookedJourneyRunner(JourneyRunner):\n    \"\"\"Runner with pre/post step hooks.\"\"\"\n\n    def __init__(self, *args, \n                 pre_step_hook: Callable | None = None,\n                 post_step_hook: Callable | None = None,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        self.pre_step_hook = pre_step_hook\n        self.post_step_hook = post_step_hook\n\n    def _run_step(self, step: Step, journey_name: str, path_name: str, context) -&gt; StepResult:\n        # Pre-step hook\n        if self.pre_step_hook:\n            self.pre_step_hook(step=step, journey=journey_name, path=path_name, context=context)\n\n        # Run the step\n        result = super()._run_step(step, journey_name, path_name, context)\n\n        # Post-step hook\n        if self.post_step_hook:\n            self.post_step_hook(step=step, result=result, context=context)\n\n        return result\n\n\n# Usage\ndef log_step(step, journey, path, context):\n    print(f\"Running: {journey}/{path}/{step.name}\")\n\ndef capture_screenshot_on_failure(step, result, context):\n    if not result.success:\n        # Take screenshot, save logs, etc.\n        print(f\"Step {step.name} failed, capturing diagnostics...\")\n\nrunner = HookedJourneyRunner(\n    client=client,\n    pre_step_hook=log_step,\n    post_step_hook=capture_screenshot_on_failure,\n)\n</code></pre>"},{"location":"advanced/#journey-lifecycle-hooks","title":"Journey Lifecycle Hooks","text":"Python<pre><code>class LifecycleRunner(JourneyRunner):\n    \"\"\"Runner with full lifecycle hooks.\"\"\"\n\n    def __init__(self, *args,\n                 on_journey_start: Callable | None = None,\n                 on_journey_end: Callable | None = None,\n                 on_branch_start: Callable | None = None,\n                 on_branch_end: Callable | None = None,\n                 on_path_start: Callable | None = None,\n                 on_path_end: Callable | None = None,\n                 **kwargs):\n        super().__init__(*args, **kwargs)\n        self.on_journey_start = on_journey_start\n        self.on_journey_end = on_journey_end\n        self.on_branch_start = on_branch_start\n        self.on_branch_end = on_branch_end\n        self.on_path_start = on_path_start\n        self.on_path_end = on_path_end\n\n    def run(self, journey):\n        if self.on_journey_start:\n            self.on_journey_start(journey=journey)\n\n        result = super().run(journey)\n\n        if self.on_journey_end:\n            self.on_journey_end(journey=journey, result=result)\n\n        return result\n</code></pre>"},{"location":"advanced/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/#reduce-request-overhead","title":"Reduce Request Overhead","text":"Python<pre><code># Reuse client across journeys\nclient = Client(base_url=\"http://localhost:8000\")\nclient.connect()  # Keep connection open\n\nfor journey in journeys:\n    runner = JourneyRunner(client=client)\n    result = runner.run(journey)\n\nclient.disconnect()\n</code></pre>"},{"location":"advanced/#batch-operations","title":"Batch Operations","text":"Python<pre><code>def create_items_batch(client, context):\n    \"\"\"Create multiple items in one request.\"\"\"\n    items = [{\"name\": f\"Item {i}\"} for i in range(10)]\n    return client.post(\"/api/items/batch\", json={\"items\": items})\n</code></pre>"},{"location":"advanced/#skip-unnecessary-steps","title":"Skip Unnecessary Steps","text":"Python<pre><code>def conditional_step(client, context):\n    # Skip if already done\n    if context.get(\"setup_complete\"):\n        return {\"status\": \"skipped\"}\n\n    # Do expensive setup\n    result = client.post(\"/api/setup\", json={...})\n    context[\"setup_complete\"] = True\n    return result\n</code></pre>"},{"location":"advanced/#parallel-data-setup","title":"Parallel Data Setup","text":"Python<pre><code>from concurrent.futures import ThreadPoolExecutor\n\ndef setup_test_data_parallel(client, context):\n    \"\"\"Setup test data in parallel.\"\"\"\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        futures = [\n            executor.submit(client.post, \"/api/users\", json={\"name\": f\"User {i}\"})\n            for i in range(10)\n        ]\n        results = [f.result() for f in futures]\n\n    context[\"user_ids\"] = [r.json()[\"id\"] for r in results]\n    return results\n</code></pre>"},{"location":"advanced/#error-handling-strategies","title":"Error Handling Strategies","text":""},{"location":"advanced/#graceful-degradation","title":"Graceful Degradation","text":"Python<pre><code>def resilient_step(client, context):\n    \"\"\"Step that degrades gracefully on failure.\"\"\"\n    try:\n        response = client.get(\"/api/features\")\n        context[\"features\"] = response.json()\n    except Exception:\n        # Use defaults if features API is down\n        context[\"features\"] = {\"default_feature\": True}\n\n    return response\n</code></pre>"},{"location":"advanced/#retry-with-exponential-backoff","title":"Retry with Exponential Backoff","text":"Python<pre><code>import time\nimport random\n\ndef retry_with_backoff(func, max_retries=3, base_delay=1.0):\n    \"\"\"Execute function with exponential backoff retry.\"\"\"\n    for attempt in range(max_retries):\n        try:\n            return func()\n        except Exception as e:\n            if attempt == max_retries - 1:\n                raise\n\n            delay = base_delay * (2 ** attempt) + random.uniform(0, 1)\n            time.sleep(delay)\n\ndef flaky_api_call(client, context):\n    return retry_with_backoff(\n        lambda: client.get(\"/api/flaky-endpoint\"),\n        max_retries=5,\n        base_delay=0.5,\n    )\n</code></pre>"},{"location":"advanced/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"Python<pre><code>from datetime import datetime, timedelta\nfrom enum import Enum\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"\n    OPEN = \"open\"\n    HALF_OPEN = \"half_open\"\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker for unreliable services.\"\"\"\n\n    def __init__(self, failure_threshold: int = 3, recovery_timeout: float = 30.0):\n        self.failure_threshold = failure_threshold\n        self.recovery_timeout = recovery_timeout\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n        self.last_failure_time: datetime | None = None\n\n    def execute(self, func):\n        if self.state == CircuitState.OPEN:\n            if self._should_try_recovery():\n                self.state = CircuitState.HALF_OPEN\n            else:\n                raise Exception(\"Circuit breaker is open\")\n\n        try:\n            result = func()\n            self._on_success()\n            return result\n        except Exception as e:\n            self._on_failure()\n            raise e\n\n    def _should_try_recovery(self) -&gt; bool:\n        if self.last_failure_time is None:\n            return True\n        return datetime.now() - self.last_failure_time &gt; timedelta(seconds=self.recovery_timeout)\n\n    def _on_success(self):\n        self.failures = 0\n        self.state = CircuitState.CLOSED\n\n    def _on_failure(self):\n        self.failures += 1\n        self.last_failure_time = datetime.now()\n        if self.failures &gt;= self.failure_threshold:\n            self.state = CircuitState.OPEN\n\n# Usage\ncircuit = CircuitBreaker(failure_threshold=3, recovery_timeout=30)\n\ndef protected_api_call(client, context):\n    return circuit.execute(lambda: client.get(\"/api/unreliable\"))\n</code></pre>"},{"location":"advanced/#known-limitations","title":"Known Limitations","text":""},{"location":"advanced/#parallel-path-execution-with-state-management","title":"Parallel Path Execution with State Management","text":"<p>When using <code>parallel_paths &gt; 1</code> (parallel branch execution), database state isolation is not guaranteed. Each path should start from the checkpoint state, but with parallel execution:</p> <ul> <li>All threads share the same database connection</li> <li>Rollback doesn't happen between parallel paths</li> <li>Paths may interfere with each other's database state</li> </ul> <p>Recommendation: Use <code>parallel_paths=1</code> (sequential execution) when: - Your journeys use database checkpoints and rollback - Your paths modify database state - State isolation between paths is important</p> <p>Parallel execution is safe when: - You're only testing read operations - Paths are independent and don't rely on specific database state - You're using the MockStateManager (in-memory)</p>"},{"location":"advanced/#testing-patterns","title":"Testing Patterns","text":""},{"location":"advanced/#data-driven-testing","title":"Data-Driven Testing","text":"Python<pre><code>from venomqa import Journey, Step\n\n# Test with multiple data sets\ntest_cases = [\n    {\"name\": \"valid_user\", \"email\": \"test@example.com\", \"expect_success\": True},\n    {\"name\": \"invalid_email\", \"email\": \"invalid\", \"expect_success\": False},\n    {\"name\": \"missing_email\", \"email\": None, \"expect_success\": False},\n]\n\njourneys = []\nfor case in test_cases:\n    def register_test(client, context, case=case):\n        return client.post(\"/api/register\", json={\"email\": case[\"email\"]})\n\n    journey = Journey(\n        name=f\"register_{case['name']}\",\n        steps=[\n            Step(\n                name=\"register\",\n                action=register_test,\n                expect_failure=not case[\"expect_success\"],\n            ),\n        ],\n    )\n    journeys.append(journey)\n</code></pre>"},{"location":"advanced/#smoke-tests","title":"Smoke Tests","text":"Python<pre><code>smoke_journey = Journey(\n    name=\"smoke_test\",\n    description=\"Quick health check of critical endpoints\",\n    timeout=30.0,\n    steps=[\n        Step(name=\"health\", action=lambda c, ctx: c.get(\"/health\")),\n        Step(name=\"api_status\", action=lambda c, ctx: c.get(\"/api/status\")),\n        Step(name=\"db_ping\", action=lambda c, ctx: c.get(\"/api/ping/db\")),\n    ],\n)\n</code></pre>"},{"location":"advanced/#regression-tests","title":"Regression Tests","text":"Python<pre><code># Capture expected responses for regression testing\nexpected_responses = {\n    \"get_user\": {\"id\": 1, \"name\": \"Test User\"},\n}\n\ndef regression_test_step(client, context):\n    response = client.get(\"/api/users/1\")\n    actual = response.json()\n    expected = expected_responses[\"get_user\"]\n\n    if actual != expected:\n        context[\"regression_diff\"] = {\n            \"expected\": expected,\n            \"actual\": actual,\n        }\n        raise AssertionError(\"Response differs from expected\")\n\n    return response\n</code></pre>"},{"location":"advanced/#chaos-testing","title":"Chaos Testing","text":"Python<pre><code>import random\n\ndef chaos_step(client, context):\n    \"\"\"Introduce random failures for resilience testing.\"\"\"\n    # Randomly fail 10% of the time\n    if random.random() &lt; 0.1:\n        raise Exception(\"Chaos monkey strike!\")\n\n    return client.get(\"/api/data\")\n\ndef slow_network_step(client, context):\n    \"\"\"Simulate slow network conditions.\"\"\"\n    import time\n    time.sleep(random.uniform(0.5, 2.0))  # Random delay\n    return client.get(\"/api/data\")\n</code></pre>"},{"location":"advanced/#ports-adapters","title":"Ports &amp; Adapters","text":"<p>The Ports and Adapters architecture enables clean separation between test logic and external dependencies.</p>"},{"location":"advanced/#dependency-injection-pattern","title":"Dependency Injection Pattern","text":"<p>Inject adapters through constructor or fixtures:</p> Python<pre><code>import pytest\nfrom venomqa.ports import CachePort, MailPort\nfrom venomqa.adapters import RedisCacheAdapter, MailhogAdapter\n\nclass TestUserRegistration:\n    def __init__(self, cache: CachePort, mail: MailPort):\n        self.cache = cache\n        self.mail = mail\n\n    def test_registration_sends_email(self):\n        # Register user\n        self.register_user(\"test@example.com\")\n\n        # Verify email was sent\n        email = self.mail.wait_for_email(\n            to=\"test@example.com\",\n            subject=\"Welcome\",\n            timeout=30.0,\n        )\n        assert email is not None\n\n        # Verify cache was updated\n        assert self.cache.exists(\"user:test@example.com\")\n\n# Using with pytest fixtures\n@pytest.fixture\ndef cache():\n    return RedisCacheAdapter(host=\"localhost\")\n\n@pytest.fixture\ndef mail():\n    return MailhogAdapter(host=\"localhost\")\n\ndef test_with_adapters(cache, mail):\n    tester = TestUserRegistration(cache, mail)\n    tester.test_registration_sends_email()\n</code></pre>"},{"location":"advanced/#swapping-adapters-for-testing","title":"Swapping Adapters for Testing","text":"<p>Use different adapters for different test environments:</p> Python<pre><code>from venomqa.ports import CachePort\nfrom venomqa.adapters import RedisCacheAdapter, LocalStorageAdapter\n\ndef get_cache_adapter(env: str) -&gt; CachePort:\n    if env == \"production\":\n        return RedisCacheAdapter(\n            host=\"redis.production.internal\",\n            password=os.environ[\"REDIS_PASSWORD\"],\n        )\n    elif env == \"staging\":\n        return RedisCacheAdapter(host=\"localhost\")\n    else:\n        # In-memory adapter for unit tests\n        return LocalStorageAdapter(base_path=\"/tmp/test-cache\")\n</code></pre>"},{"location":"advanced/#time-travel-testing","title":"Time Travel Testing","text":"<p>Test time-dependent logic without waiting:</p> Python<pre><code>from datetime import timedelta\nfrom venomqa.adapters import ControllableTimeAdapter\n\ndef test_token_expiration():\n    time = ControllableTimeAdapter()\n    time.freeze()\n\n    # Create token that expires in 1 hour\n    token = create_token(expires_in=3600)\n    assert token.is_valid()\n\n    # Fast forward 59 minutes\n    time.advance(timedelta(minutes=59))\n    assert token.is_valid()\n\n    # Fast forward 1 more minute - token should expire\n    time.advance(timedelta(minutes=1))\n    assert not token.is_valid()\n\ndef test_scheduled_task():\n    time = ControllableTimeAdapter()\n    results = []\n\n    def callback():\n        results.append(\"executed\")\n\n    # Schedule task for 5 seconds\n    time.schedule_after(5.0, callback)\n\n    # Time hasn't advanced yet\n    assert len(results) == 0\n\n    # Advance past scheduled time\n    time.advance(timedelta(seconds=5))\n    assert len(results) == 1\n</code></pre>"},{"location":"advanced/#mock-server-integration","title":"Mock Server Integration","text":"<p>Use WireMock for API stubbing in tests:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import WireMockAdapter\nfrom venomqa import Client\n\n@pytest.fixture\ndef mock_server():\n    mock = WireMockAdapter(port=8080)\n    yield mock\n    mock.reset()\n\ndef test_api_with_mock(mock_server):\n    # Stub API response\n    mock_server.stub(\n        \"GET\",\n        \"/api/users/1\",\n        body={\"id\": 1, \"name\": \"John Doe\"},\n        status_code=200,\n    )\n\n    # Stub error response\n    mock_server.stub(\n        \"GET\",\n        \"/api/users/999\",\n        body={\"error\": \"Not found\"},\n        status_code=404,\n    )\n\n    # Use mocked API\n    client = Client(base_url=mock_server.get_base_url())\n\n    response = client.get(\"/api/users/1\")\n    assert response.status_code == 200\n    assert response.json()[\"name\"] == \"John Doe\"\n\n    # Verify request was made\n    assert mock_server.verify(\"GET\", \"/api/users/1\", count=1)\n\ndef test_sequential_responses(mock_server):\n    # Return different responses on each call\n    mock_server.stub_sequence(\"POST\", \"/api/orders\", responses=[\n        MockResponse(status_code=201, body={\"id\": 1}),\n        MockResponse(status_code=201, body={\"id\": 2}),\n        MockResponse(status_code=429, body={\"error\": \"Rate limited\"}),\n    ])\n\n    client = Client(base_url=mock_server.get_base_url())\n\n    # First call\n    r1 = client.post(\"/api/orders\")\n    assert r1.status_code == 201\n\n    # Second call\n    r2 = client.post(\"/api/orders\")\n    assert r2.status_code == 201\n\n    # Third call - rate limited\n    r3 = client.post(\"/api/orders\")\n    assert r3.status_code == 429\n</code></pre>"},{"location":"advanced/#parallel-task-execution","title":"Parallel Task Execution","text":"<p>Test concurrent operations:</p> Python<pre><code>from venomqa.adapters import ThreadingConcurrencyAdapter\n\ndef test_concurrent_requests():\n    concurrency = ThreadingConcurrencyAdapter(max_workers=10)\n\n    def make_request(user_id):\n        # Simulate API call\n        return client.get(f\"/api/users/{user_id}\")\n\n    # Spawn 100 concurrent tasks\n    task_ids = concurrency.map_async(make_request, range(100))\n\n    # Wait for all to complete\n    results = concurrency.join_all(task_ids, timeout=30.0)\n\n    # Verify all succeeded\n    successful = [r for r in results if r.success]\n    assert len(successful) == 100\n</code></pre>"},{"location":"advanced/#email-testing-workflow","title":"Email Testing Workflow","text":"<p>Complete email testing with cleanup:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import MailhogAdapter\n\n@pytest.fixture\ndef mail():\n    adapter = MailhogAdapter(host=\"localhost\")\n    adapter.delete_all_emails()  # Clean slate\n    yield adapter\n    adapter.delete_all_emails()  # Cleanup\n\ndef test_password_reset_email(mail):\n    # Request password reset\n    response = client.post(\"/api/auth/forgot-password\", json={\n        \"email\": \"user@example.com\",\n    })\n    assert response.status_code == 200\n\n    # Wait for and verify email\n    email = mail.wait_for_email(\n        to=\"user@example.com\",\n        subject=\"Password Reset\",\n        timeout=30.0,\n    )\n\n    assert email is not None\n    assert \"reset\" in email.body.lower()\n\n    # Extract reset link from email\n    import re\n    match = re.search(r'https://\\S+/reset/\\S+', email.body)\n    assert match\n    reset_link = match.group(0)\n\n    # Use reset link\n    response = client.post(reset_link, json={\"password\": \"newpass123\"})\n    assert response.status_code == 200\n</code></pre>"},{"location":"advanced/#cache-testing-patterns","title":"Cache Testing Patterns","text":"<p>Test cache behavior:</p> Python<pre><code>from venomqa.adapters import RedisCacheAdapter\n\ndef test_cache_expiration():\n    cache = RedisCacheAdapter()\n\n    # Set with TTL\n    cache.set(\"session:abc123\", {\"user_id\": 1}, ttl=60)\n\n    # Verify exists\n    assert cache.exists(\"session:abc123\")\n\n    # Check TTL\n    ttl = cache.get_ttl(\"session:abc123\")\n    assert 0 &lt; ttl &lt;= 60\n\n    # Get stats\n    stats = cache.get_stats()\n    print(f\"Hit rate: {stats.hit_rate}%\")\n\ndef test_cache_invalidation():\n    cache = RedisCacheAdapter()\n\n    # Cache user data\n    cache.set(\"user:1\", {\"name\": \"John\", \"role\": \"user\"})\n\n    # Update user\n    update_user(1, role=\"admin\")\n\n    # Invalidate cache\n    cache.delete(\"user:1\")\n\n    # Next read will fetch fresh data\n    user = cache.get(\"user:1\")\n    assert user is None\n</code></pre>"},{"location":"advanced/#queue-testing-patterns","title":"Queue Testing Patterns","text":"<p>Test async job processing:</p> Python<pre><code>from venomqa.adapters import RedisQueueAdapter\n\ndef test_job_queue():\n    queue = RedisQueueAdapter(host=\"localhost\")\n\n    # Clear queue\n    queue.clear_queue(\"test\")\n\n    # Enqueue job\n    job_id = queue.enqueue(\n        \"myapp.tasks.send_notification\",\n        user_id=123,\n        message=\"Hello!\",\n        queue=\"test\",\n    )\n\n    # Check job status\n    job = queue.get_job(job_id)\n    assert job.status == \"pending\"\n\n    # Wait for completion (requires worker running)\n    result = queue.get_job_result(job_id, timeout=60.0)\n\n    if result:\n        assert result.success\n        print(f\"Job result: {result.result}\")\n\n    # Check for failed jobs\n    failed = queue.get_failed_jobs(queue=\"test\")\n    assert len(failed) == 0\n</code></pre>"},{"location":"advanced/#creating-test-fixtures-with-ports","title":"Creating Test Fixtures with Ports","text":"<p>Create reusable test fixtures:</p> Python<pre><code>import pytest\nfrom typing import TypeVar, Protocol\nfrom venomqa.ports import CachePort, MailPort, QueuePort\n\nT = TypeVar('T')\n\nclass TestFixtures:\n    \"\"\"Collection of test fixtures using ports.\"\"\"\n\n    def __init__(\n        self,\n        cache: CachePort,\n        mail: MailPort,\n        queue: QueuePort,\n    ):\n        self.cache = cache\n        self.mail = mail\n        self.queue = queue\n\n    def reset(self):\n        \"\"\"Reset all fixtures to clean state.\"\"\"\n        self.cache.clear()\n        self.mail.delete_all_emails()\n        self.queue.clear_queue()\n\n    def cached_user(self, user_id: int) -&gt; dict:\n        \"\"\"Get or create cached user.\"\"\"\n        key = f\"test:user:{user_id}\"\n        user = self.cache.get(key)\n        if user is None:\n            user = {\"id\": user_id, \"name\": f\"User {user_id}\"}\n            self.cache.set(key, user, ttl=300)\n        return user\n\n@pytest.fixture\ndef fixtures():\n    from venomqa.adapters import (\n        RedisCacheAdapter,\n        MailhogAdapter,\n        RedisQueueAdapter,\n    )\n\n    fx = TestFixtures(\n        cache=RedisCacheAdapter(),\n        mail=MailhogAdapter(),\n        queue=RedisQueueAdapter(),\n    )\n    fx.reset()\n    yield fx\n    fx.reset()\n</code></pre>"},{"location":"advanced/#health-check-pattern","title":"Health Check Pattern","text":"<p>Verify external services before tests:</p> Python<pre><code>import pytest\nfrom venomqa.adapters import (\n    RedisCacheAdapter,\n    MailhogAdapter,\n    ElasticsearchAdapter,\n)\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef verify_services():\n    \"\"\"Verify all required services are healthy.\"\"\"\n    services = [\n        (\"Redis\", RedisCacheAdapter()),\n        (\"MailHog\", MailhogAdapter()),\n        (\"Elasticsearch\", ElasticsearchAdapter()),\n    ]\n\n    unhealthy = []\n    for name, adapter in services:\n        if not adapter.health_check():\n            unhealthy.append(name)\n\n    if unhealthy:\n        pytest.skip(f\"Services not available: {', '.join(unhealthy)}\")\n</code></pre>"},{"location":"advanced/#multi-environment-configuration","title":"Multi-Environment Configuration","text":"<p>Configure adapters for different environments:</p> Python<pre><code>from dataclasses import dataclass\nfrom venomqa.ports import CachePort, MailPort\nfrom venomqa.adapters import RedisCacheAdapter, MailhogAdapter, MailpitAdapter\n\n@dataclass\nclass Environment:\n    name: str\n    cache: CachePort\n    mail: MailPort\n\ndef get_environment() -&gt; Environment:\n    env_name = os.environ.get(\"ENV\", \"local\")\n\n    if env_name == \"production\":\n        return Environment(\n            name=\"production\",\n            cache=RedisCacheAdapter(\n                host=\"redis.prod.internal\",\n                password=os.environ[\"REDIS_PASSWORD\"],\n            ),\n            mail=MailpitAdapter(\n                host=\"mail.prod.internal\",\n                use_tls=True,\n            ),\n        )\n    elif env_name == \"staging\":\n        return Environment(\n            name=\"staging\",\n            cache=RedisCacheAdapter(host=\"localhost\"),\n            mail=MailhogAdapter(host=\"localhost\"),\n        )\n    else:\n        return Environment(\n            name=\"local\",\n            cache=RedisCacheAdapter(host=\"localhost\"),\n            mail=MailhogAdapter(host=\"localhost\"),\n        )\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to VenomQA will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>MkDocs documentation site with Material theme</li> <li>Comprehensive API documentation</li> <li>Tutorial guides for common scenarios</li> <li>Advanced usage documentation</li> </ul>"},{"location":"changelog/#020-2024-01-15","title":"[0.2.0] - 2024-01-15","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Ports and Adapters architecture</li> <li>Multiple cache adapters (Redis, Memory)</li> <li>Email testing adapters (Mailhog, Mailpit)</li> <li>Queue adapters (Redis Queue, Celery)</li> <li>Time control adapter for testing</li> <li>Mock server adapter (WireMock)</li> <li>SARIF report format</li> <li>Slack and Discord reporters</li> <li>Performance optimizations (connection pooling, caching)</li> <li>Security features (input validation, secrets management)</li> <li>File handling utilities</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improved error messages with fix suggestions</li> <li>Enhanced CLI output formatting</li> <li>Better parallel execution support</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Checkpoint rollback in nested branches</li> <li>Context restoration edge cases</li> <li>Connection handling in long-running journeys</li> </ul>"},{"location":"changelog/#010-2024-01-01","title":"[0.1.0] - 2024-01-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Initial release</li> <li>Core journey DSL (Journey, Step, Checkpoint, Branch, Path)</li> <li>PostgreSQL state management</li> <li>HTTP client with retry logic</li> <li>Basic reporters (Markdown, JSON, JUnit)</li> <li>Docker Compose integration</li> <li>CLI tool (venomqa run, venomqa list, venomqa report)</li> </ul>"},{"location":"changelog/#version-history","title":"Version History","text":"Version Date Highlights 0.2.0 2024-01-15 Ports &amp; Adapters, Performance 0.1.0 2024-01-01 Initial release"},{"location":"changelog/#upgrade-guide","title":"Upgrade Guide","text":""},{"location":"changelog/#01x-to-02x","title":"0.1.x to 0.2.x","text":"<p>No breaking changes. New features are additive.</p> <p>To use new adapters:</p> Bash<pre><code>pip install \"venomqa[redis,s3]\"  # Install adapter dependencies\n</code></pre>"},{"location":"changelog/#roadmap","title":"Roadmap","text":""},{"location":"changelog/#v030-enhanced-reporting","title":"v0.3.0 - Enhanced Reporting","text":"<ul> <li>Interactive HTML reports with charts</li> <li>Slack/Teams webhook notifications</li> <li>Test trend analysis</li> <li>Flaky test detection</li> </ul>"},{"location":"changelog/#v040-parallel-execution","title":"v0.4.0 - Parallel Execution","text":"<ul> <li>Distributed journey execution</li> <li>Shared state cache for checkpoints</li> <li>Resource-aware scheduling</li> </ul>"},{"location":"changelog/#v050-ai-powered-features","title":"v0.5.0 - AI-Powered Features","text":"<ul> <li>Journey generation from OpenAPI specs</li> <li>Intelligent failure analysis</li> <li>Anomaly detection</li> </ul> <p>See GitHub Projects for detailed tracking.</p>"},{"location":"ci-cd/","title":"VenomQA CI/CD Integration Guide","text":"<p>This guide covers how to integrate VenomQA into your CI/CD pipelines for automated journey testing.</p>"},{"location":"ci-cd/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Exit Codes</li> <li>GitHub Actions</li> <li>GitLab CI</li> <li>Docker-based Runner</li> <li>Other CI Systems</li> <li>Best Practices</li> <li>Handling Secrets</li> <li>Parallelization Strategies</li> <li>Troubleshooting</li> </ul>"},{"location":"ci-cd/#overview","title":"Overview","text":"<p>VenomQA is designed for CI/CD environments with proper exit codes, report generation, and configurable timeouts. The CLI returns meaningful exit codes that CI systems can use to determine build success or failure.</p>"},{"location":"ci-cd/#key-features-for-cicd","title":"Key Features for CI/CD","text":"<ul> <li>Proper Exit Codes: Clear indication of success, failure, or configuration errors</li> <li>Multiple Report Formats: JUnit XML, HTML, JSON, and Markdown</li> <li>Docker Support: Pre-built runner image for consistent environments</li> <li>Parallel Execution: Run journey groups in parallel for faster feedback</li> <li>Service Orchestration: Integration with Docker Compose for test dependencies</li> </ul>"},{"location":"ci-cd/#exit-codes","title":"Exit Codes","text":"<p>VenomQA uses standard exit codes for CI/CD integration:</p> Exit Code Meaning CI Action <code>0</code> All journeys passed Build succeeds <code>1</code> Some journeys failed Build fails <code>2</code> Configuration error Build fails (setup issue) <p>Example usage in shell scripts:</p> Bash<pre><code>venomqa run --config qa/venomqa.yaml\nEXIT_CODE=$?\n\ncase $EXIT_CODE in\n    0)\n        echo \"All journeys passed!\"\n        ;;\n    1)\n        echo \"Some journeys failed - check reports\"\n        exit 1\n        ;;\n    2)\n        echo \"Configuration error - check venomqa.yaml\"\n        exit 2\n        ;;\nesac\n</code></pre>"},{"location":"ci-cd/#github-actions","title":"GitHub Actions","text":""},{"location":"ci-cd/#basic-setup","title":"Basic Setup","text":"<p>Create <code>.github/workflows/venomqa.yml</code>:</p> YAML<pre><code>name: VenomQA Tests\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    services:\n      postgres:\n        image: postgres:15-alpine\n        env:\n          POSTGRES_USER: qa\n          POSTGRES_PASSWORD: ${{ secrets.QA_DB_PASSWORD }}\n          POSTGRES_DB: venomqa_qa\n        ports:\n          - 5432:5432\n        options: &gt;-\n          --health-cmd \"pg_isready -U qa\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.12'\n          cache: 'pip'\n\n      - name: Install VenomQA\n        run: pip install venomqa[all]\n\n      - name: Start application\n        run: docker compose up -d --wait\n\n      - name: Run journeys\n        run: |\n          venomqa run --config qa/venomqa.yaml\n\n      - name: Generate reports\n        if: always()\n        run: |\n          mkdir -p reports\n          venomqa report --format junit --output reports/junit.xml\n          venomqa report --format html --output reports/report.html\n\n      - name: Upload reports\n        uses: actions/upload-artifact@v4\n        if: always()\n        with:\n          name: venomqa-reports\n          path: reports/\n</code></pre>"},{"location":"ci-cd/#parallel-journey-groups","title":"Parallel Journey Groups","text":"<p>For larger test suites, run journey groups in parallel:</p> YAML<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        group: [auth, checkout, api, content]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Run ${{ matrix.group }} journeys\n        run: |\n          venomqa run ${{ matrix.group }}_* --config qa/venomqa.yaml\n</code></pre>"},{"location":"ci-cd/#full-example","title":"Full Example","text":"<p>See <code>.github/workflows/venomqa.yml.example</code> for a complete workflow with: - Configuration validation - Parallel test execution - Artifact collection - JUnit report publishing - Conditional deployment</p>"},{"location":"ci-cd/#gitlab-ci","title":"GitLab CI","text":""},{"location":"ci-cd/#basic-setup_1","title":"Basic Setup","text":"<p>Create <code>.gitlab-ci.yml</code>:</p> YAML<pre><code>stages:\n  - test\n  - deploy\n\nvariables:\n  POSTGRES_USER: qa\n  POSTGRES_PASSWORD: $QA_DB_PASSWORD\n  POSTGRES_DB: venomqa_qa\n\ntest:\n  stage: test\n  image: python:3.12\n  services:\n    - postgres:15-alpine\n    - redis:7-alpine\n  script:\n    - pip install venomqa[all]\n    - venomqa run --config qa/venomqa.yaml\n    - venomqa report --format junit --output reports/junit.xml\n  artifacts:\n    when: always\n    paths:\n      - reports/\n    reports:\n      junit: reports/junit.xml\n</code></pre>"},{"location":"ci-cd/#parallel-groups-with-gitlab","title":"Parallel Groups with GitLab","text":"YAML<pre><code>.test-template:\n  stage: test\n  image: python:3.12\n  services:\n    - postgres:15-alpine\n  before_script:\n    - pip install venomqa[all]\n  artifacts:\n    when: always\n    reports:\n      junit: reports/junit-*.xml\n\ntest-auth:\n  extends: .test-template\n  script:\n    - venomqa run auth_* --config qa/venomqa.yaml\n    - venomqa report --format junit --output reports/junit-auth.xml\n\ntest-checkout:\n  extends: .test-template\n  script:\n    - venomqa run checkout_* --config qa/venomqa.yaml\n    - venomqa report --format junit --output reports/junit-checkout.xml\n</code></pre>"},{"location":"ci-cd/#full-example_1","title":"Full Example","text":"<p>See <code>.gitlab-ci.yml.example</code> for a complete pipeline with: - Multi-stage workflow - Parallel job execution - GitLab Pages for reports - Environment-based deployment</p>"},{"location":"ci-cd/#docker-based-runner","title":"Docker-based Runner","text":"<p>VenomQA provides a Docker image that can run in any CI system.</p>"},{"location":"ci-cd/#building-the-runner-image","title":"Building the Runner Image","text":"Bash<pre><code># Build the runner image\ndocker build -f docker/Dockerfile.runner -t venomqa-runner:latest .\n\n# Or use multi-stage for smaller image\ndocker build -f docker/Dockerfile.runner --target production -t venomqa-runner:prod .\n</code></pre>"},{"location":"ci-cd/#using-the-runner","title":"Using the Runner","text":"Bash<pre><code># Run journeys with mounted volumes\ndocker run --rm \\\n  -e API_BASE_URL=http://host.docker.internal:8000 \\\n  -v $(pwd)/qa:/app/qa:ro \\\n  -v $(pwd)/reports:/app/reports \\\n  venomqa-runner:latest \\\n  run --config qa/venomqa.yaml\n</code></pre>"},{"location":"ci-cd/#docker-compose-integration","title":"Docker Compose Integration","text":"YAML<pre><code>version: \"3.8\"\n\nservices:\n  api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      - postgres\n\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_USER: qa\n      POSTGRES_PASSWORD: qapass\n      POSTGRES_DB: qa\n\n  venomqa:\n    image: venomqa-runner:latest\n    environment:\n      - API_BASE_URL=http://api:8000\n      - WAIT_FOR_POSTGRES=postgres:5432\n      - WAIT_FOR_HTTP=http://api:8000/health\n    volumes:\n      - ./qa:/app/qa:ro\n      - ./reports:/app/reports\n    depends_on:\n      - api\n    command: [\"run\", \"--config\", \"qa/venomqa.yaml\"]\n</code></pre>"},{"location":"ci-cd/#helper-scripts","title":"Helper Scripts","text":"<p>The runner image includes helper scripts:</p> <p>wait-for-services.sh: Wait for dependencies before running tests</p> Bash<pre><code>docker run --rm venomqa-runner:latest \\\n  /usr/local/bin/wait-for-services.sh \\\n    --postgres db:5432 \\\n    --redis cache:6379 \\\n    --http http://api:8000/health \\\n    -- venomqa run\n</code></pre> <p>run-journeys.sh: Comprehensive test runner with reports</p> Bash<pre><code>docker run --rm \\\n  -e WAIT_FOR_POSTGRES=db:5432 \\\n  -e VENOMQA_CONFIG=qa/venomqa.yaml \\\n  -v ./qa:/app/qa:ro \\\n  -v ./reports:/app/reports \\\n  venomqa-runner:latest \\\n  /usr/local/bin/run-journeys.sh\n</code></pre>"},{"location":"ci-cd/#other-ci-systems","title":"Other CI Systems","text":""},{"location":"ci-cd/#jenkins","title":"Jenkins","text":"Groovy<pre><code>pipeline {\n    agent {\n        docker {\n            image 'venomqa-runner:latest'\n        }\n    }\n\n    environment {\n        API_BASE_URL = 'http://localhost:8000'\n    }\n\n    stages {\n        stage('Test') {\n            steps {\n                sh 'venomqa run --config qa/venomqa.yaml'\n            }\n            post {\n                always {\n                    sh 'venomqa report --format junit --output reports/junit.xml'\n                    junit 'reports/junit.xml'\n                    archiveArtifacts artifacts: 'reports/**'\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"ci-cd/#circleci","title":"CircleCI","text":"YAML<pre><code>version: 2.1\n\njobs:\n  test:\n    docker:\n      - image: python:3.12\n      - image: postgres:15-alpine\n        environment:\n          POSTGRES_USER: qa\n          POSTGRES_PASSWORD: qapass\n          POSTGRES_DB: qa\n    steps:\n      - checkout\n      - run:\n          name: Install VenomQA\n          command: pip install venomqa[all]\n      - run:\n          name: Run journeys\n          command: venomqa run --config qa/venomqa.yaml\n      - run:\n          name: Generate reports\n          command: venomqa report --format junit --output reports/junit.xml\n          when: always\n      - store_test_results:\n          path: reports\n      - store_artifacts:\n          path: reports\n\nworkflows:\n  test:\n    jobs:\n      - test\n</code></pre>"},{"location":"ci-cd/#azure-devops","title":"Azure DevOps","text":"YAML<pre><code>trigger:\n  - main\n\npool:\n  vmImage: 'ubuntu-latest'\n\nservices:\n  postgres:\n    image: postgres:15-alpine\n    ports:\n      - 5432:5432\n\nsteps:\n  - task: UsePythonVersion@0\n    inputs:\n      versionSpec: '3.12'\n\n  - script: pip install venomqa[all]\n    displayName: Install VenomQA\n\n  - script: venomqa run --config qa/venomqa.yaml\n    displayName: Run Journeys\n\n  - script: |\n      venomqa report --format junit --output $(Build.ArtifactStagingDirectory)/junit.xml\n    displayName: Generate Reports\n    condition: always()\n\n  - task: PublishTestResults@2\n    inputs:\n      testResultsFormat: 'JUnit'\n      testResultsFiles: '$(Build.ArtifactStagingDirectory)/junit.xml'\n    condition: always()\n</code></pre>"},{"location":"ci-cd/#buildkite","title":"Buildkite","text":"YAML<pre><code>steps:\n  - label: \":snake: VenomQA Tests\"\n    command:\n      - pip install venomqa[all]\n      - venomqa run --config qa/venomqa.yaml\n      - venomqa report --format junit --output reports/junit.xml\n    plugins:\n      - docker-compose#v4.0.0:\n          services:\n            - postgres\n            - redis\n    artifact_paths:\n      - \"reports/**\"\n</code></pre>"},{"location":"ci-cd/#best-practices","title":"Best Practices","text":""},{"location":"ci-cd/#1-fail-fast-in-development-full-run-in-ci","title":"1. Fail Fast in Development, Full Run in CI","text":"YAML<pre><code># Development - stop on first failure for quick feedback\nvenomqa run --fail-fast --config qa/venomqa.yaml\n\n# CI - run all tests for complete picture\nvenomqa run --config qa/venomqa.yaml\n</code></pre>"},{"location":"ci-cd/#2-use-journey-groups-for-parallelization","title":"2. Use Journey Groups for Parallelization","text":"<p>Organize journeys by domain: Text Only<pre><code>qa/journeys/\n  auth_login.py\n  auth_registration.py\n  checkout_basic.py\n  checkout_with_coupon.py\n  api_crud.py\n  api_versioning.py\n</code></pre></p> <p>Then run groups in parallel: YAML<pre><code>matrix:\n  group: [auth, checkout, api]\n</code></pre></p>"},{"location":"ci-cd/#3-generate-multiple-report-formats","title":"3. Generate Multiple Report Formats","text":"Bash<pre><code># JUnit for CI integration\nvenomqa report --format junit --output reports/junit.xml\n\n# HTML for human review\nvenomqa report --format html --output reports/report.html\n\n# JSON for custom processing\nvenomqa report --format json --output reports/results.json\n</code></pre>"},{"location":"ci-cd/#4-set-appropriate-timeouts","title":"4. Set Appropriate Timeouts","text":"YAML<pre><code># venomqa.yaml\ntimeout: 30  # Default request timeout\n\n# For specific slow operations, override in journey\nsteps:\n  - name: process_large_file\n    action: upload.process\n    timeout: 120  # 2 minutes for this step\n</code></pre>"},{"location":"ci-cd/#5-use-health-checks","title":"5. Use Health Checks","text":"<p>Always wait for services before running tests:</p> YAML<pre><code>services:\n  api:\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n</code></pre>"},{"location":"ci-cd/#6-capture-logs-on-failure","title":"6. Capture Logs on Failure","text":"YAML<pre><code>- name: Collect logs on failure\n  if: failure()\n  run: |\n    docker compose logs &gt; reports/docker.log\n    docker ps -a &gt; reports/containers.txt\n</code></pre>"},{"location":"ci-cd/#handling-secrets","title":"Handling Secrets","text":""},{"location":"ci-cd/#environment-variables","title":"Environment Variables","text":"<p>Never commit secrets to code. Use CI/CD secret management:</p> <p>GitHub Actions: YAML<pre><code>env:\n  DATABASE_URL: ${{ secrets.DATABASE_URL }}\n  API_KEY: ${{ secrets.API_KEY }}\n</code></pre></p> <p>GitLab CI: YAML<pre><code>variables:\n  DATABASE_URL: $DB_URL  # CI/CD variable\n</code></pre></p>"},{"location":"ci-cd/#secret-files","title":"Secret Files","text":"<p>For complex secrets (certificates, key files):</p> YAML<pre><code># GitHub Actions\n- name: Setup credentials\n  run: |\n    echo \"${{ secrets.SERVICE_ACCOUNT_KEY }}\" &gt; /tmp/sa-key.json\n    export GOOGLE_APPLICATION_CREDENTIALS=/tmp/sa-key.json\n</code></pre>"},{"location":"ci-cd/#venomqa-configuration","title":"VenomQA Configuration","text":"<p>Reference secrets via environment variables in <code>venomqa.yaml</code>:</p> YAML<pre><code># venomqa.yaml\nbase_url: ${API_BASE_URL:-http://localhost:8000}\n\nports:\n  - name: database\n    adapter_type: postgres\n    config:\n      host: ${POSTGRES_HOST:-localhost}\n      port: ${POSTGRES_PORT:-5432}\n      user: ${POSTGRES_USER}\n      password: ${POSTGRES_PASSWORD}  # From environment\n      database: ${POSTGRES_DB}\n</code></pre>"},{"location":"ci-cd/#secret-masking","title":"Secret Masking","text":"<p>VenomQA automatically masks common secret patterns in logs: - API keys - Passwords - Tokens - Authorization headers</p>"},{"location":"ci-cd/#parallelization-strategies","title":"Parallelization Strategies","text":""},{"location":"ci-cd/#1-journey-group-parallelization","title":"1. Journey Group Parallelization","text":"<p>Split journeys by domain/feature:</p> YAML<pre><code># GitHub Actions\nstrategy:\n  matrix:\n    group: [auth, checkout, api, content, realtime]\n</code></pre>"},{"location":"ci-cd/#2-test-environment-parallelization","title":"2. Test Environment Parallelization","text":"<p>Run against multiple environments:</p> YAML<pre><code>strategy:\n  matrix:\n    environment: [staging, qa, preview]\n    include:\n      - environment: staging\n        base_url: https://staging.example.com\n      - environment: qa\n        base_url: https://qa.example.com\n</code></pre>"},{"location":"ci-cd/#3-database-sharding","title":"3. Database Sharding","text":"<p>For database-heavy tests, use separate databases:</p> YAML<pre><code>strategy:\n  matrix:\n    shard: [1, 2, 3, 4]\n\nservices:\n  postgres:\n    image: postgres:15-alpine\n    env:\n      POSTGRES_DB: qa_shard_${{ matrix.shard }}\n</code></pre>"},{"location":"ci-cd/#4-time-based-parallelization","title":"4. Time-based Parallelization","text":"<p>Run different test suites at different times:</p> YAML<pre><code># Fast tests on every push\non:\n  push:\n    branches: [main, develop]\n\n# Full test suite nightly\non:\n  schedule:\n    - cron: '0 2 * * *'  # 2 AM daily\n</code></pre>"},{"location":"ci-cd/#troubleshooting","title":"Troubleshooting","text":""},{"location":"ci-cd/#common-issues","title":"Common Issues","text":"<p>1. Services not ready</p> Text Only<pre><code>Error: Connection refused to localhost:5432\n</code></pre> <p>Solution: Use health checks and wait scripts: Bash<pre><code>wait-for-services.sh --postgres localhost:5432 -- venomqa run\n</code></pre></p> <p>2. Timeout errors</p> Text Only<pre><code>Error: Request timeout after 30s\n</code></pre> <p>Solution: Increase timeout in config: YAML<pre><code>timeout: 60  # Increase default timeout\n</code></pre></p> <p>3. Permission errors in Docker</p> Text Only<pre><code>Error: Permission denied: /app/reports\n</code></pre> <p>Solution: Match user IDs: Bash<pre><code>docker run --user $(id -u):$(id -g) ...\n</code></pre></p> <p>4. Exit code not propagated</p> <p>Ensure your shell script properly captures exit codes: Bash<pre><code>set +e  # Don't exit on error\nvenomqa run\nEXIT_CODE=$?\nset -e  # Re-enable exit on error\n# ... generate reports ...\nexit $EXIT_CODE  # Propagate original exit code\n</code></pre></p>"},{"location":"ci-cd/#debugging-ci-failures","title":"Debugging CI Failures","text":"<p>1. Enable verbose output: Bash<pre><code>venomqa run --verbose --config qa/venomqa.yaml\n</code></pre></p> <p>2. Add debugging steps: YAML<pre><code>- name: Debug environment\n  if: failure()\n  run: |\n    env | sort\n    docker ps -a\n    docker compose logs\n    cat qa/venomqa.yaml\n</code></pre></p> <p>3. SSH into failed runner (GitHub Actions): YAML<pre><code>- name: Debug with tmate\n  if: failure()\n  uses: mxschmitt/action-tmate@v3\n  with:\n    limit-access-to-actor: true\n</code></pre></p>"},{"location":"ci-cd/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: https://venomqa.dev/docs</li> <li>Issues: https://github.com/namanag97/venomqa/issues</li> <li>Discussions: https://github.com/namanag97/venomqa/discussions</li> </ul> <p>For complete working examples, see: - <code>.github/workflows/venomqa.yml.example</code> - GitHub Actions - <code>.gitlab-ci.yml.example</code> - GitLab CI - <code>docker/Dockerfile.runner</code> - Docker runner image</p>"},{"location":"cli-output/","title":"VenomQA CLI Output Features","text":"<p>VenomQA includes professional, live progress indicators and beautiful visualizations for your test journeys using the Rich library.</p>"},{"location":"cli-output/#features","title":"Features","text":""},{"location":"cli-output/#1-live-progress-bar","title":"1. Live Progress Bar","text":"<p>Real-time progress tracking with: - Spinner animation - Shows activity while tests are running - Progress bar - Visual representation: <code>[=====&gt;    ] 50%</code> - Step counter - Current and total steps: <code>5/10</code> - Elapsed time - How long the journey has been running - Estimated time remaining (ETA) - Predicted completion time</p> <p>Example output: Text Only<pre><code>\u280b \u2192 Step 5/10: process_payment \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 5/10 \u2022 0:00:02 \u2022 0:00:02\n</code></pre></p>"},{"location":"cli-output/#2-current-step-indicator","title":"2. Current Step Indicator","text":"<p>Each step is displayed with: - Spinner - Animated spinner (\u280b \u2819 \u2839 \u2838 \u283c \u2834 \u2826 \u2827 \u2807 \u280f) - Step number - Current position in journey - Step name - Descriptive name of the action - Status updates - Updates in real-time without spamming the terminal</p>"},{"location":"cli-output/#3-timing-information","title":"3. Timing Information","text":"<p>Comprehensive timing data: - Per-step duration - Time taken for each step (shown after completion) - Elapsed time - Total time since journey started - ETA calculation - Smart prediction based on average step time - Summary timing - Complete breakdown in the final summary</p> <p>Example: Text Only<pre><code>Step Timings:\n  login            270ms\n  browse_products  290ms\n  add_to_cart      310ms\n  ...\n</code></pre></p>"},{"location":"cli-output/#4-branch-visualization","title":"4. Branch Visualization","text":"<p>Tree-like visualization for branches and paths:</p> Text Only<pre><code>\u251c\u2500 Branch: before_payment (3 paths)\n  \u2502 \u251c\u2500 Path: credit_card_payment\n  \u2502 \u2514\u2500 \u2713 credit_card_payment (3 steps)\n  \u2502 \u251c\u2500 Path: paypal_payment\n  \u2502 \u2514\u2500 \u2713 paypal_payment (2 steps)\n  \u2502 \u251c\u2500 Path: crypto_payment\n  \u2502 \u2514\u2500 \u2717 crypto_payment (2 steps)\n</code></pre> <p>Features: - Tree characters - Visual hierarchy (\u251c\u2500, \u2514\u2500, \u2502) - Branch indicators - Shows checkpoint name and path count - Path status - Success (\u2713) or failure (\u2717) with step counts - Color coding - Green for success, red for failure</p>"},{"location":"cli-output/#5-checkpoint-rollback-indicators","title":"5. Checkpoint &amp; Rollback Indicators","text":"<p>Visual markers for state management:</p> Text Only<pre><code>\u25c9 Checkpoint: before_payment\n\u21a9 Rollback to: before_payment\n</code></pre> <ul> <li>Checkpoints - Shown in yellow with \u25c9 symbol</li> <li>Rollbacks - Shown in cyan with \u21a9 symbol</li> <li>Integration - Seamlessly displayed during live progress</li> </ul>"},{"location":"cli-output/#6-summary-panel","title":"6. Summary Panel","text":"<p>Beautiful summary boxes at journey completion:</p> Text Only<pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 JOURNEY COMPLETE: checkout_flow \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                \u2502\n\u2502  Status:            \u2713 PASSED                                                   \u2502\n\u2502  Duration:          3.50s                                                      \u2502\n\u2502  Steps:             10/10 passed                                               \u2502\n\u2502  Paths:             3/3 passed                                                 \u2502\n\u2502                                                                                \u2502\n\u2502  Step Timings:                                                                 \u2502\n\u2502    login            270ms                                                      \u2502\n\u2502    browse_products  290ms                                                      \u2502\n\u2502    add_to_cart      310ms                                                      \u2502\n\u2502    ...                                                                         \u2502\n\u2502                                                                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Includes: - Status indicator - Pass/fail with colored symbols - Duration - Total execution time - Step statistics - Passed vs total steps - Path statistics - Passed vs total paths (if applicable) - Timing breakdown - Top 10 slowest steps - Border styling - Green for success, red for failure</p>"},{"location":"cli-output/#7-overall-summary","title":"7. Overall Summary","text":"<p>Multi-journey summary with aggregate statistics:</p> Text Only<pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2713 SUMMARY: ALL JOURNEYS PASSED \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                \u2502\n\u2502  Total:     5                                                                  \u2502\n\u2502  Passed:    5                                                                  \u2502\n\u2502  Failed:    0                                                                  \u2502\n\u2502  Duration:  15.00s                                                             \u2502\n\u2502                                                                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli-output/#8-issue-reporting","title":"8. Issue Reporting","text":"<p>Failed steps are clearly highlighted:</p> Text Only<pre><code>\u2717 Issues:\n  \u2717 apply_discount: Discount code expired\n  \u2717 payment_gateway: Connection timeout\n</code></pre>"},{"location":"cli-output/#configuration","title":"Configuration","text":"<p>Control output features via <code>ProgressConfig</code>:</p> Python<pre><code>from venomqa.cli.output import CLIOutput, ProgressConfig\n\nconfig = ProgressConfig(\n    show_progress=True,      # Enable progress bars\n    show_checkpoints=True,   # Show checkpoint markers\n    show_paths=True,         # Show branch paths\n    show_timing=True,        # Show timing information\n    use_colors=True,         # Enable colored output\n    use_unicode=True,        # Use Unicode symbols (vs ASCII)\n)\n\noutput = CLIOutput(config)\n</code></pre>"},{"location":"cli-output/#terminal-compatibility","title":"Terminal Compatibility","text":""},{"location":"cli-output/#unicode-support","title":"Unicode Support","text":"<p>The CLI automatically detects terminal capabilities:</p> <p>Unicode terminals (default): - Beautiful symbols: \u2713 \u2717 \u2699 \u25c9 \u21a9 \u2192 \u251c\u2500 \u2514\u2500 \u2502 - Smooth spinners: \u280b \u2819 \u2839 \u2838 \u283c \u2834 \u2826 \u2827</p> <p>ASCII-only terminals: - ASCII fallbacks: [OK][FAIL] [*] &lt;- -&gt; |-- `-- | - Text-based indicators</p>"},{"location":"cli-output/#color-support","title":"Color Support","text":"<ul> <li>Color terminals: Rich colors with ANSI codes</li> <li>No-color terminals: Plain text output</li> <li>Auto-detection: Automatically detects TTY capabilities</li> </ul>"},{"location":"cli-output/#usage-examples","title":"Usage Examples","text":""},{"location":"cli-output/#basic-journey","title":"Basic Journey","text":"Python<pre><code>from venomqa import Journey, Step\nfrom venomqa.cli.output import CLIOutput, ProgressConfig\n\noutput = CLIOutput()\n\n# Start journey\noutput.journey_start(\n    name=\"user_registration\",\n    description=\"Complete user registration flow\",\n    total_steps=5\n)\n\n# Run steps (integrated with runner)\n# Output automatically updates during execution\n\n# Show summary\noutput.journey_summary(\n    name=\"user_registration\",\n    success=True,\n    step_count=5,\n    passed_steps=5,\n    duration_ms=1200\n)\n</code></pre>"},{"location":"cli-output/#with-branches","title":"With Branches","text":"Python<pre><code># Branch starts automatically\noutput.branch_start(\"after_signup\", 3)\n\n# Paths run automatically\noutput.path_start(\"email_verification\")\noutput.path_result(\"email_verification\", True, 3)\n\noutput.path_start(\"phone_verification\")\noutput.path_result(\"phone_verification\", True, 2)\n</code></pre>"},{"location":"cli-output/#integration","title":"Integration","text":"<p>The CLI output is automatically integrated with: - JourneyRunner - Automatic progress updates during execution - Commands - Built into <code>venomqa run</code> command - Reporters - Works alongside all reporter formats</p>"},{"location":"cli-output/#performance","title":"Performance","text":"<ul> <li>Non-blocking - Progress updates don't slow down tests</li> <li>Efficient rendering - Updates at 10 FPS (configurable)</li> <li>Memory conscious - Minimal overhead</li> <li>Live updates - In-place rendering without terminal spam</li> </ul>"},{"location":"cli-output/#best-practices","title":"Best Practices","text":"<ol> <li>Always provide total_steps for accurate progress bars</li> <li>Use descriptive step names for clarity</li> <li>Enable timing to identify slow steps</li> <li>Color support improves readability in CI logs</li> <li>Unicode symbols provide better visual hierarchy</li> </ol>"},{"location":"cli-output/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli-output/#progress-bar-not-showing","title":"Progress bar not showing","text":"<ul> <li>Ensure <code>total_steps &gt; 0</code> in <code>journey_start()</code></li> <li>Check <code>show_progress=True</code> in config</li> </ul>"},{"location":"cli-output/#symbols-displaying-incorrectly","title":"Symbols displaying incorrectly","text":"<ul> <li>Terminal may not support Unicode</li> <li>Set <code>use_unicode=False</code> for ASCII fallback</li> </ul>"},{"location":"cli-output/#colors-not-working","title":"Colors not working","text":"<ul> <li>Verify terminal supports ANSI colors</li> <li>Check TTY detection with <code>output._supports_color()</code></li> </ul>"},{"location":"cli-output/#future-enhancements","title":"Future Enhancements","text":"<p>Planned features: - Real-time request/response preview - Interactive mode for step debugging - Performance graphs and charts - Export progress to file/stream - WebSocket streaming for remote monitoring</p>"},{"location":"cli-output/#see-also","title":"See Also","text":"<ul> <li>CLI Commands - Command-line interface</li> <li>Journeys - Journey structure</li> <li>Reporters - Report formats</li> </ul>"},{"location":"comparison/","title":"VenomQA vs Other API Testing Tools","text":"<p>Most API testing tools check one endpoint at a time. VenomQA does something fundamentally different: it explores sequences of API calls \u2014 <code>create \u2192 refund \u2192 refund</code>, <code>login \u2192 delete \u2192 login</code> \u2014 and checks that your invariants hold across every reachable state.</p> <p>This page compares VenomQA to the tools developers search for most: Schemathesis, pytest, Postman/Newman, Dredd, Hypothesis, and Playwright.</p>"},{"location":"comparison/#decision-tree-which-tool-do-you-need","title":"Decision Tree: Which Tool Do You Need?","text":"Text Only<pre><code>Do you need to test sequences of API calls?\n  \u2514\u2500 YES \u2192 VenomQA\n\nDo you need to fuzz individual endpoint inputs from an OpenAPI spec?\n  \u2514\u2500 YES \u2192 Schemathesis  (use alongside VenomQA \u2014 they're complementary)\n\nDo you need browser / UI testing?\n  \u2514\u2500 YES \u2192 Playwright\n\nDo you need a visual GUI for ad-hoc exploration?\n  \u2514\u2500 YES \u2192 Postman\n\nDo you need property-based unit testing?\n  \u2514\u2500 YES \u2192 Hypothesis\n\nDo you need unit or integration tests with maximum flexibility?\n  \u2514\u2500 YES \u2192 pytest\n\nDo you need contract validation from an OpenAPI/Swagger spec?\n  \u2514\u2500 YES \u2192 Dredd\n</code></pre>"},{"location":"comparison/#quick-comparison-table","title":"Quick Comparison Table","text":"Tool What it tests Sequence testing Real DB state Auto-exploration Language VenomQA API state sequences Yes \u2014 exhaustive Yes (savepoints) Yes \u2014 BFS/DFS over state graph Python Schemathesis Individual endpoint inputs No No Yes \u2014 fuzz per endpoint Python / CLI pytest Anything you write Manual Manual (fixtures) No Python Postman/Newman Request-response flows Manual collections No No JS / GUI Dredd OpenAPI contract compliance No No No CLI / any Hypothesis Property-based unit tests No No Yes \u2014 per function Python Playwright Browser + UI flows Via scripts No No JS / Python / Java"},{"location":"comparison/#schemathesis-vs-venomqa-most-important-comparison","title":"Schemathesis vs VenomQA (Most Important Comparison)","text":"<p>Schemathesis is the closest tool to VenomQA in the Python ecosystem, and the most common comparison search. Understanding the difference is critical before choosing.</p>"},{"location":"comparison/#what-schemathesis-does","title":"What Schemathesis does","text":"<p>Schemathesis reads your OpenAPI spec and fuzzes every endpoint in isolation with generated inputs. It is excellent at finding:</p> <ul> <li>Missing input validation (null values, unexpected types)</li> <li>500 errors on malformed requests</li> <li>Schema mismatches between spec and implementation</li> <li>Edge-case inputs that crash a single handler</li> </ul> Bash<pre><code># Schemathesis: fuzz every endpoint independently\nschemathesis run openapi.json --checks all --base-url http://localhost:8000\n</code></pre>"},{"location":"comparison/#what-venomqa-does","title":"What VenomQA does","text":"<p>VenomQA treats your API as a state machine and explores every reachable sequence of calls. It finds bugs that only appear in a specific order:</p> Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    resp = api.post(f\"/orders/{order_id}/refund\")\n    return resp\n\nno_double_refund = Invariant(\n    name=\"no_double_refund\",\n    check=lambda world: world.context.get(\"last_status\", 200) != 200\n                        or world.context.get(\"refund_count\", 0) &lt;= 1,\n    severity=Severity.CRITICAL,\n)\n\nagent = Agent(\n    world=world,\n    actions=[\n        Action(\"create_order\", create_order),\n        Action(\"refund_order\", refund_order),\n    ],\n    invariants=[no_double_refund],\n    strategy=BFS(),\n    max_steps=50,\n)\n\nresult = agent.explore()\n# VenomQA automatically tries: create, refund, refund \u2014 and catches the double-refund bug\n</code></pre> <p>Schemathesis would never try <code>refund \u2192 refund</code> because it fuzzes endpoints independently. VenomQA finds exactly these sequence-dependent bugs.</p>"},{"location":"comparison/#head-to-head","title":"Head-to-head","text":"Schemathesis VenomQA Finds single-endpoint validation bugs Yes Limited Finds sequence-dependent bugs No Yes Requires OpenAPI spec Yes No Tests real DB state No Yes (savepoints) Exploration strategy Fuzz per endpoint BFS/DFS over state graph Best for Input validation, contract testing Business logic, state machine bugs"},{"location":"comparison/#when-to-use-schemathesis","title":"When to use Schemathesis","text":"<ul> <li>You want to fuzz every endpoint with random valid/invalid inputs</li> <li>You have an OpenAPI spec and want instant coverage without writing test code</li> <li>You are looking for crashes on malformed inputs</li> </ul>"},{"location":"comparison/#when-to-use-venomqa","title":"When to use VenomQA","text":"<ul> <li>You want to test sequences like <code>create \u2192 update \u2192 delete \u2192 create</code></li> <li>You have business rules (invariants) that must hold across all orderings</li> <li>You need real database rollback between explored paths</li> </ul>"},{"location":"comparison/#use-them-together","title":"Use them together","text":"<p>They test completely different things and compose well:</p> YAML<pre><code># CI: run both in parallel\njobs:\n  fuzz-endpoints:\n    run: schemathesis run openapi.json --checks all\n\n  sequence-test:\n    run: python qa/run_agent.py  # VenomQA explores state sequences\n</code></pre> <p>Schemathesis catches bad inputs. VenomQA catches bad sequences.</p>"},{"location":"comparison/#pytest-vs-venomqa","title":"pytest vs VenomQA","text":"<p>pytest is the standard Python testing framework. It is excellent for unit tests and integration tests where you write the exact sequence to execute.</p>"},{"location":"comparison/#the-core-difference","title":"The core difference","text":"<p>With pytest, you write the path:</p> Python<pre><code>import httpx\n\ndef test_double_refund():\n    client = httpx.Client(base_url=\"http://localhost:8000\")\n\n    # You must manually think of this sequence\n    resp = client.post(\"/orders\", json={\"amount\": 100})\n    order_id = resp.json()[\"id\"]\n\n    client.post(f\"/orders/{order_id}/refund\")\n    resp2 = client.post(f\"/orders/{order_id}/refund\")  # Should this 200 or 400?\n    assert resp2.status_code == 400  # You have to know to test this\n</code></pre> <p>With VenomQA, you define what is possible and what must be true, and the agent explores all paths automatically:</p> Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\ndef refund_order(api, context):\n    order_id = context.get(\"order_id\")\n    return api.post(f\"/orders/{order_id}/refund\")\n\nno_500s = Invariant(\n    name=\"no_server_errors\",\n    check=lambda world: world.context.get(\"last_status\", 200) &lt; 500,\n    severity=Severity.CRITICAL,\n)\n\nagent = Agent(\n    world=world,\n    actions=[Action(\"create_order\", create_order), Action(\"refund_order\", refund_order)],\n    invariants=[no_500s],\n    strategy=BFS(),\n    max_steps=100,\n)\n\nresult = agent.explore()\n# Agent automatically discovers: create, refund, refund, refund...\n# You did not have to think of this path\nprint(f\"Paths explored: {result.states_visited}, Violations: {result.violations}\")\n</code></pre>"},{"location":"comparison/#feature-comparison","title":"Feature comparison","text":"pytest VenomQA Unit testing Excellent Not the purpose Integration testing Yes (manual paths) Yes (auto-explored paths) Auto-exploration of sequences No Yes DB rollback between paths Manual (fixtures) Built-in (savepoints) Invariant checking across all paths No Yes Plugin ecosystem Extensive Focused on API testing Flexibility Maximum Focused"},{"location":"comparison/#use-them-together_1","title":"Use them together","text":"<p>VenomQA works inside a pytest project. Run your unit tests with pytest, your sequence tests with VenomQA's agent:</p> Python<pre><code># tests/test_agent.py \u2014 run with pytest\nfrom venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\ndef test_no_violations_in_order_flow():\n    api = HttpClient(\"http://localhost:8000\")\n    world = World(api=api, state_from_context=[\"order_id\"])\n\n    agent = Agent(\n        world=world,\n        actions=[Action(\"create_order\", create_order)],\n        invariants=[no_500s],\n        strategy=BFS(),\n        max_steps=50,\n    )\n\n    result = agent.explore()\n    assert len(result.violations) == 0, f\"Violations found: {result.violations}\"\n</code></pre>"},{"location":"comparison/#postmannewman-vs-venomqa","title":"Postman/Newman vs VenomQA","text":"<p>Postman is the industry-standard GUI tool for API exploration and manual testing. Newman is its CLI runner for CI/CD.</p>"},{"location":"comparison/#what-postman-does-well","title":"What Postman does well","text":"<ul> <li>Visual exploration of an API during development</li> <li>Sharing collections with non-technical stakeholders</li> <li>Generating API documentation from collections</li> <li>Quick smoke tests on a new environment</li> </ul>"},{"location":"comparison/#what-venomqa-does-instead","title":"What VenomQA does instead","text":"<p>VenomQA is code-first and designed for automated, exhaustive state-space exploration \u2014 not manual scripting of known-good flows.</p> <p>Postman collection (JavaScript): JavaScript<pre><code>// You manually define every step in order\npm.test(\"Create order\", function() {\n    pm.sendRequest({\n        url: pm.environment.get(\"base_url\") + \"/orders\",\n        method: \"POST\",\n        body: { mode: \"raw\", raw: JSON.stringify({ amount: 100 }) }\n    }, function(err, res) {\n        pm.environment.set(\"order_id\", res.json().id);\n    });\n});\n</code></pre></p> <p>VenomQA: Python<pre><code>from venomqa import Action, Agent, BFS, Invariant, Severity, World\nfrom venomqa.adapters.http import HttpClient\n\napi = HttpClient(\"http://localhost:8000\")\nworld = World(api=api, state_from_context=[\"order_id\"])\n\ndef create_order(api, context):\n    resp = api.post(\"/orders\", json={\"amount\": 100})\n    context.set(\"order_id\", resp.json()[\"id\"])\n    return resp\n\nagent = Agent(\n    world=world,\n    actions=[Action(\"create_order\", create_order)],\n    invariants=[Invariant(\"no_500s\", lambda w: w.context.get(\"last_status\", 200) &lt; 500, Severity.CRITICAL)],\n    strategy=BFS(),\n    max_steps=50,\n)\nresult = agent.explore()\n</code></pre></p>"},{"location":"comparison/#when-to-use-postman","title":"When to use Postman","text":"<ul> <li>Your team needs a GUI to explore or demo an API</li> <li>You want to generate API documentation alongside tests</li> <li>You are running simple smoke checks on a deployed environment</li> </ul>"},{"location":"comparison/#when-to-use-venomqa_1","title":"When to use VenomQA","text":"<ul> <li>You want to find bugs in sequences your team has not thought of yet</li> <li>You need tests in version control, reviewed in pull requests</li> <li>You need database state control and rollback between paths</li> </ul>"},{"location":"comparison/#dredd-vs-venomqa","title":"Dredd vs VenomQA","text":"<p>Dredd validates that your API implementation matches an OpenAPI or API Blueprint contract. It sends example requests from the spec and checks that responses match the defined schema.</p> <p>Dredd answers: \"Does my implementation conform to its spec?\"</p> <p>VenomQA answers: \"Does my implementation behave correctly across all sequences of operations?\"</p> <p>These are orthogonal questions. Use Dredd to catch spec drift, use VenomQA to catch logic bugs in sequences.</p>"},{"location":"comparison/#hypothesis-vs-venomqa","title":"Hypothesis vs VenomQA","text":"<p>Hypothesis is a property-based testing library for Python. You define properties that should hold for any input, and Hypothesis generates inputs that try to falsify them.</p> <p>Hypothesis operates at the function level \u2014 it generates inputs to a Python function and checks that it behaves correctly for all of them.</p> <p>VenomQA operates at the API sequence level \u2014 it generates sequences of HTTP calls and checks that business invariants hold across all reachable states.</p> <p>They are both \"property-based\" in spirit but at completely different layers:</p> Python<pre><code># Hypothesis: test a Python function with generated inputs\nfrom hypothesis import given, strategies as st\n\n@given(st.integers(min_value=1))\ndef test_refund_never_exceeds_payment(amount):\n    order = Order(amount=amount)\n    refund = Refund(order, amount=amount)\n    assert refund.total &lt;= order.amount  # tests the Python object, not the HTTP API\n</code></pre> Python<pre><code># VenomQA: test the HTTP API with generated sequences\nno_over_refund = Invariant(\n    name=\"no_over_refund\",\n    check=lambda world: world.context.get(\"refunded\", 0) &lt;= world.context.get(\"amount\", 0),\n    severity=Severity.CRITICAL,\n)\n# Agent explores create \u2192 refund \u2192 refund \u2192 refund against a real (or test) server\n</code></pre>"},{"location":"comparison/#playwright-vs-venomqa","title":"Playwright vs VenomQA","text":"<p>Playwright automates a real browser. It is the right tool when you need to test JavaScript rendering, CSS interactions, accessibility, or any behavior that only manifests in a browser.</p> <p>VenomQA makes direct HTTP calls. There is no browser involved.</p> <p>Use Playwright for end-to-end tests that include the UI. Use VenomQA to cover the API layer exhaustively before those E2E tests run.</p> YAML<pre><code># Recommended CI pipeline\njobs:\n  unit:\n    run: pytest tests/unit/\n\n  stateful-api:\n    run: python qa/run_agent.py  # VenomQA\n\n  fuzz:\n    run: schemathesis run openapi.json --checks all  # Schemathesis\n\n  e2e:\n    needs: [unit, stateful-api, fuzz]\n    run: npx playwright test\n</code></pre>"},{"location":"comparison/#full-feature-matrix","title":"Full Feature Matrix","text":"Feature VenomQA Schemathesis pytest Postman Dredd Hypothesis Playwright Sequence / stateful testing Yes No Manual Manual No No Manual Auto-exploration Yes (BFS/DFS) Yes (fuzz) No No No Yes (unit) No Real DB state + rollback Yes No No No No No No Invariant checking Yes Partial Manual Manual Schema only Yes No OpenAPI spec required No Yes No Optional Yes No No Browser support No No No No No No Yes GUI No No No Yes No No No Language Python Python / CLI Python JS CLI Python JS / Python / Java CI/CD ready Yes Yes Yes Yes (Newman) Yes Yes Yes"},{"location":"comparison/#venomqa-schemathesis-the-recommended-stack","title":"VenomQA + Schemathesis: The Recommended Stack","text":"<p>For Python teams building REST APIs, running both tools gives you two complementary layers of coverage:</p> <ol> <li>Schemathesis \u2014 fuzzes every endpoint with random valid and invalid inputs, catches crashes and schema violations fast</li> <li>VenomQA \u2014 explores state sequences and checks business invariants across all reachable paths</li> </ol> <p>Neither tool replaces the other. A bug that requires <code>create \u2192 refund \u2192 refund</code> will never be found by fuzzing <code>POST /refund</code> in isolation. A null-pointer crash on a malformed <code>amount</code> field will never be found by exploring pre-seeded state sequences.</p> Bash<pre><code># Install both\npip install venomqa schemathesis\n\n# Fuzz endpoints\nschemathesis run openapi.json --checks all --base-url http://localhost:8000\n\n# Explore state sequences\npython qa/run_agent.py\n</code></pre>"},{"location":"comparison/#summary","title":"Summary","text":"Tool Use it when... VenomQA You need to find bugs in sequences of API calls, and maintain real DB state between paths Schemathesis You need to fuzz individual endpoints with generated inputs from an OpenAPI spec pytest You need unit tests or integration tests where you write the exact sequence Postman You need a GUI to explore an API or share collections with non-technical teammates Dredd You need to verify your implementation matches its OpenAPI contract Hypothesis You need property-based tests at the Python function level Playwright You need browser automation and end-to-end UI testing <p>The tools are not mutually exclusive. A mature backend project typically uses pytest for unit tests, Schemathesis for endpoint fuzzing, VenomQA for stateful sequence testing, and Playwright for end-to-end tests. Each covers a distinct layer.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We love contributions! Here's how to get started with VenomQA development.</p>"},{"location":"contributing/#quick-start","title":"Quick Start","text":"Bash<pre><code># Clone the repository\ngit clone https://github.com/venomqa/venomqa.git\ncd venomqa\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install with development dependencies\npip install -e \".[dev,docs]\"\n\n# Install pre-commit hooks\npre-commit install\n\n# Run tests\npytest\n\n# Run linting\nruff check .\nmypy venomqa\n</code></pre>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Found a bug? Open an issue with:</p> <ul> <li>VenomQA version</li> <li>Python version</li> <li>Minimal reproduction steps</li> <li>Expected vs actual behavior</li> </ul>"},{"location":"contributing/#suggest-features","title":"Suggest Features","text":"<p>Have an idea? Start a discussion to:</p> <ul> <li>Describe the use case</li> <li>Explain the proposed solution</li> <li>Discuss alternatives</li> </ul>"},{"location":"contributing/#improve-documentation","title":"Improve Documentation","text":"<p>Documentation improvements are always welcome:</p> <ul> <li>Fix typos</li> <li>Add examples</li> <li>Clarify explanations</li> <li>Translate documentation</li> </ul>"},{"location":"contributing/#submit-code","title":"Submit Code","text":"<p>Ready to code? Look for issues labeled <code>good first issue</code>.</p>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"Bash<pre><code># Fork on GitHub, then clone\ngit clone https://github.com/YOUR_USERNAME/venomqa.git\ncd venomqa\ngit remote add upstream https://github.com/venomqa/venomqa.git\n</code></pre>"},{"location":"contributing/#2-create-branch","title":"2. Create Branch","text":"Bash<pre><code>git checkout -b feature/my-feature\n# or\ngit checkout -b fix/my-fix\n</code></pre>"},{"location":"contributing/#3-make-changes","title":"3. Make Changes","text":"<ul> <li>Write code</li> <li>Add tests</li> <li>Update documentation</li> </ul>"},{"location":"contributing/#4-test-changes","title":"4. Test Changes","text":"Bash<pre><code># Run all tests\npytest\n\n# Run specific tests\npytest tests/test_models.py\n\n# Run with coverage\npytest --cov=venomqa\n\n# Run linting\nruff check .\nruff format --check .\n\n# Run type checking\nmypy venomqa\n</code></pre>"},{"location":"contributing/#5-commit-changes","title":"5. Commit Changes","text":"<p>Follow Conventional Commits:</p> Bash<pre><code>git commit -m \"feat: add support for MySQL backend\"\ngit commit -m \"fix: resolve checkpoint naming conflict\"\ngit commit -m \"docs: add MySQL configuration example\"\ngit commit -m \"test: add tests for branch rollback\"\n</code></pre>"},{"location":"contributing/#6-push-and-create-pr","title":"6. Push and Create PR","text":"Bash<pre><code>git push origin feature/my-feature\n</code></pre> <p>Then create a Pull Request on GitHub.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":""},{"location":"contributing/#python-style","title":"Python Style","text":"<p>We use:</p> <ul> <li>Ruff for linting and formatting</li> <li>mypy for type checking</li> <li>Line length: 100 characters</li> </ul> Bash<pre><code># Format code\nruff format .\n\n# Check linting\nruff check .\n\n# Fix linting issues\nruff check --fix .\n</code></pre>"},{"location":"contributing/#type-hints","title":"Type Hints","text":"<p>Use type hints for all public APIs:</p> Python<pre><code>def create_journey(\n    name: str,\n    steps: list[Step],\n    description: str = \"\",\n    tags: list[str] | None = None,\n) -&gt; Journey:\n    \"\"\"Create a new journey.\n\n    Args:\n        name: Unique journey identifier\n        steps: List of steps to execute\n        description: Human-readable description\n        tags: Optional tags for filtering\n\n    Returns:\n        A new Journey instance\n    \"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings:</p> Python<pre><code>def process_result(\n    result: StepResult,\n    context: ExecutionContext,\n) -&gt; dict[str, Any]:\n    \"\"\"Process a step result and update context.\n\n    Args:\n        result: The step execution result\n        context: The execution context to update\n\n    Returns:\n        A dictionary containing processed result data\n\n    Raises:\n        ValueError: If result is invalid\n        StateError: If context cannot be updated\n    \"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#test-structure","title":"Test Structure","text":"Text Only<pre><code>tests/\n\u251c\u2500\u2500 test_models.py          # Core model tests\n\u251c\u2500\u2500 test_runner.py          # Runner tests\n\u251c\u2500\u2500 test_client.py          # HTTP client tests\n\u251c\u2500\u2500 test_state.py           # State manager tests\n\u251c\u2500\u2500 test_reporters.py       # Reporter tests\n\u2514\u2500\u2500 conftest.py             # Shared fixtures\n</code></pre>"},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"Python<pre><code>import pytest\nfrom venomqa import Journey, Step, Client\n\n\nclass TestJourney:\n    def test_journey_creation(self):\n        \"\"\"Test basic journey creation.\"\"\"\n        journey = Journey(\n            name=\"test\",\n            steps=[\n                Step(name=\"step1\", action=lambda c, ctx: c.get(\"/\"))\n            ],\n        )\n        assert journey.name == \"test\"\n        assert len(journey.steps) == 1\n\n    def test_journey_validation(self):\n        \"\"\"Test journey validates checkpoint references.\"\"\"\n        with pytest.raises(ValueError):\n            Journey(\n                name=\"test\",\n                steps=[\n                    Branch(checkpoint_name=\"nonexistent\", paths=[])\n                ],\n            )\n\n\n@pytest.fixture\ndef client():\n    \"\"\"Create test client.\"\"\"\n    return Client(base_url=\"http://localhost:8000\")\n\n\n@pytest.fixture\ndef mock_response(respx_mock):\n    \"\"\"Mock HTTP responses.\"\"\"\n    respx_mock.get(\"/health\").respond(200, json={\"status\": \"ok\"})\n    return respx_mock\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"Bash<pre><code># All tests\npytest\n\n# With coverage\npytest --cov=venomqa --cov-report=html\n\n# Specific file\npytest tests/test_models.py\n\n# Specific test\npytest tests/test_models.py::TestJourney::test_journey_creation\n\n# Verbose output\npytest -v\n\n# Stop on first failure\npytest -x\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#building-docs","title":"Building Docs","text":"Bash<pre><code># Install docs dependencies\npip install -e \".[docs]\"\n\n# Serve locally\nmkdocs serve\n\n# Build\nmkdocs build\n</code></pre>"},{"location":"contributing/#documentation-structure","title":"Documentation Structure","text":"Text Only<pre><code>docs/\n\u251c\u2500\u2500 index.md                  # Home page\n\u251c\u2500\u2500 getting-started/          # Getting started guides\n\u251c\u2500\u2500 concepts/                 # Core concepts\n\u251c\u2500\u2500 tutorials/                # Step-by-step tutorials\n\u251c\u2500\u2500 reference/                # API reference\n\u251c\u2500\u2500 examples/                 # Code examples\n\u2514\u2500\u2500 advanced/                 # Advanced topics\n</code></pre>"},{"location":"contributing/#release-process","title":"Release Process","text":"<ol> <li>Update version in <code>venomqa/__init__.py</code> and <code>pyproject.toml</code></li> <li>Update CHANGELOG.md</li> <li>Create release PR</li> <li>After merge, tag release: <code>git tag v0.x.0</code></li> <li>Push tag: <code>git push --tags</code></li> <li>GitHub Actions builds and publishes to PyPI</li> </ol>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please read our Code of Conduct before contributing.</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>GitHub Discussions</li> <li>Discord</li> </ul>"},{"location":"examples/","title":"Real-World Examples","text":"<p>This page provides practical, real-world examples of using VenomQA.</p> <p>Looking for basics? See the Getting Started Guide for introductory examples.</p>"},{"location":"examples/#table-of-contents","title":"Table of Contents","text":"<ul> <li>E-Commerce Checkout Flow</li> <li>User Registration with Email Verification</li> <li>API Rate Limiting Tests</li> <li>Multi-Tenant Application Testing</li> <li>Payment Gateway Integration</li> <li>File Upload and Processing</li> <li>WebSocket and Real-Time Features</li> <li>Third-Party API Mocking</li> </ul>"},{"location":"examples/#related-documentation","title":"Related Documentation","text":"Topic Document Journey DSL journeys.md Adapters adapters.md Ports ports.md Advanced Patterns advanced.md"},{"location":"examples/#e-commerce-checkout-flow","title":"E-Commerce Checkout Flow","text":"<p>Complete checkout journey testing multiple payment methods.</p>"},{"location":"examples/#actions-file","title":"Actions File","text":"Python<pre><code># actions/shop.py\n\ndef add_to_cart(client, context, product_id=None, quantity=1):\n    \"\"\"Add product to shopping cart.\"\"\"\n    product_id = product_id or context.get(\"product_id\")\n    response = client.post(\"/api/cart/items\", json={\n        \"product_id\": product_id,\n        \"quantity\": quantity,\n    })\n    if response.status_code == 200:\n        context[\"cart_id\"] = response.json()[\"cart_id\"]\n    return response\n\ndef get_cart(client, context):\n    \"\"\"Get current cart contents.\"\"\"\n    cart_id = context.get(\"cart_id\")\n    if cart_id:\n        return client.get(f\"/api/cart/{cart_id}\")\n    return client.get(\"/api/cart\")\n\ndef apply_coupon(client, context, code=\"DISCOUNT10\"):\n    \"\"\"Apply discount coupon to cart.\"\"\"\n    cart_id = context.get_required(\"cart_id\")\n    return client.post(f\"/api/cart/{cart_id}/coupon\", json={\"code\": code})\n\ndef start_checkout(client, context):\n    \"\"\"Begin checkout process.\"\"\"\n    cart_id = context.get_required(\"cart_id\")\n    response = client.post(f\"/api/cart/{cart_id}/checkout\")\n    if response.status_code == 200:\n        context[\"order_id\"] = response.json()[\"order_id\"]\n    return response\n\ndef add_shipping_address(client, context):\n    \"\"\"Add shipping address to order.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/shipping\", json={\n        \"name\": \"John Doe\",\n        \"address\": \"123 Main St\",\n        \"city\": \"New York\",\n        \"state\": \"NY\",\n        \"zip\": \"10001\",\n        \"country\": \"USA\",\n    })\n\ndef pay_with_credit_card(client, context):\n    \"\"\"Process credit card payment.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/payment\", json={\n        \"method\": \"credit_card\",\n        \"card_number\": \"4242424242424242\",\n        \"exp_month\": 12,\n        \"exp_year\": 2025,\n        \"cvv\": \"123\",\n    })\n\ndef pay_with_paypal(client, context):\n    \"\"\"Process PayPal payment.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/payment\", json={\n        \"method\": \"paypal\",\n        \"return_url\": \"https://example.com/return\",\n    })\n\ndef pay_with_crypto(client, context):\n    \"\"\"Process cryptocurrency payment.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    return client.post(f\"/api/orders/{order_id}/payment\", json={\n        \"method\": \"crypto\",\n        \"currency\": \"BTC\",\n    })\n\ndef confirm_order(client, context):\n    \"\"\"Confirm and finalize order.\"\"\"\n    order_id = context.get_required(\"order_id\")\n    response = client.post(f\"/api/orders/{order_id}/confirm\")\n    if response.status_code == 200:\n        context[\"confirmation_number\"] = response.json()[\"confirmation_number\"]\n    return response\n</code></pre>"},{"location":"examples/#journey-definition","title":"Journey Definition","text":"Python<pre><code># journeys/ecommerce_checkout.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.shop import (\n    add_to_cart, get_cart, apply_coupon, start_checkout,\n    add_shipping_address, pay_with_credit_card, pay_with_paypal,\n    pay_with_crypto, confirm_order,\n)\n\ncheckout_journey = Journey(\n    name=\"ecommerce_checkout\",\n    description=\"Complete e-commerce checkout flow with multiple payment methods\",\n    tags=[\"e-commerce\", \"checkout\", \"payment\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"add_item\", action=lambda c, ctx: add_to_cart(c, ctx, product_id=123)),\n        Step(name=\"verify_cart\", action=get_cart),\n        Step(name=\"apply_discount\", action=apply_coupon),\n        Checkpoint(name=\"cart_ready\"),\n        Step(name=\"start_checkout\", action=start_checkout),\n        Step(name=\"add_shipping\", action=add_shipping_address),\n        Checkpoint(name=\"ready_for_payment\"),\n        Branch(\n            checkpoint_name=\"ready_for_payment\",\n            paths=[\n                Path(name=\"credit_card\", steps=[\n                    Step(name=\"pay_card\", action=pay_with_credit_card),\n                    Step(name=\"confirm_card\", action=confirm_order),\n                ]),\n                Path(name=\"paypal\", steps=[\n                    Step(name=\"pay_paypal\", action=pay_with_paypal),\n                    Step(name=\"confirm_paypal\", action=confirm_order),\n                ]),\n                Path(name=\"crypto\", steps=[\n                    Step(name=\"pay_crypto\", action=pay_with_crypto),\n                    Step(name=\"confirm_crypto\", action=confirm_order),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#user-registration-with-email-verification","title":"User Registration with Email Verification","text":"<p>Test complete registration flow including email verification.</p>"},{"location":"examples/#actions","title":"Actions","text":"Python<pre><code># actions/user_registration.py\nimport time\n\ndef register_user(client, context, email=None, password=None):\n    \"\"\"Register a new user account.\"\"\"\n    email = email or context.get(\"email\", f\"test_{int(time.time())}@example.com\")\n    password = password or context.get(\"password\", \"SecurePass123!\")\n\n    response = client.post(\"/api/auth/register\", json={\n        \"email\": email,\n        \"password\": password,\n        \"name\": \"Test User\",\n    })\n\n    if response.status_code == 201:\n        context[\"user_email\"] = email\n        context[\"user_password\"] = password\n        context[\"user_id\"] = response.json()[\"user\"][\"id\"]\n\n    return response\n\ndef get_verification_token(client, context):\n    \"\"\"Get email verification token (simulating email retrieval).\"\"\"\n    # In real tests, this might query a test email service\n    user_id = context.get_required(\"user_id\")\n    response = client.get(f\"/api/test/verification-token/{user_id}\")\n\n    if response.status_code == 200:\n        context[\"verification_token\"] = response.json()[\"token\"]\n\n    return response\n\ndef verify_email(client, context):\n    \"\"\"Verify email with token.\"\"\"\n    token = context.get_required(\"verification_token\")\n    return client.post(\"/api/auth/verify-email\", json={\"token\": token})\n\ndef login_and_verify(client, context):\n    \"\"\"Login and verify account is active.\"\"\"\n    email = context.get_required(\"user_email\")\n    password = context.get_required(\"user_password\")\n\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": email,\n        \"password\": password,\n    })\n\n    if response.status_code == 200:\n        context[\"auth_token\"] = response.json()[\"token\"]\n        client.set_auth_token(context[\"auth_token\"])\n\n    return response\n\ndef check_account_status(client, context):\n    \"\"\"Verify account is verified and active.\"\"\"\n    return client.get(\"/api/auth/me\")\n</code></pre>"},{"location":"examples/#journey","title":"Journey","text":"Python<pre><code># journeys/user_registration.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.user_registration import (\n    register_user, get_verification_token, verify_email,\n    login_and_verify, check_account_status,\n)\n\nregistration_journey = Journey(\n    name=\"user_registration\",\n    description=\"Complete user registration with email verification\",\n    tags=[\"auth\", \"registration\", \"email\"],\n    steps=[\n        Step(name=\"register\", action=register_user),\n        Checkpoint(name=\"user_created\"),\n        Step(name=\"get_token\", action=get_verification_token),\n        Checkpoint(name=\"token_retrieved\"),\n        Branch(\n            checkpoint_name=\"token_retrieved\",\n            paths=[\n                Path(name=\"valid_verification\", steps=[\n                    Step(name=\"verify_email\", action=verify_email),\n                    Step(name=\"login\", action=login_and_verify),\n                    Step(name=\"check_status\", action=check_account_status),\n                ]),\n                Path(name=\"invalid_token\", steps=[\n                    Step(\n                        name=\"verify_with_invalid\",\n                        action=lambda c, ctx: c.post(\"/api/auth/verify-email\", json={\"token\": \"invalid\"}),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"expired_token\", steps=[\n                    Step(\n                        name=\"verify_with_expired\",\n                        action=lambda c, ctx: c.post(\"/api/auth/verify-email\", json={\"token\": \"expired_token_123\"}),\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#api-rate-limiting-tests","title":"API Rate Limiting Tests","text":"<p>Test rate limiting behavior and error handling.</p>"},{"location":"examples/#actions_1","title":"Actions","text":"Python<pre><code># actions/rate_limit.py\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef make_request(client, context, endpoint=\"/api/data\"):\n    \"\"\"Make a single API request.\"\"\"\n    return client.get(endpoint)\n\ndef burst_requests(client, context, count=10, endpoint=\"/api/data\"):\n    \"\"\"Make multiple rapid requests.\"\"\"\n    results = []\n    for _ in range(count):\n        results.append(client.get(endpoint))\n    context[\"burst_results\"] = results\n    return results[-1]\n\ndef parallel_requests(client, context, count=10, endpoint=\"/api/data\"):\n    \"\"\"Make parallel requests to trigger rate limiting.\"\"\"\n    def make_request():\n        return client.get(endpoint)\n\n    with ThreadPoolExecutor(max_workers=count) as executor:\n        futures = [executor.submit(make_request) for _ in range(count)]\n        results = [f.result() for f in futures]\n\n    context[\"parallel_results\"] = results\n    return results[-1]\n\ndef wait_and_retry(client, context):\n    \"\"\"Wait for rate limit to reset and retry.\"\"\"\n    time.sleep(60)  # Wait for rate limit window\n    return client.get(\"/api/data\")\n\ndef check_rate_limit_headers(client, context):\n    \"\"\"Check rate limit headers in response.\"\"\"\n    response = client.get(\"/api/data\")\n\n    headers = response.headers\n    context[\"rate_limit\"] = {\n        \"limit\": headers.get(\"X-RateLimit-Limit\"),\n        \"remaining\": headers.get(\"X-RateLimit-Remaining\"),\n        \"reset\": headers.get(\"X-RateLimit-Reset\"),\n    }\n\n    return response\n</code></pre>"},{"location":"examples/#journey_1","title":"Journey","text":"Python<pre><code># journeys/rate_limiting.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.rate_limit import (\n    make_request, burst_requests, parallel_requests,\n    wait_and_retry, check_rate_limit_headers,\n)\n\nrate_limit_journey = Journey(\n    name=\"rate_limiting\",\n    description=\"Test API rate limiting behavior\",\n    tags=[\"rate-limit\", \"api\", \"reliability\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"check_headers\", action=check_rate_limit_headers),\n        Checkpoint(name=\"initial_state\"),\n        Branch(\n            checkpoint_name=\"initial_state\",\n            paths=[\n                Path(name=\"sequential_burst\", steps=[\n                    Step(name=\"burst_10\", action=lambda c, ctx: burst_requests(c, ctx, count=10)),\n                    Step(\n                        name=\"expect_rate_limited\",\n                        action=lambda c, ctx: make_request(c, ctx),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"parallel_burst\", steps=[\n                    Step(name=\"parallel_20\", action=lambda c, ctx: parallel_requests(c, ctx, count=20)),\n                    Step(\n                        name=\"expect_blocked\",\n                        action=lambda c, ctx: make_request(c, ctx),\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#multi-tenant-application-testing","title":"Multi-Tenant Application Testing","text":"<p>Test behavior across different tenants with data isolation.</p>"},{"location":"examples/#actions_2","title":"Actions","text":"Python<pre><code># actions/multi_tenant.py\n\ndef switch_tenant(client, context, tenant_id=None):\n    \"\"\"Switch to a specific tenant context.\"\"\"\n    tenant_id = tenant_id or context.get(\"tenant_id\")\n    client.clear_auth()\n\n    # Get tenant-specific auth\n    response = client.post(\"/api/auth/tenant-login\", json={\n        \"tenant_id\": tenant_id,\n        \"api_key\": f\"key_{tenant_id}\",\n    })\n\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n        context[\"current_tenant\"] = tenant_id\n\n    return response\n\ndef create_tenant_resource(client, context, name=None):\n    \"\"\"Create a resource in current tenant.\"\"\"\n    tenant = context.get(\"current_tenant\")\n    name = name or f\"Resource for {tenant}\"\n\n    response = client.post(\"/api/resources\", json={\n        \"name\": name,\n        \"tenant_id\": tenant,\n    })\n\n    if response.status_code == 201:\n        context[f\"resource_{tenant}\"] = response.json()[\"id\"]\n\n    return response\n\ndef list_tenant_resources(client, context):\n    \"\"\"List resources for current tenant.\"\"\"\n    return client.get(\"/api/resources\")\n\ndef try_cross_tenant_access(client, context, target_tenant=None, resource_id=None):\n    \"\"\"Attempt to access another tenant's resource.\"\"\"\n    target = target_tenant or context.get(\"other_tenant\")\n    resource = resource_id or context.get(f\"resource_{target}\")\n\n    return client.get(f\"/api/resources/{resource}\")\n</code></pre>"},{"location":"examples/#journey_2","title":"Journey","text":"Python<pre><code># journeys/multi_tenant.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.multi_tenant import (\n    switch_tenant, create_tenant_resource, list_tenant_resources,\n    try_cross_tenant_access,\n)\n\nmulti_tenant_journey = Journey(\n    name=\"multi_tenant_isolation\",\n    description=\"Test multi-tenant data isolation\",\n    tags=[\"multi-tenant\", \"security\", \"isolation\"],\n    steps=[\n        # Setup tenant A\n        Step(name=\"switch_tenant_a\", action=lambda c, ctx: switch_tenant(c, ctx, tenant_id=\"tenant_a\")),\n        Step(name=\"create_resource_a\", action=create_tenant_resource),\n        Checkpoint(name=\"tenant_a_setup\"),\n\n        # Setup tenant B\n        Step(name=\"switch_tenant_b\", action=lambda c, ctx: switch_tenant(c, ctx, tenant_id=\"tenant_b\")),\n        Step(name=\"create_resource_b\", action=create_tenant_resource),\n        context[\"other_tenant\"] = \"tenant_a\",\n        Checkpoint(name=\"tenant_b_setup\"),\n\n        # Test isolation\n        Branch(\n            checkpoint_name=\"tenant_b_setup\",\n            paths=[\n                Path(name=\"isolation_test\", steps=[\n                    # Tenant B tries to access Tenant A's resource\n                    Step(\n                        name=\"cross_tenant_access\",\n                        action=try_cross_tenant_access,\n                        expect_failure=True,  # Should fail\n                    ),\n                ]),\n                Path(name=\"list_own_resources\", steps=[\n                    Step(name=\"list_b_resources\", action=list_tenant_resources),\n                ]),\n            ],\n        ),\n\n        # Switch back to A and verify\n        Step(name=\"back_to_tenant_a\", action=lambda c, ctx: switch_tenant(c, ctx, tenant_id=\"tenant_a\")),\n        Step(name=\"verify_a_resources\", action=list_tenant_resources),\n    ],\n)\n</code></pre>"},{"location":"examples/#payment-gateway-integration","title":"Payment Gateway Integration","text":"<p>Test payment processing with various scenarios.</p>"},{"location":"examples/#actions_3","title":"Actions","text":"Python<pre><code># actions/payment.py\n\ndef create_payment_intent(client, context, amount=1000, currency=\"usd\"):\n    \"\"\"Create a payment intent.\"\"\"\n    response = client.post(\"/api/payments/intents\", json={\n        \"amount\": amount,\n        \"currency\": currency,\n    })\n\n    if response.status_code == 201:\n        context[\"payment_intent_id\"] = response.json()[\"id\"]\n        context[\"payment_amount\"] = amount\n\n    return response\n\ndef confirm_payment(client, context, payment_method=\"card_success\"):\n    \"\"\"Confirm a payment with specified method.\"\"\"\n    intent_id = context.get_required(\"payment_intent_id\")\n\n    response = client.post(f\"/api/payments/intents/{intent_id}/confirm\", json={\n        \"payment_method\": payment_method,\n    })\n\n    if response.status_code == 200:\n        context[\"payment_status\"] = response.json()[\"status\"]\n\n    return response\n\ndef refund_payment(client, context, amount=None):\n    \"\"\"Refund a payment.\"\"\"\n    intent_id = context.get_required(\"payment_intent_id\")\n    amount = amount or context.get(\"payment_amount\")\n\n    return client.post(f\"/api/payments/intents/{intent_id}/refund\", json={\n        \"amount\": amount,\n    })\n\ndef get_payment_status(client, context):\n    \"\"\"Get current payment status.\"\"\"\n    intent_id = context.get_required(\"payment_intent_id\")\n    return client.get(f\"/api/payments/intents/{intent_id}\")\n</code></pre>"},{"location":"examples/#journey_3","title":"Journey","text":"Python<pre><code># journeys/payment_gateway.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.payment import (\n    create_payment_intent, confirm_payment, refund_payment, get_payment_status,\n)\n\npayment_journey = Journey(\n    name=\"payment_gateway\",\n    description=\"Test payment gateway integration\",\n    tags=[\"payment\", \"integration\", \"critical\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"create_intent\", action=create_payment_intent),\n        Checkpoint(name=\"intent_created\"),\n        Branch(\n            checkpoint_name=\"intent_created\",\n            paths=[\n                Path(name=\"successful_payment\", steps=[\n                    Step(name=\"confirm_success\", action=lambda c, ctx: confirm_payment(c, ctx, \"card_success\")),\n                    Step(name=\"verify_success\", action=get_payment_status),\n                ]),\n                Path(name=\"declined_payment\", steps=[\n                    Step(\n                        name=\"confirm_declined\",\n                        action=lambda c, ctx: confirm_payment(c, ctx, \"card_declined\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"insufficient_funds\", steps=[\n                    Step(\n                        name=\"confirm_insufficient\",\n                        action=lambda c, ctx: confirm_payment(c, ctx, \"card_insufficient\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"payment_then_refund\", steps=[\n                    Step(name=\"confirm_for_refund\", action=lambda c, ctx: confirm_payment(c, ctx, \"card_success\")),\n                    Step(name=\"refund_full\", action=refund_payment),\n                    Step(name=\"verify_refunded\", action=get_payment_status),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#file-upload-and-processing","title":"File Upload and Processing","text":"<p>Test file upload and async processing.</p>"},{"location":"examples/#actions_4","title":"Actions","text":"Python<pre><code># actions/file_upload.py\nimport io\nimport time\n\ndef upload_file(client, context, filename=\"test.csv\", content=None):\n    \"\"\"Upload a file for processing.\"\"\"\n    content = content or b\"id,name\\n1,Test\\n2,Example\"\n\n    files = {\n        \"file\": (filename, io.BytesIO(content), \"text/csv\"),\n    }\n\n    response = client.post(\"/api/uploads\", files=files)\n\n    if response.status_code == 201:\n        context[\"upload_id\"] = response.json()[\"upload_id\"]\n\n    return response\n\ndef get_upload_status(client, context):\n    \"\"\"Get upload processing status.\"\"\"\n    upload_id = context.get_required(\"upload_id\")\n    return client.get(f\"/api/uploads/{upload_id}\")\n\ndef wait_for_processing(client, context, timeout=60):\n    \"\"\"Wait for upload to finish processing.\"\"\"\n    upload_id = context.get_required(\"upload_id\")\n    start = time.time()\n\n    while time.time() - start &lt; timeout:\n        response = client.get(f\"/api/uploads/{upload_id}\")\n        status = response.json()[\"status\"]\n\n        if status in [\"completed\", \"failed\"]:\n            context[\"processing_status\"] = status\n            return response\n\n        time.sleep(1)\n\n    raise TimeoutError(\"Processing timed out\")\n\ndef get_upload_results(client, context):\n    \"\"\"Get results of processed upload.\"\"\"\n    upload_id = context.get_required(\"upload_id\")\n    return client.get(f\"/api/uploads/{upload_id}/results\")\n\ndef upload_large_file(client, context, size_mb=10):\n    \"\"\"Upload a large file.\"\"\"\n    content = b\"x\" * (size_mb * 1024 * 1024)\n    return upload_file(client, context, filename=\"large.bin\", content=content)\n</code></pre>"},{"location":"examples/#journey_4","title":"Journey","text":"Python<pre><code># journeys/file_upload.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.file_upload import (\n    upload_file, get_upload_status, wait_for_processing,\n    get_upload_results, upload_large_file,\n)\n\nfile_upload_journey = Journey(\n    name=\"file_upload\",\n    description=\"Test file upload and processing\",\n    tags=[\"upload\", \"async\", \"processing\"],\n    timeout=120.0,\n    steps=[\n        Step(name=\"login\", action=login),\n        Checkpoint(name=\"authenticated\"),\n        Branch(\n            checkpoint_name=\"authenticated\",\n            paths=[\n                Path(name=\"small_csv\", steps=[\n                    Step(name=\"upload_csv\", action=upload_file),\n                    Step(name=\"wait_process\", action=wait_for_processing),\n                    Step(name=\"get_results\", action=get_upload_results),\n                ]),\n                Path(name=\"invalid_format\", steps=[\n                    Step(\n                        name=\"upload_invalid\",\n                        action=lambda c, ctx: upload_file(c, ctx, filename=\"test.exe\", content=b\"invalid\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"large_file\", steps=[\n                    Step(name=\"upload_large\", action=lambda c, ctx: upload_large_file(c, ctx, size_mb=50)),\n                    Step(name=\"wait_large\", action=wait_for_processing),\n                ], description=\"Test large file handling\"),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#websocket-and-real-time-features","title":"WebSocket and Real-Time Features","text":"<p>Test WebSocket connections and real-time updates.</p>"},{"location":"examples/#actions_5","title":"Actions","text":"Python<pre><code># actions/websocket.py\nimport json\nimport time\n\ndef subscribe_to_channel(client, context, channel=\"updates\"):\n    \"\"\"Subscribe to a real-time channel via REST.\"\"\"\n    response = client.post(\"/api/realtime/subscribe\", json={\n        \"channel\": channel,\n    })\n\n    if response.status_code == 200:\n        context[\"channel\"] = channel\n        context[\"subscription_id\"] = response.json()[\"subscription_id\"]\n\n    return response\n\ndef trigger_event(client, context, event_type=\"test_event\", data=None):\n    \"\"\"Trigger a real-time event.\"\"\"\n    channel = context.get(\"channel\", \"updates\")\n\n    return client.post(\"/api/realtime/events\", json={\n        \"channel\": channel,\n        \"event\": event_type,\n        \"data\": data or {\"message\": \"test\"},\n    })\n\ndef poll_for_events(client, context, timeout=10):\n    \"\"\"Poll for events (simulating WebSocket).\"\"\"\n    subscription_id = context.get_required(\"subscription_id\")\n    events = []\n    start = time.time()\n\n    while time.time() - start &lt; timeout:\n        response = client.get(f\"/api/realtime/events/{subscription_id}\")\n        if response.status_code == 200:\n            new_events = response.json().get(\"events\", [])\n            events.extend(new_events)\n\n            if events:\n                context[\"received_events\"] = events\n                return response\n\n        time.sleep(0.5)\n\n    context[\"received_events\"] = events\n    return response\n\ndef unsubscribe(client, context):\n    \"\"\"Unsubscribe from channel.\"\"\"\n    subscription_id = context.get_required(\"subscription_id\")\n    return client.delete(f\"/api/realtime/subscriptions/{subscription_id}\")\n</code></pre>"},{"location":"examples/#journey_5","title":"Journey","text":"Python<pre><code># journeys/realtime.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.websocket import (\n    subscribe_to_channel, trigger_event, poll_for_events, unsubscribe,\n)\n\nrealtime_journey = Journey(\n    name=\"realtime_features\",\n    description=\"Test real-time WebSocket features\",\n    tags=[\"websocket\", \"realtime\", \"events\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"subscribe\", action=subscribe_to_channel),\n        Checkpoint(name=\"subscribed\"),\n        Branch(\n            checkpoint_name=\"subscribed\",\n            paths=[\n                Path(name=\"single_event\", steps=[\n                    Step(name=\"trigger\", action=trigger_event),\n                    Step(name=\"poll\", action=poll_for_events),\n                ]),\n                Path(name=\"multiple_events\", steps=[\n                    Step(name=\"trigger_1\", action=lambda c, ctx: trigger_event(c, ctx, \"event_1\")),\n                    Step(name=\"trigger_2\", action=lambda c, ctx: trigger_event(c, ctx, \"event_2\")),\n                    Step(name=\"trigger_3\", action=lambda c, ctx: trigger_event(c, ctx, \"event_3\")),\n                    Step(name=\"poll_multiple\", action=lambda c, ctx: poll_for_events(c, ctx, timeout=15)),\n                ]),\n            ],\n        ),\n        Step(name=\"unsubscribe\", action=unsubscribe),\n    ],\n)\n</code></pre>"},{"location":"examples/#third-party-api-mocking","title":"Third-Party API Mocking","text":"<p>Test with mocked third-party services.</p>"},{"location":"examples/#actions_6","title":"Actions","text":"Python<pre><code># actions/integrations.py\n\ndef configure_stripe_mock(client, context, scenario=\"success\"):\n    \"\"\"Configure Stripe mock for testing.\"\"\"\n    return client.post(\"/api/test/mock/stripe\", json={\n        \"scenario\": scenario,\n    })\n\ndef configure_sendgrid_mock(client, context, scenario=\"success\"):\n    \"\"\"Configure SendGrid mock for testing.\"\"\"\n    return client.post(\"/api/test/mock/sendgrid\", json={\n        \"scenario\": scenario,\n    })\n\ndef verify_email_sent(client, context):\n    \"\"\"Verify email was sent via mock.\"\"\"\n    response = client.get(\"/api/test/mock/sendgrid/emails\")\n\n    if response.status_code == 200:\n        emails = response.json().get(\"emails\", [])\n        if emails:\n            context[\"last_email\"] = emails[-1]\n\n    return response\n\ndef verify_stripe_charge(client, context):\n    \"\"\"Verify Stripe charge was created.\"\"\"\n    response = client.get(\"/api/test/mock/stripe/charges\")\n\n    if response.status_code == 200:\n        charges = response.json().get(\"charges\", [])\n        if charges:\n            context[\"last_charge\"] = charges[-1]\n\n    return response\n</code></pre>"},{"location":"examples/#journey_6","title":"Journey","text":"Python<pre><code># journeys/third_party_mocks.py\nfrom venomqa import Journey, Step, Checkpoint, Branch, Path\nfrom actions.auth import login\nfrom actions.integrations import (\n    configure_stripe_mock, configure_sendgrid_mock,\n    verify_email_sent, verify_stripe_charge,\n)\nfrom actions.payment import create_payment_intent, confirm_payment\nfrom actions.user_registration import register_user\n\nmocked_integration_journey = Journey(\n    name=\"third_party_mocks\",\n    description=\"Test with mocked third-party services\",\n    tags=[\"mocking\", \"integration\", \"testing\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Checkpoint(name=\"authenticated\"),\n\n        Branch(\n            checkpoint_name=\"authenticated\",\n            paths=[\n                Path(name=\"stripe_success\", steps=[\n                    Step(name=\"mock_stripe_ok\", action=lambda c, ctx: configure_stripe_mock(c, ctx, \"success\")),\n                    Step(name=\"create_payment\", action=create_payment_intent),\n                    Step(name=\"confirm_payment\", action=lambda c, ctx: confirm_payment(c, ctx, \"card_success\")),\n                    Step(name=\"verify_charge\", action=verify_stripe_charge),\n                ]),\n                Path(name=\"stripe_failure\", steps=[\n                    Step(name=\"mock_stripe_fail\", action=lambda c, ctx: configure_stripe_mock(c, ctx, \"card_declined\")),\n                    Step(name=\"create_payment_fail\", action=create_payment_intent),\n                    Step(\n                        name=\"confirm_fail\",\n                        action=lambda c, ctx: confirm_payment(c, ctx, \"card_declined\"),\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"email_success\", steps=[\n                    Step(name=\"mock_sendgrid_ok\", action=lambda c, ctx: configure_sendgrid_mock(c, ctx, \"success\")),\n                    Step(name=\"register_user\", action=register_user),\n                    Step(name=\"verify_email\", action=verify_email_sent),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"faq/","title":"FAQ","text":"<p>Common questions about VenomQA.</p>"},{"location":"faq/#general","title":"General","text":"<p>Q: What is VenomQA?</p> <p>A: VenomQA is a state-based API testing framework that helps you test your entire application through state exploration. Unlike traditional API testing tools that test endpoints in isolation, VenomQA tests complete user workflows and verifies that your system remains consistent after every action.</p>"},{"location":"faq/#getting-started","title":"Getting Started","text":"<p>Q: When should I use StateGraph vs Journey?</p> <p>A: Use each approach for different scenarios:</p> Scenario Recommended Approach Testing a specific user flow (login, checkout, etc.) Journey Exploring all possible state transitions StateGraph Smoke tests and quick sanity checks Journey Finding edge cases and unexpected paths StateGraph CI/CD integration Both work well <p>Journey is simpler and more intuitive - start here if you're new. It's like writing a script that a user would follow.</p> <p>StateGraph is more powerful - it automatically explores all paths through your system and finds bugs that linear tests miss.</p> Python<pre><code># Journey: Test one specific flow\njourney = Journey(\n    name=\"checkout\",\n    steps=[Step(name=\"login\", action=login), Step(name=\"checkout\", action=checkout)]\n)\n\n# StateGraph: Explore ALL state transitions\ngraph = StateGraph(name=\"shopping\")\ngraph.add_node(\"empty\", initial=True)\ngraph.add_node(\"has_items\")\ngraph.add_edge(\"empty\", \"has_items\", action=add_item)\ngraph.add_edge(\"has_items\", \"empty\", action=remove_item)\nresult = graph.explore(client)  # Tests all paths automatically\n</code></pre> <p>Q: Do I need PostgreSQL to use VenomQA?</p> <p>A: No! PostgreSQL is optional and only needed for advanced features:</p> Feature Requires Database? Basic Journey testing No HTTP assertions No Checkpoint/Branch (context only) No Checkpoint/Branch (database rollback) Yes (PostgreSQL, MySQL, or SQLite) StateGraph exploration No (but recommended for full rollback) <p>For most use cases, you can start without any database:</p> YAML<pre><code># venomqa.yaml - minimal config (no database)\nbase_url: \"http://localhost:8000\"\ntimeout: 30\n</code></pre> <p>If you need database state rollback, add:</p> YAML<pre><code># venomqa.yaml - with PostgreSQL\nbase_url: \"http://localhost:8000\"\ndb_url: \"postgresql://user:pass@localhost:5432/testdb\"\ndb_backend: \"postgresql\"\n</code></pre> <p>Q: How do I test without a real API?</p> <p>A: You have several options:</p> <ol> <li> <p>Use the test server we provide: Bash<pre><code>cd examples/quickstart\npip install fastapi uvicorn\npython test_server.py\n</code></pre></p> </li> <li> <p>Use mocking (for unit testing the framework itself): Python<pre><code>from venomqa.mocking import MockClient\n\nmock = MockClient()\nmock.when_get(\"/health\").respond({\"status\": \"ok\"})\n\njourney(mock)  # Uses mock responses\n</code></pre></p> </li> <li> <p>Use fixtures for predictable test data: Python<pre><code>from venomqa.data import DataFactory\n\nfactory = DataFactory()\nuser = factory.user(email=\"test@example.com\")\n</code></pre></p> </li> </ol> <p>Q: What's the difference between <code>context[\"key\"]</code> and <code>context.get(\"key\")</code>?</p> <p>A: They behave differently when the key doesn't exist:</p> Python<pre><code># context[\"key\"] - Raises KeyError if key doesn't exist\nitem_id = context[\"item_id\"]  # Crashes if item_id not set!\n\n# context.get(\"key\") - Returns None (or default) if key doesn't exist\nitem_id = context.get(\"item_id\")  # Returns None if not set\nitem_id = context.get(\"item_id\", default=1)  # Returns 1 if not set\n\n# context.get_required(\"key\") - Raises KeyError with a better error message\nitem_id = context.get_required(\"item_id\")  # KeyError: \"Required context key not found: item_id\"\n</code></pre> <p>Best practice: Use <code>context.get()</code> in most cases, and <code>context.get_required()</code> when the value MUST exist.</p>"},{"location":"faq/#common-errors","title":"Common Errors","text":"<p>Q: I get \"Connection refused\" error. What's wrong?</p> <p>A: Your API server isn't running or isn't accessible. Check:</p> <ol> <li> <p>Is the server running? Bash<pre><code># Check if anything is listening on the port\nlsof -i :8000\ncurl http://localhost:8000/health\n</code></pre></p> </li> <li> <p>Is <code>base_url</code> correct in <code>venomqa.yaml</code>? YAML<pre><code># Make sure this matches your actual server\nbase_url: \"http://localhost:8000\"  # Not https, correct port\n</code></pre></p> </li> <li> <p>If using Docker, is the network configured? YAML<pre><code># docker-compose.yml\nservices:\n  api:\n    ports:\n      - \"8000:8000\"  # Make sure port is exposed\n</code></pre></p> </li> </ol> <p>Q: I get \"Journey not found\" error. How do I fix it?</p> <p>A: VenomQA can't find your journey file. Check:</p> <ol> <li> <p>Is the file in the right directory? Text Only<pre><code>my-project/\n\u251c\u2500\u2500 journeys/           # Journeys go here\n\u2502   \u2514\u2500\u2500 my_journey.py\n\u2514\u2500\u2500 venomqa.yaml\n</code></pre></p> </li> <li> <p>Does the file have a <code>journey</code> variable? Python<pre><code># journeys/my_journey.py\nfrom venomqa import Journey, Step\n\njourney = Journey(  # Must be named 'journey' at module level\n    name=\"my_journey\",\n    steps=[...]\n)\n</code></pre></p> </li> <li> <p>Are you using the correct name? Bash<pre><code># Run with the journey 'name', not the filename\nvenomqa run my_journey      # Correct (uses name=\"my_journey\")\nvenomqa run my_journey.py   # Wrong (filename)\n</code></pre></p> </li> </ol> <p>List available journeys: Bash<pre><code>venomqa list\n</code></pre></p> <p>Q: I get \"KeyError: 'item_id'\" in my action. What happened?</p> <p>A: A previous step didn't set the value you're expecting. Common causes:</p> <ol> <li> <p>Previous step failed silently: Python<pre><code>def create_item(client, context):\n    response = client.post(\"/items\", json={...})\n    # This only sets item_id if successful!\n    if response.status_code == 201:\n        context[\"item_id\"] = response.json()[\"id\"]\n    return response\n</code></pre></p> </li> <li> <p>You're in a branch and context was reset:    Branches restore context to the checkpoint state. Make sure the value was set BEFORE the checkpoint.</p> </li> <li> <p>Typo in the key name: Python<pre><code>context[\"item_Id\"] = 123  # Set with capital I\ncontext[\"item_id\"]        # Get with lowercase i - KeyError!\n</code></pre></p> </li> </ol> <p>Fix: Use defensive programming: Python<pre><code>def get_item(client, context):\n    item_id = context.get(\"item_id\")\n    if not item_id:\n        raise ValueError(\"item_id not set - did create_item succeed?\")\n    return client.get(f\"/items/{item_id}\")\n</code></pre></p> <p>Q: How do I debug a failing step?</p> <p>A: Use verbose mode and add logging:</p> <ol> <li> <p>Run with verbose output: Bash<pre><code>venomqa run my_journey --verbose\n</code></pre></p> </li> <li> <p>Add logging to your actions: Python<pre><code>def create_item(client, context):\n    print(f\"Creating item with context: {dict(context._data)}\")\n    response = client.post(\"/items\", json={...})\n    print(f\"Response: {response.status_code} - {response.text}\")\n    return response\n</code></pre></p> </li> <li> <p>Check the response content: Python<pre><code>def create_item(client, context):\n    response = client.post(\"/items\", json={\"name\": \"test\"})\n    if response.status_code != 201:\n        print(f\"Unexpected status: {response.status_code}\")\n        print(f\"Response body: {response.json()}\")\n    return response\n</code></pre></p> </li> </ol> <p>Q: My step times out. How do I increase the timeout?</p> <p>A: Set timeout at the step or journey level:</p> Python<pre><code># Per-step timeout\nStep(\n    name=\"long_operation\",\n    action=long_operation,\n    timeout=120.0,  # 2 minutes\n)\n\n# Default timeout for all steps in journey\njourney = Journey(\n    name=\"my_journey\",\n    timeout=60.0,  # 1 minute default\n    steps=[...]\n)\n</code></pre> <p>Or in <code>venomqa.yaml</code>: YAML<pre><code>timeout: 60  # Global default in seconds\n</code></pre></p>"},{"location":"faq/#advanced-usage","title":"Advanced Usage","text":"<p>Q: How do I run the same journey with different data?</p> <p>A: Use the <code>args</code> parameter on steps:</p> Python<pre><code>def login(client, context, email, password):\n    return client.post(\"/login\", json={\"email\": email, \"password\": password})\n\n# Reuse the same action with different credentials\njourney = Journey(\n    name=\"multi_user_test\",\n    steps=[\n        Step(name=\"login_admin\", action=login, args={\"email\": \"admin@example.com\", \"password\": \"admin123\"}),\n        Step(name=\"logout\", action=logout),\n        Step(name=\"login_user\", action=login, args={\"email\": \"user@example.com\", \"password\": \"user123\"}),\n    ]\n)\n</code></pre> <p>Q: How do I test authentication flows?</p> <p>A: Store the token in context and use <code>client.set_auth_token()</code>:</p> Python<pre><code>def login(client, context):\n    response = client.post(\"/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n    if response.status_code == 200:\n        token = response.json()[\"access_token\"]\n        context[\"token\"] = token\n        client.set_auth_token(token)  # Sets Authorization: Bearer header\n    return response\n\ndef protected_action(client, context):\n    # Client automatically includes the auth header\n    return client.get(\"/api/protected\")\n</code></pre> <p>Q: Can I use VenomQA with GraphQL APIs?</p> <p>A: Yes! Use the GraphQL client:</p> Python<pre><code>from venomqa.clients.graphql import GraphQLClient\n\nclient = GraphQLClient(\"http://localhost:8000/graphql\")\n\ndef get_users(client, context):\n    query = \"\"\"\n    query {\n        users {\n            id\n            name\n            email\n        }\n    }\n    \"\"\"\n    return client.query(query)\n\ndef create_user(client, context):\n    mutation = \"\"\"\n    mutation CreateUser($name: String!, $email: String!) {\n        createUser(name: $name, email: $email) {\n            id\n            name\n        }\n    }\n    \"\"\"\n    return client.query(mutation, variables={\"name\": \"Test\", \"email\": \"test@example.com\"})\n</code></pre> <p>Q: How do I integrate VenomQA with CI/CD?</p> <p>A: VenomQA works with any CI system. Here's an example for GitHub Actions:</p> YAML<pre><code># .github/workflows/test.yml\nname: API Tests\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    services:\n      api:\n        image: your-api:latest\n        ports:\n          - 8000:8000\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install VenomQA\n        run: pip install venomqa\n\n      - name: Run tests\n        run: venomqa run --all\n\n      - name: Generate report\n        if: always()\n        run: venomqa report --format junit --output results.xml\n\n      - name: Upload results\n        uses: actions/upload-artifact@v3\n        with:\n          name: test-results\n          path: results.xml\n</code></pre> <p>Q: How do I test error handling in my API?</p> <p>A: Use <code>expect_failure=True</code> on steps that should fail:</p> Python<pre><code>journey = Journey(\n    name=\"error_handling\",\n    steps=[\n        # Test 401 Unauthorized\n        Step(\n            name=\"access_without_auth\",\n            action=lambda c, ctx: c.get(\"/api/protected\"),\n            expect_failure=True,\n        ),\n\n        # Test 404 Not Found\n        Step(\n            name=\"get_nonexistent\",\n            action=lambda c, ctx: c.get(\"/api/items/99999\"),\n            expect_failure=True,\n        ),\n\n        # Test 422 Validation Error\n        Step(\n            name=\"invalid_input\",\n            action=lambda c, ctx: c.post(\"/api/items\", json={\"price\": \"not_a_number\"}),\n            expect_failure=True,\n        ),\n    ]\n)\n</code></pre>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":"<p>Q: VenomQA is slow. How do I speed it up?</p> <p>A: Try these optimizations:</p> <ol> <li> <p>Use <code>--no-infra</code> if services are already running: Bash<pre><code>venomqa run --no-infra\n</code></pre></p> </li> <li> <p>Reduce unnecessary waits: Python<pre><code># Don't wait unnecessarily\nStep(name=\"fast_check\", action=fast_check, timeout=5.0)\n</code></pre></p> </li> <li> <p>Run tests in parallel (coming soon): Bash<pre><code>venomqa run --parallel 4\n</code></pre></p> </li> <li> <p>Use targeted test runs: Bash<pre><code>venomqa run specific_journey  # Instead of --all\n</code></pre></p> </li> </ol> <p>Q: Where can I get help?</p> <p>A: You have several options:</p> <ol> <li>Check the documentation: https://venomqa.dev/docs</li> <li>Search existing issues: https://github.com/namanag97/venomqa/issues</li> <li>Open a new issue: https://github.com/namanag97/venomqa/issues/new</li> <li>Join the community: (Coming soon)</li> </ol> <p>When reporting issues, include: - VenomQA version (<code>venomqa --version</code>) - Python version (<code>python --version</code>) - Your <code>venomqa.yaml</code> config (remove secrets) - The full error message and traceback</p>"},{"location":"plugins/","title":"VenomQA Plugin System","text":"<p>VenomQA provides a comprehensive plugin architecture that enables you to extend the framework's functionality. Plugins can add custom reporters, service adapters, data generators, reusable actions, and lifecycle hooks.</p>"},{"location":"plugins/#overview","title":"Overview","text":"<p>The plugin system supports five main extension points:</p> <ol> <li>Reporters - Custom output formats (Slack, DataDog, custom formats)</li> <li>Adapters - Service integrations (databases, caches, queues)</li> <li>Generators - Data generation (domain-specific test data)</li> <li>Actions - Reusable action sets (common test patterns)</li> <li>Hooks - Lifecycle callbacks (notifications, metrics, logging)</li> </ol>"},{"location":"plugins/#creating-a-plugin","title":"Creating a Plugin","text":""},{"location":"plugins/#basic-plugin-structure","title":"Basic Plugin Structure","text":"<p>All plugins inherit from <code>VenomQAPlugin</code>:</p> Python<pre><code>from venomqa.plugins import VenomQAPlugin, PluginType, HookPriority\n\nclass MyPlugin(VenomQAPlugin):\n    # Required: Plugin identifier\n    name = \"my-plugin\"\n    version = \"1.0.0\"\n\n    # Optional: Plugin type (default: HOOK)\n    plugin_type = PluginType.HOOK\n    description = \"My custom plugin\"\n    author = \"Your Name\"\n    priority = HookPriority.NORMAL\n\n    def on_load(self, config: dict) -&gt; None:\n        \"\"\"Called when plugin is loaded.\"\"\"\n        super().on_load(config)\n        self.api_key = config.get(\"api_key\")\n\n    def on_journey_start(self, context):\n        \"\"\"Called before each journey.\"\"\"\n        print(f\"Starting: {context.journey.name}\")\n\n    def on_failure(self, context):\n        \"\"\"Called when a test fails.\"\"\"\n        self.send_alert(context.error)\n</code></pre>"},{"location":"plugins/#plugin-types","title":"Plugin Types","text":""},{"location":"plugins/#hook-plugin","title":"Hook Plugin","text":"<p>For plugins that only need lifecycle callbacks:</p> Python<pre><code>from venomqa.plugins import HookPlugin, HookPriority\n\nclass NotifierPlugin(HookPlugin):\n    name = \"notifier\"\n    version = \"1.0.0\"\n    priority = HookPriority.LOW  # Run after other plugins\n\n    def on_failure(self, context):\n        self.send_notification(context)\n</code></pre>"},{"location":"plugins/#reporter-plugin","title":"Reporter Plugin","text":"<p>For plugins that provide custom report formats:</p> Python<pre><code>from venomqa.plugins import ReporterPlugin\nfrom venomqa.reporters.base import BaseReporter\n\nclass MyReporter(BaseReporter):\n    @property\n    def file_extension(self) -&gt; str:\n        return \".html\"\n\n    def generate(self, results):\n        return \"&lt;html&gt;...&lt;/html&gt;\"\n\nclass MyReporterPlugin(ReporterPlugin):\n    name = \"my-reporter\"\n    version = \"1.0.0\"\n\n    def get_reporter(self) -&gt; BaseReporter:\n        return MyReporter()\n</code></pre>"},{"location":"plugins/#adapter-plugin","title":"Adapter Plugin","text":"<p>For plugins that provide service adapters:</p> Python<pre><code>from venomqa.plugins import AdapterPlugin\n\nclass MongoDBPlugin(AdapterPlugin):\n    name = \"mongodb\"\n    version = \"1.0.0\"\n    provides_adapters = [\"database\"]\n\n    def get_adapter(self, port_type: str):\n        if port_type == \"database\":\n            return MongoDBAdapter(self.config)\n        return None\n</code></pre>"},{"location":"plugins/#action-plugin","title":"Action Plugin","text":"<p>For plugins that provide reusable actions:</p> Python<pre><code>from venomqa.plugins import ActionPlugin\n\nclass AuthActionsPlugin(ActionPlugin):\n    name = \"auth-actions\"\n    version = \"1.0.0\"\n\n    def get_actions(self) -&gt; dict:\n        return {\n            \"auth.login\": self._login,\n            \"auth.logout\": self._logout,\n            \"auth.refresh\": self._refresh_token,\n        }\n\n    def _login(self, client, ctx, **kwargs):\n        return client.post(\"/auth/login\", json=kwargs)\n</code></pre>"},{"location":"plugins/#available-hooks","title":"Available Hooks","text":""},{"location":"plugins/#plugin-lifecycle","title":"Plugin Lifecycle","text":"Hook Method Called When <code>ON_LOAD</code> <code>on_load(config)</code> Plugin is loaded <code>ON_UNLOAD</code> <code>on_unload()</code> Plugin is unloaded"},{"location":"plugins/#journey-lifecycle","title":"Journey Lifecycle","text":"Hook Method Called When <code>BEFORE_JOURNEY</code> <code>on_journey_start(context)</code> Before journey execution <code>AFTER_JOURNEY</code> <code>on_journey_complete(journey, result, context)</code> After journey completes <code>ON_JOURNEY_ERROR</code> <code>on_journey_error(journey, error, context)</code> Journey fails with exception"},{"location":"plugins/#step-lifecycle","title":"Step Lifecycle","text":"Hook Method Called When <code>BEFORE_STEP</code> <code>on_step_start(step, context)</code> Before step execution <code>AFTER_STEP</code> <code>on_step_complete(step, result, context)</code> After step completes <code>ON_STEP_ERROR</code> <code>on_step_error(step, error, context)</code> Step fails with exception"},{"location":"plugins/#branch-lifecycle","title":"Branch Lifecycle","text":"Hook Method Called When <code>BEFORE_BRANCH</code> <code>on_branch_start(branch, context)</code> Before branch exploration <code>AFTER_BRANCH</code> <code>on_branch_complete(branch, result, context)</code> After all paths complete <code>BEFORE_PATH</code> <code>on_path_start(path, context)</code> Before path execution <code>AFTER_PATH</code> <code>on_path_complete(path, result, context)</code> After path completes"},{"location":"plugins/#state-lifecycle","title":"State Lifecycle","text":"Hook Method Called When <code>ON_CHECKPOINT</code> <code>on_checkpoint(checkpoint_name, context)</code> Checkpoint created <code>ON_ROLLBACK</code> <code>on_rollback(checkpoint_name, context)</code> Rolling back to checkpoint"},{"location":"plugins/#error-handling","title":"Error Handling","text":"Hook Method Called When <code>ON_FAILURE</code> <code>on_failure(context)</code> Test failure captured <code>ON_RETRY</code> <code>on_retry(step, attempt, max_attempts, error, context)</code> Step being retried <code>ON_TIMEOUT</code> <code>on_timeout(step, timeout, context)</code> Step times out"},{"location":"plugins/#plugin-configuration","title":"Plugin Configuration","text":""},{"location":"plugins/#yaml-configuration","title":"YAML Configuration","text":"<p>Configure plugins in <code>venomqa.yaml</code>:</p> YAML<pre><code>plugins:\n  # Auto-discover plugins from entry points\n  auto_discover: true\n\n  # Local plugins directory\n  local_plugins_path: qa/plugins\n\n  # Plugin configurations\n  plugins:\n    # Reference by entry point name\n    - name: venomqa-slack\n      enabled: true\n      priority: low\n      config:\n        webhook_url: https://hooks.slack.com/services/...\n        channel: \"#qa-alerts\"\n\n    # Reference by module path\n    - name: venomqa.plugins.examples.timing_analyzer\n      config:\n        threshold_warning_ms: 1000\n\n    # Reference local file\n    - name: ./qa/plugins/custom.py\n      enabled: true\n</code></pre>"},{"location":"plugins/#programmatic-configuration","title":"Programmatic Configuration","text":"Python<pre><code>from venomqa.plugins import (\n    PluginManager,\n    PluginsConfig,\n    PluginConfig,\n    HookPriority,\n)\n\nconfig = PluginsConfig(\n    auto_discover=True,\n    local_plugins_path=\"qa/plugins\",\n    plugins=[\n        PluginConfig(\n            name=\"my-plugin\",\n            enabled=True,\n            priority=HookPriority.HIGH,\n            config={\"api_key\": \"xxx\"},\n        ),\n    ],\n)\n\nmanager = PluginManager()\nmanager.load_plugins_from_config(config)\n</code></pre>"},{"location":"plugins/#plugin-discovery","title":"Plugin Discovery","text":"<p>Plugins are discovered from multiple sources:</p>"},{"location":"plugins/#1-entry-points-recommended","title":"1. Entry Points (Recommended)","text":"<p>Register plugins in <code>pyproject.toml</code>:</p> TOML<pre><code>[project.entry-points.\"venomqa.plugins\"]\nmy-plugin = \"my_package.plugin:MyPlugin\"\n</code></pre> <p>Install the package and VenomQA will auto-discover it.</p>"},{"location":"plugins/#2-local-directory","title":"2. Local Directory","text":"<p>Place Python files in <code>qa/plugins/</code>:</p> Python<pre><code># qa/plugins/custom.py\nfrom venomqa.plugins import VenomQAPlugin\n\nclass CustomPlugin(VenomQAPlugin):\n    name = \"custom\"\n    version = \"1.0.0\"\n    ...\n\n# Either export directly:\nplugin = CustomPlugin()\n\n# Or use 'Plugin' class name:\nPlugin = CustomPlugin\n</code></pre>"},{"location":"plugins/#3-module-import","title":"3. Module Import","text":"<p>Load by module path:</p> Python<pre><code>manager.load_plugin(\"my_package.plugins.custom\")\n</code></pre>"},{"location":"plugins/#built-in-example-plugins","title":"Built-in Example Plugins","text":"<p>VenomQA includes several example plugins:</p>"},{"location":"plugins/#console-logger","title":"Console Logger","text":"<p>Rich console output during test execution:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.console_logger\n    config:\n      level: debug\n      color: true\n      show_timestamps: true\n</code></pre>"},{"location":"plugins/#timing-analyzer","title":"Timing Analyzer","text":"<p>Analyze step execution times:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.timing_analyzer\n    config:\n      threshold_warning_ms: 1000\n      threshold_critical_ms: 5000\n      track_percentiles: [50, 90, 95, 99]\n</code></pre>"},{"location":"plugins/#slack-notifier","title":"Slack Notifier","text":"<p>Send Slack notifications:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.slack_notifier\n    config:\n      webhook_url: ${SLACK_WEBHOOK_URL}\n      channel: \"#qa-alerts\"\n      notify_on_failure: true\n      mention_on_failure: \"@qa-team\"\n</code></pre>"},{"location":"plugins/#datadog-metrics","title":"DataDog Metrics","text":"<p>Report metrics to DataDog:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.datadog_metrics\n    config:\n      api_key: ${DATADOG_API_KEY}\n      prefix: venomqa\n      tags:\n        - env:production\n        - team:qa\n</code></pre>"},{"location":"plugins/#custom-assertions","title":"Custom Assertions","text":"<p>Additional assertion helpers:</p> YAML<pre><code>plugins:\n  - name: venomqa.plugins.examples.custom_assertions\n    config:\n      strict_mode: false\n</code></pre> <p>Use in steps:</p> Python<pre><code>from venomqa.plugins import get_plugin_manager\n\nmanager = get_plugin_manager()\nassertions = manager.get_assertion(\"assert_json_path\")\n\ndef my_step(client, ctx):\n    response = client.get(\"/api/users\")\n    assertions[\"assert_json_path\"](response, \"data.users.0.name\", \"John\")\n</code></pre>"},{"location":"plugins/#hook-priority","title":"Hook Priority","text":"<p>Control hook execution order with priorities:</p> Python<pre><code>from venomqa.plugins import HookPriority\n\nclass EarlyPlugin(VenomQAPlugin):\n    priority = HookPriority.HIGHEST  # Run first (0)\n\nclass LatePlugin(VenomQAPlugin):\n    priority = HookPriority.LOWEST   # Run last (100)\n</code></pre> <p>Priority levels: - <code>HIGHEST</code> (0) - <code>HIGH</code> (25) - <code>NORMAL</code> (50) - default - <code>LOW</code> (75) - <code>LOWEST</code> (100)</p>"},{"location":"plugins/#error-handling_1","title":"Error Handling","text":"<p>Plugin errors are isolated by default:</p> Python<pre><code># In PluginManager\nmanager = PluginManager(fail_on_plugin_error=False)  # Default\n\n# If True, plugin errors propagate and abort test execution\nmanager = PluginManager(fail_on_plugin_error=True)\n</code></pre>"},{"location":"plugins/#context-objects","title":"Context Objects","text":""},{"location":"plugins/#journeycontext","title":"JourneyContext","text":"Python<pre><code>@dataclass\nclass JourneyContext:\n    journey: Journey          # The Journey object\n    client: Client           # HTTP client\n    state_manager: Any       # State manager (optional)\n    context: ExecutionContext  # Shared state\n</code></pre>"},{"location":"plugins/#stepcontext","title":"StepContext","text":"Python<pre><code>@dataclass\nclass StepContext:\n    journey_name: str\n    path_name: str\n    step_name: str\n    step_number: int\n    step: Step\n    context: ExecutionContext\n</code></pre>"},{"location":"plugins/#failurecontext","title":"FailureContext","text":"Python<pre><code>@dataclass\nclass FailureContext:\n    journey_name: str\n    path_name: str\n    step_name: str\n    error: Exception | str\n    request: dict | None\n    response: dict | None\n    traceback: str | None\n</code></pre>"},{"location":"plugins/#best-practices","title":"Best Practices","text":"<ol> <li>Keep plugins focused - Each plugin should do one thing well</li> <li>Use appropriate priority - Logging plugins should run early, notifications late</li> <li>Handle errors gracefully - Don't let plugin failures break tests</li> <li>Document configuration - Clearly document required and optional config</li> <li>Version your plugins - Follow semantic versioning</li> <li>Test your plugins - Write unit tests for plugin logic</li> </ol>"},{"location":"preflight-configuration/","title":"Preflight Configuration","text":"<p>VenomQA's preflight system runs quick smoke tests against your API before executing a full test suite. This guide explains how to configure those tests using a YAML file so you can reuse the same checks across environments.</p>"},{"location":"preflight-configuration/#quick-start","title":"Quick Start","text":"<p>Generate a starter config:</p> Bash<pre><code>venomqa smoke-test --init &gt; preflight.yaml\n</code></pre> <p>Run smoke tests from the config:</p> Bash<pre><code>venomqa smoke-test --config preflight.yaml\n</code></pre>"},{"location":"preflight-configuration/#configuration-file-format","title":"Configuration File Format","text":"<p>A preflight config is a single YAML file with the following top-level keys:</p> YAML<pre><code>base_url: \"http://localhost:8000\"\ntimeout: 10.0\n\nauth:\n  token_env_var: \"API_TOKEN\"\n  header: \"Authorization\"\n  prefix: \"Bearer\"\n\nhealth_checks: [...]\nauth_checks: [...]\ncrud_checks: [...]\nlist_checks: [...]\ncustom_checks: [...]\n</code></pre>"},{"location":"preflight-configuration/#base-settings","title":"Base Settings","text":"Field Type Default Description <code>base_url</code> string <code>http://localhost:8000</code> Root URL of the API under test <code>timeout</code> float <code>10.0</code> HTTP timeout in seconds"},{"location":"preflight-configuration/#authentication","title":"Authentication","text":"YAML<pre><code>auth:\n  token_env_var: \"API_TOKEN\"   # Read token from this env var\n  # token: \"eyJ...\"           # Or hardcode a token\n  header: \"Authorization\"      # HTTP header name\n  prefix: \"Bearer\"             # Prefix before the token value\n</code></pre> Field Type Default Description <code>token</code> string - Hardcoded auth token <code>token_env_var</code> string - Env var name containing the token <code>header</code> string <code>Authorization</code> HTTP header to set <code>prefix</code> string <code>Bearer</code> Prefix before the token value <p>If both <code>token</code> and <code>token_env_var</code> are set, the explicit <code>token</code> takes precedence.</p>"},{"location":"preflight-configuration/#health-checks","title":"Health Checks","text":"<p>Verify the API is running and healthy.</p> YAML<pre><code>health_checks:\n  - path: /health\n    expected_status: [200]\n    expected_json:\n      status: \"healthy\"\n    timeout: 5.0  # Override global timeout\n\n  - path: /health/ready\n    expected_status: [200]\n</code></pre> Field Type Default Description <code>path</code> string <code>/health</code> Endpoint path <code>expected_status</code> list[int] <code>[200]</code> HTTP status codes treated as success <code>expected_json</code> dict - Response body must be a superset <code>timeout</code> float - Per-check timeout override"},{"location":"preflight-configuration/#auth-checks","title":"Auth Checks","text":"<p>Verify that authenticated requests succeed.</p> YAML<pre><code>auth_checks:\n  - path: /api/v1/me\n    expected_status: [200]\n\n  - path: /api/v1/workspaces\n    method: GET\n    expected_status: [200]\n</code></pre> Field Type Default Description <code>path</code> string <code>/api/v1/me</code> Auth-protected endpoint <code>method</code> string <code>GET</code> HTTP method <code>expected_status</code> list[int] <code>[200]</code> Success status codes"},{"location":"preflight-configuration/#crud-checks","title":"CRUD Checks","text":"<p>Verify resource creation works.</p> YAML<pre><code>crud_checks:\n  - name: \"Create workspace\"\n    path: /api/v1/workspaces\n    method: POST\n    payload:\n      name: \"Preflight Test ${RANDOM}\"\n    expected_status: [201, 409]\n    cleanup_path: /api/v1/workspaces/${id}\n</code></pre> Field Type Default Description <code>name</code> string - Human-readable label <code>path</code> string <code>/api/v1/resources</code> POST endpoint path <code>method</code> string <code>POST</code> HTTP method <code>payload</code> dict <code>{}</code> JSON body to send <code>expected_status</code> list[int] <code>[200, 201, 409]</code> Success status codes <code>cleanup_path</code> string - DELETE path template (future)"},{"location":"preflight-configuration/#list-checks","title":"List Checks","text":"<p>Verify list/pagination endpoints return data.</p> YAML<pre><code>list_checks:\n  - path: /api/v1/items\n    expected_type: array\n\n  - path: /api/v1/orders\n    expected_type: paginated\n</code></pre> Field Type Default Description <code>path</code> string <code>/api/v1/resources</code> GET endpoint path <code>expected_status</code> list[int] <code>[200]</code> Success status codes <code>expected_type</code> string <code>array</code> <code>\"array\"</code> or <code>\"paginated\"</code>"},{"location":"preflight-configuration/#custom-checks","title":"Custom Checks","text":"<p>Run any arbitrary HTTP request with validation.</p> YAML<pre><code>custom_checks:\n  - name: \"OpenAPI spec available\"\n    method: GET\n    path: /openapi.json\n    expected_status: [200]\n    expected_json:\n      openapi: \"3.0.0\"\n\n  - name: \"Create via PUT\"\n    method: PUT\n    path: /api/v1/settings\n    payload:\n      theme: \"dark\"\n    headers:\n      X-Custom: \"value\"\n    expected_status: [200, 204]\n</code></pre> Field Type Default Description <code>name</code> string <code>Custom check</code> Human-readable label <code>method</code> string <code>GET</code> HTTP method <code>path</code> string <code>/</code> Endpoint path <code>payload</code> dict - JSON body (for POST/PUT/PATCH) <code>headers</code> dict - Extra HTTP headers <code>expected_status</code> list[int] <code>[200]</code> Success status codes <code>expected_json</code> dict - Response must be a superset"},{"location":"preflight-configuration/#environment-variable-substitution","title":"Environment Variable Substitution","text":"<p>All string values in the YAML support <code>${VAR}</code> substitution.</p> Syntax Behavior <code>${VAR}</code> Replaced with env var value; error if not set <code>${VAR:default}</code> Replaced with env var value or <code>default</code> <code>${RANDOM}</code> Random 8-character hex string <code>${UUID}</code> Random UUID4 string <code>${TIMESTAMP}</code> Current UNIX timestamp <p>Example:</p> YAML<pre><code>base_url: \"${API_URL:http://localhost:8000}\"\ncrud_checks:\n  - path: /api/v1/items\n    payload:\n      name: \"test-${RANDOM}\"\n      id: \"${UUID}\"\n</code></pre>"},{"location":"preflight-configuration/#cli-usage","title":"CLI Usage","text":"Bash<pre><code># Run from config file\nvenomqa smoke-test --config preflight.yaml\n\n# Override base URL (e.g., for staging)\nvenomqa smoke-test --config preflight.yaml --base-url http://staging:8000\n\n# Override token\nvenomqa smoke-test --config preflight.yaml --token $STAGING_TOKEN\n\n# JSON output (for CI)\nvenomqa smoke-test --config preflight.yaml --json\n\n# Generate example config\nvenomqa smoke-test --init &gt; preflight.yaml\n</code></pre>"},{"location":"preflight-configuration/#programmatic-usage","title":"Programmatic Usage","text":"Python<pre><code>from venomqa.preflight import SmokeTest, PreflightConfig\n\n# From YAML file\nsmoke = SmokeTest.from_yaml(\"preflight.yaml\")\nreport = smoke.run_all()\nreport.print_report()\n\n# From config object\nconfig = PreflightConfig(\n    base_url=\"http://localhost:8000\",\n    health_checks=[HealthCheckConfig(path=\"/health\")],\n    crud_checks=[CRUDCheckConfig(path=\"/items\", payload={\"name\": \"test\"})],\n)\nsmoke = SmokeTest.from_config(config)\nreport = smoke.run_all()\n\n# From dict (e.g., loaded from another source)\nconfig = PreflightConfig.from_dict({\n    \"base_url\": \"http://localhost:8000\",\n    \"health_checks\": [{\"path\": \"/health\"}],\n})\nsmoke = SmokeTest.from_config(config)\n</code></pre>"},{"location":"preflight-configuration/#example-configs","title":"Example Configs","text":"<p>VenomQA includes pre-built configs for common frameworks in <code>examples/preflight_configs/</code>:</p> <ul> <li><code>generic_rest_api.yaml</code> -- Minimal config for any REST API</li> <li><code>fastapi_app.yaml</code> -- FastAPI with OpenAPI docs</li> <li><code>django_app.yaml</code> -- Django REST Framework</li> <li><code>dip_api.yaml</code> -- DIP API (the original use case)</li> </ul> <p>Copy one as a starting point:</p> Bash<pre><code>cp examples/preflight_configs/fastapi_app.yaml preflight.yaml\n# Edit to match your API\nvenomqa smoke-test --config preflight.yaml\n</code></pre>"},{"location":"roadmap/","title":"VenomQA Development Roadmap","text":""},{"location":"roadmap/#current-sprint-comprehensive-enhancement","title":"Current Sprint: Comprehensive Enhancement","text":"<p>Status: 22 parallel workstreams in progress</p>"},{"location":"roadmap/#workstreams","title":"Workstreams","text":""},{"location":"roadmap/#core-framework-improvements","title":"Core Framework Improvements","text":"# Task Status Description 1 Performance Optimization \ud83d\udd04 In Progress Connection pooling, parallel execution fix, caching, benchmarking 2 Retry and Timeout \ud83d\udd04 In Progress Configurable retries, timeouts, circuit breakers 3 Error Messages \ud83d\udd04 In Progress Better errors, debug mode, step-through mode"},{"location":"roadmap/#real-world-validation","title":"Real-World Validation","text":"# Task Status Description 4 Medusa Setup \ud83d\udd04 In Progress Clone, Docker setup, API exploration 5 Medusa Integration \ud83d\udd04 In Progress Full test suite with actions, fixtures, journeys 6 Test Scenarios \ud83d\udd04 In Progress Deep branching, concurrent users, failure recovery"},{"location":"roadmap/#developer-experience","title":"Developer Experience","text":"# Task Status Description 7 Watch Mode \ud83d\udd04 In Progress File watching, auto-rerun on changes 8 OpenAPI Import \ud83d\udd04 In Progress Auto-generate actions from API specs 9 Data Generation \ud83d\udd04 In Progress Faker integration, reproducible test data 10 Data Seeding \ud83d\udd04 In Progress Seed files, auto cleanup, isolation"},{"location":"roadmap/#reporting-and-output","title":"Reporting and Output","text":"# Task Status Description 11 CLI Output \ud83d\udd04 In Progress Real-time progress, better formatting 12 Result Persistence \ud83d\udd04 In Progress Save to database, history command 13 Run Comparison \ud83d\udd04 In Progress Diff between runs, baseline snapshots 14 Notifications \ud83d\udd04 In Progress Slack, email, PagerDuty alerts"},{"location":"roadmap/#testing-capabilities","title":"Testing Capabilities","text":"# Task Status Description 15 Load Testing \ud83d\udd04 In Progress Concurrent users, metrics, assertions 16 Security Testing \ud83d\udd04 In Progress OWASP checks, injection testing 17 Service Mocking \ud83d\udd04 In Progress Mock Stripe, SendGrid, etc. 18 GraphQL Support \ud83d\udd04 In Progress Enhanced queries, subscriptions"},{"location":"roadmap/#infrastructure","title":"Infrastructure","text":"# Task Status Description 19 CI/CD Examples \ud83d\udd04 In Progress GitHub Actions, GitLab CI, Docker 20 Environment Mgmt \ud83d\udd04 In Progress Multi-env configs, secrets 21 Plugin System \ud83d\udd04 In Progress Extensible architecture 22 Documentation \ud83d\udd04 In Progress MkDocs site, tutorials"},{"location":"roadmap/#previously-completed","title":"Previously Completed","text":"Task Status Fix CLI init bootstrap \u2705 Complete Fix optional imports \u2705 Complete Fix verbose flag \u2705 Complete Create examples README \u2705 Complete Document parallel limitation \u2705 Complete"},{"location":"roadmap/#success-metrics","title":"Success Metrics","text":""},{"location":"roadmap/#for-10-release","title":"For 1.0 Release","text":"<ul> <li> VenomQA runs successfully against Medusa e-commerce</li> <li> All 22 workstreams completed and tested</li> <li> Documentation site live</li> <li> PyPI package published</li> <li> At least 3 real-world examples working</li> <li> Test suite &gt;90% passing</li> <li> Performance: 100+ steps/second</li> </ul>"},{"location":"roadmap/#quality-gates","title":"Quality Gates","text":"<ul> <li>All new code has tests</li> <li>No regressions in existing tests</li> <li>Documentation updated</li> <li>Examples verified working</li> </ul>"},{"location":"roadmap/#timeline","title":"Timeline","text":"<ul> <li>Week 1-2: Core improvements, real-world validation</li> <li>Week 3-4: Developer experience, reporting</li> <li>Week 5-6: Testing capabilities, infrastructure</li> <li>Week 7-8: Polish, documentation, release</li> </ul>"},{"location":"roadmap/#architecture-goals","title":"Architecture Goals","text":"<ol> <li>Language Agnostic: Test any API (REST, GraphQL, gRPC)</li> <li>State Management: Database checkpoints and rollback</li> <li>Branching: Explore multiple paths from same state</li> <li>Extensible: Plugin system for customization</li> <li>Observable: Rich reporting and persistence</li> <li>Performant: Fast execution, parallel support</li> </ol>"},{"location":"examples/","title":"Examples","text":"<p>Real-world examples of VenomQA usage patterns.</p>"},{"location":"examples/#quick-links","title":"Quick Links","text":""},{"location":"examples/#crud-operations","title":"CRUD Operations","text":"<p>Test create, read, update, delete operations with proper validation.</p>"},{"location":"examples/#authentication-flows","title":"Authentication Flows","text":"<p>Login, registration, password reset, and token refresh patterns.</p>"},{"location":"examples/#e-commerce-checkout","title":"E-commerce Checkout","text":"<p>Complete checkout flow with multiple payment methods.</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":"Category Description CRUD Operations Basic CRUD with validation Authentication Auth flows and security testing E-commerce Shopping cart and checkout"},{"location":"examples/#minimal-example","title":"Minimal Example","text":"<p>The simplest possible journey:</p> Python<pre><code>from venomqa import Journey, Step\n\njourney = Journey(\n    name=\"health_check\",\n    steps=[\n        Step(\n            name=\"check_api\",\n            action=lambda c, ctx: c.get(\"/health\"),\n        ),\n    ],\n)\n</code></pre> <p>Run it:</p> Bash<pre><code>venomqa run health_check\n</code></pre>"},{"location":"examples/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/#context-sharing","title":"Context Sharing","text":"Python<pre><code>def create_user(client, context):\n    response = client.post(\"/api/users\", json={\"name\": \"John\"})\n    context[\"user_id\"] = response.json()[\"id\"]\n    return response\n\ndef get_user(client, context):\n    return client.get(f\"/api/users/{context['user_id']}\")\n\njourney = Journey(\n    name=\"user_flow\",\n    steps=[\n        Step(name=\"create\", action=create_user),\n        Step(name=\"retrieve\", action=get_user),\n    ],\n)\n</code></pre>"},{"location":"examples/#authentication","title":"Authentication","text":"Python<pre><code>def login(client, context):\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret\",\n    })\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n    return response\n\ndef protected_action(client, context):\n    return client.get(\"/api/protected\")\n\njourney = Journey(\n    name=\"auth_flow\",\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"access\", action=protected_action),\n    ],\n)\n</code></pre>"},{"location":"examples/#error-testing","title":"Error Testing","text":"Python<pre><code>journey = Journey(\n    name=\"error_handling\",\n    steps=[\n        Step(\n            name=\"unauthorized\",\n            action=lambda c, ctx: c.get(\"/api/admin\"),\n            expect_failure=True,\n        ),\n        Step(\n            name=\"not_found\",\n            action=lambda c, ctx: c.get(\"/api/users/999999\"),\n            expect_failure=True,\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#branching","title":"Branching","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\njourney = Journey(\n    name=\"payment_test\",\n    steps=[\n        Step(name=\"setup\", action=setup_order),\n        Checkpoint(name=\"ready_to_pay\"),\n        Branch(\n            checkpoint_name=\"ready_to_pay\",\n            paths=[\n                Path(name=\"card\", steps=[\n                    Step(name=\"pay\", action=pay_with_card),\n                ]),\n                Path(name=\"wallet\", steps=[\n                    Step(name=\"pay\", action=pay_with_wallet),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/#project-structure","title":"Project Structure","text":"<p>Recommended project layout:</p> Text Only<pre><code>my-tests/\n\u251c\u2500\u2500 venomqa.yaml              # Configuration\n\u251c\u2500\u2500 docker-compose.qa.yml     # Test infrastructure\n\u251c\u2500\u2500 journeys/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 login.py\n\u2502   \u2502   \u2514\u2500\u2500 registration.py\n\u2502   \u251c\u2500\u2500 checkout/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 payment.py\n\u2502   \u2514\u2500\u2500 admin/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 users.py\n\u251c\u2500\u2500 actions/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth.py               # Reusable auth actions\n\u2502   \u2514\u2500\u2500 users.py              # Reusable user actions\n\u2514\u2500\u2500 reports/\n    \u2514\u2500\u2500 (generated)\n</code></pre>"},{"location":"examples/#more-examples","title":"More Examples","text":"<p>See the examples directory for complete working examples:</p> <ul> <li><code>quickstart/</code> - Getting started examples</li> <li><code>fastapi-example/</code> - Testing a FastAPI application</li> <li><code>test-server/</code> - Example test server</li> </ul>"},{"location":"examples/auth/","title":"Authentication Flows","text":"<p>Examples of testing authentication and authorization.</p>"},{"location":"examples/auth/#basic-loginlogout","title":"Basic Login/Logout","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef login(client, context):\n    \"\"\"Login with valid credentials.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"token\"] = data[\"token\"]\n        context[\"user_id\"] = data[\"user\"][\"id\"]\n        client.set_auth_token(data[\"token\"])\n\n    return response\n\n\ndef get_profile(client, context):\n    \"\"\"Get authenticated user's profile.\"\"\"\n    return client.get(\"/api/users/me\")\n\n\ndef logout(client, context):\n    \"\"\"Logout and invalidate token.\"\"\"\n    return client.post(\"/api/auth/logout\")\n\n\ndef access_after_logout(client, context):\n    \"\"\"Try to access protected endpoint after logout.\"\"\"\n    return client.get(\"/api/users/me\")\n\n\njourney = Journey(\n    name=\"login_logout\",\n    description=\"Test login and logout flow\",\n    tags=[\"auth\", \"login\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"get_profile\", action=get_profile),\n        Step(name=\"logout\", action=logout),\n        Step(\n            name=\"access_after_logout\",\n            action=access_after_logout,\n            expect_failure=True,\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#user-registration","title":"User Registration","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\nimport uuid\n\n\ndef register_user(client, context):\n    \"\"\"Register a new user.\"\"\"\n    email = f\"test-{uuid.uuid4().hex[:8]}@example.com\"\n    context[\"email\"] = email\n    context[\"password\"] = \"SecurePass123!\"\n\n    response = client.post(\"/api/auth/register\", json={\n        \"email\": email,\n        \"password\": context[\"password\"],\n        \"name\": \"Test User\",\n    })\n\n    if response.status_code in [200, 201]:\n        context[\"user_id\"] = response.json().get(\"user_id\")\n\n    return response\n\n\ndef verify_email(client, context):\n    \"\"\"Verify email (mock token).\"\"\"\n    return client.post(\"/api/auth/verify-email\", json={\n        \"token\": \"mock-verification-token\",\n    })\n\n\ndef login_verified(client, context):\n    \"\"\"Login with verified account.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": context[\"email\"],\n        \"password\": context[\"password\"],\n    })\n\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n\n    return response\n\n\ndef login_unverified(client, context):\n    \"\"\"Try login without verification.\"\"\"\n    return client.post(\"/api/auth/login\", json={\n        \"email\": context[\"email\"],\n        \"password\": context[\"password\"],\n    })\n\n\njourney = Journey(\n    name=\"user_registration\",\n    description=\"Test user registration flow\",\n    tags=[\"auth\", \"registration\"],\n    steps=[\n        Step(name=\"register\", action=register_user),\n        Checkpoint(name=\"registered\"),\n\n        Branch(\n            checkpoint_name=\"registered\",\n            paths=[\n                Path(name=\"verified_login\", steps=[\n                    Step(name=\"verify\", action=verify_email),\n                    Step(name=\"login\", action=login_verified),\n                ]),\n                Path(name=\"unverified_login\", steps=[\n                    Step(\n                        name=\"login\",\n                        action=login_unverified,\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#password-reset","title":"Password Reset","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef request_password_reset(client, context):\n    \"\"\"Request password reset email.\"\"\"\n    return client.post(\"/api/auth/forgot-password\", json={\n        \"email\": \"test@example.com\",\n    })\n\n\ndef reset_password(client, context):\n    \"\"\"Reset password with token.\"\"\"\n    return client.post(\"/api/auth/reset-password\", json={\n        \"token\": \"mock-reset-token\",\n        \"password\": \"NewSecurePass456!\",\n    })\n\n\ndef login_with_new_password(client, context):\n    \"\"\"Login with new password.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"NewSecurePass456!\",\n    })\n\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n\n    return response\n\n\ndef login_with_old_password(client, context):\n    \"\"\"Try login with old password.\"\"\"\n    return client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n\n\njourney = Journey(\n    name=\"password_reset\",\n    description=\"Test password reset flow\",\n    tags=[\"auth\", \"password\"],\n    steps=[\n        Step(name=\"request_reset\", action=request_password_reset),\n        Step(name=\"reset_password\", action=reset_password),\n        Step(name=\"login_new\", action=login_with_new_password),\n        Step(\n            name=\"login_old\",\n            action=login_with_old_password,\n            expect_failure=True,\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#token-refresh","title":"Token Refresh","text":"Python<pre><code>from venomqa import Journey, Step\nimport time\n\n\ndef login_get_tokens(client, context):\n    \"\"\"Login and get access + refresh tokens.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"access_token\"] = data[\"access_token\"]\n        context[\"refresh_token\"] = data[\"refresh_token\"]\n        client.set_auth_token(data[\"access_token\"])\n\n    return response\n\n\ndef access_protected(client, context):\n    \"\"\"Access protected resource.\"\"\"\n    return client.get(\"/api/protected\")\n\n\ndef refresh_token(client, context):\n    \"\"\"Refresh access token.\"\"\"\n    response = client.post(\"/api/auth/refresh\", json={\n        \"refresh_token\": context[\"refresh_token\"],\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"access_token\"] = data[\"access_token\"]\n        client.set_auth_token(data[\"access_token\"])\n\n    return response\n\n\ndef use_old_token(client, context):\n    \"\"\"Try using old access token after refresh.\"\"\"\n    old_token = context.get(\"old_access_token\", context[\"access_token\"])\n    client.set_auth_token(old_token)\n    return client.get(\"/api/protected\")\n\n\njourney = Journey(\n    name=\"token_refresh\",\n    description=\"Test token refresh flow\",\n    tags=[\"auth\", \"tokens\"],\n    steps=[\n        Step(name=\"login\", action=login_get_tokens),\n        Step(name=\"access\", action=access_protected),\n        Step(name=\"refresh\", action=refresh_token),\n        Step(name=\"access_new_token\", action=access_protected),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#authorization-testing","title":"Authorization Testing","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\n\ndef login_as_user(client, context):\n    \"\"\"Login as regular user.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"user@example.com\",\n        \"password\": \"userpass\",\n    })\n\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n        context[\"role\"] = \"user\"\n\n    return response\n\n\ndef login_as_admin(client, context):\n    \"\"\"Login as admin.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"admin@example.com\",\n        \"password\": \"adminpass\",\n    })\n\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n        context[\"role\"] = \"admin\"\n\n    return response\n\n\ndef access_user_endpoint(client, context):\n    \"\"\"Access user-level endpoint.\"\"\"\n    return client.get(\"/api/users/me\")\n\n\ndef access_admin_endpoint(client, context):\n    \"\"\"Access admin-only endpoint.\"\"\"\n    return client.get(\"/api/admin/users\")\n\n\ndef access_superadmin_endpoint(client, context):\n    \"\"\"Access superadmin-only endpoint.\"\"\"\n    return client.get(\"/api/admin/settings\")\n\n\njourney = Journey(\n    name=\"authorization\",\n    description=\"Test role-based authorization\",\n    tags=[\"auth\", \"authorization\", \"rbac\"],\n    steps=[\n        Checkpoint(name=\"start\"),\n\n        Branch(\n            checkpoint_name=\"start\",\n            paths=[\n                Path(name=\"user_permissions\", steps=[\n                    Step(name=\"login\", action=login_as_user),\n                    Step(name=\"user_endpoint\", action=access_user_endpoint),\n                    Step(\n                        name=\"admin_endpoint\",\n                        action=access_admin_endpoint,\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"admin_permissions\", steps=[\n                    Step(name=\"login\", action=login_as_admin),\n                    Step(name=\"user_endpoint\", action=access_user_endpoint),\n                    Step(name=\"admin_endpoint\", action=access_admin_endpoint),\n                    Step(\n                        name=\"superadmin_endpoint\",\n                        action=access_superadmin_endpoint,\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#oauth-flow","title":"OAuth Flow","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef initiate_oauth(client, context):\n    \"\"\"Start OAuth flow.\"\"\"\n    response = client.get(\"/api/auth/oauth/google/authorize\")\n\n    if response.status_code == 200:\n        context[\"oauth_url\"] = response.json()[\"authorize_url\"]\n        context[\"state\"] = response.json()[\"state\"]\n\n    return response\n\n\ndef oauth_callback(client, context):\n    \"\"\"Handle OAuth callback.\"\"\"\n    # Simulate OAuth provider callback\n    response = client.get(\"/api/auth/oauth/google/callback\", params={\n        \"code\": \"mock-oauth-code\",\n        \"state\": context[\"state\"],\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"token\"] = data[\"token\"]\n        client.set_auth_token(data[\"token\"])\n\n    return response\n\n\ndef get_oauth_profile(client, context):\n    \"\"\"Get profile after OAuth login.\"\"\"\n    return client.get(\"/api/users/me\")\n\n\njourney = Journey(\n    name=\"oauth_google\",\n    description=\"Test Google OAuth flow\",\n    tags=[\"auth\", \"oauth\"],\n    steps=[\n        Step(name=\"initiate\", action=initiate_oauth),\n        Step(name=\"callback\", action=oauth_callback),\n        Step(name=\"profile\", action=get_oauth_profile),\n    ],\n)\n</code></pre>"},{"location":"examples/auth/#security-testing","title":"Security Testing","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef test_sql_injection(client, context):\n    \"\"\"Test SQL injection prevention.\"\"\"\n    return client.post(\"/api/auth/login\", json={\n        \"email\": \"'; DROP TABLE users; --\",\n        \"password\": \"test\",\n    })\n\n\ndef test_xss_prevention(client, context):\n    \"\"\"Test XSS prevention.\"\"\"\n    return client.post(\"/api/users\", json={\n        \"name\": \"&lt;script&gt;alert('xss')&lt;/script&gt;\",\n    })\n\n\ndef test_rate_limiting(client, context):\n    \"\"\"Test rate limiting (many requests).\"\"\"\n    for i in range(100):\n        response = client.post(\"/api/auth/login\", json={\n            \"email\": \"test@example.com\",\n            \"password\": \"wrong\",\n        })\n        if response.status_code == 429:  # Rate limited\n            return response\n\n    return response\n\n\ndef test_brute_force_protection(client, context):\n    \"\"\"Test brute force protection.\"\"\"\n    for i in range(10):\n        client.post(\"/api/auth/login\", json={\n            \"email\": \"test@example.com\",\n            \"password\": f\"wrongpassword{i}\",\n        })\n\n    # Account should be locked\n    return client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"correctpassword\",\n    })\n\n\njourney = Journey(\n    name=\"security_tests\",\n    description=\"Test security measures\",\n    tags=[\"auth\", \"security\"],\n    steps=[\n        Step(\n            name=\"sql_injection\",\n            action=test_sql_injection,\n            expect_failure=True,\n        ),\n        Step(\n            name=\"xss_prevention\",\n            action=test_xss_prevention,\n            expect_failure=True,\n        ),\n        Step(\n            name=\"rate_limiting\",\n            action=test_rate_limiting,\n            expect_failure=True,\n        ),\n        Step(\n            name=\"brute_force\",\n            action=test_brute_force_protection,\n            expect_failure=True,\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/checkout/","title":"E-commerce Checkout","text":"<p>Complete examples of testing e-commerce checkout flows.</p>"},{"location":"examples/checkout/#complete-checkout-journey","title":"Complete Checkout Journey","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\n\n# ====================\n# Setup Actions\n# ====================\n\ndef login(client, context):\n    \"\"\"Authenticate user.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"shopper@example.com\",\n        \"password\": \"shopperpass\",\n    })\n\n    if response.status_code == 200:\n        data = response.json()\n        context[\"token\"] = data[\"token\"]\n        context[\"user_id\"] = data[\"user\"][\"id\"]\n        client.set_auth_token(data[\"token\"])\n\n    return response\n\n\ndef browse_products(client, context):\n    \"\"\"Browse available products.\"\"\"\n    response = client.get(\"/api/products\", params={\"category\": \"electronics\"})\n\n    if response.status_code == 200:\n        products = response.json()[\"products\"]\n        if products:\n            context[\"product_id\"] = products[0][\"id\"]\n            context[\"product_price\"] = products[0][\"price\"]\n\n    return response\n\n\ndef add_to_cart(client, context):\n    \"\"\"Add product to cart.\"\"\"\n    response = client.post(\"/api/cart/items\", json={\n        \"product_id\": context[\"product_id\"],\n        \"quantity\": 2,\n    })\n\n    if response.status_code in [200, 201]:\n        data = response.json()\n        context[\"cart_id\"] = data[\"cart_id\"]\n        context[\"cart_total\"] = data[\"total\"]\n\n    return response\n\n\ndef apply_coupon(client, context):\n    \"\"\"Apply discount coupon.\"\"\"\n    response = client.post(f\"/api/cart/{context['cart_id']}/coupon\", json={\n        \"code\": \"SAVE10\",\n    })\n\n    if response.status_code == 200:\n        context[\"discount\"] = response.json()[\"discount\"]\n        context[\"cart_total\"] = response.json()[\"total\"]\n\n    return response\n\n\ndef set_shipping_address(client, context):\n    \"\"\"Set shipping address.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/shipping\", json={\n        \"address\": {\n            \"name\": \"John Doe\",\n            \"street\": \"123 Main St\",\n            \"city\": \"New York\",\n            \"state\": \"NY\",\n            \"zip\": \"10001\",\n            \"country\": \"US\",\n        },\n    })\n\n\ndef create_order(client, context):\n    \"\"\"Create order from cart.\"\"\"\n    response = client.post(\"/api/orders\", json={\n        \"cart_id\": context[\"cart_id\"],\n    })\n\n    if response.status_code in [200, 201]:\n        data = response.json()\n        context[\"order_id\"] = data[\"id\"]\n        context[\"order_total\"] = data[\"total\"]\n\n    return response\n\n\n# ====================\n# Payment Actions\n# ====================\n\ndef pay_with_card_success(client, context):\n    \"\"\"Pay with valid credit card.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"credit_card\",\n        \"card\": {\n            \"number\": \"4242424242424242\",\n            \"exp_month\": 12,\n            \"exp_year\": 2025,\n            \"cvv\": \"123\",\n        },\n    })\n\n\ndef pay_with_card_declined(client, context):\n    \"\"\"Pay with card that will be declined.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"credit_card\",\n        \"card\": {\n            \"number\": \"4000000000000002\",  # Decline test card\n            \"exp_month\": 12,\n            \"exp_year\": 2025,\n            \"cvv\": \"123\",\n        },\n    })\n\n\ndef pay_with_paypal(client, context):\n    \"\"\"Pay with PayPal.\"\"\"\n    response = client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"paypal\",\n        \"return_url\": \"https://example.com/success\",\n        \"cancel_url\": \"https://example.com/cancel\",\n    })\n\n    if response.status_code == 200:\n        context[\"paypal_redirect\"] = response.json()[\"redirect_url\"]\n\n    return response\n\n\ndef pay_with_wallet(client, context):\n    \"\"\"Pay with digital wallet.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"wallet\",\n        \"wallet_id\": context.get(\"wallet_id\", \"default\"),\n    })\n\n\ndef pay_with_installments(client, context):\n    \"\"\"Pay in installments.\"\"\"\n    return client.post(\"/api/payments\", json={\n        \"order_id\": context[\"order_id\"],\n        \"method\": \"installments\",\n        \"installment_plan\": {\n            \"count\": 3,\n            \"interval\": \"monthly\",\n        },\n    })\n\n\n# ====================\n# Verification Actions\n# ====================\n\ndef verify_order_completed(client, context):\n    \"\"\"Verify order status is completed.\"\"\"\n    response = client.get(f\"/api/orders/{context['order_id']}\")\n\n    if response.status_code == 200:\n        status = response.json()[\"status\"]\n        if status not in [\"completed\", \"processing\"]:\n            raise AssertionError(f\"Expected completed, got {status}\")\n\n    return response\n\n\ndef get_order_receipt(client, context):\n    \"\"\"Get order receipt.\"\"\"\n    return client.get(f\"/api/orders/{context['order_id']}/receipt\")\n\n\n# ====================\n# Journey Definition\n# ====================\n\njourney = Journey(\n    name=\"checkout_complete\",\n    description=\"Complete checkout flow with multiple payment options\",\n    tags=[\"checkout\", \"payment\", \"e-commerce\", \"critical\"],\n    steps=[\n        # Setup\n        Step(name=\"login\", action=login),\n        Step(name=\"browse\", action=browse_products),\n        Step(name=\"add_to_cart\", action=add_to_cart),\n        Step(name=\"apply_coupon\", action=apply_coupon),\n        Step(name=\"set_shipping\", action=set_shipping_address),\n        Step(name=\"create_order\", action=create_order),\n\n        # Save state before payment\n        Checkpoint(name=\"ready_to_pay\"),\n\n        # Test all payment methods\n        Branch(\n            checkpoint_name=\"ready_to_pay\",\n            paths=[\n                # Credit card success\n                Path(name=\"card_success\", steps=[\n                    Step(name=\"pay\", action=pay_with_card_success),\n                    Step(name=\"verify\", action=verify_order_completed),\n                    Step(name=\"receipt\", action=get_order_receipt),\n                ]),\n\n                # Credit card declined\n                Path(name=\"card_declined\", steps=[\n                    Step(\n                        name=\"pay\",\n                        action=pay_with_card_declined,\n                        expect_failure=True,\n                    ),\n                ]),\n\n                # PayPal\n                Path(name=\"paypal\", steps=[\n                    Step(name=\"pay\", action=pay_with_paypal),\n                ]),\n\n                # Digital wallet\n                Path(name=\"wallet\", steps=[\n                    Step(name=\"pay\", action=pay_with_wallet),\n                    Step(name=\"verify\", action=verify_order_completed),\n                ]),\n\n                # Installments\n                Path(name=\"installments\", steps=[\n                    Step(name=\"pay\", action=pay_with_installments),\n                    Step(name=\"verify\", action=verify_order_completed),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/checkout/#cart-operations","title":"Cart Operations","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint\n\n\ndef login(client, context):\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n    if response.status_code == 200:\n        client.set_auth_token(response.json()[\"token\"])\n    return response\n\n\ndef create_cart(client, context):\n    \"\"\"Create a new cart.\"\"\"\n    response = client.post(\"/api/cart\")\n    if response.status_code in [200, 201]:\n        context[\"cart_id\"] = response.json()[\"id\"]\n    return response\n\n\ndef add_item_1(client, context):\n    \"\"\"Add first item to cart.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/items\", json={\n        \"product_id\": 1,\n        \"quantity\": 2,\n    })\n\n\ndef add_item_2(client, context):\n    \"\"\"Add second item to cart.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/items\", json={\n        \"product_id\": 2,\n        \"quantity\": 1,\n    })\n\n\ndef update_quantity(client, context):\n    \"\"\"Update item quantity.\"\"\"\n    return client.patch(f\"/api/cart/{context['cart_id']}/items/1\", json={\n        \"quantity\": 5,\n    })\n\n\ndef remove_item(client, context):\n    \"\"\"Remove item from cart.\"\"\"\n    return client.delete(f\"/api/cart/{context['cart_id']}/items/2\")\n\n\ndef get_cart(client, context):\n    \"\"\"Get cart contents.\"\"\"\n    return client.get(f\"/api/cart/{context['cart_id']}\")\n\n\ndef clear_cart(client, context):\n    \"\"\"Clear all items from cart.\"\"\"\n    return client.delete(f\"/api/cart/{context['cart_id']}/items\")\n\n\njourney = Journey(\n    name=\"cart_operations\",\n    description=\"Test shopping cart operations\",\n    tags=[\"cart\", \"e-commerce\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Step(name=\"create_cart\", action=create_cart),\n        Checkpoint(name=\"cart_created\"),\n        Step(name=\"add_item_1\", action=add_item_1),\n        Step(name=\"add_item_2\", action=add_item_2),\n        Step(name=\"view_cart\", action=get_cart),\n        Step(name=\"update_quantity\", action=update_quantity),\n        Step(name=\"remove_item\", action=remove_item),\n        Step(name=\"view_updated\", action=get_cart),\n        Step(name=\"clear_cart\", action=clear_cart),\n    ],\n)\n</code></pre>"},{"location":"examples/checkout/#order-management","title":"Order Management","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\n\ndef setup_and_create_order(client, context):\n    \"\"\"Setup and create an order.\"\"\"\n    # Login\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n    client.set_auth_token(response.json()[\"token\"])\n\n    # Create order\n    response = client.post(\"/api/orders\", json={\n        \"items\": [{\"product_id\": 1, \"quantity\": 2}],\n        \"shipping_address\": {\"street\": \"123 Main St\", \"city\": \"NYC\"},\n    })\n    context[\"order_id\"] = response.json()[\"id\"]\n\n    return response\n\n\ndef pay_order(client, context):\n    \"\"\"Pay for the order.\"\"\"\n    return client.post(f\"/api/orders/{context['order_id']}/pay\", json={\n        \"method\": \"credit_card\",\n        \"card_token\": \"tok_visa\",\n    })\n\n\ndef cancel_order(client, context):\n    \"\"\"Cancel the order.\"\"\"\n    return client.post(f\"/api/orders/{context['order_id']}/cancel\", json={\n        \"reason\": \"Changed my mind\",\n    })\n\n\ndef request_refund(client, context):\n    \"\"\"Request a refund.\"\"\"\n    return client.post(f\"/api/orders/{context['order_id']}/refund\", json={\n        \"reason\": \"Product not as described\",\n    })\n\n\ndef get_order_status(client, context):\n    \"\"\"Get order status.\"\"\"\n    return client.get(f\"/api/orders/{context['order_id']}\")\n\n\ndef get_order_tracking(client, context):\n    \"\"\"Get shipping tracking info.\"\"\"\n    return client.get(f\"/api/orders/{context['order_id']}/tracking\")\n\n\njourney = Journey(\n    name=\"order_lifecycle\",\n    description=\"Test order lifecycle\",\n    tags=[\"orders\", \"e-commerce\"],\n    steps=[\n        Step(name=\"create_order\", action=setup_and_create_order),\n        Checkpoint(name=\"order_created\"),\n\n        Branch(\n            checkpoint_name=\"order_created\",\n            paths=[\n                # Normal flow: pay and track\n                Path(name=\"complete_flow\", steps=[\n                    Step(name=\"pay\", action=pay_order),\n                    Step(name=\"status\", action=get_order_status),\n                    Step(name=\"tracking\", action=get_order_tracking),\n                ]),\n\n                # Cancel before payment\n                Path(name=\"cancel_unpaid\", steps=[\n                    Step(name=\"cancel\", action=cancel_order),\n                    Step(name=\"verify_cancelled\", action=get_order_status),\n                ]),\n\n                # Pay then refund\n                Path(name=\"refund_flow\", steps=[\n                    Step(name=\"pay\", action=pay_order),\n                    Step(name=\"refund\", action=request_refund),\n                    Step(name=\"verify_refunded\", action=get_order_status),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/checkout/#inventory-testing","title":"Inventory Testing","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint\n\n\ndef check_stock(client, context):\n    \"\"\"Check product stock.\"\"\"\n    response = client.get(\"/api/products/1/stock\")\n    context[\"initial_stock\"] = response.json()[\"quantity\"]\n    return response\n\n\ndef add_to_cart_available(client, context):\n    \"\"\"Add available quantity to cart.\"\"\"\n    return client.post(\"/api/cart/items\", json={\n        \"product_id\": 1,\n        \"quantity\": 2,\n    })\n\n\ndef add_to_cart_excess(client, context):\n    \"\"\"Try to add more than available.\"\"\"\n    return client.post(\"/api/cart/items\", json={\n        \"product_id\": 1,\n        \"quantity\": 999999,\n    })\n\n\ndef complete_purchase(client, context):\n    \"\"\"Complete purchase.\"\"\"\n    return client.post(\"/api/checkout\", json={\n        \"payment_method\": \"credit_card\",\n        \"card_token\": \"tok_visa\",\n    })\n\n\ndef check_stock_after(client, context):\n    \"\"\"Check stock after purchase.\"\"\"\n    response = client.get(\"/api/products/1/stock\")\n    context[\"final_stock\"] = response.json()[\"quantity\"]\n    return response\n\n\njourney = Journey(\n    name=\"inventory_management\",\n    description=\"Test inventory during checkout\",\n    tags=[\"inventory\", \"stock\", \"e-commerce\"],\n    steps=[\n        Step(name=\"check_initial_stock\", action=check_stock),\n        Step(name=\"add_available\", action=add_to_cart_available),\n        Step(\n            name=\"add_excess\",\n            action=add_to_cart_excess,\n            expect_failure=True,\n        ),\n        Step(name=\"purchase\", action=complete_purchase),\n        Step(name=\"check_final_stock\", action=check_stock_after),\n    ],\n)\n</code></pre>"},{"location":"examples/checkout/#promotion-and-discount-testing","title":"Promotion and Discount Testing","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint, Branch, Path\n\n\ndef setup_cart(client, context):\n    \"\"\"Setup cart with items.\"\"\"\n    client.post(\"/api/auth/login\", json={\n        \"email\": \"test@example.com\",\n        \"password\": \"secret123\",\n    })\n\n    response = client.post(\"/api/cart/items\", json={\n        \"product_id\": 1,\n        \"quantity\": 3,\n    })\n    context[\"cart_id\"] = response.json()[\"cart_id\"]\n    context[\"original_total\"] = response.json()[\"total\"]\n\n    return response\n\n\ndef apply_percentage_coupon(client, context):\n    \"\"\"Apply percentage discount coupon.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/coupon\", json={\n        \"code\": \"SAVE20\",  # 20% off\n    })\n\n\ndef apply_fixed_coupon(client, context):\n    \"\"\"Apply fixed amount coupon.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/coupon\", json={\n        \"code\": \"FLAT10\",  # $10 off\n    })\n\n\ndef apply_expired_coupon(client, context):\n    \"\"\"Apply expired coupon.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/coupon\", json={\n        \"code\": \"EXPIRED2023\",\n    })\n\n\ndef apply_invalid_coupon(client, context):\n    \"\"\"Apply invalid coupon.\"\"\"\n    return client.post(f\"/api/cart/{context['cart_id']}/coupon\", json={\n        \"code\": \"NOTREAL\",\n    })\n\n\ndef remove_coupon(client, context):\n    \"\"\"Remove applied coupon.\"\"\"\n    return client.delete(f\"/api/cart/{context['cart_id']}/coupon\")\n\n\njourney = Journey(\n    name=\"coupon_testing\",\n    description=\"Test coupon and discount functionality\",\n    tags=[\"coupons\", \"discounts\", \"e-commerce\"],\n    steps=[\n        Step(name=\"setup\", action=setup_cart),\n        Checkpoint(name=\"cart_ready\"),\n\n        Branch(\n            checkpoint_name=\"cart_ready\",\n            paths=[\n                Path(name=\"percentage_discount\", steps=[\n                    Step(name=\"apply\", action=apply_percentage_coupon),\n                    Step(name=\"remove\", action=remove_coupon),\n                ]),\n                Path(name=\"fixed_discount\", steps=[\n                    Step(name=\"apply\", action=apply_fixed_coupon),\n                ]),\n                Path(name=\"expired_coupon\", steps=[\n                    Step(\n                        name=\"apply\",\n                        action=apply_expired_coupon,\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"invalid_coupon\", steps=[\n                    Step(\n                        name=\"apply\",\n                        action=apply_invalid_coupon,\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/","title":"CRUD Operations","text":"<p>Examples of testing Create, Read, Update, Delete operations.</p>"},{"location":"examples/crud/#basic-crud-journey","title":"Basic CRUD Journey","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint\n\ndef create_item(client, context):\n    \"\"\"Create a new item.\"\"\"\n    response = client.post(\"/api/items\", json={\n        \"name\": \"Test Item\",\n        \"price\": 29.99,\n        \"description\": \"A test item\",\n    })\n\n    if response.status_code in [200, 201]:\n        context[\"item_id\"] = response.json()[\"id\"]\n        context[\"item_name\"] = response.json()[\"name\"]\n\n    return response\n\n\ndef read_item(client, context):\n    \"\"\"Read the created item.\"\"\"\n    item_id = context.get_required(\"item_id\")\n    return client.get(f\"/api/items/{item_id}\")\n\n\ndef update_item(client, context):\n    \"\"\"Update the item.\"\"\"\n    item_id = context.get_required(\"item_id\")\n    return client.put(f\"/api/items/{item_id}\", json={\n        \"name\": \"Updated Item\",\n        \"price\": 39.99,\n        \"description\": \"An updated test item\",\n    })\n\n\ndef delete_item(client, context):\n    \"\"\"Delete the item.\"\"\"\n    item_id = context.get_required(\"item_id\")\n    return client.delete(f\"/api/items/{item_id}\")\n\n\ndef verify_deleted(client, context):\n    \"\"\"Verify item no longer exists.\"\"\"\n    item_id = context.get_required(\"item_id\")\n    return client.get(f\"/api/items/{item_id}\")\n\n\njourney = Journey(\n    name=\"item_crud\",\n    description=\"Test complete CRUD operations for items\",\n    tags=[\"crud\", \"items\"],\n    steps=[\n        Step(name=\"create\", action=create_item),\n        Checkpoint(name=\"item_created\"),\n        Step(name=\"read\", action=read_item),\n        Step(name=\"update\", action=update_item),\n        Step(name=\"read_updated\", action=read_item),\n        Step(name=\"delete\", action=delete_item),\n        Step(\n            name=\"verify_deleted\",\n            action=verify_deleted,\n            expect_failure=True,\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/#crud-with-authentication","title":"CRUD with Authentication","text":"Python<pre><code>from venomqa import Journey, Step, Checkpoint\n\n\ndef login(client, context):\n    \"\"\"Login to get auth token.\"\"\"\n    response = client.post(\"/api/auth/login\", json={\n        \"email\": \"admin@example.com\",\n        \"password\": \"admin123\",\n    })\n\n    if response.status_code == 200:\n        token = response.json()[\"token\"]\n        context[\"token\"] = token\n        client.set_auth_token(token)\n\n    return response\n\n\ndef create_user(client, context):\n    \"\"\"Create a new user.\"\"\"\n    response = client.post(\"/api/users\", json={\n        \"email\": \"newuser@example.com\",\n        \"name\": \"New User\",\n        \"role\": \"member\",\n    })\n\n    if response.status_code in [200, 201]:\n        context[\"user_id\"] = response.json()[\"id\"]\n\n    return response\n\n\ndef read_user(client, context):\n    \"\"\"Read user details.\"\"\"\n    user_id = context.get_required(\"user_id\")\n    return client.get(f\"/api/users/{user_id}\")\n\n\ndef update_user(client, context):\n    \"\"\"Update user details.\"\"\"\n    user_id = context.get_required(\"user_id\")\n    return client.patch(f\"/api/users/{user_id}\", json={\n        \"name\": \"Updated User\",\n        \"role\": \"admin\",\n    })\n\n\ndef delete_user(client, context):\n    \"\"\"Delete user.\"\"\"\n    user_id = context.get_required(\"user_id\")\n    return client.delete(f\"/api/users/{user_id}\")\n\n\njourney = Journey(\n    name=\"user_crud_admin\",\n    description=\"Admin CRUD operations for users\",\n    tags=[\"crud\", \"users\", \"admin\"],\n    steps=[\n        Step(name=\"login\", action=login),\n        Checkpoint(name=\"authenticated\"),\n        Step(name=\"create_user\", action=create_user),\n        Checkpoint(name=\"user_created\"),\n        Step(name=\"read_user\", action=read_user),\n        Step(name=\"update_user\", action=update_user),\n        Step(name=\"verify_update\", action=read_user),\n        Step(name=\"delete_user\", action=delete_user),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/#crud-with-validation-testing","title":"CRUD with Validation Testing","text":"Python<pre><code>from venomqa import Journey, Step, Branch, Path, Checkpoint\n\n\ndef create_valid_item(client, context):\n    \"\"\"Create item with valid data.\"\"\"\n    return client.post(\"/api/items\", json={\n        \"name\": \"Valid Item\",\n        \"price\": 29.99,\n    })\n\n\ndef create_without_name(client, context):\n    \"\"\"Create item without required name.\"\"\"\n    return client.post(\"/api/items\", json={\n        \"price\": 29.99,\n    })\n\n\ndef create_with_negative_price(client, context):\n    \"\"\"Create item with invalid price.\"\"\"\n    return client.post(\"/api/items\", json={\n        \"name\": \"Invalid Item\",\n        \"price\": -10.00,\n    })\n\n\ndef create_with_empty_name(client, context):\n    \"\"\"Create item with empty name.\"\"\"\n    return client.post(\"/api/items\", json={\n        \"name\": \"\",\n        \"price\": 29.99,\n    })\n\n\njourney = Journey(\n    name=\"item_validation\",\n    description=\"Test item creation validation\",\n    tags=[\"crud\", \"validation\"],\n    steps=[\n        # Valid creation\n        Step(name=\"create_valid\", action=create_valid_item),\n\n        Checkpoint(name=\"baseline\"),\n\n        # Validation errors\n        Branch(\n            checkpoint_name=\"baseline\",\n            paths=[\n                Path(name=\"missing_name\", steps=[\n                    Step(\n                        name=\"create\",\n                        action=create_without_name,\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"negative_price\", steps=[\n                    Step(\n                        name=\"create\",\n                        action=create_with_negative_price,\n                        expect_failure=True,\n                    ),\n                ]),\n                Path(name=\"empty_name\", steps=[\n                    Step(\n                        name=\"create\",\n                        action=create_with_empty_name,\n                        expect_failure=True,\n                    ),\n                ]),\n            ],\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/#bulk-operations","title":"Bulk Operations","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef create_items_batch(client, context):\n    \"\"\"Create multiple items in one request.\"\"\"\n    items = [\n        {\"name\": f\"Item {i}\", \"price\": 10.00 + i}\n        for i in range(10)\n    ]\n\n    response = client.post(\"/api/items/batch\", json={\"items\": items})\n\n    if response.status_code in [200, 201]:\n        context[\"item_ids\"] = [item[\"id\"] for item in response.json()[\"items\"]]\n\n    return response\n\n\ndef list_items(client, context):\n    \"\"\"List all items.\"\"\"\n    return client.get(\"/api/items\", params={\"limit\": 100})\n\n\ndef delete_items_batch(client, context):\n    \"\"\"Delete multiple items.\"\"\"\n    item_ids = context.get_required(\"item_ids\")\n    return client.post(\"/api/items/batch-delete\", json={\"ids\": item_ids})\n\n\njourney = Journey(\n    name=\"bulk_operations\",\n    description=\"Test bulk create and delete\",\n    tags=[\"crud\", \"bulk\"],\n    steps=[\n        Step(name=\"create_batch\", action=create_items_batch),\n        Step(name=\"list_items\", action=list_items),\n        Step(name=\"delete_batch\", action=delete_items_batch),\n        Step(name=\"verify_empty\", action=list_items),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/#pagination-testing","title":"Pagination Testing","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef create_many_items(client, context):\n    \"\"\"Create items for pagination testing.\"\"\"\n    for i in range(25):\n        client.post(\"/api/items\", json={\n            \"name\": f\"Item {i}\",\n            \"price\": 10.00,\n        })\n    return {\"created\": 25}\n\n\ndef get_page_1(client, context):\n    \"\"\"Get first page.\"\"\"\n    response = client.get(\"/api/items\", params={\"page\": 1, \"limit\": 10})\n    context[\"page_1_count\"] = len(response.json()[\"items\"])\n    return response\n\n\ndef get_page_2(client, context):\n    \"\"\"Get second page.\"\"\"\n    response = client.get(\"/api/items\", params={\"page\": 2, \"limit\": 10})\n    context[\"page_2_count\"] = len(response.json()[\"items\"])\n    return response\n\n\ndef get_page_3(client, context):\n    \"\"\"Get third page (partial).\"\"\"\n    response = client.get(\"/api/items\", params={\"page\": 3, \"limit\": 10})\n    context[\"page_3_count\"] = len(response.json()[\"items\"])\n    return response\n\n\njourney = Journey(\n    name=\"pagination_test\",\n    description=\"Test pagination\",\n    tags=[\"crud\", \"pagination\"],\n    steps=[\n        Step(name=\"create_items\", action=create_many_items),\n        Step(name=\"page_1\", action=get_page_1),\n        Step(name=\"page_2\", action=get_page_2),\n        Step(name=\"page_3\", action=get_page_3),\n    ],\n)\n</code></pre>"},{"location":"examples/crud/#search-and-filter","title":"Search and Filter","text":"Python<pre><code>from venomqa import Journey, Step\n\n\ndef setup_items(client, context):\n    \"\"\"Create items with different categories.\"\"\"\n    items = [\n        {\"name\": \"Apple\", \"category\": \"fruit\", \"price\": 1.50},\n        {\"name\": \"Banana\", \"category\": \"fruit\", \"price\": 0.75},\n        {\"name\": \"Carrot\", \"category\": \"vegetable\", \"price\": 2.00},\n        {\"name\": \"Broccoli\", \"category\": \"vegetable\", \"price\": 3.00},\n    ]\n\n    for item in items:\n        client.post(\"/api/items\", json=item)\n\n    return {\"created\": len(items)}\n\n\ndef search_by_name(client, context):\n    \"\"\"Search items by name.\"\"\"\n    return client.get(\"/api/items\", params={\"q\": \"apple\"})\n\n\ndef filter_by_category(client, context):\n    \"\"\"Filter items by category.\"\"\"\n    return client.get(\"/api/items\", params={\"category\": \"fruit\"})\n\n\ndef filter_by_price_range(client, context):\n    \"\"\"Filter items by price range.\"\"\"\n    return client.get(\"/api/items\", params={\n        \"min_price\": 1.00,\n        \"max_price\": 2.00,\n    })\n\n\ndef sort_by_price(client, context):\n    \"\"\"Sort items by price.\"\"\"\n    return client.get(\"/api/items\", params={\n        \"sort\": \"price\",\n        \"order\": \"desc\",\n    })\n\n\njourney = Journey(\n    name=\"search_filter\",\n    description=\"Test search and filter\",\n    tags=[\"crud\", \"search\", \"filter\"],\n    steps=[\n        Step(name=\"setup\", action=setup_items),\n        Step(name=\"search_name\", action=search_by_name),\n        Step(name=\"filter_category\", action=filter_by_category),\n        Step(name=\"filter_price\", action=filter_by_price_range),\n        Step(name=\"sort_price\", action=sort_by_price),\n    ],\n)\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>Complete reference documentation for VenomQA.</p>"},{"location":"reference/#quick-links","title":"Quick Links","text":""},{"location":"reference/#api-reference","title":"API Reference","text":"<p>Complete documentation for all public classes and functions.</p>"},{"location":"reference/#cli-reference","title":"CLI Reference","text":"<p>Command-line interface documentation.</p>"},{"location":"reference/#configuration","title":"Configuration","text":"<p>All configuration options and environment variables.</p>"},{"location":"reference/#database-backends","title":"Database Backends","text":"<p>Configure state management backends.</p>"},{"location":"reference/#adapters","title":"Adapters","text":"<p>Available adapters for external services.</p>"},{"location":"reference/#reporters","title":"Reporters","text":"<p>Report formats and custom reporters.</p>"},{"location":"reference/#api-overview","title":"API Overview","text":""},{"location":"reference/#core-models","title":"Core Models","text":"Python<pre><code>from venomqa import (\n    Journey,          # Complete user scenario\n    Step,             # Single action\n    Checkpoint,       # Database savepoint\n    Branch,           # Multiple paths\n    Path,             # Path within a branch\n)\n</code></pre>"},{"location":"reference/#results","title":"Results","text":"Python<pre><code>from venomqa import (\n    JourneyResult,    # Journey execution result\n    StepResult,       # Step execution result\n    PathResult,       # Path execution result\n    Issue,            # Captured failure\n    Severity,         # Issue severity level\n)\n</code></pre>"},{"location":"reference/#execution","title":"Execution","text":"Python<pre><code>from venomqa import (\n    JourneyRunner,    # Execute journeys\n    Client,           # HTTP client\n    ExecutionContext, # Shared state\n    QAConfig,         # Configuration\n)\n</code></pre>"},{"location":"reference/#state-management","title":"State Management","text":"Python<pre><code>from venomqa.state import (\n    PostgreSQLStateManager,  # PostgreSQL backend\n    SQLiteStateManager,      # SQLite backend\n    BaseStateManager,        # Base class\n)\n</code></pre>"},{"location":"reference/#ports-adapters","title":"Ports &amp; Adapters","text":"Python<pre><code>from venomqa.ports import (\n    CachePort,        # Cache interface\n    MailPort,         # Email interface\n    QueuePort,        # Queue interface\n    # ... more ports\n)\n\nfrom venomqa.adapters import (\n    RedisCacheAdapter,   # Redis cache\n    MailhogAdapter,      # Mailhog email\n    # ... more adapters\n)\n</code></pre>"},{"location":"reference/#cli-commands","title":"CLI Commands","text":"Command Description <code>venomqa run [JOURNEYS]</code> Run journeys <code>venomqa list</code> List available journeys <code>venomqa report</code> Generate reports <code>venomqa --version</code> Show version <code>venomqa --help</code> Show help"},{"location":"reference/#configuration-quick-reference","title":"Configuration Quick Reference","text":"YAML<pre><code># venomqa.yaml\nbase_url: \"http://localhost:8000\"\ndb_url: \"postgresql://user:pass@host:5432/db\"\ndb_backend: \"postgresql\"\ntimeout: 30\nretry_count: 3\nparallel_paths: 1\nfail_fast: false\nverbose: false\nreport_dir: \"reports\"\nreport_formats: [\"markdown\", \"junit\"]\n</code></pre> <p>Environment variables:</p> Bash<pre><code>VENOMQA_BASE_URL=http://api.example.com\nVENOMQA_DB_URL=postgresql://...\nVENOMQA_TIMEOUT=60\nVENOMQA_VERBOSE=true\n</code></pre>"},{"location":"reference/config/","title":"Configuration Reference","text":"<p>Complete reference for all VenomQA configuration options.</p>"},{"location":"reference/config/#configuration-file","title":"Configuration File","text":"<p>VenomQA reads configuration from <code>venomqa.yaml</code> in the project root.</p> YAML<pre><code># venomqa.yaml - Complete configuration reference\n\n# ====================\n# API Configuration\n# ====================\nbase_url: \"http://localhost:8000\"    # Base URL for all API requests\ntimeout: 30                          # Request timeout in seconds\nretry_count: 3                       # Number of retry attempts\nretry_delay: 1.0                     # Base delay between retries (seconds)\n\n# ====================\n# Database Configuration\n# ====================\ndb_url: \"postgresql://qa:secret@localhost:5432/qa_test\"\ndb_backend: \"postgresql\"             # postgresql, sqlite, mysql\n\n# ====================\n# Infrastructure\n# ====================\ndocker_compose_file: \"docker-compose.qa.yml\"\n\n# ====================\n# Execution\n# ====================\nparallel_paths: 1                    # Max concurrent branch paths\nfail_fast: false                     # Stop on first failure\n\n# ====================\n# Logging\n# ====================\nverbose: false                       # Enable verbose/debug output\ncapture_logs: true                   # Capture infrastructure logs\nlog_lines: 50                        # Number of log lines to capture\n\n# ====================\n# Reporting\n# ====================\nreport_dir: \"reports\"                # Output directory for reports\nreport_formats:                      # Report formats to generate\n  - markdown\n  - junit\n</code></pre>"},{"location":"reference/config/#configuration-options","title":"Configuration Options","text":""},{"location":"reference/config/#api-configuration","title":"API Configuration","text":"Option Type Default Environment Variable Description <code>base_url</code> string <code>\"http://localhost:8000\"</code> <code>VENOMQA_BASE_URL</code> Base URL for API requests <code>timeout</code> integer <code>30</code> <code>VENOMQA_TIMEOUT</code> Request timeout (seconds) <code>retry_count</code> integer <code>3</code> <code>VENOMQA_RETRY_COUNT</code> Retry attempts on failure <code>retry_delay</code> float <code>1.0</code> <code>VENOMQA_RETRY_DELAY</code> Base delay between retries"},{"location":"reference/config/#database-configuration","title":"Database Configuration","text":"Option Type Default Environment Variable Description <code>db_url</code> string <code>null</code> <code>VENOMQA_DB_URL</code> Database connection URL <code>db_backend</code> string <code>\"postgresql\"</code> <code>VENOMQA_DB_BACKEND</code> Database backend type <p>Supported backends:</p> <ul> <li><code>postgresql</code> - PostgreSQL with SAVEPOINT support (recommended)</li> <li><code>sqlite</code> - SQLite with limited checkpoint support</li> <li><code>mysql</code> - MySQL with SAVEPOINT support</li> </ul> <p>Connection URL formats:</p> Bash<pre><code># PostgreSQL\npostgresql://user:password@host:5432/database\npostgresql://user:password@host:5432/database?sslmode=require\n\n# SQLite\nsqlite:///path/to/database.db\nsqlite:///:memory:\n\n# MySQL\nmysql://user:password@host:3306/database\n</code></pre>"},{"location":"reference/config/#infrastructure-configuration","title":"Infrastructure Configuration","text":"Option Type Default Environment Variable Description <code>docker_compose_file</code> string <code>\"docker-compose.qa.yml\"</code> <code>VENOMQA_DOCKER_COMPOSE_FILE</code> Docker Compose file path"},{"location":"reference/config/#execution-configuration","title":"Execution Configuration","text":"Option Type Default Environment Variable Description <code>parallel_paths</code> integer <code>1</code> <code>VENOMQA_PARALLEL_PATHS</code> Max concurrent paths <code>fail_fast</code> boolean <code>false</code> <code>VENOMQA_FAIL_FAST</code> Stop on first failure <p>Parallel Execution</p> <p>Using <code>parallel_paths &gt; 1</code> with database state management may cause isolation issues. Use sequential execution (<code>parallel_paths=1</code>) when state isolation is critical.</p>"},{"location":"reference/config/#logging-configuration","title":"Logging Configuration","text":"Option Type Default Environment Variable Description <code>verbose</code> boolean <code>false</code> <code>VENOMQA_VERBOSE</code> Enable debug output <code>capture_logs</code> boolean <code>true</code> <code>VENOMQA_CAPTURE_LOGS</code> Capture infra logs <code>log_lines</code> integer <code>50</code> <code>VENOMQA_LOG_LINES</code> Log lines to capture"},{"location":"reference/config/#reporting-configuration","title":"Reporting Configuration","text":"Option Type Default Environment Variable Description <code>report_dir</code> string <code>\"reports\"</code> <code>VENOMQA_REPORT_DIR</code> Report output directory <code>report_formats</code> list <code>[\"markdown\"]</code> <code>VENOMQA_REPORT_FORMATS</code> Formats to generate <p>Available formats:</p> <ul> <li><code>markdown</code> - Human-readable Markdown</li> <li><code>json</code> - Structured JSON</li> <li><code>junit</code> - JUnit XML for CI/CD</li> <li><code>html</code> - Standalone HTML report</li> <li><code>sarif</code> - SARIF for security tools</li> </ul>"},{"location":"reference/config/#environment-variables","title":"Environment Variables","text":"<p>All configuration options can be overridden with environment variables prefixed with <code>VENOMQA_</code>:</p> Bash<pre><code># API\nexport VENOMQA_BASE_URL=\"http://api.example.com\"\nexport VENOMQA_TIMEOUT=60\nexport VENOMQA_RETRY_COUNT=5\n\n# Database\nexport VENOMQA_DB_URL=\"postgresql://user:pass@host:5432/db\"\nexport VENOMQA_DB_BACKEND=\"postgresql\"\n\n# Execution\nexport VENOMQA_PARALLEL_PATHS=4\nexport VENOMQA_FAIL_FAST=true\nexport VENOMQA_VERBOSE=true\n\n# Reporting\nexport VENOMQA_REPORT_DIR=\"/tmp/reports\"\nexport VENOMQA_REPORT_FORMATS=\"markdown,junit\"\n</code></pre> <p>Type conversion:</p> YAML Type Environment Variable string As-is integer Parsed as int float Parsed as float boolean <code>true</code>/<code>false</code>, <code>1</code>/<code>0</code>, <code>yes</code>/<code>no</code> list Comma-separated values"},{"location":"reference/config/#priority-order","title":"Priority Order","text":"<p>Configuration is loaded in this order (later sources override earlier):</p> <ol> <li>Default values (lowest priority)</li> <li>Configuration file (<code>venomqa.yaml</code>)</li> <li>Environment variables (<code>VENOMQA_*</code>)</li> <li>CLI arguments (highest priority)</li> </ol>"},{"location":"reference/config/#multiple-environments","title":"Multiple Environments","text":""},{"location":"reference/config/#using-different-config-files","title":"Using Different Config Files","text":"Bash<pre><code># Development\nvenomqa run -c venomqa.dev.yaml\n\n# Staging\nvenomqa run -c venomqa.staging.yaml\n\n# Production (read-only tests)\nvenomqa run -c venomqa.prod.yaml\n</code></pre>"},{"location":"reference/config/#example-development-config","title":"Example: Development Config","text":"YAML<pre><code># venomqa.dev.yaml\nbase_url: \"http://localhost:8000\"\ndb_url: \"postgresql://dev:dev@localhost:5432/dev_db\"\nverbose: true\ntimeout: 10\n</code></pre>"},{"location":"reference/config/#example-staging-config","title":"Example: Staging Config","text":"YAML<pre><code># venomqa.staging.yaml\nbase_url: \"https://api.staging.example.com\"\ndb_url: \"postgresql://qa:secret@staging-db:5432/qa_test\"\nverbose: false\ntimeout: 60\n</code></pre>"},{"location":"reference/config/#example-cicd-config","title":"Example: CI/CD Config","text":"YAML<pre><code># venomqa.ci.yaml\nbase_url: \"${API_URL}\"  # Replaced by environment variable\ntimeout: 120\nfail_fast: true\nreport_formats:\n  - junit\n  - html\n</code></pre>"},{"location":"reference/config/#programmatic-configuration","title":"Programmatic Configuration","text":""},{"location":"reference/config/#qaconfig-class","title":"QAConfig Class","text":"Python<pre><code>from venomqa import QAConfig\n\nconfig = QAConfig(\n    base_url=\"http://localhost:8000\",\n    db_url=\"postgresql://qa:secret@localhost:5432/qa_test\",\n    db_backend=\"postgresql\",\n    timeout=30,\n    retry_count=3,\n    retry_delay=1.0,\n    parallel_paths=2,\n    fail_fast=False,\n    verbose=True,\n    capture_logs=True,\n    log_lines=100,\n    report_dir=\"reports\",\n    report_formats=[\"markdown\", \"junit\"],\n)\n</code></pre>"},{"location":"reference/config/#loading-from-file","title":"Loading from File","text":"Python<pre><code>from venomqa.config import load_config\n\n# Load from default location\nconfig = load_config()\n\n# Load from specific path\nconfig = load_config(\"path/to/config.yaml\")\n\n# Access values\nprint(config.base_url)\nprint(config.db_url)\nprint(config.timeout)\n</code></pre>"},{"location":"reference/config/#creating-client-from-config","title":"Creating Client from Config","text":"Python<pre><code>from venomqa import Client, QAConfig\n\nconfig = load_config()\n\nclient = Client(\n    base_url=config.base_url,\n    timeout=config.timeout,\n    retry_count=config.retry_count,\n    retry_delay=config.retry_delay,\n)\n</code></pre>"},{"location":"reference/config/#validation","title":"Validation","text":"<p>VenomQA validates configuration on load:</p> Python<pre><code>from venomqa.config import load_config, ConfigValidationError\n\ntry:\n    config = load_config()\nexcept ConfigValidationError as e:\n    print(f\"Invalid configuration: {e}\")\n</code></pre> <p>Validation rules:</p> <ul> <li><code>base_url</code> must be a valid URL</li> <li><code>timeout</code> must be positive</li> <li><code>retry_count</code> must be non-negative</li> <li><code>db_url</code> must be valid connection string (if provided)</li> <li><code>report_formats</code> must contain valid format names</li> </ul>"},{"location":"reference/config/#best-practices","title":"Best Practices","text":""},{"location":"reference/config/#1-use-environment-variables-for-secrets","title":"1. Use Environment Variables for Secrets","text":"YAML<pre><code># venomqa.yaml (safe to commit)\nbase_url: \"http://localhost:8000\"\ndb_backend: \"postgresql\"\n\n# Set secrets via environment\n# export VENOMQA_DB_URL=\"postgresql://...\"\n</code></pre>"},{"location":"reference/config/#2-different-timeouts-for-different-environments","title":"2. Different Timeouts for Different Environments","text":"YAML<pre><code># Local development - fast feedback\ntimeout: 10\n\n# CI/CD - allow for network latency\ntimeout: 60\n\n# Production smoke tests - be patient\ntimeout: 120\n</code></pre>"},{"location":"reference/config/#3-enable-verbose-only-for-debugging","title":"3. Enable Verbose Only for Debugging","text":"YAML<pre><code># Development\nverbose: true\n\n# CI/CD - too noisy\nverbose: false\n</code></pre>"},{"location":"reference/config/#4-use-sequential-execution-with-database-state","title":"4. Use Sequential Execution with Database State","text":"YAML<pre><code># Safe for database checkpointing\nparallel_paths: 1\n</code></pre>"},{"location":"reference/config/#5-specify-report-formats-for-cicd","title":"5. Specify Report Formats for CI/CD","text":"YAML<pre><code># CI/CD\nreport_formats:\n  - junit    # For test results\n  - html     # For artifacts\n</code></pre>"}]}